Rule ID,Rule Type,NL Query,Java Visitor
S100,CODE_SMELL,Method names should comply with a naming convention,"package org.sonar.java.checks.naming;

import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00100"", repositoryKey = ""squid"")
@Rule(key = ""S100"")
public class BadMethodNameCheck extends IssuableSubscriptionVisitor {

  private static final String DEFAULT_FORMAT = ""^[a-z][a-zA-Z0-9]*$"";

  @RuleProperty(
    key = ""format"",
    description = ""Regular expression used to check the method names against."",
    defaultValue = DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;

  private Pattern pattern = null;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    if (pattern == null) {
      pattern = Pattern.compile(format, Pattern.DOTALL);
    }
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (!isExcluded(methodTree) && !pattern.matcher(methodTree.simpleName().name()).matches()) {
      reportIssue(methodTree.simpleName(), ""Rename this method name to match the regular expression '"" + format + ""'."");
    }
  }

  private static boolean isExcluded(MethodTree methodTree) {
    return !Boolean.FALSE.equals(methodTree.isOverriding()) || isExcludedByAnnotation(methodTree);
  }

  private static boolean isExcludedByAnnotation(MethodTree methodTree) {
    return methodTree.modifiers().annotations().stream().anyMatch(
      // use simple name, so we have no FP on missing semantics
      it -> ""AttributeDefinition"".equals(it.annotationType().symbolType().name())
    );
  }
}
"
S101,CODE_SMELL,Class names should comply with a naming convention,"package org.sonar.java.checks.naming;

import java.util.Locale;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00101"", repositoryKey = ""squid"")
@Rule(key = ""S101"")
public class BadClassNameCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String ISSUE_MESSAGE = ""Rename this %s name to match the regular expression '%s'."";
  private static final String DEFAULT_FORMAT = ""^[A-Z][a-zA-Z0-9]*$"";

  @RuleProperty(
    key = ""format"",
    description = ""Regular expression used to check the class names against."",
    defaultValue = """" + DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;

  private Pattern pattern = null;
  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    if (pattern == null) {
      pattern = Pattern.compile(format, Pattern.DOTALL);
    }
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    IdentifierTree simpleName = tree.simpleName();
    boolean isNameNotMatching = (tree.is(Tree.Kind.CLASS, Tree.Kind.RECORD) && simpleName != null && !pattern.matcher(simpleName.name()).matches());
    if (isNameNotMatching && !tree.symbol().type().isSubtypeOf(""java.util.ResourceBundle"")) {
      context.reportIssue(this, simpleName, String.format(ISSUE_MESSAGE, tree.kind().name().toLowerCase(Locale.ROOT), format));
    }
    super.visitClass(tree);
  }
}
"
S103,CODE_SMELL,Lines should not be too long,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonar.plugins.java.api.tree.EmptyStatementTree;
import org.sonar.plugins.java.api.tree.ImportClauseTree;
import org.sonar.plugins.java.api.tree.ImportTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.text.MessageFormat;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00103"", repositoryKey = ""squid"")
@Rule(key = ""S103"")
public class TooLongLineCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_MAXIMUM_LINE_LENGTH = 120;

  @RuleProperty(
      key = ""maximumLineLength"",
      description = ""The maximum authorized line length."",
      defaultValue = """" + DEFAULT_MAXIMUM_LINE_LENGTH)
  int maximumLineLength = DEFAULT_MAXIMUM_LINE_LENGTH;

  private final Set<Integer> ignoredLines = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.emptyList();
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    ignoredLines.clear();
    ignoreLines(context.getTree());
    super.setContext(context);
    visitFile();
  }

  private void ignoreLines(CompilationUnitTree tree) {
    List<ImportClauseTree> imports = tree.imports();
    if (!imports.isEmpty()) {
      int start = getLine(imports.get(0), true);
      int end = getLine(imports.get(imports.size() - 1), false);
      for (int i = start; i <= end; i++) {
        ignoredLines.add(i);
      }
    }
  }

  private static int getLine(ImportClauseTree importClauseTree, boolean fromStart) {
    if (importClauseTree.is(Tree.Kind.IMPORT)) {
      if (fromStart) {
        return LineUtils.startLine(((ImportTree) importClauseTree).importKeyword());
      } else {
        return LineUtils.startLine(((ImportTree) importClauseTree).semicolonToken());
      }
    }
    return LineUtils.startLine(((EmptyStatementTree) importClauseTree).semicolonToken());
  }

  private void visitFile() {
    List<String> lines = context.getFileLines();
    for (int i = 0; i < lines.size(); i++) {
      if (!ignoredLines.contains(i + 1)) {
        String origLine = lines.get(i);
        if (origLine.length() > maximumLineLength && removeIgnoredPatterns(origLine).length() > maximumLineLength) {
          addIssue(i + 1, MessageFormat.format(""Split this {0} characters long line (which is greater than {1} authorized)."", origLine.length(), maximumLineLength));
        }
      }
    }
  }

  private static String removeIgnoredPatterns(String line) {
    if (!line.matches(""\\s*(?:\\*|//).*"")) return line;
    return line
      // @see <a href=""http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#link"">@link ...</a>
      .replaceFirst(""\\{@link [^}]+\\}\\s*"", """")
      // @see <a href=""http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#see"">@see reference</a>
      .replaceFirst(""@see .+"", """");
  }
}
"
S104,CODE_SMELL,Files should not have too many lines of code,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.metrics.MetricsScannerContext;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.Tree;

import java.text.MessageFormat;
import java.util.Collections;
import java.util.List;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00104"", repositoryKey = ""squid"")
@Rule(key = ""S104"")
public class TooManyLinesOfCodeInFileCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_MAXIMUM = 750;

  @RuleProperty(
      key = ""Max"",
      description = ""Maximum authorized lines in a file."",
      defaultValue = """" + DEFAULT_MAXIMUM)
  public int maximum = DEFAULT_MAXIMUM;


  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.COMPILATION_UNIT);
  }

  @Override
  public void visitNode(Tree tree) {
    var metricsComputer = ((MetricsScannerContext)context).getMetricsComputer();
    int lines = metricsComputer.getLinesOfCode(tree);
    if (lines > maximum) {
      addIssueOnFile(MessageFormat.format(""This file has {0} lines, which is greater than {1} authorized. Split it into smaller files."", lines, maximum));
    }
  }
}
"
S105,CODE_SMELL,Tabulation characters should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00105"", repositoryKey = ""squid"")
@Rule(key = ""S105"")
public class TabCharacterCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.emptyList();
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    super.context = context;
    List<String> lines = context.getFileLines();
    for (String line : lines) {
      if (line.contains(""\t"")) {
        addIssueOnFile(""Replace all tab characters in this file by sequences of white-spaces."");
        break;
      }
    }
  }


}
"
S106,CODE_SMELL,Standard outputs should not be used directly to log anything,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S106"")
public class SystemOutOrErrUsageCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.MEMBER_SELECT);
  }

  @Override
  public void visitNode(Tree tree) {
    MemberSelectExpressionTree mset = (MemberSelectExpressionTree) tree;
    String name = mset.identifier().name();

    if (""out"".equals(name) && isSystem(mset.expression())) {
      reportIssue(tree, ""Replace this use of System.out by a logger."");
    } else if (""err"".equals(name) && isSystem(mset.expression())) {
      reportIssue(tree, ""Replace this use of System.err by a logger."");
    }
  }

  private static boolean isSystem(ExpressionTree expression) {
    IdentifierTree identifierTree = null;
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      identifierTree = (IdentifierTree) expression;
    } else if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      identifierTree = ((MemberSelectExpressionTree) expression).identifier();
    }
    return identifierTree != null && ""System"".equals(identifierTree.name());
  }
}
"
S1065,CODE_SMELL,Unused labels should be removed,"package org.sonar.java.checks.unused;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.LabeledStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1065"")
public class UnusedLabelCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.LABELED_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    if (((LabeledStatementTree) tree).symbol().usages().isEmpty()) {
      reportIssue(((LabeledStatementTree) tree).label(), ""Remove this unused label."");
    }
  }
}
"
S1066,CODE_SMELL,"Mergeable ""if"" statements should be combined","package org.sonar.java.checks;

import java.util.ArrayDeque;
import java.util.Collections;
import java.util.Deque;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1066"")
public class CollapsibleIfCandidateCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;
  private Deque<IfStatementTree> outerIf = new ArrayDeque<>();

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
    outerIf.clear();
  }

  @Override
  public void visitIfStatement(IfStatementTree tree) {

    if (!outerIf.isEmpty() && !hasElseClause(tree)) {
      IfStatementTree outerIfStatement = outerIf.peek();
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(tree.ifKeyword())
        .withMessage(""Merge this if statement with the enclosing one."")
        .withSecondaries(Collections.singletonList(new JavaFileScannerContext.Location("""", outerIfStatement.ifKeyword())))
        .withQuickFix(() -> computeQuickFix(tree, outerIfStatement))
        .report();
    }

    if (!hasElseClause(tree) && hasBodySingleIfStatement(tree.thenStatement())) {
      // children of this if statement are eligible for issues
      outerIf.push(tree);
      // recurse into sub-tree
      super.visitIfStatement(tree);
      if (!outerIf.isEmpty()) {
        outerIf.pop();
      }
    } else {
      // direct children of this if statement not eligible for issues. Reset nesting count
      outerIf.clear();
      super.visitIfStatement(tree);
    }
  }

  private static boolean hasElseClause(IfStatementTree tree) {
    return tree.elseStatement() != null;
  }

  private static boolean hasBodySingleIfStatement(StatementTree thenStatement) {

    if (thenStatement.is(Tree.Kind.BLOCK)) {
      // thenStatement has curly braces. Let's see what's inside...
      BlockTree block = (BlockTree) thenStatement;
      return block.body().size() == 1 && block.body().get(0).is(Tree.Kind.IF_STATEMENT);
    } else if (thenStatement.is(Tree.Kind.IF_STATEMENT)) {
      // no curlys on thenStatement; it's a bare if statement
      return true;
    }

    return false;
  }

  private static JavaQuickFix computeQuickFix(IfStatementTree innerIf, IfStatementTree outerIf) {
    var quickFixBuilder = JavaQuickFix.newQuickFix(""Merge this if statement with the enclosing one"");
    quickFixBuilder.addTextEdit(
      JavaTextEdit.replaceBetweenTree(outerIf.condition(), false, innerIf.condition(), false, "" && ""));
    addParenthesisIfRequired(quickFixBuilder, outerIf.condition());
    addParenthesisIfRequired(quickFixBuilder, innerIf.condition());

    if (outerIf.thenStatement() instanceof BlockTree outerBlock) {
      quickFixBuilder.addTextEdit(JavaTextEdit.removeTree(outerBlock.closeBraceToken()));
    }
    return quickFixBuilder.build();
  }

  private static void addParenthesisIfRequired(JavaQuickFix.Builder quickFixBuilder, ExpressionTree expression) {
    if (isLowerOperatorPrecedenceThanLogicalAnd(expression)) {
      quickFixBuilder.addTextEdit(JavaTextEdit.insertBeforeTree(expression, ""(""));
      quickFixBuilder.addTextEdit(JavaTextEdit.insertAfterTree(expression, "")""));
    }
  }

  private static boolean isLowerOperatorPrecedenceThanLogicalAnd(ExpressionTree expression) {
    return (expression instanceof BinaryExpressionTree binExpression)
      ? ""||"".equals(binExpression.operatorToken().text())
      : expression.is(Tree.Kind.CONDITIONAL_EXPRESSION, Tree.Kind.ASSIGNMENT);
  }
}
"
S1067,CODE_SMELL,Expressions should not be too complex,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

@Rule(key = ""S1067"")
public class ExpressionComplexityCheck extends IssuableSubscriptionVisitor {


  private static final int DEFAULT_MAX = 3;

  @RuleProperty(
    description = ""Maximum number of allowed conditional operators in an expression"",
    defaultValue = """" + DEFAULT_MAX)
  public int max = DEFAULT_MAX;

  private final Deque<Integer> count = new LinkedList<>();
  private final Deque<Integer> level = new LinkedList<>();

  @Override
  public void setContext(JavaFileScannerContext context) {
    count.clear();
    level.clear();
    level.push(0);
    count.push(0);
    super.setContext(context);
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.CLASS,
      Tree.Kind.RECORD,
      Tree.Kind.POSTFIX_INCREMENT,
      Tree.Kind.POSTFIX_DECREMENT,
      Tree.Kind.PREFIX_INCREMENT,
      Tree.Kind.PREFIX_DECREMENT,
      Tree.Kind.UNARY_PLUS,
      Tree.Kind.UNARY_MINUS,
      Tree.Kind.BITWISE_COMPLEMENT,
      Tree.Kind.LOGICAL_COMPLEMENT,
      Tree.Kind.MULTIPLY,
      Tree.Kind.DIVIDE,
      Tree.Kind.REMAINDER,
      Tree.Kind.PLUS,
      Tree.Kind.MINUS,
      Tree.Kind.LEFT_SHIFT,
      Tree.Kind.RIGHT_SHIFT,
      Tree.Kind.UNSIGNED_RIGHT_SHIFT,
      Tree.Kind.LESS_THAN,
      Tree.Kind.GREATER_THAN,
      Tree.Kind.LESS_THAN_OR_EQUAL_TO,
      Tree.Kind.GREATER_THAN_OR_EQUAL_TO,
      Tree.Kind.EQUAL_TO,
      Tree.Kind.NOT_EQUAL_TO,
      Tree.Kind.AND,
      Tree.Kind.XOR,
      Tree.Kind.OR,
      Tree.Kind.CONDITIONAL_AND,
      Tree.Kind.CONDITIONAL_OR,
      Tree.Kind.CONDITIONAL_EXPRESSION,
      Tree.Kind.ARRAY_ACCESS_EXPRESSION,
      Tree.Kind.MEMBER_SELECT,
      Tree.Kind.NEW_CLASS,
      Tree.Kind.NEW_ARRAY,
      Tree.Kind.METHOD_INVOCATION,
      Tree.Kind.TYPE_CAST,
      Tree.Kind.INSTANCE_OF,
      Tree.Kind.PARENTHESIZED_EXPRESSION,
      Tree.Kind.ASSIGNMENT,
      Tree.Kind.MULTIPLY_ASSIGNMENT,
      Tree.Kind.DIVIDE_ASSIGNMENT,
      Tree.Kind.REMAINDER_ASSIGNMENT,
      Tree.Kind.PLUS_ASSIGNMENT,
      Tree.Kind.MINUS_ASSIGNMENT,
      Tree.Kind.LEFT_SHIFT_ASSIGNMENT,
      Tree.Kind.RIGHT_SHIFT_ASSIGNMENT,
      Tree.Kind.UNSIGNED_RIGHT_SHIFT_ASSIGNMENT,
      Tree.Kind.AND_ASSIGNMENT,
      Tree.Kind.XOR_ASSIGNMENT,
      Tree.Kind.OR_ASSIGNMENT,
      Tree.Kind.INT_LITERAL,
      Tree.Kind.LONG_LITERAL,
      Tree.Kind.FLOAT_LITERAL,
      Tree.Kind.DOUBLE_LITERAL,
      Tree.Kind.BOOLEAN_LITERAL,
      Tree.Kind.CHAR_LITERAL,
      Tree.Kind.STRING_LITERAL,
      Tree.Kind.NULL_LITERAL,
      Tree.Kind.IDENTIFIER,
      Tree.Kind.ARRAY_TYPE,
      Tree.Kind.LAMBDA_EXPRESSION,
      Tree.Kind.PRIMITIVE_TYPE);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.CLASS, Tree.Kind.RECORD, Tree.Kind.NEW_ARRAY) || isLambdaWithBlock(tree)) {
      count.push(0);
      level.push(0);
    } else {
      if (tree.is(Tree.Kind.CONDITIONAL_OR) || tree.is(Tree.Kind.CONDITIONAL_AND) || tree.is(Tree.Kind.CONDITIONAL_EXPRESSION)) {
        count.push(count.pop() + 1);
      }
      level.push(level.pop() + 1);
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.CLASS, Tree.Kind.RECORD, Tree.Kind.NEW_ARRAY) || isLambdaWithBlock(tree)) {
      count.pop();
      level.pop();
    } else {
      int currentLevel = level.peek();
      if (currentLevel == 1) {
        int opCount = count.pop();
        if (opCount > max && !isInsideEquals(tree)) {
          reportIssue(tree, String.format(""Reduce the number of conditional operators (%d) used in the expression (maximum allowed %d)."", opCount, max),
            Collections.emptyList(), opCount - max);
        }
        count.push(0);
      }
      level.push(level.pop() - 1);
    }
  }

  private static boolean isInsideEquals(Tree tree) {
    Tree parent = tree.parent();
    while (parent != null && !parent.is(Tree.Kind.CLASS, Tree.Kind.RECORD)) {
      if (parent.is(Tree.Kind.METHOD) && MethodTreeUtils.isEqualsMethod((MethodTree) parent)) {
        return true;
      }
      parent = parent.parent();
    }
    return false;
  }

  private static boolean isLambdaWithBlock(Tree tree) {
    return tree.is(Tree.Kind.LAMBDA_EXPRESSION) && ((LambdaExpressionTree) tree).body().is(Tree.Kind.BLOCK);
  }
}
"
S1068,CODE_SMELL,"Unused ""private"" fields should be removed","package org.sonar.java.checks.unused;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1068"")
public class UnusedPrivateFieldCheck extends IssuableSubscriptionVisitor {

  private static final String DEFAULT_IGNORE_ANNOTATIONS_KEY = ""ignoreAnnotations"";
  private static final String DEFAULT_IGNORE_ANNOTATIONS_DESCRIPTION = ""Ignore annotations with next names (fully qualified class names separated with \"",\"")."";

  private static final Set<String> OWNER_CLASS_ALLOWED_ANNOTATIONS = Set.of(
    ""lombok.Data"",
    ""lombok.Getter"",
    ""lombok.Setter"",
    ""lombok.AllArgsConstructor""
  );

  private static final Tree.Kind[] ASSIGNMENT_KINDS = {
    Tree.Kind.ASSIGNMENT,
    Tree.Kind.MULTIPLY_ASSIGNMENT,
    Tree.Kind.DIVIDE_ASSIGNMENT,
    Tree.Kind.REMAINDER_ASSIGNMENT,
    Tree.Kind.PLUS_ASSIGNMENT,
    Tree.Kind.MINUS_ASSIGNMENT,
    Tree.Kind.LEFT_SHIFT_ASSIGNMENT,
    Tree.Kind.RIGHT_SHIFT_ASSIGNMENT,
    Tree.Kind.UNSIGNED_RIGHT_SHIFT_ASSIGNMENT,
    Tree.Kind.AND_ASSIGNMENT,
    Tree.Kind.XOR_ASSIGNMENT,
    Tree.Kind.OR_ASSIGNMENT};

  private final List<ClassTree> classes = new ArrayList<>();
  private final Map<Symbol, List<AssignmentExpressionTree>> assignments = new HashMap<>();
  private final Set<String> unknownIdentifiers = new HashSet<>();
  private boolean hasNativeMethod = false;

  @RuleProperty(
    key = DEFAULT_IGNORE_ANNOTATIONS_KEY,
    description = DEFAULT_IGNORE_ANNOTATIONS_DESCRIPTION)
  public String ignoreAnnotations = """";
  private Set<String> ignoredAnnotations;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.METHOD, Tree.Kind.EXPRESSION_STATEMENT, Tree.Kind.IDENTIFIER);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    clearState();
    super.setContext(context);
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    if (!hasNativeMethod) {
      classes.forEach(this::checkClassFields);
    }
    clearState();
  }

  private void clearState() {
    classes.clear();
    assignments.clear();
    unknownIdentifiers.clear();
    hasNativeMethod = false;
  }

  @Override
  public void visitNode(Tree tree) {
    switch (tree.kind()) {
      case METHOD:
        checkIfNativeMethod((MethodTree) tree);
        break;
      case CLASS:
        classes.add((ClassTree) tree);
        break;
      case EXPRESSION_STATEMENT:
        collectAssignment(((ExpressionStatementTree) tree).expression());
        break;
      case IDENTIFIER:
        collectUnknownIdentifier((IdentifierTree) tree);
        break;
      default:
        throw new IllegalStateException(""Unexpected subscribed tree."");
    }
  }

  private void collectUnknownIdentifier(IdentifierTree identifier) {
    if (identifier.symbol().isUnknown() && !isMethodIdentifier(identifier)) {
      unknownIdentifiers.add(identifier.name());
    }
  }

  private static boolean isMethodIdentifier(IdentifierTree identifier) {
    Tree parent = identifier.parent();
    while (parent != null && !parent.is(Tree.Kind.METHOD_INVOCATION, Tree.Kind.METHOD_REFERENCE)) {
      parent = parent.parent();
    }
    if (parent == null) {
      return false;
    }
    if (parent.is(Tree.Kind.METHOD_INVOCATION)) {
      return identifier.equals(ExpressionUtils.methodName((MethodInvocationTree) parent));
    }
    return identifier.equals(((MethodReferenceTree) parent).method());
  }

  private void checkIfNativeMethod(MethodTree method) {
    if (ModifiersUtils.hasModifier(method.modifiers(), Modifier.NATIVE)) {
      hasNativeMethod = true;
    }
  }

  private void checkClassFields(ClassTree classTree) {
    classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.VARIABLE))
      .map(VariableTree.class::cast)
      .forEach(this::checkIfUnused);
  }

  public void checkIfUnused(VariableTree tree) {
    if (hasOnlyIgnoredAnnotations(tree)) {
      Symbol symbol = tree.symbol();
      String name = symbol.name();
      if (symbol.isPrivate()
        && onlyUsedInVariableAssignment(symbol)
        && !""serialVersionUID"".equals(name)
        && !unknownIdentifiers.contains(name)
        && !hasOwnerClassAllowedAnnotations(tree)) {
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(tree.simpleName())
          .withMessage(""Remove this unused \"""" + name + ""\"" private field."")
          .withQuickFix(() -> computeQuickFix(tree, assignments.getOrDefault(symbol, Collections.emptyList())))
          .report();
      }
    }
  }

  private static boolean hasOwnerClassAllowedAnnotations(VariableTree variableTree) {
    var ownerClass = (ClassTree) variableTree.parent();
    return ownerClass.modifiers().annotations().stream().anyMatch(
      annotation -> OWNER_CLASS_ALLOWED_ANNOTATIONS.contains(annotation.annotationType().symbolType().fullyQualifiedName())
    );
  }

  private boolean onlyUsedInVariableAssignment(Symbol symbol) {
    return symbol.usages().size() == assignments.getOrDefault(symbol, Collections.emptyList()).size();
  }

  private boolean hasOnlyIgnoredAnnotations(VariableTree tree) {
    return tree.modifiers().annotations().stream().allMatch(
      it -> getIgnoredAnnotations().contains(it.annotationType().symbolType().fullyQualifiedName()));
  }

  private Set<String> getIgnoredAnnotations() {
    if (ignoredAnnotations == null) {
      ignoredAnnotations = Stream.of(ignoreAnnotations.split("",""))
        .map(String::trim)
        .filter(it -> !it.isEmpty())
        .collect(Collectors.toSet());
    }
    return ignoredAnnotations;
  }

  private void collectAssignment(ExpressionTree expressionTree) {
    if (expressionTree.is(ASSIGNMENT_KINDS)) {
      AssignmentExpressionTree assignmentExpressionTree = (AssignmentExpressionTree) expressionTree;
      ExpressionTree variable = (assignmentExpressionTree).variable();
      IdentifierTree identifier = null;
      if (variable.is(Tree.Kind.IDENTIFIER)) {
        identifier = (IdentifierTree) variable;
      } else if (variable.is(Tree.Kind.MEMBER_SELECT)) {
        identifier = ((MemberSelectExpressionTree) variable).identifier();
      } else {
        return;
      }
      Symbol reference = identifier.symbol();
      if (!reference.isUnknown()) {
        List<AssignmentExpressionTree> assignmentsToVariable = assignments.computeIfAbsent(reference, k -> new ArrayList<>());
        assignmentsToVariable.add(assignmentExpressionTree);
      }
    }
  }

  private JavaQuickFix computeQuickFix(VariableTree tree, List<AssignmentExpressionTree> assignments) {
    AnalyzerMessage.TextSpan textSpan = computeTextSpan(tree);
    List<JavaTextEdit> edits = new ArrayList<>(assignments.size() + 1);
    edits.addAll(computeExpressionCaptures(assignments));
    edits.add(JavaTextEdit.removeTextSpan(textSpan));
    return JavaQuickFix.newQuickFix(""Remove this unused private field"")
      .addTextEdits(edits)
      .reverseSortEdits()
      .build();
  }

  private static AnalyzerMessage.TextSpan computeTextSpan(VariableTree tree) {
    // If the variable is followed by another in a mutli-variable declaration, we remove include the space up to the following variable's name
    Optional<VariableTree> followingVariable = QuickFixHelper.nextVariable(tree);
    if (followingVariable.isPresent()) {
      return AnalyzerMessage.textSpanBetween(tree.simpleName(), true, followingVariable.get().simpleName(), false);
    }
    // If the variable is preceded by another in a multi-variable declaration, we include the space up to the comma that precedes tree
    Optional<SyntaxToken> precedingComma = getPrecedingComma(tree);
    if (precedingComma.isPresent()) {
      SyntaxToken endingSemiColon = tree.lastToken();
      return AnalyzerMessage.textSpanBetween(precedingComma.get(), true, endingSemiColon, false);
    }
    // If the variable is preceded by some related javadoc, we include the javadoc in the span
    List<SyntaxTrivia> trivias = tree.firstToken().trivias();
    if (!trivias.isEmpty()) {
      SyntaxTrivia lastTrivia = trivias.get(trivias.size() - 1);
      if (lastTrivia.comment().startsWith(""/**"")) {
        SyntaxToken lastToken = tree.lastToken();
        Position start = Position.startOf(lastTrivia);
        Position end = Position.endOf(lastToken);
        return JavaTextEdit.textSpan(start.line(), start.columnOffset(), end.line(), end.columnOffset());
      }
    }
    // By default, we delete the variable's tree
    return AnalyzerMessage.textSpanFor(tree);
  }

  private List<JavaTextEdit> computeExpressionCaptures(List<AssignmentExpressionTree> assignments) {
    List<JavaTextEdit> edits = new ArrayList<>();
    for (int i = 1; i <= assignments.size(); i++) {
      AssignmentExpressionTree assignment = assignments.get(i - 1);
      ExpressionTree variable = assignment.variable();
      String replacement = computeReplacement(variable, i);
      edits.add(
        JavaTextEdit.replaceBetweenTree(variable, true, assignment.expression(), false, replacement)
      );
    }
    return edits;
  }

  private String computeReplacement(ExpressionTree variable, int index) {
    String name = """";
    IdentifierTree identifier;
    if (variable.is(Tree.Kind.IDENTIFIER)) {
      identifier = ((IdentifierTree) variable);
      name = identifier.name() + index;
    } else {
      identifier = ((MemberSelectExpressionTree) variable).identifier();
      name = identifier.name() + index;
    }
    name = Character.toUpperCase(name.charAt(0)) + name.substring(1);
    TypeTree typeInDeclaration = ((VariableTree) identifier.symbol().declaration()).type();
    String type = QuickFixHelper.contentForTree(typeInDeclaration, context);
    return String.format(""%s valueFormerlyAssignedTo%s = "", type, name);
  }

  private static Optional<SyntaxToken> getPrecedingComma(VariableTree variable) {
    return QuickFixHelper.previousVariable(variable).map(VariableTree::lastToken);
  }

}
"
S107,CODE_SMELL,Methods should not have too many parameters,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

import static org.sonar.java.checks.helpers.AnnotationsHelper.hasUnknownAnnotation;

@DeprecatedRuleKey(ruleKey = ""S00107"", repositoryKey = ""squid"")
@Rule(key = ""S107"")
public class TooManyParametersCheck extends IssuableSubscriptionVisitor {

  private static final Tree.Kind[] METHOD_AND_CONSTRUCTOR = {Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR};
  private static final Tree.Kind[] METHOD_ONLY = {Tree.Kind.METHOD};

  private static final int DEFAULT_MAXIMUM = 7;

  @RuleProperty(
    key = ""max"",
    description = ""Maximum authorized number of parameters"",
    defaultValue = """" + DEFAULT_MAXIMUM)
  public int maximum = DEFAULT_MAXIMUM;

  @RuleProperty(
    key = ""constructorMax"",
    description = ""Maximum authorized number of parameters for a constructor"",
    defaultValue = """" + DEFAULT_MAXIMUM)
  public int constructorMax = DEFAULT_MAXIMUM;

  private static final List<String> METHOD_ANNOTATION_EXCEPTIONS = Arrays.asList(
    ""com.fasterxml.jackson.annotation.JsonCreator"",
    ""javax.ws.rs.GET"",
    ""javax.ws.rs.POST"",
    ""javax.ws.rs.PUT"",
    ""javax.ws.rs.PATCH"",
    ""javax.inject.Inject"",
    ""jakarta.ws.rs.GET"",
    ""jakarta.ws.rs.POST"",
    ""jakarta.ws.rs.PUT"",
    ""jakarta.ws.rs.PATCH"",
    ""jakarta.inject.Inject"",
    ""io.micronaut.http.annotation.Get"",
    ""io.micronaut.http.annotation.Post"",
    ""io.micronaut.http.annotation.Put"",
    ""io.micronaut.http.annotation.Delete"",
    ""io.micronaut.http.annotation.Options"",
    ""io.micronaut.http.annotation.Patch"",
    ""io.micronaut.http.annotation.Head"",
    ""io.micronaut.http.annotation.Trace"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    // This rule has the following exceptions: RECORD, ANNOTATION_TYPE
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.INTERFACE, Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;

    // this is true only if the class has unknown annotations or a single constructor
    // if TRUE, we can skip the analysis of constructors in the forEach below
    Tree.Kind[] membersToVisit = membersToVisit(classTree);

    classTree.members().stream()
      .filter(member -> member.is(membersToVisit))
      .forEach(member -> visitMethod((MethodTree) member));
  }

  private void visitMethod(MethodTree method) {
    if (isOverriding(method) || usesAuthorizedAnnotation(method)) {
      return;
    }
    int max;
    String partialMessage;
    if (method.is(Tree.Kind.CONSTRUCTOR)) {
      max = constructorMax;
      partialMessage = ""Constructor"";
    } else {
      max = maximum;
      partialMessage = ""Method"";
    }
    int size = method.parameters().size();
    if (size > max) {
      reportIssue(method.simpleName(), partialMessage + "" has "" + size + "" parameters, which is greater than "" + max + "" authorized."");
    }
  }

  private static boolean isOverriding(MethodTree tree) {
    // In case of unknown hierarchy, isOverriding() returns null, we return true to avoid FPs.
    return !Boolean.FALSE.equals(tree.isOverriding());
  }

  private static boolean usesAuthorizedAnnotation(MethodTree method) {
    SymbolMetadata metadata = method.symbol().metadata();
    return hasUnknownAnnotation(metadata) || METHOD_ANNOTATION_EXCEPTIONS.stream().anyMatch(metadata::isAnnotatedWith);
  }

  private static Tree.Kind[] membersToVisit(ClassTree methodParentClass) {
    SymbolMetadata parentClassMetadata = methodParentClass.symbol().metadata();
    if (hasUnknownAnnotation(parentClassMetadata)) {
      long numberOfConstructors = methodParentClass.members().stream().filter(member -> member.is(Tree.Kind.CONSTRUCTOR)).count();
      if (numberOfConstructors == 1) {
        // skip constructors
        return METHOD_ONLY;
      }
    }
    return METHOD_AND_CONSTRUCTOR;
  }
}
"
S1075,CODE_SMELL,URIs should not be hardcoded,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S1075"")
public class HardcodedURICheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final MethodMatchers MATCHERS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(""java.net.URI"")
      .constructor()
      .addParametersMatcher(JAVA_LANG_STRING).build(),
    MethodMatchers.create()
      .ofTypes(""java.io.File"")
      .constructor()
      .addParametersMatcher(JAVA_LANG_STRING)
      .addParametersMatcher(ANY, JAVA_LANG_STRING)
      .build());

  private static final String SCHEME = ""[a-zA-Z][a-zA-Z\\+\\.\\-]+"";
  private static final String FOLDER_NAME = ""[^/?%*:\\\\|\""<>]+"";
  private static final String URI_REGEX = String.format(""^%s://.+"", SCHEME);
  private static final String LOCAL_URI = String.format(""^(~/|/|//[\\w-]+/|%s:/)(%s/)*%s/?"",
    SCHEME, FOLDER_NAME, FOLDER_NAME);
  private static final String BACKSLASH_LOCAL_URI = String.format(""^(~\\\\\\\\|\\\\\\\\\\\\\\\\[\\w-]+\\\\\\\\|%s:\\\\\\\\)(%s\\\\\\\\)*%s(\\\\\\\\)?"",
    SCHEME, FOLDER_NAME, FOLDER_NAME);
  private static final String DISK_URI = ""^[A-Za-z]:(/|\\\\)"";

  private static final Pattern URI_PATTERN = Pattern.compile(URI_REGEX + ""|"" + LOCAL_URI + ""|"" + DISK_URI + ""|"" + BACKSLASH_LOCAL_URI);
  private static final Pattern VARIABLE_NAME_PATTERN = Pattern.compile(""filename|path"", Pattern.CASE_INSENSITIVE);
  private static final Pattern PATH_DELIMETERS_PATTERN = Pattern.compile(""\""/\""|\""//\""|\""\\\\\\\\\""|\""\\\\\\\\\\\\\\\\\"""");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.NEW_CLASS, Tree.Kind.VARIABLE, Tree.Kind.ASSIGNMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.NEW_CLASS)) {
      checkNewClassTree((NewClassTree) tree);
    } else if (tree.is(Tree.Kind.VARIABLE)) {
      checkVariable((VariableTree) tree);
    } else {
      checkAssignment((AssignmentExpressionTree) tree);
    }
  }

  private void checkNewClassTree(NewClassTree nct) {
    if (MATCHERS.matches(nct)) {
      nct.arguments().forEach(this::checkExpression);
    }
  }

  private void checkVariable(VariableTree tree) {
    if (isFileNameVariable(tree.simpleName())) {
      checkExpression(tree.initializer());
    }
  }

  private void checkAssignment(AssignmentExpressionTree tree) {
    if (isFileNameVariable(getVariableIdentifier(tree)) && !isPartOfAnnotation(tree)) {
      checkExpression(tree.expression());
    }
  }

  private static boolean isPartOfAnnotation(AssignmentExpressionTree tree) {
    Tree parent = tree.parent();
    while (parent != null) {
      if (parent.is(Tree.Kind.ANNOTATION)) {
        return true;
      }
      parent = parent.parent();
    }
    return false;
  }

  private static boolean isFileNameVariable(@Nullable IdentifierTree variable) {
    return variable != null && VARIABLE_NAME_PATTERN.matcher(variable.name()).find();
  }

  private void checkExpression(@Nullable ExpressionTree expr) {
    if (expr != null) {
      if (isHardcodedURI(expr)) {
        reportHardcodedURI(expr);
      } else {
        reportStringConcatenationWithPathDelimiter(expr);
      }
    }
  }

  private static boolean isHardcodedURI(ExpressionTree expr) {
    ExpressionTree newExpr = ExpressionUtils.skipParentheses(expr);
    if (!newExpr.is(Tree.Kind.STRING_LITERAL)) {
      return false;
    }
    String stringLiteral = LiteralUtils.trimQuotes(((LiteralTree) newExpr).value());
    if(stringLiteral.contains(""*"") || stringLiteral.contains(""$"")) {
      return false;
    }
    return URI_PATTERN.matcher(stringLiteral).find();
  }

  private void reportHardcodedURI(ExpressionTree hardcodedURI) {
    reportIssue(hardcodedURI, ""Refactor your code to get this URI from a customizable parameter."");
  }

  private void reportStringConcatenationWithPathDelimiter(ExpressionTree expr) {
    expr.accept(new StringConcatenationVisitor());
  }

  private class StringConcatenationVisitor extends BaseTreeVisitor {
    @Override
    public void visitBinaryExpression(BinaryExpressionTree tree) {
      if (tree.is(Tree.Kind.PLUS)) {
        checkPathDelimiter(tree.leftOperand());
        checkPathDelimiter(tree.rightOperand());
      }
      super.visitBinaryExpression(tree);
    }

    private void checkPathDelimiter(ExpressionTree expr) {
      ExpressionTree newExpr = ExpressionUtils.skipParentheses(expr);
      if (newExpr.is(Tree.Kind.STRING_LITERAL) && PATH_DELIMETERS_PATTERN.matcher(((LiteralTree) newExpr).value()).find()) {
        reportIssue(newExpr, ""Remove this hard-coded path-delimiter."");
      }
    }
  }

  @CheckForNull
  private static IdentifierTree getVariableIdentifier(AssignmentExpressionTree tree) {
    ExpressionTree variable = ExpressionUtils.skipParentheses(tree.variable());
    if (variable.is(Tree.Kind.IDENTIFIER)) {
      return (IdentifierTree) variable;
    } else if (variable.is(Tree.Kind.MEMBER_SELECT)) {
      return ((MemberSelectExpressionTree) variable).identifier();
    }
    // ignore assignments in arrays
    return null;
  }

}
"
S108,CODE_SMELL,Nested blocks of code should not be left empty,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.SwitchStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Arrays;
import java.util.List;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00108"", repositoryKey = ""squid"")
@Rule(key = ""S108"")
public class EmptyBlockCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Either remove or fill this block of code."";
  private boolean isMethodBlock;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.METHOD,
      Tree.Kind.CONSTRUCTOR,
      Tree.Kind.BLOCK,
      Tree.Kind.INITIALIZER,
      Tree.Kind.STATIC_INITIALIZER,
      Tree.Kind.SWITCH_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.SWITCH_STATEMENT)) {
      SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree;
      if (switchStatementTree.cases().isEmpty()) {
        reportIssue(switchStatementTree.openBraceToken(), MESSAGE);
      }
    } else if (tree.is(Tree.Kind.METHOD) || tree.is(Tree.Kind.CONSTRUCTOR)) {
      isMethodBlock = true;
    } else {
      if (isMethodBlock) {
        isMethodBlock = false;
      } else if (!tree.parent().is(Tree.Kind.LAMBDA_EXPRESSION)
              && !hasStatements((BlockTree) tree)
              && !isRuleException((BlockTree) tree)) {
        reportIssue(((BlockTree) tree).openBraceToken(), MESSAGE);
      }
    }
  }

  private static boolean isRuleException(BlockTree tree) {
    return hasCommentInside(tree) && !tree.parent().is(Tree.Kind.SYNCHRONIZED_STATEMENT);
  }

  private static boolean hasCommentInside(BlockTree tree) {
    return tree.closeBraceToken() == null || !tree.closeBraceToken().trivias().isEmpty();
  }

  private static boolean hasStatements(BlockTree tree) {
    return !tree.body().isEmpty();
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD) || tree.is(Tree.Kind.CONSTRUCTOR)) {
      isMethodBlock = false;
    }
  }

}
"
S109,CODE_SMELL,Magic numbers should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.EnumConstantTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

@Rule(key = ""S109"")
public class MagicNumberCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String DEFAULT_AUTHORIZED_NUMBERS = ""-1,0,1"";

  @RuleProperty(
    key = ""Authorized numbers"",
    description = ""Comma separated list of authorized numbers. Example: -1,0,1,2"",
    defaultValue = """" + DEFAULT_AUTHORIZED_NUMBERS)
  public String authorizedNumbers = DEFAULT_AUTHORIZED_NUMBERS;
  private List<BigDecimal> authorizedNumbersList = null;
  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    this.authorizedNumbersList = new ArrayList<>();
    for (String s : authorizedNumbers.split("","")) {
      authorizedNumbersList.add(new BigDecimal(s.trim()));
    }
    scan(context.getTree());
  }

  @Override
  public void visitEnumConstant(EnumConstantTree tree) {
    scan(tree.initializer().classBody());
  }

  @Override
  public void visitLiteral(LiteralTree tree) {
    if (isNumberLiteral(tree)) {
      DecimalFormat decimalFormat = new DecimalFormat();
      decimalFormat.setDecimalFormatSymbols(new DecimalFormatSymbols(Locale.ENGLISH));
      decimalFormat.setParseBigDecimal(true);
      BigDecimal checked = null;
      try {
        checked = (BigDecimal) decimalFormat.parse(tree.value());
      } catch (ParseException e) {
        // noop case not encountered
      }
      if (checked != null && !isExcluded(checked)) {
        context.reportIssue(this, tree, ""Assign this magic number "" + tree.value() + "" to a well-named constant, and use the constant instead."");
      }
    }
  }

  private static boolean isNumberLiteral(LiteralTree tree) {
    return tree.is(Tree.Kind.DOUBLE_LITERAL, Tree.Kind.FLOAT_LITERAL, Tree.Kind.LONG_LITERAL, Tree.Kind.INT_LITERAL);
  }

  private boolean isExcluded(BigDecimal bigDecimal) {
    for (BigDecimal bd : this.authorizedNumbersList) {
      if (bigDecimal.compareTo(bd) == 0) {
        return true;
      }
    }
    return false;
  }

  @Override
  public void visitAnnotation(AnnotationTree annotationTree) {
    // Ignore literals within annotation
  }

  @Override
  public void visitVariable(VariableTree tree) {
    ExpressionTree initializer = tree.initializer();
    boolean arrayNotInitialized = initializer != null && initializer.is(Kind.NEW_ARRAY) && ((NewArrayTree) initializer).initializers().isEmpty();
    boolean isFinalOrNoSemantic = context.getSemanticModel() == null || tree.symbol().isFinal();
    if (arrayNotInitialized || !isFinalOrNoSemantic) {
      super.visitVariable(tree);
    }
  }

  @Override
  public void visitMethod(MethodTree tree) {
    if (!MethodTreeUtils.isHashCodeMethod(tree)) {
      super.visitMethod(tree);
    }
  }
}
"
S110,CODE_SMELL,Inheritance tree of classes should not be too deep,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.sonar.api.utils.WildcardPattern;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.annotations.VisibleForTesting;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""MaximumInheritanceDepth"", repositoryKey = ""squid"")
@Rule(key = ""S110"")
public class DepthOfInheritanceTreeCheck extends BaseTreeVisitor implements JavaFileScanner {

  public static final int DEFAULT_MAX_DEPTH = 5;
  private static final List<String> FRAMEWORK_EXCLUSION_PATTERNS = Arrays.asList(
    ""android.**"",
    ""com.intellij.**"",
    ""com.persistit.**"",
    ""javax.swing.**"",
    ""javafx.scene.**"",
    ""org.eclipse.**"",
    ""org.springframework.**""
  );

  private JavaFileScannerContext context;

  @RuleProperty(
    key = ""max"",
    description = ""Maximum depth of the inheritance tree. (Number)"",
    defaultValue = """" + DEFAULT_MAX_DEPTH)
  private Integer max = DEFAULT_MAX_DEPTH;

  @RuleProperty(
    key = ""filteredClasses"",
    description = ""Classes to be filtered out of the count of inheritance. Ex : java.fwk.AbstractFwkClass, java.fwkPackage.*"",
    defaultValue = """")
  private String filteredClasses = """";

  private List<WildcardPattern> filteredPatterns;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    if (context.getSemanticModel() != null) {
      scan(context.getTree());
    }
  }

  @Override
  public void visitClass(ClassTree tree) {
    if (!isBodyOfEnumConstantTree(tree)) {
      Type superClass = tree.symbol().superClass();
      int dit = 0;
      while (superClass != null) {
        String fullyQualifiedName = superClass.fullyQualifiedName();
        if (getPatterns().stream().anyMatch(pattern -> pattern.match(fullyQualifiedName))) {
          break;
        }
        dit++;
        superClass = superClass.symbol().superClass();
      }
      if (dit > max) {
        Tree reportTree = tree.simpleName();
        if (tree.parent().is(Tree.Kind.NEW_CLASS)) {
          reportTree = ((NewClassTree) tree.parent()).newKeyword();
        }
        context.reportIssue(this, reportTree, ""This class has "" + dit + "" parents which is greater than "" + max + "" authorized."",
          new ArrayList<>(), dit - max);
      }
    }
    super.visitClass(tree);
  }

  private static boolean isBodyOfEnumConstantTree(ClassTree tree) {
    Tree parent = tree.parent();
    return parent.is(Tree.Kind.NEW_CLASS) && parent.parent().is(Tree.Kind.ENUM_CONSTANT);
  }

  @VisibleForTesting
  void setMax(int max) {
    this.max = max;
  }

  private List<WildcardPattern> getPatterns() {
    if (filteredPatterns == null) {
      String permittedPatterns = String.join("","",
        String.join("","", FRAMEWORK_EXCLUSION_PATTERNS),
        filteredClasses
      );
      filteredPatterns = Arrays.asList(PatternUtils.createPatterns(permittedPatterns));
    }
    return filteredPatterns;
  }

  public void setFilteredClasses(String filteredClasses) {
    this.filteredClasses = filteredClasses;
  }
}
"
S1104,CODE_SMELL,Class variable fields should not have public accessibility,"package org.sonar.java.checks;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""ClassVariableVisibilityCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1104"")
public class ClassVariableVisibilityCheck extends BaseTreeVisitor implements JavaFileScanner {

  private Deque<Boolean> isClassStack = new ArrayDeque<>();

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    isClassStack.push(tree.is(Tree.Kind.CLASS) || tree.is(Tree.Kind.ENUM));
    super.visitClass(tree);
    isClassStack.pop();
  }

  @Override
  public void visitVariable(VariableTree tree) {
    ModifiersTree modifiers = tree.modifiers();
    List<AnnotationTree> annotations = modifiers.annotations();

    if (isClass() && isPublic(modifiers) && !(isFinal(modifiers) || !annotations.isEmpty())) {
      context.reportIssue(this, tree.simpleName(), ""Make "" + tree.simpleName() + "" a static final constant or non-public and provide accessors if needed."");
    }
    super.visitVariable(tree);
  }

  private boolean isClass() {
    return !isClassStack.isEmpty() && isClassStack.peek();
  }

  private static boolean isFinal(ModifiersTree modifiers) {
    return ModifiersUtils.hasModifier(modifiers, Modifier.FINAL);
  }

  private static boolean isPublic(ModifiersTree modifiers) {
    return ModifiersUtils.hasModifier(modifiers, Modifier.PUBLIC);
  }

}
"
S1105,CODE_SMELL,An open curly brace should be located at the end of a line,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""LeftCurlyBraceEndLineCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1105"")
public class LeftCurlyBraceEndLineCheck extends LeftCurlyBraceBaseTreeVisitor {

  @Override
  protected void checkTokens(SyntaxToken lastToken, SyntaxToken openBraceToken) {
    if (LineUtils.startLine(lastToken) != LineUtils.startLine(openBraceToken)) {
      addIssue(openBraceToken, this, ""Move this left curly brace to the end of previous line of code."");
    }
  }
}
"
S1106,CODE_SMELL,An open curly brace should be located at the beginning of a line,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""LeftCurlyBraceStartLineCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1106"")
public class LeftCurlyBraceStartLineCheck extends LeftCurlyBraceBaseTreeVisitor {

  @Override
  protected void checkTokens(SyntaxToken lastToken, SyntaxToken openBraceToken) {
    if (LineUtils.startLine(lastToken) == LineUtils.startLine(openBraceToken)) {
      addIssue(openBraceToken, this, ""Move this left curly brace to the beginning of next line of code."");
    }
  }
}
"
S1107,CODE_SMELL,"Close curly brace and the next ""else"", ""catch"" and ""finally"" keywords should be located on the same line","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.LineUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@DeprecatedRuleKey(ruleKey = ""RightCurlyBraceSameLineAsNextBlockCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1107"")
public class RightCurlyBraceSameLineAsNextBlockCheck extends RightCurlyBraceToNextBlockAbstractVisitor {

  @Override
  protected void checkTokenPosition(SyntaxToken syntaxToken, BlockTree previousBlock) {
    if (LineUtils.startLine(syntaxToken) != LineUtils.startLine(previousBlock.closeBraceToken())) {
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(syntaxToken)
        .withMessage(""Move this \""%s\"" on the same line that the previous closing curly brace."", syntaxToken.text())
        .withQuickFix(() -> JavaQuickFix.newQuickFix(""Move to the same line as the closing curly brace"")
          .addTextEdit(JavaTextEdit.replaceTextSpan(textSpanBetween(previousBlock, false, syntaxToken, false), "" "")
          ).build())
        .report();
    }
  }
}
"
S1108,CODE_SMELL,"Close curly brace and the next ""else"", ""catch"" and ""finally"" keywords should be on two different lines","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""RightCurlyBraceDifferentLineAsNextBlockCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1108"")
public class RightCurlyBraceDifferentLineAsNextBlockCheck extends RightCurlyBraceToNextBlockAbstractVisitor {

  @Override
  protected void checkTokenPosition(SyntaxToken syntaxToken, BlockTree previousBlock) {
    if (LineUtils.startLine(syntaxToken) == LineUtils.startLine(previousBlock.closeBraceToken())) {
      reportIssue(syntaxToken, ""Move this \"""" + syntaxToken.text() + ""\"" keyword to a new dedicated line."");
    }
  }
}
"
S1109,CODE_SMELL,A close curly brace should be located at the beginning of a line,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Arrays;
import java.util.List;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""RightCurlyBraceStartLineCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1109"")
public class RightCurlyBraceStartLineCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.BLOCK,
      Tree.Kind.STATIC_INITIALIZER,
      Tree.Kind.INITIALIZER,
      Tree.Kind.CLASS,
      Tree.Kind.INTERFACE,
      Tree.Kind.ANNOTATION_TYPE,
      Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.BLOCK, Tree.Kind.STATIC_INITIALIZER, Tree.Kind.INITIALIZER)) {
      BlockTree blockTree = (BlockTree) tree;
      checkBlockBody(blockTree.openBraceToken(), blockTree.closeBraceToken(), blockTree.body());
    } else {
      ClassTree classTree = (ClassTree) tree;
      checkBlockBody(classTree.openBraceToken(), classTree.closeBraceToken(), classTree.members());
    }
  }

  private void checkBlockBody(SyntaxToken openBraceToken, SyntaxToken closeBraceToken, List<? extends Tree> trees) {
    if (LineUtils.startLine(openBraceToken) != LineUtils.startLine(closeBraceToken) && !trees.isEmpty()) {
      Tree lastTree = trees.get(trees.size() - 1);
      if (LineUtils.startLine(lastTree.lastToken()) == LineUtils.startLine(closeBraceToken)) {
        reportIssue(closeBraceToken, ""Move this closing curly brace to the next line."");
      }
    }
  }
}
"
S1110,CODE_SMELL,Redundant pairs of parentheses should be removed,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.ParenthesizedTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Collections;
import java.util.List;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""UselessParenthesesCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1110"")
public class UselessParenthesesCheck extends IssuableSubscriptionVisitor {

  @Override
  public void visitNode(Tree tree) {
    ParenthesizedTree parenthesizedTree = (ParenthesizedTree) tree;
    if (parenthesizedTree.expression().is(Kind.PARENTHESIZED_EXPRESSION)) {
      reportIssue(((ParenthesizedTree) parenthesizedTree.expression()).openParenToken(),
          ""Remove these useless parentheses."",
          Collections.singletonList(new JavaFileScannerContext.Location("""", parenthesizedTree.closeParenToken())), null);
    }
  }

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.PARENTHESIZED_EXPRESSION);
  }
}
"
S1111,BUG,"The ""Object.finalize()"" method should not be called","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.PrimitiveTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""ObjectFinalizeCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1111"")
public class ObjectFinalizeCheck extends IssuableSubscriptionVisitor {

  private boolean isInFinalizeMethod = false;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      isInFinalizeMethod = isFinalizeMethodMember((MethodTree) tree);
    } else {
      MethodInvocationTree methodInvocationTree = (MethodInvocationTree) tree;
      IdentifierTree methodName = ExpressionUtils.methodName(methodInvocationTree);
      if (!isInFinalizeMethod && ""finalize"".equals(methodName.name()) && methodInvocationTree.arguments().isEmpty()) {
        reportIssue(methodName, ""Remove this call to finalize()."");
      }
    }

  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD) && isFinalizeMethodMember((MethodTree) tree)) {
      isInFinalizeMethod = false;
    }
  }

  private static boolean isFinalizeMethodMember(MethodTree methodTree) {
    Tree returnType = methodTree.returnType();
    boolean returnVoid = returnType != null && returnType.is(Tree.Kind.PRIMITIVE_TYPE) && ""void"".equals(((PrimitiveTypeTree) returnType).keyword().text());
    return returnVoid && ""finalize"".equals(methodTree.simpleName().name());
  }

}
"
S1113,CODE_SMELL,"The ""Object.finalize()"" method should not be overridden","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""ObjectFinalizeOverridenCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1113"")
public class ObjectFinalizeOverriddenCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers FINALIZE_MATCHER = MethodMatchers.create()
    .ofSubTypes(""java.lang.Object"")
    .names(""finalize"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (FINALIZE_MATCHER.matches(methodTree) && isNotFinalOrHasNonEmptyBody(methodTree)) {
      reportIssue(methodTree.simpleName(), ""Do not override the Object.finalize() method."");
    }
  }

  private static boolean isNotFinalOrHasNonEmptyBody(MethodTree methodTree) {
    return !ModifiersUtils.hasModifier(methodTree.modifiers(), Modifier.FINAL)
      || !Objects.requireNonNull(methodTree.block()).body().isEmpty();
  }
}
"
S1114,BUG,"""super.finalize()"" should be called at the end of ""Object.finalize()"" implementations","package org.sonar.java.checks;

import java.util.List;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.ListUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Symbol.TypeSymbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""ObjectFinalizeOverridenCallsSuperFinalizeCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1114"")
public class ObjectFinalizeOverridenCallsSuperFinalizeCheck extends IssuableSubscriptionVisitor {

  private static final String FINALIZE = ""finalize"";
  private static final MethodMatchers FINALIZE_MATCHER = MethodMatchers.create()
    .ofAnyType().names(FINALIZE).addWithoutParametersMatcher().build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {

    MethodTree methodTree = (MethodTree) tree;
    if (isFinalizeOverriddenMethod(methodTree)) {
      BlockTree blockTree = methodTree.block();
      if (blockTree != null) {
        MethodInvocationTree lastSuperFinalizeInvocation = findLastSuperFinalizeInvocation(blockTree);
        if (lastSuperFinalizeInvocation == null) {
          reportIssue(methodTree.simpleName(), ""Add a call to super.finalize() at the end of this Object.finalize() implementation."");
        } else if (!isLastStatement(blockTree, lastSuperFinalizeInvocation)) {
          reportIssue(lastSuperFinalizeInvocation, ""Move this super.finalize() call to the end of this Object.finalize() implementation."");
        }
      }
    }
  }

  private static boolean isFinalizeOverriddenMethod(MethodTree methodTree) {
    return FINALIZE_MATCHER.matches(methodTree) && doesOverrideFinalize((TypeSymbol) methodTree.symbol().owner());
  }

  private static boolean doesOverrideFinalize(TypeSymbol typeSymbol) {
    Type superClassType = typeSymbol.superClass();
    while (superClassType != null && !superClassType.is(""java.lang.Object"")) {
      Symbol.TypeSymbol currentClass = superClassType.symbol();
      if (currentClass.lookupSymbols(FINALIZE).stream().anyMatch(FINALIZE_MATCHER::matches)) {
        return true;
      }
      superClassType = currentClass.superClass();
    }
    return false;
  }

  @Nullable
  private static MethodInvocationTree findLastSuperFinalizeInvocation(BlockTree blockTree) {
    FindLastSuperFinalizeInvocationVisitor visitor = new FindLastSuperFinalizeInvocationVisitor();
    blockTree.accept(visitor);
    return visitor.lastSuperFinalizeInvocation;
  }

  private static boolean isLastStatement(BlockTree blockTree, MethodInvocationTree lastStatementTree) {
    if (blockTree.body().stream().anyMatch(statement ->
      statement.is(Tree.Kind.TRY_STATEMENT) && isLastStatementInner(((TryStatementTree) statement).finallyBlock(), lastStatementTree)
    )) {
      return true;
    }
    return isLastStatementInner(blockTree, lastStatementTree);
  }

  private static boolean isLastStatementInner(@Nullable BlockTree blockTree, MethodInvocationTree lastStatementTree) {
    if (blockTree != null) {
      StatementTree last = ListUtils.getLast(blockTree.body());
      if (last.is(Tree.Kind.EXPRESSION_STATEMENT)) {
        return lastStatementTree.equals(((ExpressionStatementTree) last).expression());
      } else if (last.is(Tree.Kind.TRY_STATEMENT)) {
        return isLastStatementInner(((TryStatementTree) last).finallyBlock(), lastStatementTree);
      }
    }
    return false;
  }

  private static class FindLastSuperFinalizeInvocationVisitor extends BaseTreeVisitor {

    @Nullable
    public MethodInvocationTree lastSuperFinalizeInvocation;

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (tree.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree mset = (MemberSelectExpressionTree) tree.methodSelect();
        if (FINALIZE.equals(mset.identifier().name()) && mset.expression().is(Tree.Kind.IDENTIFIER) && ""super"".equals(((IdentifierTree) mset.expression()).name())) {
          lastSuperFinalizeInvocation = tree;
        }
      }
    }

    @Override
    public void visitClass(ClassTree tree) {
      // cut analysis on inner and anonymous classes, because we want to analyze actual control flow of finalize method only
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // cut analysis on lambda function bodies, because we want to analyze actual control flow of finalize method only
    }
  }
}
"
S1116,CODE_SMELL,Empty statements should be removed,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.LineUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.EmptyStatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@DeprecatedRuleKey(ruleKey = ""EmptyStatementUsageCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1116"")
public class EmptyStatementUsageCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.EMPTY_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    if (usedForEmptyEnum(tree) || uniqueStatementOfLoop(tree)) {
      return;
    }
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(tree)
      .withMessage(""Remove this empty statement."")
      .withQuickFix(() -> getQuickFix((EmptyStatementTree) tree))
      .report();
  }

  private static JavaQuickFix getQuickFix(EmptyStatementTree emptyStatement) {
    SyntaxToken previousToken = QuickFixHelper.previousToken(emptyStatement);
    JavaTextEdit edit;
    // Remove the statement if it is not the only one on his line, otherwise, remove the line until the previous token
    if (sameLine(previousToken, emptyStatement)) {
      edit = JavaTextEdit.removeTree(emptyStatement);
    } else {
      SyntaxToken nextToken = QuickFixHelper.nextToken(emptyStatement);
      if (sameLine(nextToken, emptyStatement)) {
        edit = JavaTextEdit.removeTree(emptyStatement);
      } else {
        edit = JavaTextEdit.removeTextSpan(textSpanBetween(previousToken, false, emptyStatement, true));
      }
    }
    return JavaQuickFix.newQuickFix(""Remove this empty statement"")
      .addTextEdit(edit)
      .build();
  }

  private static boolean sameLine(SyntaxToken token, EmptyStatementTree emptyStatement) {
    return LineUtils.startLine(token) == LineUtils.startLine(emptyStatement.semicolonToken());
  }

  private static boolean usedForEmptyEnum(Tree tree) {
    Tree parent = tree.parent();
    if (parent.is(Tree.Kind.ENUM)) {
      return ((ClassTree) parent).members().indexOf(tree) == 0;
    }
    return false;
  }

  private static boolean uniqueStatementOfLoop(Tree tree) {
    return tree.parent().is(Tree.Kind.WHILE_STATEMENT, Tree.Kind.FOR_EACH_STATEMENT, Tree.Kind.FOR_STATEMENT, Tree.Kind.DO_STATEMENT);
  }
}
"
S1117,CODE_SMELL,Local variables should not shadow class fields,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.java.model.JavaTree;
import org.sonar.java.model.LineUtils;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""HiddenFieldCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1117"")
public class HiddenFieldCheck extends IssuableSubscriptionVisitor {

  private final Deque<Map<String, VariableTree>> fields = new LinkedList<>();
  private final Deque<List<VariableTree>> excludedVariables = new LinkedList<>();
  private final Set<VariableTree> flattenExcludedVariables = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
        Tree.Kind.CLASS,
        Tree.Kind.ENUM,
        Tree.Kind.INTERFACE,
        Tree.Kind.ANNOTATION_TYPE,
        Tree.Kind.RECORD,
        Tree.Kind.VARIABLE,
        Tree.Kind.METHOD,
        Tree.Kind.CONSTRUCTOR,
        Tree.Kind.STATIC_INITIALIZER
    );
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    fields.clear();
    excludedVariables.clear();
    flattenExcludedVariables.clear();
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    if (isClassTree(tree)) {
      ClassTree classTree = (ClassTree) tree;
      MapBuilder<String, VariableTree> builder = MapBuilder.newMap();
      for (Tree member : classTree.members()) {
        if (member.is(Tree.Kind.VARIABLE)) {
          VariableTree variableTree = (VariableTree) member;
          builder.put(variableTree.simpleName().name(), variableTree);
        }
      }
      fields.push(builder.build());
      excludedVariables.push(new ArrayList<>());
    } else if (tree.is(Tree.Kind.VARIABLE)) {
      VariableTree variableTree = (VariableTree) tree;
      isVariableHidingField(variableTree);
    } else if (tree.is(Tree.Kind.STATIC_INITIALIZER)) {
      excludeVariablesFromBlock((BlockTree) tree);
    } else {
      MethodTree methodTree = (MethodTree) tree;
      excludedVariables.peek().addAll(methodTree.parameters());
      flattenExcludedVariables.addAll(methodTree.parameters());
      if (ModifiersUtils.hasModifier(methodTree.modifiers(), Modifier.STATIC)) {
        excludeVariablesFromBlock(methodTree.block());
      }
    }
  }

  private void isVariableHidingField(VariableTree variableTree) {
    for (Map<String, VariableTree> variables : fields) {
      if (variables.containsValue(variableTree)) {
        return;
      }
      String identifier = variableTree.simpleName().name();
      VariableTree hiddenVariable = variables.get(identifier);
      if (!flattenExcludedVariables.contains(variableTree) && hiddenVariable != null && !isInStaticInnerClass(hiddenVariable, variableTree)) {
        int line = LineUtils.startLine(hiddenVariable);
        reportIssue(variableTree.simpleName(), ""Rename \"""" + identifier + ""\"" which hides the field declared at line "" + line + ""."");
        return;
      }
    }
  }

  private static boolean isInStaticInnerClass(VariableTree hiddenVariable, VariableTree variableTree) {
    Symbol hiddenVariableOwner = hiddenVariable.symbol().owner();
    Symbol owner = variableTree.symbol().owner();
    while (owner != null && !owner.equals(hiddenVariableOwner)) {
      if (owner.isTypeSymbol() && owner.isStatic()) {
        return true;
      }
      owner = owner.owner();
    }
    return false;
  }

  private static boolean isClassTree(Tree tree) {
    return tree.is(Tree.Kind.CLASS, Tree.Kind.ENUM, Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE, Tree.Kind.RECORD);
  }

  @Override
  public void leaveNode(Tree tree) {
    if (isClassTree(tree)) {
      fields.pop();
      flattenExcludedVariables.removeAll(excludedVariables.pop());
    }
  }

  private void excludeVariablesFromBlock(@Nullable BlockTree blockTree) {
    if (blockTree != null) {
      List<VariableTree> variableTrees = new VariableList().scan(blockTree);
      excludedVariables.peek().addAll(variableTrees);
      flattenExcludedVariables.addAll(variableTrees);
    }
  }

  private static class VariableList {

    private List<VariableTree> variables;
    private Set<Tree.Kind> visitNodes;
    private Set<Tree.Kind> excludedNodes;

    List<VariableTree> scan(Tree tree) {
      visitNodes = nodesToVisit();
      excludedNodes = excludedNodes();
      variables = new ArrayList<>();
      visit(tree);
      return variables;
    }

    public Set<Tree.Kind> nodesToVisit() {
      return Collections.singleton(Tree.Kind.VARIABLE);
    }

    public Set<Tree.Kind> excludedNodes() {
      return SetUtils.immutableSetOf(Tree.Kind.METHOD, Tree.Kind.CLASS, Tree.Kind.ENUM, Tree.Kind.INTERFACE, Tree.Kind.NEW_CLASS);
    }

    private void visit(Tree tree) {
      if (isSubscribed(tree)) {
        variables.add((VariableTree) tree);
      }
      visitChildren(tree);
    }

    private void visitChildren(Tree tree) {
      JavaTree javaTree = (JavaTree) tree;
      if (!javaTree.isLeaf()) {
        for (Tree next : javaTree.getChildren()) {
          if (next != null && !isExcluded(next)) {
            visit(next);
          }
        }
      }
    }

    private boolean isSubscribed(Tree tree) {
      return visitNodes.contains(tree.kind());
    }

    private boolean isExcluded(Tree tree) {
      return excludedNodes.contains(tree.kind());
    }
  }

}
"
S1118,CODE_SMELL,Utility classes should not have public constructors,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ClassPatternsUtils;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1118"")
public class UtilityClassWithPublicConstructorCheck extends IssuableSubscriptionVisitor {

  private static final Set<String> LOMBOK_CONSTRUCTOR_GENERATORS = Set.of(
    ""lombok.NoArgsConstructor"",
    ""lombok.AllArgsConstructor"",
    ""lombok.RequiredArgsConstructor"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (!ClassPatternsUtils.isUtilityClass(classTree) || ClassPatternsUtils.isPrivateInnerClass(classTree)) {
      return;
    }
    boolean hasImplicitPublicConstructor = true;
    for (MethodTree explicitConstructor : getExplicitConstructors(classTree)) {
      hasImplicitPublicConstructor = false;
      if (isPublicConstructor(explicitConstructor)) {
        reportIssue(explicitConstructor.simpleName(), ""Hide this public constructor."");
      }
    }
    if (hasImplicitPublicConstructor && !hasCompliantGeneratedConstructors(classTree)) {
      reportIssue(classTree.simpleName(), ""Add a private constructor to hide the implicit public one."");
    }
  }

  private static List<MethodTree> getExplicitConstructors(ClassTree classTree) {
    return classTree.members().stream()
      .filter(UtilityClassWithPublicConstructorCheck::isConstructor)
      .map(MethodTree.class::cast)
      .toList();
  }

  private static boolean isConstructor(Tree tree) {
    return tree.is(Tree.Kind.CONSTRUCTOR);
  }

  private static boolean isPublicConstructor(Tree tree) {
    return isConstructor(tree) && hasPublicModifier((MethodTree) tree);
  }

  private static boolean hasPublicModifier(MethodTree methodTree) {
    return ModifiersUtils.hasModifier(methodTree.modifiers(), Modifier.PUBLIC);
  }

  private static boolean hasCompliantGeneratedConstructors(ClassTree classTree) {
    return classTree.modifiers().annotations().stream().anyMatch(it -> isLombokConstructorGenerator(it) && !hasPublicAccess(it));
  }

  private static boolean isLombokConstructorGenerator(AnnotationTree annotation) {
    return LOMBOK_CONSTRUCTOR_GENERATORS.contains(annotation.annotationType().symbolType().fullyQualifiedName());
  }

  private static boolean hasPublicAccess(AnnotationTree annotation) {
    return annotation.arguments().stream().noneMatch(it ->
      isAccessLevelNotPublic(((AssignmentExpressionTree) it).expression())
    );
  }

  private static boolean isAccessLevelNotPublic(ExpressionTree tree) {
    String valueName;
    if (tree instanceof MemberSelectExpressionTree mset) {
      valueName = mset.identifier().name();
    } else if (tree instanceof IdentifierTree identifier) {
      valueName = identifier.name();
    } else {
      return false;
    }
    return !""PUBLIC"".equals(valueName);
  }

}
"
S1119,CODE_SMELL,Labels should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.LabeledStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""LabelsShouldNotBeUsedCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1119"")
public class LabelsShouldNotBeUsedCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.LABELED_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    reportIssue(((LabeledStatementTree) tree).label(), ""Refactor the code to remove this label and the need for it."");
  }

}
"
S112,CODE_SMELL,Generic exceptions should never be thrown,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.reporting.FluentReporting;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00112"", repositoryKey = ""squid"")
@Rule(key = ""S112"")
public class RawExceptionCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final List<String> RAW_EXCEPTIONS = Arrays.asList(
    ""java.lang.Throwable"",
    ""java.lang.Error"",
    ""java.lang.Exception"",
    ""java.lang.RuntimeException"");

  private FluentReporting context;
  private final Set<Type> exceptionsThrownByMethodInvocations = new HashSet<>();

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = (FluentReporting) context;
    scan(context.getTree());
  }

  @Override
  public void visitMethod(MethodTree method) {
    super.visitMethod(method);
    if ((method.is(Tree.Kind.CONSTRUCTOR) || isNotOverridden(method)) && isNotMainMethod(method) && hasNoUnknownMethod(method)) {
      for (TypeTree throwClause : method.throwsClauses()) {
        Type exceptionType = throwClause.symbolType();
        if (isRawException(exceptionType) && !exceptionsThrownByMethodInvocations.contains(exceptionType)) {
          reportIssue(throwClause);
        }
      }
    }
    exceptionsThrownByMethodInvocations.clear();
  }

  private static boolean hasNoUnknownMethod(MethodTree method) {
    MethodTreeUtils.MethodInvocationCollector unknownMethodVisitor = new MethodTreeUtils.MethodInvocationCollector(Symbol::isUnknown);
    method.accept(unknownMethodVisitor);
    return unknownMethodVisitor.getInvocationTree().isEmpty();
  }

  @Override
  public void visitThrowStatement(ThrowStatementTree tree) {
    if (tree.expression().is(Tree.Kind.NEW_CLASS)) {
      TypeTree exception = ((NewClassTree) tree.expression()).identifier();
      if (isRawException(exception.symbolType())) {
        reportIssue(exception);
      }
    }
    super.visitThrowStatement(tree);
  }

  private void reportIssue(Tree tree) {
    context.newIssue()
      .forRule(this)
      .onTree(tree)
      .withMessage(""Define and throw a dedicated exception instead of using a generic one."")
      .report();
  }

  @Override
  public void visitMethodInvocation(MethodInvocationTree mit) {
    collectThrownTypes(mit.methodSymbol());
    super.visitMethodInvocation(mit);
  }

  @Override
  public void visitNewClass(NewClassTree nct) {
    collectThrownTypes(nct.methodSymbol());
    super.visitNewClass(nct);
  }

  private void collectThrownTypes(Symbol.MethodSymbol symbol) {
    if (!symbol.isUnknown()) {
      exceptionsThrownByMethodInvocations.addAll(symbol.thrownTypes());
    }
  }

  private static boolean isRawException(Type type) {
    return RAW_EXCEPTIONS.stream().anyMatch(type::is);
  }

  private static boolean isNotOverridden(MethodTree tree) {
    return Boolean.FALSE.equals(tree.isOverriding());
  }

  private static boolean isNotMainMethod(MethodTree tree) {
    return !MethodTreeUtils.isMainMethod(tree);
  }

}
"
S1120,CODE_SMELL,Source code should be indented consistently,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.JavaTree;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.CaseLabelTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SwitchStatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;
import org.sonarsource.analyzer.commons.collections.ListUtils;

@DeprecatedRuleKey(ruleKey = ""IndentationCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1120"")
public class IndentationCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final int DEFAULT_INDENTATION_LEVEL = 2;

  @RuleProperty(
    key = ""indentationLevel"",
    description = ""Number of white-spaces of an indent."",
    defaultValue = """" + DEFAULT_INDENTATION_LEVEL)
  public int indentationLevel = DEFAULT_INDENTATION_LEVEL;

  private int expectedLevel;
  private boolean isBlockAlreadyReported;
  private int excludeIssueAtLine;
  private JavaFileScannerContext context;
  private List<String> fileLines;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    expectedLevel = 0;
    isBlockAlreadyReported = false;
    excludeIssueAtLine = 0;
    this.context = context;
    fileLines = context.getFileLines();
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    // Exclude anonymous classes
    boolean isAnonymous = tree.simpleName() == null;
    if (!isAnonymous) {
      checkIndentation(Collections.singletonList(tree));
    }
    int previousLevel = expectedLevel;
    if (isAnonymous) {
      excludeIssueAtLine = LineUtils.startLine(tree.openBraceToken());
      expectedLevel = Position.startOf(tree.closeBraceToken()).columnOffset();
    }
    newBlock();
    checkIndentation(tree.members());
    super.visitClass(tree);
    leaveNode(tree);
    expectedLevel = previousLevel;
  }

  @Override
  public void visitBlock(BlockTree tree) {
    newBlock();
    int oldExpectedLevel = expectedLevel;
    adjustBlockForExceptionalParents(tree);
    checkIndentation(tree.body());
    super.visitBlock(tree);
    expectedLevel = oldExpectedLevel;
    leaveNode(tree);
  }

  @Override
  public void visitSwitchStatement(SwitchStatementTree tree) {
    newBlock();
    scan(tree.expression());
    for (CaseGroupTree caseGroupTree : tree.cases()) {
      newBlock();
      checkCaseGroup(caseGroupTree);
      scan(caseGroupTree);
      leaveNode(caseGroupTree);
    }
    leaveNode(tree);
  }

  @Override
  public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
    // doesn't scan lambda parameters because there's no indentation check on types and identifiers
    Tree body = lambdaExpressionTree.body();
    if (body.is(Kind.BLOCK)) {
      BlockTree block = (BlockTree) body;
      excludeIssueAtLine = LineUtils.startLine(block.openBraceToken());
      int previousLevel = expectedLevel;
      expectedLevel = Position.startOf(block.closeBraceToken()).columnOffset();
      scan(block);
      expectedLevel = previousLevel;
    } else {
      scan(body);
    }
  }

  private void newBlock() {
    expectedLevel += indentationLevel;
    isBlockAlreadyReported = false;
  }

  private void leaveNode(Tree tree) {
    expectedLevel -= indentationLevel;
    isBlockAlreadyReported = false;
    excludeIssueAtLine = LineUtils.startLine(tree.lastToken());
  }

  private void checkCaseGroup(CaseGroupTree tree) {
    List<CaseLabelTree> labels = tree.labels();
    if (labels.size() >= 2) {
      CaseLabelTree previousCaseLabelTree = labels.get(labels.size() - 2);
      excludeIssueAtLine = LineUtils.startLine(previousCaseLabelTree.lastToken());
    }
    List<StatementTree> body = tree.body();

    if (body.size() == 1 && body.get(0).is(Kind.BLOCK)) {
      checkCaseGroupSingleBlock(tree);
    } else {
      checkCaseGroupMixedStatements(tree);
    }
  }

  private void checkCaseGroupSingleBlock(CaseGroupTree tree) {
    List<StatementTree> body = tree.body();
    SyntaxToken separatorToken = ListUtils.getLast(tree.labels()).colonOrArrowToken();
    int nextOffsetInLine = Position.endOf(separatorToken).columnOffset() + 1;

    BlockTree block = (BlockTree) body.get(0);
    Position openBracePosition = Position.startOf(block.openBraceToken());
    Position separatorPosition = Position.endOf(separatorToken);
    if (openBracePosition.line() == separatorPosition.line()) {
      // `{` is on same line -> one additional indentation for inner block and `}` is optional
      checkIndentation(block.openBraceToken(), nextOffsetInLine);
      if (block.body().isEmpty()) {
        checkIndentationWithOptionalAllowed(block.closeBraceToken(), expectedLevel - indentationLevel);
      } else {
        int level = checkIndentationWithOptionalAllowed(block.body().get(0), expectedLevel) - indentationLevel;
        checkIndentation(block.closeBraceToken(), level);
      }
    } else {
      // `{` is on next line -> one additional indentation is optional, inner block and `}` must have same indentation
      int level = checkIndentationWithOptionalAllowed(block.openBraceToken(), expectedLevel - indentationLevel);
      if (!block.body().isEmpty()) {
        checkIndentation(block.body().get(0), level + indentationLevel);
      }
      checkIndentation(block.closeBraceToken(), level);
    }
  }

  private void checkCaseGroupMixedStatements(CaseGroupTree tree) {
    List<StatementTree> body = tree.body();
    SyntaxToken separatorToken = ListUtils.getLast(tree.labels()).colonOrArrowToken();
    int nextOffsetInLine = Position.endOf(separatorToken).columnOffset() + 1;
    List<StatementTree> newBody = body;
    int bodySize = body.size();

    int oldExpectedLevel = expectedLevel;
    if (bodySize > 0 && body.get(0).is(Kind.BLOCK)) {
      expectedLevel -= indentationLevel;
      checkIndentation(body.get(0), nextOffsetInLine);
      newBody = body.subList(1, bodySize);
    }

    if (bodySize == 1 && ""->"".equals(separatorToken.text())) {
      checkSameOrNextLineIndentation(Position.startOf(separatorToken).line(), nextOffsetInLine, body.get(0));
    } else {
      checkIndentation(newBody);
    }

    expectedLevel = oldExpectedLevel;
  }

  private void checkSameOrNextLineIndentation(int curLine, int nextOffsetInLine, StatementTree statement) {
    checkIndentation(statement, Position.startOf(statement).line() == curLine ? nextOffsetInLine : expectedLevel);
  }

  private void adjustBlockForExceptionalParents(BlockTree tree) {
    if (Objects.requireNonNull(tree.parent()).is(Kind.CASE_GROUP)) {
      expectedLevel = tree.body().isEmpty() ?
        (getIndentation(Position.startOf(tree.closeBraceToken())) + indentationLevel) :
        getIndentation(Position.startOf(tree.body().get(0)));
    }
  }

  private void checkIndentation(List<? extends Tree> trees) {
    for (Tree tree : trees) {
      checkIndentation(tree, expectedLevel);
    }
  }

  private void checkIndentation(Tree tree, int expectedLevel) {
    Position treeStart = Position.startOf(tree);
    if (getIndentation(treeStart) != expectedLevel) {
      addIssue(tree, expectedLevel);
    }
    excludeIssueAtLine = LineUtils.startLine(tree.lastToken());
  }

  private int checkIndentationWithOptionalAllowed(Tree tree, int expectedLevel) {
    Position treeStart = Position.startOf(tree);
    int level = getIndentation(treeStart);
    boolean isAdditionalIndentation = level == expectedLevel + indentationLevel;

    if (level != expectedLevel && !isAdditionalIndentation) {
      addIssue(tree, expectedLevel, expectedLevel + indentationLevel);
    }
    excludeIssueAtLine = LineUtils.startLine(tree.lastToken());
    return isAdditionalIndentation ? (expectedLevel + indentationLevel) : expectedLevel;
  }

  void addIssue(Tree tree, Integer... expectedLevels) {
    Position treeStart = Position.startOf(tree);
    String messageAfter = Arrays.stream(expectedLevels).map(Object::toString).collect(Collectors.joining("" or ""));
    if (!isExcluded(tree, treeStart.line())) {
      int level = getIndentation(treeStart);
      String message = ""Make this line start after "" + messageAfter + "" spaces instead of "" +
        level + "" in order to indent the code consistently. (Indentation level is at "" + indentationLevel + "".)"";
      context.addIssue(((JavaTree) tree).getLine(), this, message);
      isBlockAlreadyReported = true;
    }
  }

  private int getIndentation(Position treeStart) {
    String line = fileLines.get(treeStart.lineOffset());
    int level = treeStart.columnOffset();
    int indentLength = Math.min(treeStart.columnOffset(),line.length());
    for (int i = 0; i < indentLength; i++) {
      if (line.charAt(i) == '\t') {
        level += indentationLevel - 1;
      }
    }
    return level;
  }

  private boolean isExcluded(Tree node, int nodeLine) {
    return excludeIssueAtLine == nodeLine || isBlockAlreadyReported || node.is(Kind.ENUM_CONSTANT);
  }

}
"
S1121,CODE_SMELL,Assignments should not be made from within sub-expressions,"package org.sonar.java.checks;

import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;
import org.sonar.plugins.java.api.tree.YieldStatementTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""AssignmentInSubExpressionCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1121"")
public class AssignmentInSubExpressionCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final Kind[] ASSIGNMENT_EXPRESSIONS = new Kind[]{
    Kind.AND_ASSIGNMENT,
    Kind.ASSIGNMENT,
    Kind.DIVIDE_ASSIGNMENT,
    Kind.LEFT_SHIFT_ASSIGNMENT,
    Kind.RIGHT_SHIFT_ASSIGNMENT,
    Kind.MINUS_ASSIGNMENT,
    Kind.MULTIPLY_ASSIGNMENT,
    Kind.OR_ASSIGNMENT,
    Kind.PLUS_ASSIGNMENT,
    Kind.REMAINDER_ASSIGNMENT,
    Kind.UNSIGNED_RIGHT_SHIFT_ASSIGNMENT,
    Kind.XOR_ASSIGNMENT};

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;

    scan(context.getTree());
  }

  @Override
  public void visitAnnotation(AnnotationTree annotationTree) {
    //skip scanning of annotation : assignment in annotation is normal behaviour
    scan(annotationTree.annotationType());
  }

  @Override
  public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
    //skip lambda if body is an assignment
    if(!lambdaExpressionTree.body().is(ASSIGNMENT_EXPRESSIONS)) {
      super.visitLambdaExpression(lambdaExpressionTree);
    }
  }

  @Override
  public void visitExpressionStatement(ExpressionStatementTree tree) {
    ExpressionTree expressionTree = ExpressionUtils.skipParentheses(tree.expression());
    expressionTree = skipChainedAssignments(expressionTree);
    scan(expressionTree);
  }

  private ExpressionTree skipChainedAssignments(ExpressionTree expressionTree) {
    ExpressionTree tree = ExpressionUtils.skipParentheses(expressionTree);
    while (tree instanceof AssignmentExpressionTree assignmentExpressionTree) {
      scan(assignmentExpressionTree.variable());
      tree = ExpressionUtils.skipParentheses(assignmentExpressionTree.expression());
    }
    return tree;
  }

  @Override
  public void visitBinaryExpression(BinaryExpressionTree tree) {
    if (isRelationalExpression(tree)) {
      visitInnerExpression(tree.leftOperand());
      visitInnerExpression(tree.rightOperand());
    } else {
      super.visitBinaryExpression(tree);
    }
  }

  private void visitInnerExpression(ExpressionTree tree) {
    AssignmentExpressionTree assignmentExpressionTree = getInnerAssignmentExpression(tree);
    if (assignmentExpressionTree != null) {
      super.visitAssignmentExpression(assignmentExpressionTree);
    } else {
      scan(tree);
    }
  }

  @Nullable
  private static AssignmentExpressionTree getInnerAssignmentExpression(ExpressionTree tree) {
    ExpressionTree expressionTree = ExpressionUtils.skipParentheses(tree);
    if (expressionTree.is(Kind.ASSIGNMENT)) {
      return (AssignmentExpressionTree) expressionTree;
    }
    return null;
  }

  private static boolean isRelationalExpression(Tree tree) {
    return tree.is(
      Kind.EQUAL_TO,
      Kind.NOT_EQUAL_TO,
      Kind.LESS_THAN,
      Kind.LESS_THAN_OR_EQUAL_TO,
      Kind.GREATER_THAN,
      Kind.GREATER_THAN_OR_EQUAL_TO);
  }

  @Override
  public void visitWhileStatement(WhileStatementTree tree) {
    scan(tree.statement());
  }

  @Override
  public void visitVariable(VariableTree tree) {
    ExpressionTree initializer = tree.initializer();
    if (initializer != null) {
      ExpressionTree expressionTree = skipChainedAssignments(initializer);
      scan(expressionTree);
    }
  }

  @Override
  public void visitYieldStatement(YieldStatementTree tree) {
    if (isWithinSwitchExpression(tree)) {
      super.visitYieldStatement(tree);
    }
  }

  private static boolean isWithinSwitchExpression(YieldStatementTree tree) {
    Tree parent = tree.parent();
    while (!parent.is(Tree.Kind.SWITCH_EXPRESSION, Tree.Kind.SWITCH_STATEMENT, Kind.COMPILATION_UNIT)) {
      parent = parent.parent();
    }
    return parent.is(Tree.Kind.SWITCH_EXPRESSION);
  }

  @Override
  public void visitAssignmentExpression(AssignmentExpressionTree tree) {
    super.visitAssignmentExpression(tree);
    context.reportIssue(this, tree.operatorToken(), ""Extract the assignment out of this expression."");
  }

}
"
S1123,CODE_SMELL,Deprecated elements should have both the annotation and the Javadoc tag,"package org.sonar.java.checks;

import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

import static org.sonar.java.checks.helpers.DeprecatedCheckerHelper.reportTreeForDeprecatedTree;

@DeprecatedRuleKey(ruleKey = ""MissingDeprecatedCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1123"")
public class MissingDeprecatedCheck extends AbstractMissingDeprecatedChecker {

  void handleDeprecatedElement(Tree tree, @CheckForNull AnnotationTree deprecatedAnnotation, boolean hasJavadocDeprecatedTag) {
    boolean hasDeprecatedAnnotation = deprecatedAnnotation != null;
    if (hasDeprecatedAnnotation) {
      if (!hasJavadocDeprecatedTag) {
        reportIssue(reportTreeForDeprecatedTree(tree), ""Add the missing @deprecated Javadoc tag."");
      }
    } else if (hasJavadocDeprecatedTag) {
      reportIssue(reportTreeForDeprecatedTree(tree), ""Add the missing @Deprecated annotation."");
    }
  }

}
"
S1124,CODE_SMELL,Modifiers should be declared in the correct order,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;
import org.sonar.plugins.java.api.tree.ModifierTree;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""ModifiersOrderCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1124"")
public class ModifiersOrderCheck extends IssuableSubscriptionVisitor {
  private Set<Tree> alreadyReported = new HashSet<>();

  @Override
  public void setContext(JavaFileScannerContext context) {
    alreadyReported.clear();
    super.setContext(context);
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.MODIFIERS);
  }

  @Override
  public void visitNode(Tree tree) {
    if (!alreadyReported.contains(tree)) {
      ModifiersTree modifiers = (ModifiersTree) tree;
      alreadyReported.add(modifiers);
      getFirstBadlyOrdered(modifiers)
        .ifPresent(wrongModifier -> QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(wrongModifier)
          .withMessage(""Reorder the modifiers to comply with the Java Language Specification."")
          .withQuickFix(() -> reorderedFix(modifiers))
          .report());
    }
  }

  private static Optional<ModifierTree> getFirstBadlyOrdered(ModifiersTree modifiersTree) {
    ListIterator<ModifierTree> modifiersIterator = modifiersTree.listIterator();
    skipAnnotations(modifiersIterator);
    Modifier[] modifiers = Modifier.values();
    int modifierIndex = 0;
    while (modifiersIterator.hasNext()){
      ModifierTree modifier = modifiersIterator.next();
      if (modifier.is(Tree.Kind.ANNOTATION)) {
        break;
      }
      ModifierKeywordTree mkt = (ModifierKeywordTree) modifier;
      for (; modifierIndex < modifiers.length && !mkt.modifier().equals(modifiers[modifierIndex]); modifierIndex++) {
        // We're just interested in the final value of modifierIndex
      }
      if (modifierIndex == modifiers.length) {
        return Optional.of(modifier);
      }
    }
    return testOnlyAnnotationsAreLeft(modifiersIterator);
  }private static void skipAnnotations(ListIterator<ModifierTree> modifiersIterator) {
    while (modifiersIterator.hasNext() && modifiersIterator.next().is(Tree.Kind.ANNOTATION)) {
      // skip modifiers which are annotations
    }
    if (modifiersIterator.hasNext()) {
      modifiersIterator.previous();
    }
  }

  private static Optional<ModifierTree> testOnlyAnnotationsAreLeft(ListIterator<ModifierTree> modifiersIterator) {
    while (modifiersIterator.hasNext()) {
      ModifierTree modifier = modifiersIterator.next();
      if (!modifier.is(Tree.Kind.ANNOTATION)) {
        modifiersIterator.previous();
        if (modifiersIterator.hasPrevious()) {
          return Optional.of(modifiersIterator.previous());
        }
      }
    }
    return Optional.empty();
  }

  private static JavaQuickFix reorderedFix(ModifiersTree modifiersTree) {
    JavaQuickFix.Builder builder = JavaQuickFix.newQuickFix(""Reorder modifiers"");
    List<AnnotationTree> annotations = new ArrayList<>(modifiersTree.annotations());

    if (annotations.isEmpty()) {
      // EASY: there is no annotations...
      // 1) remove all modifiers
      builder.addTextEdit(JavaTextEdit.removeTree(modifiersTree));
      // 2) add it at the beginning of modifiers
      builder.addTextEdit(reorderedModifiers(modifiersTree, false));
    } else {
      // HARD: there is annotations, and they might be anywhere, and spread on multiple lines
      // 1) Remove all modifiers individually
      removalOfAllModifiers(modifiersTree).stream()
        .map(JavaTextEdit::removeTextSpan)
        .forEach(builder::addTextEdit);

      // 2) reintroduce them right before the next token
      builder.addTextEdit(reorderedModifiers(modifiersTree, true));
    }

    return builder.build();
  }

  private static List<AnalyzerMessage.TextSpan> removalOfAllModifiers(ModifiersTree modifiersTree) {
    List<AnalyzerMessage.TextSpan> removals = new ArrayList<>();
    int numberModifiers = modifiersTree.size();
    for (int i = 0; i < numberModifiers; i++) {
      ModifierTree current = modifiersTree.get(i);
      if (current.is(Tree.Kind.ANNOTATION)) {
        continue;
      }
      if (i == (numberModifiers - 1)) {
        // Last: remove last token and potential space
        removals.add(AnalyzerMessage.textSpanBetween(current, true, QuickFixHelper.nextToken(modifiersTree), false));
      } else {
        // Take into account neighboring modifiers (can be on different lines)
        removals.add(AnalyzerMessage.textSpanBetween(current, true, modifiersTree.get(i + 1), false));
      }
    }
    return removals;
  }

  private static JavaTextEdit reorderedModifiers(ModifiersTree modifiersTree, boolean useParent) {
    String replacement = modifiersTree.modifiers()
      .stream()
      .sorted((m1, m2) -> m1.modifier().compareTo(m2.modifier()))
      .map(ModifierKeywordTree::keyword)
      .map(SyntaxToken::text)
      .collect(Collectors.joining("" ""));
    if (!useParent) {
      return JavaTextEdit.insertBeforeTree(modifiersTree.get(0), replacement);
    }
    return JavaTextEdit.insertBeforeTree(QuickFixHelper.nextToken(modifiersTree), replacement + "" "");
  }
}
"
S1125,CODE_SMELL,Boolean literals should not be redundant,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.ParenthesizedTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@Rule(key = ""S1125"")
public class BooleanLiteralCheck extends IssuableSubscriptionVisitor {

  private static final String FALSE_LITERAL = ""false"";
  private static final String TRUE_LITERAL = ""true"";

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Kind.EQUAL_TO, Kind.NOT_EQUAL_TO, Kind.CONDITIONAL_AND, Kind.CONDITIONAL_OR,
      Kind.LOGICAL_COMPLEMENT, Kind.CONDITIONAL_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    List<LiteralTree> literalList;
    if (tree.is(Kind.LOGICAL_COMPLEMENT)) {
      literalList = getBooleanLiterals(((UnaryExpressionTree) tree).expression());
    } else if (tree.is(Kind.CONDITIONAL_EXPRESSION)) {
      ConditionalExpressionTree expression = (ConditionalExpressionTree) tree;
      literalList = getBooleanLiterals(expression.trueExpression(), expression.falseExpression());
    } else {
      BinaryExpressionTree expression = (BinaryExpressionTree) tree;
      literalList = getBooleanLiterals(expression.leftOperand(), expression.rightOperand());
    }

    int nLiterals = literalList.size();
    if (nLiterals > 0) {
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(literalList.get(0))
        .withMessage(""Remove the unnecessary boolean literal%s."", nLiterals > 1 ? ""s"" : """")
        .withSecondaries(literalList.stream().skip(1).map(lit -> new JavaFileScannerContext.Location("""", lit)).toList())
        .withQuickFixes(() -> getQuickFix(tree))
        .report();
    }
  }

  private static List<LiteralTree> getBooleanLiterals(Tree... trees) {
    List<LiteralTree> booleanLiterals = new ArrayList<>();
    for (Tree t : trees) {
      if (t.is(Kind.NULL_LITERAL)) {
        return Collections.emptyList();
      } else if (t.is(Kind.BOOLEAN_LITERAL)) {
        booleanLiterals.add((LiteralTree) t);
      }
    }
    return booleanLiterals;
  }

  private static List<JavaQuickFix> getQuickFix(Tree tree) {
    List<JavaTextEdit> edits;
    if (tree.is(Kind.CONDITIONAL_EXPRESSION)) {
      edits = editsForConditionalExpression((ConditionalExpressionTree) tree);
    } else if (tree.is(Kind.LOGICAL_COMPLEMENT)) {
      String booleanValue = ((LiteralTree) ((UnaryExpressionTree) tree).expression()).value();
      edits = new ArrayList<>();
      edits.add(JavaTextEdit.replaceTree(tree, TRUE_LITERAL.equals(booleanValue) ? FALSE_LITERAL : TRUE_LITERAL));
    } else if (tree.is(Kind.EQUAL_TO)) {
      edits = editsForEquality((BinaryExpressionTree) tree, true);
    } else if (tree.is(Kind.NOT_EQUAL_TO)) {
      edits = editsForEquality((BinaryExpressionTree) tree, false);
    } else if (tree.is(Kind.CONDITIONAL_OR)) {
      edits = editsForConditional((BinaryExpressionTree) tree, true);
    } else {
      // Kind.CONDITIONAL_AND
      edits = editsForConditional((BinaryExpressionTree) tree, false);
    }

    if (edits.isEmpty()) {
      return Collections.emptyList();
    }
    return Collections.singletonList(JavaQuickFix.newQuickFix(""Simplify the expression"").addTextEdits(edits).build());
  }

  private static List<JavaTextEdit> editsForConditionalExpression(ConditionalExpressionTree tree) {
    List<JavaTextEdit> edits = new ArrayList<>();
    Boolean left = getBooleanValue(tree.trueExpression());
    Boolean right = getBooleanValue(tree.falseExpression());

    if (left != null) {
      if (right != null) {
        edits = editsForConditionalBothLiterals(tree, left, right);
      } else {
        if (left) {
          // cond() ? true : expr --> cond() || expr
          edits.add(JavaTextEdit.replaceBetweenTree(tree.questionToken(), tree.colonToken(), ""||""));
        } else {
          // cond() ? false : expr --> !cond() && expr
          edits.add(JavaTextEdit.replaceBetweenTree(tree.questionToken(), tree.colonToken(), ""&&""));
          List<JavaTextEdit> collection = computeNegatingTextEdits(tree.condition(), true);
          edits.addAll(collection);
        }
      }
    } else if (right != null) {
      // Defensive programming, if we reached this point, right must be a boolean literal
      edits.add(JavaTextEdit.removeTextSpan(textSpanBetween(tree.trueExpression(), false, tree.falseExpression(), true)));
      String operator;
      if (right) {
        // cond() ? expr : true --> !cond() || expr
        operator = ""||"";
        edits.add(JavaTextEdit.insertBeforeTree(tree.condition(), ""!""));
      } else {
        // cond() ? expr : false --> cond() && expr
        operator = ""&&"";
      }
      edits.add(JavaTextEdit.replaceTree(tree.questionToken(), operator));
    }
    return edits;
  }

  private static List<JavaTextEdit> computeNegatingTextEdits(ExpressionTree tree, boolean followedByConjunction) {
    List<JavaTextEdit> edits = new ArrayList<>();

    if (tree.is(Kind.PARENTHESIZED_EXPRESSION)) {
      ParenthesizedTree expression = (ParenthesizedTree) tree;
      edits.addAll(computeNegatingTextEdits(expression.expression(), false));
    } else if (tree.is(Kind.EQUAL_TO)) {
      BinaryExpressionTree condition = (BinaryExpressionTree) tree;
      edits.add(JavaTextEdit.replaceTree(condition.operatorToken(), ""!=""));
    } else if (tree.is(Kind.NOT_EQUAL_TO)) {
      BinaryExpressionTree condition = (BinaryExpressionTree) tree;
      edits.add(JavaTextEdit.replaceTree(condition.operatorToken(), ""==""));
    } else if (tree.is(Kind.CONDITIONAL_AND)) {
      BinaryExpressionTree condition = (BinaryExpressionTree) tree;
      if (followedByConjunction) {
        edits.add(JavaTextEdit.insertAfterTree(tree, "")""));
      }
      edits.addAll(computeNegatingTextEdits(condition.rightOperand(), followedByConjunction));
      edits.add(JavaTextEdit.replaceTree(condition.operatorToken(), ""||""));
      edits.addAll(computeNegatingTextEdits(condition.leftOperand(), false));
      if (followedByConjunction) {
        edits.add(JavaTextEdit.insertBeforeTree(tree, ""(""));
      }
    } else if (tree.is(Kind.CONDITIONAL_OR)) {
      BinaryExpressionTree condition = (BinaryExpressionTree) tree;
      edits.addAll(computeNegatingTextEdits(condition.rightOperand(), followedByConjunction));
      edits.add(JavaTextEdit.replaceTree(condition.operatorToken(), ""&&""));
      edits.addAll(computeNegatingTextEdits(condition.leftOperand(), true));
    } else {
      edits.add(JavaTextEdit.insertBeforeTree(tree, ""!""));
    }

    return edits;
  }

  private static List<JavaTextEdit> editsForConditionalBothLiterals(ConditionalExpressionTree tree, Boolean left, Boolean right) {
    List<JavaTextEdit> edits = new ArrayList<>();
    // Both side are literals.
    JavaTextEdit editRemoveExpressions = JavaTextEdit.removeTextSpan(textSpanBetween(tree.condition(), false, tree.falseExpression(), true));
    if (left && !right) {
      // cond() ? true : false --> cond()
      edits.add(editRemoveExpressions);
    } else if (!left && right) {
      // cond() ? false : true --> !cond()
      edits.add(editRemoveExpressions);
      edits.add(JavaTextEdit.insertBeforeTree(tree, ""!""));
    }
    // In case of ""true : true"" or ""false : false"", we do not add a quick fix as it looks like a bug (see S3923).
    return edits;
  }

  private static List<JavaTextEdit> editsForEquality(BinaryExpressionTree tree, boolean equalToOperator) {
    List<JavaTextEdit> edits = new ArrayList<>();

    ExpressionTree leftOperand = tree.leftOperand();
    ExpressionTree rightOperand = tree.rightOperand();
    Boolean left = getBooleanValue(leftOperand);
    Boolean right = getBooleanValue(rightOperand);

    if (left != null) {
      if (right != null) {
        edits.add(editForEqualityWhenBothLiterals(tree, left, right, equalToOperator));
      } else {
        // Presence of ""!"" is deducted from the inverse of the operator value.
        if (!left) {
          // false == expr -> !expr, false != expr --> expr
          equalToOperator = !equalToOperator;
        }
        edits.add(JavaTextEdit.replaceTextSpan(textSpanBetween(leftOperand, true, rightOperand, false), equalToOperator ? """" : ""!""));
      }
    } else if (right != null) {
      // Defensive programming, if we reached this point, right must be a boolean literal
      edits = editsForEqualityWhenRightIsLiteral(right, leftOperand, rightOperand, equalToOperator);
    }

    return edits;
  }

  private static JavaTextEdit editForEqualityWhenBothLiterals(BinaryExpressionTree tree, Boolean left, Boolean right, boolean equalToOperator) {
    if (!left.equals(right)) {
      // left and right are not the same, simplification is the inverse of the operator value.
      // true == false --> false, false == true --> false, true != false --> true, false != true --> true
      equalToOperator = !equalToOperator;
    }
    // left and right are the same, simplification can be deducted thanks to the operator value.
    return JavaTextEdit.replaceTree(tree, equalToOperator ? TRUE_LITERAL : FALSE_LITERAL);
  }

  private static List<JavaTextEdit> editsForEqualityWhenRightIsLiteral(Boolean right, ExpressionTree leftOperand, ExpressionTree rightOperand, boolean equalToOperator) {
    List<JavaTextEdit> edits = new ArrayList<>();
    // Right operand is a literal
    if (!right.equals(equalToOperator)) {
      // expr == false or expr != true --> !expr
      edits.add(JavaTextEdit.insertBeforeTree(leftOperand, ""!""));
    }
    edits.add(JavaTextEdit.removeTextSpan(textSpanBetween(leftOperand, false, rightOperand, true)));
    return edits;
  }


  private static List<JavaTextEdit> editsForConditional(BinaryExpressionTree tree, boolean conditionalOr) {
    List<JavaTextEdit> edits = new ArrayList<>();

    ExpressionTree leftOperand = tree.leftOperand();
    ExpressionTree rightOperand = tree.rightOperand();
    Boolean left = getBooleanValue(leftOperand);
    Boolean right = getBooleanValue(rightOperand);

    if (left != null) {
      if (right != null) {
        edits.add(editForConditionalWhenBothLiterals(tree, left, right, conditionalOr));
      } else {
        AnalyzerMessage.TextSpan textSpanToRemove;
        if (conditionalOr == left) {
          // true || var --> true or false && var --> false
          textSpanToRemove = textSpanBetween(leftOperand, false, rightOperand, true);
        } else {
          // false || var --> var or true && var --> var
          textSpanToRemove = textSpanBetween(leftOperand, true, rightOperand, false);
        }
        edits.add(JavaTextEdit.removeTextSpan(textSpanToRemove));
      }
    } else if (right != null) {
      // Defensive programming, if we reached this point, right must be a boolean literal
      editForConditionalWhenRightIsLiteral(right, leftOperand, rightOperand, conditionalOr)
        .ifPresent(edits::add);
    }

    return edits;
  }

  @Nullable
  private static Boolean getBooleanValue(Tree expression) {
    if (expression.is(Kind.BOOLEAN_LITERAL)) {
      return Boolean.parseBoolean(((LiteralTree) expression).value());
    }
    return null;
  }

  private static JavaTextEdit editForConditionalWhenBothLiterals(BinaryExpressionTree tree, Boolean left, Boolean right, boolean conditionalOr) {
    boolean conditionalAnd = !conditionalOr;
    boolean simplification =
      // true || true or true || false or false || true --> true
      (conditionalOr && (left || right))
        // true && true --> true
        || (conditionalAnd && left && right);

    return JavaTextEdit.replaceTree(tree, simplification ? TRUE_LITERAL : FALSE_LITERAL);
  }

  private static Optional<JavaTextEdit> editForConditionalWhenRightIsLiteral(Boolean right, ExpressionTree leftOperand, ExpressionTree rightOperand, boolean conditionalOr) {
    AnalyzerMessage.TextSpan textSpanToRemove;
    if (right.equals(conditionalOr)) {
      // var || true --> true or var && false --> false
      if (mayHaveSideEffect(leftOperand)) {
        // Can not remove a tree that could have side effect. We do not suggest to extract the side effect.
        return Optional.empty();
      }
      textSpanToRemove = textSpanBetween(leftOperand, true, rightOperand, false);
    } else {
      // var || false or var && true --> var
      textSpanToRemove = textSpanBetween(leftOperand, false, rightOperand, true);
    }
    return Optional.of(JavaTextEdit.removeTextSpan(textSpanToRemove));
  }

  private static boolean mayHaveSideEffect(Tree tree) {
    MethodInvocationFinder methodInvocationFinder = new MethodInvocationFinder();
    tree.accept(methodInvocationFinder);
    return methodInvocationFinder.found;
  }

  private static class MethodInvocationFinder extends BaseTreeVisitor {

    boolean found = false;

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      found = true;
    }
  }

}
"
S1126,CODE_SMELL,"Return of boolean expressions should not be wrapped into an ""if-then-else"" statement","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.JavaTree;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S1126"")
public class ReturnOfBooleanExpressionsCheck extends IssuableSubscriptionVisitor {


  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.IF_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    IfStatementTree ifStatementTree = (IfStatementTree) tree;
    StatementTree elseStatementOrNextStatement = getStatementTree(ifStatementTree);
    StatementTree thenStatement = ifStatementTree.thenStatement();

    if (hasOneReturnBoolean(elseStatementOrNextStatement) && hasOneReturnBoolean(thenStatement)) {
      reportIssue(ifStatementTree.ifKeyword(), ""Replace this if-then-else statement by a single return statement."");
    } else {
      Optional<MethodInvocationTree> elseMIT = getMethodInvocation(elseStatementOrNextStatement);
      Optional<MethodInvocationTree> thenMIT = getMethodInvocation(thenStatement);
      if (elseMIT.isPresent()
        && thenMIT.isPresent()
        && areAllSyntacticallyEquivalentExceptBoolean(elseMIT.get(), thenMIT.get())) {
        reportIssue(ifStatementTree.ifKeyword(), ""Replace this if-then-else statement by a single method invocation."");
      }
    }
  }

  private static StatementTree getStatementTree(IfStatementTree ifStatementTree) {
    StatementTree elseStatementOrNextStatement = ifStatementTree.elseStatement();
    if (elseStatementOrNextStatement == null) {
      JavaTree parent = (JavaTree) ifStatementTree.parent();
      List<Tree> children = parent.getChildren();
      int indexOfIf = children.indexOf(ifStatementTree);
      if (indexOfIf < children.size() - 1) {
        // Defensive, this condition should always be true as if necessarily followed by a statement or a token.
        Tree next = children.get(indexOfIf + 1);
        if(!next.is(Kind.TOKEN)) {
          elseStatementOrNextStatement = (StatementTree) next;
        }
      }
    }
    return elseStatementOrNextStatement;
  }

  private static boolean hasOneReturnBoolean(@Nullable StatementTree statementTree) {
    if (statementTree == null) {
      return false;
    }
    if (statementTree.is(Kind.BLOCK)) {
      BlockTree block = (BlockTree) statementTree;
      return block.body().size() == 1 && isReturnBooleanLiteral(block.body().get(0));
    }
    return isReturnBooleanLiteral(statementTree);
  }

  private static boolean isReturnBooleanLiteral(StatementTree statementTree) {
    if (statementTree.is(Kind.RETURN_STATEMENT)) {
      ExpressionTree expression = ((ReturnStatementTree) statementTree).expression();
      return expression != null && expression.is(Tree.Kind.BOOLEAN_LITERAL);
    }
    return false;
  }

  private static Optional<MethodInvocationTree> getMethodInvocation(@Nullable StatementTree statementTree) {
    if (statementTree == null) {
      return Optional.empty();
    }
    Tree newTree = statementTree;
    if (newTree.is(Tree.Kind.BLOCK)) {
      List<StatementTree> body = ((BlockTree) newTree).body();
      if (body.size() != 1) {
        return Optional.empty();
      }
      newTree = body.get(0);
    }
    ExpressionTree expressionTree = null;
    if (newTree.is(Tree.Kind.RETURN_STATEMENT)) {
      expressionTree = ((ReturnStatementTree) newTree).expression();
    } else if (newTree.is(Tree.Kind.EXPRESSION_STATEMENT)) {
      expressionTree = ((ExpressionStatementTree) newTree).expression();
    }
    if (expressionTree != null) {
      expressionTree = ExpressionUtils.skipParentheses(expressionTree);
      if (expressionTree.is(Kind.METHOD_INVOCATION)) {
        return Optional.of((MethodInvocationTree) expressionTree);
      }
    }
    return Optional.empty();
  }

  private static Tree firstNonParenthesesParent(Tree tree) {
    Tree skip = tree.parent();
    while (skip.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {
      skip = skip.parent();
    }
    return skip;
  }

  private static boolean areAllSyntacticallyEquivalentExceptBoolean(MethodInvocationTree mit1, MethodInvocationTree mit2) {
    if (firstNonParenthesesParent(mit1).kind() != firstNonParenthesesParent(mit2).kind()) {
      // requires to have on both side a return statement, or on both side an expression statement.
      return false;
    }
    if (!SyntacticEquivalence.areEquivalent(mit1.methodSelect(), mit2.methodSelect())) {
      return false;
    }
    List<ExpressionTree> mit1Args = mit1.arguments();
    List<ExpressionTree> mit2Args = mit2.arguments();
    if (mit1Args.size() != mit2Args.size()) {
      return false;
    }
    boolean containsBooleanLiteral = false;
    for (int i = 0; i < mit1Args.size(); i++) {
      ExpressionTree arg1 = ExpressionUtils.skipParentheses(mit1Args.get(i));
      ExpressionTree arg2 = ExpressionUtils.skipParentheses(mit2Args.get(i));
      boolean arg1IsBooleanLiteral = arg1.is(Tree.Kind.BOOLEAN_LITERAL);
      boolean arg2IsBooleanLiteral = arg2.is(Tree.Kind.BOOLEAN_LITERAL);
      if (SyntacticEquivalence.areEquivalent(arg1, arg2)) {
        containsBooleanLiteral |= arg1IsBooleanLiteral;
      } else {
        if (!(arg1IsBooleanLiteral && arg2IsBooleanLiteral)) {
          return false;
        }
        containsBooleanLiteral = true;
      }
    }
    return containsBooleanLiteral;
  }
}
"
S1128,CODE_SMELL,Unnecessary imports should be removed,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.JProblem;
import org.sonar.java.model.JWarning;
import org.sonar.java.model.JavaTree.CompilationUnitTreeImpl;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ImportTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.PackageDeclarationTree;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""UselessImportCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1128"")
public class UselessImportCheck extends IssuableSubscriptionVisitor {

  private static final Pattern COMPILER_WARNING = Pattern.compile(""The import ([$\\w]+(\\.[$\\w]+)*+) is never used"");
  private static final Pattern NON_WORDS_CHARACTERS = Pattern.compile(""\\W+"");
  private static final Pattern JAVADOC_REFERENCE = Pattern.compile(""\\{@link[^\\}]*\\}|(@see|@throws)[^\n]*\n"");

  private String currentPackage = """";
  private final List<ImportTree> imports = new ArrayList<>();
  private final Map<String, String> importsNames = new HashMap<>();
  private final Set<String> duplicatedImports = new HashSet<>();
  private final Set<String> usedInJavaDoc = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.TRIVIA, Tree.Kind.COMPILATION_UNIT, Tree.Kind.PACKAGE, Tree.Kind.IMPORT);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      ((CompilationUnitTree) tree).imports()
        .stream()
        .filter(importTree -> importTree.is(Tree.Kind.IMPORT))
        .map(ImportTree.class::cast)
        .forEach(imports::add);
      importsNames.clear();
      duplicatedImports.clear();
      usedInJavaDoc.clear();
      currentPackage = """";
    } else if (tree.is(Tree.Kind.PACKAGE)) {
      currentPackage = ExpressionsHelper.concatenate(((PackageDeclarationTree) tree).packageName());
    } else {
      handleImportTree((ImportTree) tree);
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      handleWarnings(((CompilationUnitTreeImpl) tree).warnings(JProblem.Type.UNUSED_IMPORT));
      imports.clear();
    }
  }

  private void handleWarnings(List<JWarning> warnings) {
    for (JWarning warning : warnings) {
      Matcher matcher = COMPILER_WARNING.matcher(warning.message());
      Optional<String> fqn = matcher.find() ? Optional.of(matcher.group(1)) : Optional.empty();
      fqn.ifPresent(importName -> {
        if (!usedInJavaDoc.contains(importName) && !importName.startsWith(""java.lang"")) {
          String message;
          if (duplicatedImports.contains(importName)) {
            message = ""Remove this duplicated import."";
          } else if (isImportFromSamePackage(importName, warning.syntaxTree())) {
            message = ""Remove this unnecessary import: same package classes are always implicitly imported."";
          } else {
            message = ""Remove this unused import '"" + importName + ""'."";
          }
          ImportTree reportTree = (ImportTree) warning.syntaxTree();
          QuickFixHelper.newIssue(context)
            .forRule(this)
            .onTree(reportTree.qualifiedIdentifier())
            .withMessage(message)
            .withQuickFix(() -> quickFix(reportTree, imports))
            .report();
        }
      });
    }
  }

  private boolean isImportFromSamePackage(String importName, Tree tree) {
    // ECJ warning message does not contain the "".*"" in case of star import, we have to find out if we are in this case.
    // Defensive programming, the syntax tree of the warning should always be an ImportTree.
    if (tree.is(Tree.Kind.IMPORT)) {
      Tree qualifiedIdentifier = ((ImportTree) tree).qualifiedIdentifier();
      // Defensive programming, the qualifiedIdentifier should always be a MemberSelectTree.
      if (qualifiedIdentifier.is(Tree.Kind.MEMBER_SELECT) &&
        ""*"".equals(((MemberSelectExpressionTree) qualifiedIdentifier).identifier().name())) {
        return importName.equals(currentPackage);
      }
    }

    return importName.substring(0, importName.lastIndexOf(""."")).equals(currentPackage);
  }

  private void handleImportTree(ImportTree importTree) {
    String importName = ExpressionsHelper.concatenate(((ExpressionTree) importTree.qualifiedIdentifier()));
    if (importsNames.containsKey(importName)) {
      duplicatedImports.add(importName);
    } else {
      importsNames.put(importName, extractLastClassName(importName));
    }
    if (isJavaLangImport(importName)) {
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(importTree.qualifiedIdentifier())
        .withMessage(""Remove this unnecessary import: java.lang classes are always implicitly imported."")
        .withQuickFix(() -> quickFix(importTree, imports))
        .report();
    }
  }

  private static String extractLastClassName(String reference) {
    int lastIndexOfDot = reference.lastIndexOf('.');
    return lastIndexOfDot == -1 ? reference : reference.substring(lastIndexOfDot + 1);
  }

  private static boolean isJavaLangImport(String reference) {
    return reference.startsWith(""java.lang."") && reference.indexOf('.', ""java.lang."".length()) == -1;
  }

  @Override
  public void visitTrivia(SyntaxTrivia syntaxTrivia) {
    String comment = syntaxTrivia.comment();
    if (!comment.startsWith(""/**"")) {
      return;
    }
    Matcher matcher = JAVADOC_REFERENCE.matcher(comment);
    while (matcher.find()) {
      String line = matcher.group(0);
      Set<String> words = NON_WORDS_CHARACTERS.splitAsStream(line)
        .filter(w -> !w.isEmpty())
        .collect(Collectors.toSet());

      if (!words.isEmpty()) {
        importsNames.forEach((fullyQualifiedName, name) -> {
          if (words.contains(name)) {
            usedInJavaDoc.add(fullyQualifiedName);
          }
        });
      }
    }
  }

  private static JavaQuickFix quickFix(ImportTree importTree, List<ImportTree> imports) {
    int indexOfImport = imports.indexOf(importTree);
    boolean isLastImport = indexOfImport == imports.size() - 1;
    JavaQuickFix.Builder quickFix = JavaQuickFix.newQuickFix(""Remove the %simport"", importTree.isStatic() ? ""static "" : """");
    if (imports.size() == 1) {
      // single import not used...
      quickFix.addTextEdit(JavaTextEdit.removeTree(importTree));
    } else if (!isLastImport) {
      ImportTree nextImport = imports.get(indexOfImport + 1);
      quickFix.addTextEdit(JavaTextEdit.removeTextSpan(AnalyzerMessage.textSpanBetween(importTree, true, nextImport, false)));
    } else {
      // last import
      ImportTree previousImport = imports.get(indexOfImport - 1);
      quickFix.addTextEdit(JavaTextEdit.removeTextSpan(AnalyzerMessage.textSpanBetween(previousImport, false, importTree, true)));
    }
    return quickFix.build();
  }
}
"
S113,CODE_SMELL,Files should end with a newline,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00113"", repositoryKey = ""squid"")
@Rule(key = ""S113"")
public class MissingNewLineAtEndOfFileCheck implements JavaFileScanner {


  @Override
  public void scanFile(JavaFileScannerContext context) {
    if (isEmptyOrNotEndingWithNewLine(context.getFileContent())) {
      context.addIssueOnFile(this, ""Add a new line at the end of this file."");
    }
  }

  private static boolean isEmptyOrNotEndingWithNewLine(String content) {
    if (content.isEmpty()) {
      return true;
    }
    char lastChar = content.charAt(content.length() - 1);
    return lastChar != '\n' && lastChar != '\r';
  }
}
"
S1130,CODE_SMELL,"Exceptions in ""throws"" clauses should not be superfluous","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.Javadoc;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.serialization.SerializableContract;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.ListTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""RedundantThrowsDeclarationCheck"", repositoryKey = ""squid"")
@Rule(key = ""S1130"")
public class RedundantThrowsDeclarationCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    ListTree<TypeTree> thrownList = ((MethodTree) tree).throwsClauses();
    if (thrownList.isEmpty()) {
      return;
    }
    checkMethodThrownList((MethodTree) tree, thrownList);
  }

  private void checkMethodThrownList(MethodTree methodTree, ListTree<TypeTree> thrownList) {
    Set<Type> thrownExceptions = thrownExceptionsFromBody(methodTree);
    boolean isOverridableMethod = methodTree.symbol().isOverridable();
    Set<String> undocumentedExceptionNames = new Javadoc(methodTree).undocumentedThrownExceptions();
    Set<String> reported = new HashSet<>();

    for (TypeTree typeTree : thrownList) {
      Type exceptionType = typeTree.symbolType();
      if (exceptionType.isUnknown()) {
        continue;
      }
      String fullyQualifiedName = exceptionType.fullyQualifiedName();
      if (!reported.contains(fullyQualifiedName)) {
        String superTypeName = isSubclassOfAny(exceptionType, thrownList);
        if (superTypeName != null && !exceptionType.isSubtypeOf(""java.lang.RuntimeException"")) {
          reportIssueWithQuickfix(methodTree, typeTree, String.format(
            ""Remove the declaration of thrown exception '%s' which is a subclass of '%s'."", fullyQualifiedName, superTypeName));
        } else if (declaredMoreThanOnce(fullyQualifiedName, thrownList)) {
          reportIssueWithQuickfix(methodTree, typeTree, String.format(
            ""Remove the redundant '%s' thrown exception declaration(s)."", fullyQualifiedName));
        } else if (canNotBeThrown(methodTree, exceptionType, thrownExceptions) && (!isOverridableMethod || undocumentedExceptionNames.contains(exceptionType.name()))) {
          reportIssueWithQuickfix(methodTree, typeTree, String.format(
            ""Remove the declaration of thrown exception '%s', as it cannot be thrown from %s's body."", fullyQualifiedName,
            methodTreeType(methodTree)));
        }
        reported.add(fullyQualifiedName);
      }
    }
  }

  private void reportIssueWithQuickfix(MethodTree methodTree, TypeTree clauseToRemove, String message) {
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(clauseToRemove)
      .withMessage(message)
      .withQuickFix(() -> createQuickFix(methodTree, clauseToRemove))
      .report();
  }

  private static JavaQuickFix createQuickFix(MethodTree methodTree, TypeTree clauseToRemove) {
    ListTree<TypeTree> throwsClauses = methodTree.throwsClauses();
    int clauseToRemoveIndex = throwsClauses.indexOf(clauseToRemove);
    boolean isFirst = clauseToRemoveIndex == 0;
    boolean isLast = clauseToRemoveIndex == throwsClauses.size() - 1;
    AnalyzerMessage.TextSpan textSpanToRemove;
    if (isFirst && isLast) {
      // also remove the ""throws"" token
      Tree treeBeforeThrows = methodTree.closeParenToken() != null ? methodTree.closeParenToken() : methodTree.simpleName();
      textSpanToRemove = AnalyzerMessage.textSpanBetween(treeBeforeThrows, false, clauseToRemove, true);
    } else if (isLast) {
      // also remove the previous coma
      TypeTree previousClause = throwsClauses.get(clauseToRemoveIndex - 1);
      textSpanToRemove = AnalyzerMessage.textSpanBetween(previousClause, false, clauseToRemove, true);
    } else {
      // also remove the next coma
      TypeTree nextClause = throwsClauses.get(clauseToRemoveIndex + 1);
      textSpanToRemove = AnalyzerMessage.textSpanBetween(clauseToRemove, true, nextClause, false);
    }
    return JavaQuickFix.newQuickFix(""Remove \""%s\"""", clauseToRemove.symbolType().name())
      .addTextEdit(JavaTextEdit.removeTextSpan(textSpanToRemove))
      .build();
  }

  private static String methodTreeType(MethodTree tree) {
    return tree.is(Tree.Kind.CONSTRUCTOR) ? ""constructor"" : ""method"";
  }

  private static boolean canNotBeThrown(MethodTree methodTree, Type exceptionType, @Nullable Set<Type> thrownExceptions) {
    if (isOverridingOrDesignedForExtension(methodTree)
      || !exceptionType.isSubtypeOf(""java.lang.Exception"")
      || exceptionType.isSubtypeOf(""java.lang.RuntimeException"")
      || thrownExceptions == null
      || thrownExceptions.stream().anyMatch(Type::isTypeVar)) {
      return false;
    }

    return thrownExceptions.stream().noneMatch(t -> t.isSubtypeOf(exceptionType));
  }

  private static boolean isOverridingOrDesignedForExtension(MethodTree methodTree) {
    // we need to be sure that it's not an override
    return !Boolean.FALSE.equals(methodTree.isOverriding())
      || SerializableContract.SERIALIZABLE_CONTRACT_METHODS.contains(methodTree.simpleName().name())
      || isDesignedForExtension(methodTree);
  }

  private static boolean isDesignedForExtension(MethodTree methodTree) {
    ModifiersTree modifiers = methodTree.modifiers();
    if (ModifiersUtils.hasModifier(modifiers, Modifier.PRIVATE)) {
      return false;
    }
    return ModifiersUtils.hasModifier(modifiers, Modifier.DEFAULT)
      || emptyBody(methodTree)
      || onlyReturnLiteralsOrThrowException(methodTree);
  }

  private static boolean onlyReturnLiteralsOrThrowException(MethodTree methodTree) {
    BlockTree block = methodTree.block();
    if (block == null) {
      return false;
    }
    List<StatementTree> body = block.body();
    if (body.size() != 1) {
      return false;
    }
    StatementTree singleStatement = body.get(0);
    return singleStatement.is(Tree.Kind.THROW_STATEMENT) || returnStatementWithLiteral(singleStatement);
  }

  private static boolean returnStatementWithLiteral(StatementTree statement) {
    if (statement.is(Tree.Kind.RETURN_STATEMENT)) {
      ExpressionTree expression = ((ReturnStatementTree) statement).expression();
      return expression == null || ExpressionUtils.skipParentheses(expression).is(
        Tree.Kind.NULL_LITERAL,
        Tree.Kind.STRING_LITERAL,
        Tree.Kind.BOOLEAN_LITERAL,
        Tree.Kind.CHAR_LITERAL,
        Tree.Kind.DOUBLE_LITERAL,
        Tree.Kind.FLOAT_LITERAL,
        Tree.Kind.LONG_LITERAL,
        Tree.Kind.INT_LITERAL);
    }
    return false;
  }

  private static boolean emptyBody(MethodTree methodTree) {
    BlockTree block = methodTree.block();
    return block != null && block.body().isEmpty();
  }

  @Nullable
  private static Set<Type> thrownExceptionsFromBody(MethodTree methodTree) {
    BlockTree block = methodTree.block();
    if (block != null) {
      ThrownExceptionVisitor visitor = new ThrownExceptionVisitor(methodTree);
      block.accept(visitor);
      return visitor.thrownExceptions();
    }
    return null;
  }

  private static class ThrownExceptionVisitor extends BaseTreeVisitor {
    private Set<Type> thrownExceptions = new HashSet<>();
    private boolean visitedUnknown = false;
    private boolean visitedOtherConstructor = false;
    private final MethodTree methodTree;
    private static final String CONSTRUCTOR_NAME = ""<init>"";

    ThrownExceptionVisitor(MethodTree methodTree) {
      this.methodTree = methodTree;
    }

    @Nullable
    public Set<Type> thrownExceptions() {
      if (visitedUnknown || thrownExceptions.stream().anyMatch(Type::isUnknown)) {
        // as soon as there is an unknown type, we discard any attempt to find an issue
        return null;
      }
      if (methodTree.is(Tree.Kind.CONSTRUCTOR) && !visitedOtherConstructor) {
        getImplicitlyCalledConstructor(methodTree)
          .map(Symbol.MethodSymbol::thrownTypes)
          .ifPresent(thrownExceptions::addAll);
      }
      return thrownExceptions;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (CONSTRUCTOR_NAME.equals(tree.methodSymbol().name())) {
        visitedOtherConstructor = true;
      }
      addThrownTypes(tree.methodSymbol());
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      addThrownTypes(tree.methodSymbol());
      super.visitNewClass(tree);
    }

    private void addThrownTypes(Symbol.MethodSymbol methodSymbol) {
      if (!visitedUnknown) {
        if (methodSymbol.isUnknown()) {
          visitedUnknown = true;
        } else {
          thrownExceptions.addAll(methodSymbol.thrownTypes());
        }
      }
    }

    @Override
    public void visitThrowStatement(ThrowStatementTree tree) {
      Type exceptionType = tree.expression().symbolType();
      thrownExceptions.add(exceptionType);
      super.visitThrowStatement(tree);
    }

    @Override
    public void visitTryStatement(TryStatementTree tree) {
      for (Tree resource : tree.resourceList()) {
        Type resourceType = resourceType(resource);
        List<Type> thrownTypes = closeMethodThrownTypes(resourceType);
        if (thrownTypes == null) {
          visitedUnknown = true;
        } else {
          thrownExceptions.addAll(thrownTypes);
        }
      }
      super.visitTryStatement(tree);
    }

    private static Type resourceType(Tree resource) {
      if (resource.is(Tree.Kind.VARIABLE)) {
        return ((VariableTree) resource).type().symbolType();
      }
      // Java9+
      return ((TypeTree) resource).symbolType();
    }

    @Override
    public void visitClass(ClassTree tree) {
      // skip anonymous classes
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // skip lambdas
    }

    @CheckForNull
    private static List<Type> closeMethodThrownTypes(Type classType) {
      return classType.symbol().lookupSymbols(""close"").stream()
        .filter(Symbol::isMethodSymbol)
        .map(Symbol.MethodSymbol.class::cast)
        .filter(method -> method.parameterTypes().isEmpty())
        .map(Symbol.MethodSymbol::thrownTypes)
        .findFirst()
        .orElseGet(() -> directSuperTypeStream(classType).map(ThrownExceptionVisitor::closeMethodThrownTypes)
          .filter(Objects::nonNull)
          .findFirst()
          .orElse(null));
    }

    private static Stream<Type> directSuperTypeStream(Type classType) {
      Symbol.TypeSymbol symbol = classType.symbol();
      Stream<Type> interfaceStream = symbol.interfaces().stream();
      Type superClass = symbol.superClass();
      return superClass != null ? Stream.concat(Stream.of(superClass), interfaceStream) : interfaceStream;
    }

    private static Optional<Symbol.MethodSymbol> getImplicitlyCalledConstructor(MethodTree methodTree) {
      Type superType = ((Symbol.TypeSymbol) methodTree.symbol().owner()).superClass();
      if (superType == null) {
        // superClass() returns null only for java.lang.Object and methods not correctly recovered
        return Optional.empty();
      }
      return Objects.requireNonNull(superType).symbol().memberSymbols().stream()
        .filter(ThrownExceptionVisitor::isDefaultConstructor)
        .map(Symbol.MethodSymbol.class::cast)
        .findFirst();
    }

    private static boolean isDefaultConstructor(Symbol symbol) {
      if (symbol.isMethodSymbol()) {
        Symbol.MethodSymbol methodSymbol = (Symbol.MethodSymbol) symbol;
        if (CONSTRUCTOR_NAME.equals(methodSymbol.name())) {
          if (methodSymbol.declaration() != null) {
            // Constructor is inside this file, in case of nested class, parameterTypes() will include an extra implicit
            // parameter type. We hopefully have access to the declaration that does not include implicit parameter.
            return methodSymbol.declaration().parameters().isEmpty();
          }
          // The declaration is in another class, we can use parameterTypes() safely since it can not be nested.
          return  methodSymbol.parameterTypes().isEmpty();
        }
      }
      return false;
    }
  }

  private static boolean declaredMoreThanOnce(String fullyQualifiedName, ListTree<TypeTree> thrown) {
    boolean firstOccurrenceFound = false;
    for (TypeTree typeTree : thrown) {
      if (typeTree.symbolType().is(fullyQualifiedName)) {
        if (firstOccurrenceFound) {
          return true;
        }
        firstOccurrenceFound = true;
      }
    }
    return false;
  }

  private static String isSubclassOfAny(Type type, ListTree<TypeTree> thrownList) {
    for (TypeTree thrown : thrownList) {
      String name = thrown.symbolType().fullyQualifiedName();
      if (!type.is(name) && type.isSubtypeOf(name)) {
        return name;
      }
    }
    return null;
  }
}
"
S1132,CODE_SMELL,Strings literals should be placed on the left side when checking for equality,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S1132"")
public class StringLiteralInsideEqualsCheck extends IssuableSubscriptionVisitor {

  private static final int MESSAGE_ARG_MAX_LENGTH = 10;

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    check((MethodInvocationTree) tree);
  }

  private void check(MethodInvocationTree tree) {
    if (tree.methodSelect() instanceof MemberSelectExpressionTree memberSelectExpressionTree && isEquals(tree)) {
      LiteralTree stringLiteral = (LiteralTree) tree.arguments().get(0);
      ExpressionTree leftSideMember = memberSelectExpressionTree.expression();
      if (!leftSideMember.is(Kind.STRING_LITERAL)) {
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(stringLiteral)
          .withMessage(""Move the "" + stringLiteral.value() + "" string literal on the left side of this string comparison."")
          .withQuickFix(() -> computeQuickFix(stringLiteral, leftSideMember))
          .report();
      }
    }
  }

  private static boolean isEquals(MethodInvocationTree tree) {
    IdentifierTree identifier = ((MemberSelectExpressionTree) tree.methodSelect()).identifier();
    return isNamedEquals(identifier) && tree.arguments().size() == 1 && tree.arguments().get(0).is(Kind.STRING_LITERAL);
  }

  private static boolean isNamedEquals(IdentifierTree tree) {
    return ""equals"".equals(tree.name()) ||
      ""equalsIgnoreCase"".equals(tree.name());
  }

  private JavaQuickFix computeQuickFix(LiteralTree equalsArgument, ExpressionTree leftSideMember) {
    String equalsParameterValue = QuickFixHelper.contentForTree(equalsArgument, context);
    String quickFixMessage = String.format(""Move %s on the left side of .equals"", cutTooLongString(equalsParameterValue));
    return JavaQuickFix.newQuickFix(quickFixMessage)
      .addTextEdit(JavaTextEdit.replaceTree(equalsArgument, QuickFixHelper.contentForTree(leftSideMember, context)))
      .addTextEdit(JavaTextEdit.replaceTree(leftSideMember, equalsParameterValue))
      .build();
  }

  private static String cutTooLongString(String s) {
    return s.length() > MESSAGE_ARG_MAX_LENGTH ? (s.substring(0, MESSAGE_ARG_MAX_LENGTH) + ""\""..."") : s;
  }

}
"
S1133,CODE_SMELL,Deprecated code should be removed,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.ast.visitors.PublicApiChecker;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.DeprecatedCheckerHelper.deprecatedAnnotation;
import static org.sonar.java.checks.helpers.DeprecatedCheckerHelper.reportTreeForDeprecatedTree;
import static org.sonar.java.checks.helpers.DeprecatedCheckerHelper.hasJavadocDeprecatedTag;

@Rule(key = ""S1133"")
public class DeprecatedTagPresenceCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(PublicApiChecker.apiKinds());
  }

  @Override
  public void visitNode(Tree tree) {
    if (hasDeprecatedAnnotation(tree) || hasJavadocDeprecatedTag(tree)) {
      reportIssue(reportTreeForDeprecatedTree(tree), ""Do not forget to remove this deprecated code someday."");
    }
  }

  private static boolean hasDeprecatedAnnotation(Tree tree) {
    return deprecatedAnnotation(tree) != null;
  }

}
"
S1134,CODE_SMELL,"Track uses of ""FIXME"" tags","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1134"")
public class FixmeTagPresenceCheck extends IssuableSubscriptionVisitor {

  private static final String PATTERN = ""FIXME"";
  private static final String MESSAGE = ""Take the required action to fix the issue indicated by this comment."";
  private final CommentContainsPatternChecker checker = new CommentContainsPatternChecker(this, PATTERN, MESSAGE);

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRIVIA);
  }

  @Override
  public void visitTrivia(SyntaxTrivia syntaxTrivia) {
    checker.checkTrivia(syntaxTrivia);
  }
}
"
S1135,CODE_SMELL,"Track uses of ""TODO"" tags","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1135"")
public class TodoTagPresenceCheck extends IssuableSubscriptionVisitor {

  private static final String PATTERN = ""TODO"";
  private static final String MESSAGE = ""Complete the task associated to this TODO comment."";

  private final CommentContainsPatternChecker checker = new CommentContainsPatternChecker(this, PATTERN, MESSAGE);

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRIVIA);
  }

  @Override
  public void visitTrivia(SyntaxTrivia syntaxTrivia) {
    checker.checkTrivia(syntaxTrivia);
  }
}
"
S114,CODE_SMELL,Interface names should comply with a naming convention,"package org.sonar.java.checks.naming;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.regex.Pattern;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00114"", repositoryKey = ""squid"")
@Rule(key = ""S114"")
public class BadInterfaceNameCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String DEFAULT_FORMAT = ""^[A-Z][a-zA-Z0-9]*$"";

  @RuleProperty(
    key = ""format"",
    description = ""Regular expression used to check the interface names against."",
    defaultValue = """" + DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;

  private Pattern pattern = null;
  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    if (pattern == null) {
      pattern = Pattern.compile(format, Pattern.DOTALL);
    }
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    if (tree.is(Tree.Kind.INTERFACE) && !pattern.matcher(tree.simpleName().name()).matches()) {
      context.reportIssue(this, tree.simpleName(), ""Rename this interface name to match the regular expression '"" + format + ""'."");
    }

    super.visitClass(tree);
  }

}
"
S1141,CODE_SMELL,Try-catch blocks should not be nested,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

@Rule(key = ""S1141"")
public class NestedTryCatchCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;
  private Deque<Deque<Tree>> nestingLevel = new ArrayDeque<>();

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    nestingLevel.clear();
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    nestingLevel.push(new ArrayDeque<>());
    super.visitClass(tree);
    nestingLevel.pop();
  }

  @Override
  public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
    nestingLevel.push(new ArrayDeque<>());
    super.visitLambdaExpression(lambdaExpressionTree);
    nestingLevel.pop();
  }

  @Override
  public void visitTryStatement(TryStatementTree tree) {
    scan(tree.resourceList());
    Deque<Tree> currentNestingLevel = nestingLevel.peek();

    if (!tree.catches().isEmpty()) {
      int size = currentNestingLevel.size();
      if (size > 0) {
        List<JavaFileScannerContext.Location> secondary = new ArrayList<>(size);
        for (Tree element : currentNestingLevel) {
          secondary.add(new JavaFileScannerContext.Location(""Nesting + 1"", element));
        }
        context.reportIssue(this, tree.tryKeyword(), ""Extract this nested try block into a separate method."", secondary, null);
      }
      currentNestingLevel.push(tree.tryKeyword());
    }
    scan(tree.block());
    if (!tree.catches().isEmpty()) {
      currentNestingLevel.pop();
    }
    scan(tree.catches());
    scan(tree.finallyBlock());
  }
}
"
S1142,CODE_SMELL,Methods should not have too many return statements,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1142"")
public class MethodWithExcessiveReturnsCheck extends IssuableSubscriptionVisitor {

  private static final String ISSUE_MESSAGE = ""This method has %d returns, which is more than the %d allowed."";

  private static final int DEFAULT_MAX = 3;

  @RuleProperty(description = ""Maximum allowed return statements per method"", defaultValue = """" + DEFAULT_MAX)
  public int max = DEFAULT_MAX;

  private final Map<Tree, List<Tree>> returnStatements = new HashMap<>();
  private final Deque<Tree> methodsOrLambdas = new LinkedList<>();

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    returnStatements.clear();
    methodsOrLambdas.clear();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.RETURN_STATEMENT, Tree.Kind.METHOD, Tree.Kind.LAMBDA_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.RETURN_STATEMENT)) {
      returnStatements.computeIfAbsent(methodsOrLambdas.peek(), k -> new LinkedList<>())
        .add(((ReturnStatementTree) tree).returnKeyword());
    } else {
      methodsOrLambdas.push(tree);
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (!tree.is(Tree.Kind.RETURN_STATEMENT)) {
      reportTree(tree).ifPresent(reportTree -> report(tree, reportTree));
      returnStatements.remove(tree);
      methodsOrLambdas.pop();
    }
  }

  private static Optional<Tree> reportTree(Tree methodOrLambda) {
    if (methodOrLambda.is(Tree.Kind.LAMBDA_EXPRESSION)) {
      return Optional.of(((LambdaExpressionTree) methodOrLambda).arrowToken());
    }
    MethodTree method = (MethodTree) methodOrLambda;
    if (!MethodTreeUtils.isEqualsMethod(method)) {
      return Optional.of(method.simpleName());
    }
    // equals can have many returns and it's OK
    return Optional.empty();
  }

  private void report(Tree currentTree, Tree reportTree) {
    List<Tree> returns = returnStatements.getOrDefault(currentTree, Collections.emptyList());
    int count = returns.size();
    if (count > max) {
      String message = String.format(ISSUE_MESSAGE, count, max);
      List<JavaFileScannerContext.Location> secondaries = returns.stream()
        .map(token -> new JavaFileScannerContext.Location(""return"", token))
        .toList();
      reportIssue(reportTree, message, secondaries, null);
    }
  }
}
"
S1143,BUG,"Jump statements should not occur in ""finally"" blocks","package org.sonar.java.checks;

import java.util.Deque;
import java.util.LinkedList;
import org.sonar.check.Rule;
import org.sonar.java.model.DefaultJavaFileScannerContext;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.BreakStatementTree;
import org.sonar.plugins.java.api.tree.ContinueStatementTree;
import org.sonar.plugins.java.api.tree.DoWhileStatementTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.SwitchStatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

@Rule(key = ""S1143"")
public class ReturnInFinallyCheck extends BaseTreeVisitor implements JavaFileScanner {

  private final Deque<Tree.Kind> treeKindStack = new LinkedList<>();
  private DefaultJavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = (DefaultJavaFileScannerContext) context;
    treeKindStack.clear();
    scan(context.getTree());
  }

  @Override
  public void visitTryStatement(TryStatementTree tree) {
    scan(tree.resourceList());
    scan(tree.block());
    scan(tree.catches());
    BlockTree finallyBlock = tree.finallyBlock();
    if (finallyBlock != null) {
      treeKindStack.push(finallyBlock.kind());
      scan(finallyBlock);
      treeKindStack.pop();
    }
  }

  @Override
  public void visitMethod(MethodTree tree) {
    treeKindStack.push(tree.kind());
    super.visitMethod(tree);
    treeKindStack.pop();
  }

  @Override
  public void visitForStatement(ForStatementTree tree) {
    treeKindStack.push(tree.kind());
    super.visitForStatement(tree);
    treeKindStack.pop();
  }

  @Override
  public void visitForEachStatement(ForEachStatement tree) {
    treeKindStack.push(tree.kind());
    super.visitForEachStatement(tree);
    treeKindStack.pop();
  }

  @Override
  public void visitWhileStatement(WhileStatementTree tree) {
    treeKindStack.push(tree.kind());
    super.visitWhileStatement(tree);
    treeKindStack.pop();
  }

  @Override
  public void visitDoWhileStatement(DoWhileStatementTree tree) {
    treeKindStack.push(tree.kind());
    super.visitDoWhileStatement(tree);
    treeKindStack.pop();
  }

  @Override
  public void visitSwitchStatement(SwitchStatementTree tree) {
    treeKindStack.push(tree.kind());
    super.visitSwitchStatement(tree);
    treeKindStack.pop();
  }

  @Override
  public void visitReturnStatement(ReturnStatementTree tree) {
    reportIssue(tree.returnKeyword(), tree.kind());
    super.visitReturnStatement(tree);
  }

  @Override
  public void visitThrowStatement(ThrowStatementTree tree) {
    reportIssue(tree.throwKeyword(), tree.kind());
    super.visitThrowStatement(tree);
  }

  @Override
  public void visitContinueStatement(ContinueStatementTree tree) {
    reportIssue(tree.continueKeyword(), tree.kind());
    super.visitContinueStatement(tree);
  }

  @Override
  public void visitBreakStatement(BreakStatementTree tree) {
    reportIssue(tree.breakKeyword(), tree.kind());
    super.visitBreakStatement(tree);
  }

  private void reportIssue(SyntaxToken syntaxToken, Tree.Kind jumpKind) {
    if (isAbruptFinallyBlock(jumpKind)) {
      context.newIssue()
        .forRule(this)
        .onTree(syntaxToken)
        .withMessage(""Remove this %s statement from this finally block."", syntaxToken.text())
        .report();
    }
  }

  private boolean isAbruptFinallyBlock(Tree.Kind jumpKind) {
    if (treeKindStack.isEmpty()) {
      return false;
    }
    Tree.Kind blockKind = treeKindStack.peek();
    switch (blockKind) {
      case BLOCK:
        return true;
      case FOR_STATEMENT:
      case FOR_EACH_STATEMENT:
      case WHILE_STATEMENT:
      case DO_STATEMENT:
      case SWITCH_STATEMENT:
        return handleControlFlowInFinally(jumpKind);
      case METHOD:
      default:
        return false;
    }
  }

  private boolean handleControlFlowInFinally(Tree.Kind jumpKind) {
    if (jumpKind == Tree.Kind.BREAK_STATEMENT || jumpKind == Tree.Kind.CONTINUE_STATEMENT) {
      return false;
    } else {
      Tree.Kind parentOfControlFlowStatement = treeKindStack.stream()
        .filter(t -> t == Tree.Kind.BLOCK || t == Tree.Kind.METHOD)
        .findFirst()
        .orElse(Tree.Kind.METHOD);
      return parentOfControlFlowStatement == Tree.Kind.BLOCK;
    }
  }

}
"
S1144,CODE_SMELL,"Unused ""private"" methods should be removed","package org.sonar.java.checks.unused;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.serialization.SerializableContract;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@DeprecatedRuleKey(ruleKey = ""UnusedPrivateMethod"", repositoryKey = ""squid"")
@Rule(key = ""S1144"")
public class UnusedPrivateMethodCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS, Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    reportUnusedPrivateMethods(findUnusedPrivateMethods((ClassTree) tree));
  }

  private static Stream<MethodTree> findUnusedPrivateMethods(ClassTree tree) {
    var collector = new UnusedMethodCollector();
    tree.members().forEach(it -> it.accept(collector));
    var unusedPrivateMethods = collector.unusedPrivateMethods;
    if (unusedPrivateMethods.isEmpty()) {
      return Stream.empty();
    }

    var methodNames = unusedPrivateMethods.stream().map(it -> it.simpleName().name()).collect(Collectors.toSet());
    methodNames.removeAll(collector.unresolvedMethodNames);
    var filter = new MethodsUsedInAnnotationsFilter(methodNames);
    tree.accept(filter);
    return unusedPrivateMethods.stream().filter(it -> filter.filteredNames.contains(it.simpleName().name()));
  }

  private void reportUnusedPrivateMethods(Stream<MethodTree> methods) {
    methods
      .forEach(methodTree -> {
        IdentifierTree simpleName = methodTree.simpleName();
        String methodType = methodTree.is(Tree.Kind.CONSTRUCTOR) ? ""constructor"" : ""method"";
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(simpleName)
          .withMessage(""Remove this unused private \""%s\"" %s."", simpleName.name(), methodType)
          .withQuickFix(() -> JavaQuickFix.newQuickFix(""Remove the unused %s"", methodType)
            .addTextEdit(JavaTextEdit.removeTextSpan(textSpanBetween(QuickFixHelper.previousToken(methodTree), false, methodTree, true)))
            .build())
          .report();
      });
  }

  private static class UnusedMethodCollector extends BaseTreeVisitor {

    public final List<MethodTree> unusedPrivateMethods = new ArrayList<>();
    public final Set<String> unresolvedMethodNames = new HashSet<>();

    private static final Set<String> PARAM_ANNOTATION_EXCEPTIONS = Set.of(
      ""javax.enterprise.event.Observes"",
      ""jakarta.enterprise.event.Observes""
    );

    @Override
    public void visitClass(ClassTree tree) {
      // cut visitation of inner classes
    }

    @Override
    public void visitMethod(MethodTree methodTree) {
      super.visitMethod(methodTree);
      Symbol symbol = methodTree.symbol();
      if (isUnusedPrivate(symbol) && hasNoAnnotation(methodTree) && (isConstructorWithParameters(methodTree) || isNotMethodFromSerializable(methodTree, symbol))) {
        unusedPrivateMethods.add(methodTree);
      }
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree mit) {
      super.visitMethodInvocation(mit);
      String name = ExpressionUtils.methodName(mit).name();
      addIfArgumentsAreUnknown(mit.arguments(), name);
      addIfUnknownOrAmbiguous(mit.methodSymbol(), name);
    }

    @Override
    public void visitMethodReference(MethodReferenceTree mref) {
      super.visitMethodReference(mref);
      IdentifierTree methodIdentifier = mref.method();
      addIfUnknownOrAmbiguous(methodIdentifier.symbol(), methodIdentifier.name());
    }

    @Override
    public void visitNewClass(NewClassTree nct) {
      super.visitNewClass(nct);
      String name = constructorName(nct.identifier());
      addIfArgumentsAreUnknown(nct.arguments(), name);
      addIfUnknownOrAmbiguous(nct.methodSymbol(), name);
    }

    private void addIfArgumentsAreUnknown(Arguments arguments, String name) {
      // In case of broken semantic, if the argument is unknown, the method call will not have the correct reference.
      if (arguments.stream().anyMatch(arg -> arg.symbolType().isUnknown())) {
        unresolvedMethodNames.add(name);
      }
    }

    private void addIfUnknownOrAmbiguous(Symbol symbol, String name) {
      // In case of broken semantic (overload with unknown args), ECJ wrongly link the symbol to the good overload.
      if (symbol.isUnknown() || (symbol.isMethodSymbol() && ((Symbol.MethodSymbol) symbol).parameterTypes().stream().anyMatch(Type::isUnknown))) {
        unresolvedMethodNames.add(name);
      }
    }

    private static String constructorName(TypeTree typeTree) {
      return switch (typeTree.kind()) {
        case PARAMETERIZED_TYPE -> constructorName(((ParameterizedTypeTree) typeTree).type());
        case MEMBER_SELECT -> ((MemberSelectExpressionTree) typeTree).identifier().name();
        case IDENTIFIER -> ((IdentifierTree) typeTree).name();
        default -> throw new IllegalStateException(""Unexpected TypeTree used as constructor."");
      };
    }

    private static boolean isUnusedPrivate(Symbol symbol) {
      return symbol.isPrivate() && symbol.usages().isEmpty();
    }

    private static boolean hasNoAnnotation(MethodTree methodTree) {
      return methodTree.modifiers().annotations().isEmpty() && methodTree.parameters().stream().noneMatch(UnusedMethodCollector::hasAllowedAnnotation);
    }

    private static boolean hasAllowedAnnotation(VariableTree variableTree) {
      List<AnnotationTree> annotations = variableTree.modifiers().annotations();
      return !annotations.isEmpty() && annotations.stream().anyMatch(UnusedMethodCollector::isAllowedAnnotation);
    }

    private static boolean isAllowedAnnotation(AnnotationTree annotation) {
      Type annotationSymbolType = annotation.symbolType();
      if (PARAM_ANNOTATION_EXCEPTIONS.stream().anyMatch(annotationSymbolType::is)) {
        return true;
      }
      if (annotationSymbolType.isUnknown()) {
        TypeTree annotationType = annotation.annotationType();
        if (annotationType.is(Tree.Kind.IDENTIFIER)) {
          return ""Observes"".equals(((IdentifierTree) annotationType).name());
        }
        if (annotationType.is(Tree.Kind.MEMBER_SELECT)) {
          String concatenatedAnnotation = ExpressionsHelper.concatenate((MemberSelectExpressionTree) annotationType);
          return PARAM_ANNOTATION_EXCEPTIONS.stream().anyMatch(concatenatedAnnotation::equals);
        }
      }
      return false;
    }

    private static boolean isConstructorWithParameters(MethodTree methodTree) {
      return methodTree.is(Tree.Kind.CONSTRUCTOR) && !methodTree.parameters().isEmpty();
    }

    private static boolean isNotMethodFromSerializable(MethodTree methodTree, Symbol symbol) {
      return methodTree.is(Tree.Kind.METHOD) && !SerializableContract.SERIALIZABLE_CONTRACT_METHODS.contains(symbol.name());
    }
  }

  private static class MethodsUsedInAnnotationsFilter extends BaseTreeVisitor {

    public MethodsUsedInAnnotationsFilter(Set<String> methodNames) {
      this.filteredNames = methodNames;
    }

    private final Set<String> filteredNames;

    private static boolean isNameIndicatingMethod(String name) {
      return name.toLowerCase(Locale.getDefault()).contains(""method"");
    }

    private void removeMethodName(LiteralTree literal) {
      filteredNames.remove(removeQuotes(literal.value()));
    }

    private static String removeQuotes(String withQuotes) {
      return withQuotes.substring(1, withQuotes.length() - 1);
    }

    @Override
    public void visitAnnotation(AnnotationTree annotationTree) {
      var isMethodAnnotation = isNameIndicatingMethod(annotationTree.annotationType().symbolType().name());
      for (var arg : annotationTree.arguments()) {
        if (arg.is(Tree.Kind.STRING_LITERAL)) {
          if (isMethodAnnotation) {
            removeMethodName((LiteralTree) arg);
          }
        } else if (arg instanceof AssignmentExpressionTree asgn && asgn.expression().is(Tree.Kind.STRING_LITERAL) && (
          isMethodAnnotation || isNameIndicatingMethod(((IdentifierTree) asgn.variable()).name())
        )) {
          removeMethodName((LiteralTree) asgn.expression());
        }
      }
    }
  }
}
"
S1147,CODE_SMELL,Exit methods should not be called,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

@Rule(key = ""S1147"")
public class SystemExitCalledCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.CONSTRUCTOR) || !MethodTreeUtils.isMainMethod((MethodTree) tree)) {
      tree.accept(new InvocationVisitor());
    }
  }

  private class InvocationVisitor extends BaseTreeVisitor {

    private String idName;

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (isCallToExitMethod(tree)) {
        reportIssue(tree.methodSelect(), ""Remove this call to \"""" + idName + ""\"" or ensure it is really required."");
      }
    }

    private boolean isCallToExitMethod(MethodInvocationTree tree) {
      String selection = concatenate(tree.methodSelect());
      return ""System.exit"".equals(selection)
        || ""Runtime.getRuntime().exit"".equals(selection)
        || ""Runtime.getRuntime().halt"".equals(selection);
    }

    private String concatenate(ExpressionTree tree) {
      Deque<String> pieces = new LinkedList<>();

      ExpressionTree expr = tree;
      while (expr.is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree mse = (MemberSelectExpressionTree) expr;
        pieces.push(mse.identifier().name());
        pieces.push(""."");
        expr = mse.expression();
      }
      if (expr.is(Tree.Kind.METHOD_INVOCATION)) {
        pieces.push(""()"");
        pieces.push(concatenate(((MethodInvocationTree) expr).methodSelect()));
      }
      if (expr.is(Tree.Kind.IDENTIFIER)) {
        IdentifierTree idt = (IdentifierTree) expr;
        pieces.push(idt.name());
      }

      StringBuilder sb = new StringBuilder();
      idName = pieces.getLast();
      for (String piece : pieces) {
        sb.append(piece);
      }
      return sb.toString();
    }
  }
}
"
S1149,CODE_SMELL,"Synchronized classes ""Vector"", ""Hashtable"", ""Stack"" and ""StringBuffer"" should not be used","package org.sonar.java.checks;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonarsource.analyzer.commons.collections.MapBuilder;

@Rule(key = ""S1149"")
public class SynchronizedClassUsageCheck extends IssuableSubscriptionVisitor {

  private static final Map<String, String> REPLACEMENTS = MapBuilder.<String, String>newMap()
    .put(""java.util.Vector"", ""\""ArrayList\"" or \""LinkedList\"""")
    .put(""java.util.Hashtable"", ""\""HashMap\"""")
    .put(""java.lang.StringBuffer"", ""\""StringBuilder\"""")
    .put(""java.util.Stack"", ""\""Deque\"""")
    .build();

  private final Deque<Set<String>> exclusions = new ArrayDeque<>();

  private final Set<Tree> visited = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    // We register on compilation units to clear the visited set when scanning a new file
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.COMPILATION_UNIT, Tree.Kind.ENUM, Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      // We clear the visited set when entering every file
      visited.clear();
      return;
    }
    ExclusionsVisitor exclusionsVisitor = new ExclusionsVisitor();
    tree.accept(exclusionsVisitor);
    Set<String> currentClassExclusions = exclusionsVisitor.exclusions;
    if (!exclusions.isEmpty()) {
      currentClassExclusions.addAll(exclusions.peek());
    }
    exclusions.push(currentClassExclusions);
    tree.accept(new DeprecatedTypeVisitor());
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      return;
    }
    exclusions.pop();
  }

  private static class ExclusionsVisitor extends BaseTreeVisitor {
    Set<String> exclusions = new HashSet<>();

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (tree.methodSymbol().isMethodSymbol() && tree.methodSymbol().declaration() == null) {
        String fqn = tree.methodSymbol().owner().type().fullyQualifiedName();
        if (isMethodFromJavaPackage(fqn)) {
          Symbol.MethodSymbol methodSymbol = tree.methodSymbol();
          List<Type> types = new ArrayList<>(methodSymbol.parameterTypes());
          Symbol.TypeSymbol returnType = methodSymbol.returnType();
          if (returnType != null) {
            types.add(returnType.type());
          }
          types.forEach(t -> exclusions.addAll(REPLACEMENTS.keySet().stream().filter(t::isSubtypeOf).collect(Collectors.toSet())));
        }
      }
      super.visitMethodInvocation(tree);
    }

    private static boolean isMethodFromJavaPackage(String fqn) {
      return fqn.startsWith(""java"") && !REPLACEMENTS.containsKey(fqn);
    }
  }

  private class DeprecatedTypeVisitor extends BaseTreeVisitor {

    private Deque<Set<String>> overridingMethodTypes = new ArrayDeque<>();

    @Override
    public void visitClass(ClassTree tree) {
      TypeTree superClass = tree.superClass();
      if (superClass != null) {
        reportIssueOnDeprecatedType(ExpressionsHelper.reportOnClassTree(tree), superClass.symbolType());
      }

      scan(tree.members());
    }

    @Override
    public void visitMethod(MethodTree tree) {
      TypeTree returnTypeTree = tree.returnType();
      boolean isConstructor = tree.is(Tree.Kind.CONSTRUCTOR);
      if (isOverriding(tree) && !isConstructor) {
        overridingMethodTypes.push(collectOverridingMethodExclusions(tree, returnTypeTree));
      } else {
        overridingMethodTypes.push(Collections.emptySet());
        if (!isConstructor) {
          reportIssueOnDeprecatedType(returnTypeTree, returnTypeTree.symbolType());
        }
        scan(tree.parameters());
      }
      scan(tree.block());
      overridingMethodTypes.pop();
    }

    private Set<String> collectOverridingMethodExclusions(MethodTree methodTree, TypeTree returnType) {
      var methodTypes = new HashSet<String>();
      methodTypes.add(returnType.symbolType().fullyQualifiedName());
      methodTree.parameters().stream()
        .map(param -> param.type().symbolType().fullyQualifiedName())
        .forEach(methodTypes::add);
      return methodTypes;
    }

    private boolean isOverriding(MethodTree tree) {
      // In case it can not be determined (isOverriding returns null), return false to avoid FP.
      return Boolean.TRUE.equals(tree.isOverriding());
    }

    @Override
    public void visitVariable(VariableTree tree) {
      ExpressionTree initializer = tree.initializer();
      if (!reportIssueOnDeprecatedType(tree.type(), tree.symbol().type()) && initializer != null && !initializer.is(Tree.Kind.METHOD_INVOCATION)) {
        reportIssueOnDeprecatedType(initializer, initializer.symbolType());
      }
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // Skip parameter types
      scan(lambdaExpressionTree.body());
    }

    private boolean reportIssueOnDeprecatedType(Tree tree, Type type) {
      if (visited.contains(tree) || isAllowedByOverridingSignature(type)) {
        return false;
      }
      visited.add(tree);
      if (isDeprecatedType(type)) {
        reportIssue(tree, ""Replace the synchronized class \"""" + type.name() + ""\"" by an unsynchronized one such as "" + REPLACEMENTS.get(type.fullyQualifiedName()) + ""."");
        return true;
      }
      return false;
    }

    private boolean isAllowedByOverridingSignature(Type type) {
      return !overridingMethodTypes.isEmpty() && overridingMethodTypes.peek().contains(type.fullyQualifiedName());
    }

    private boolean isDeprecatedType(Type symbolType) {
      if (symbolType.isClass()) {
        for (String deprecatedType : REPLACEMENTS.keySet()) {
          if (symbolType.is(deprecatedType)) {
            return !exclusions.peek().contains(deprecatedType);
          }
        }
      }
      return false;
    }

  }
}
"
S115,CODE_SMELL,Constant names should comply with a naming convention,"package org.sonar.java.checks.naming;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.serialization.SerializableContract;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00115"", repositoryKey = ""squid"")
@Rule(key = ""S115"")
public class BadConstantNameCheck extends IssuableSubscriptionVisitor {

  private static final String DEFAULT_FORMAT = ""^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"";
  @RuleProperty(
    key = ""format"",
    description = ""Regular expression used to check the constant names against."",
    defaultValue = """" + DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;

  private Pattern pattern = null;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.ENUM, Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    if (pattern == null) {
      pattern = Pattern.compile(format, Pattern.DOTALL);
    }
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    for (Tree member : classTree.members()) {
      if (member.is(Tree.Kind.VARIABLE)) {
        VariableTree variableTree = (VariableTree) member;
        Type symbolType = variableTree.type().symbolType();
        if (isConstantType(symbolType) && (classTree.is(Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE) || isStaticFinal(variableTree))) {
          checkName(variableTree);
        }
      } else if (member.is(Tree.Kind.ENUM_CONSTANT)) {
        checkName((VariableTree) member);
      }
    }
  }

  private static boolean isConstantType(Type symbolType) {
    return symbolType.isPrimitive() || symbolType.is(""java.lang.String"") || symbolType.isPrimitiveWrapper();
  }

  private void checkName(VariableTree variableTree) {
    if (!SerializableContract.SERIAL_VERSION_UID_FIELD.equals(variableTree.simpleName().name()) && !pattern.matcher(variableTree.simpleName().name()).matches()) {
      reportIssue(variableTree.simpleName(), ""Rename this constant name to match the regular expression '"" + format + ""'."");
    }
  }

  private static boolean isStaticFinal(VariableTree variableTree) {
    boolean isStatic = false;
    boolean isFinal = false;
    for (ModifierKeywordTree modifierKeywordTree : variableTree.modifiers().modifiers()) {
      Modifier modifier = modifierKeywordTree.modifier();
      if (modifier == Modifier.STATIC) {
        isStatic = true;
      }
      if (modifier == Modifier.FINAL) {
        isFinal = true;
      }
    }
    return isStatic && isFinal;
  }

}
"
S1150,CODE_SMELL,"""Enumeration"" should not be implemented","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

@Rule(key = ""S1150"")
public class ImplementsEnumerationCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.ENUM, Tree.Kind.INTERFACE);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    for (TypeTree superInterface : classTree.superInterfaces()) {
      IdentifierTree identifierTree = null;
      if (superInterface.is(Tree.Kind.IDENTIFIER)) {
        identifierTree = (IdentifierTree) superInterface;
      } else if (superInterface.is(Tree.Kind.PARAMETERIZED_TYPE) && ((ParameterizedTypeTree) superInterface).type().is(Tree.Kind.IDENTIFIER)) {
        identifierTree = (IdentifierTree) ((ParameterizedTypeTree) superInterface).type();
      }
      if (isEnumeration(identifierTree)) {
        reportIssue(superInterface, ""Implement Iterator rather than Enumeration."");
      }
    }
  }

  private static boolean isEnumeration(@Nullable IdentifierTree tree) {
    return tree != null && ""Enumeration"".equals(tree.name());
  }
}
"
S1151,CODE_SMELL,"""switch case"" clauses should not have too many lines of code","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.metrics.MetricsScannerContext;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.SwitchTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1151"")
public class SwitchCaseTooBigCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_MAX = 5;

  @RuleProperty(
    description = ""Maximum number of lines"",
    defaultValue = """" + DEFAULT_MAX)
  public int max = DEFAULT_MAX;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.SWITCH_STATEMENT, Tree.Kind.SWITCH_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    SwitchTree switchTree = (SwitchTree) tree;
    var metricsComputer = ((MetricsScannerContext)context).getMetricsComputer();
    switchTree.cases().forEach(
      cgt -> {
        int lines = cgt.body().stream().mapToInt(metricsComputer::getLinesOfCode).sum();
        if (lines > max) {
          reportIssue(cgt.labels().get(cgt.labels().size() - 1),
            ""Reduce this switch case number of lines from "" + lines + "" to at most "" + max + "", for example by extracting code into methods."");
        }
      }
      );
  }
}
"
S1153,CODE_SMELL,"""String.valueOf()"" should not be appended to a ""String""","package org.sonar.java.checks;

import java.util.HashSet;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S1153"")
public class ConcatenationWithStringValueOfCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitBinaryExpression(BinaryExpressionTree tree) {
    if (!tree.is(Kind.PLUS)) {
      super.visitBinaryExpression(tree);
      return;
    }

    Set<MethodInvocationTree> valueOfTrees = new HashSet<>();
    boolean flagIssue = false;
    ExpressionTree current = tree;
    while (current.is(Kind.PLUS)) {
      BinaryExpressionTree binOp = (BinaryExpressionTree) current;
      scan(binOp.rightOperand());
      if (isStringValueOf(binOp.rightOperand())) {
        valueOfTrees.add((MethodInvocationTree) binOp.rightOperand());
      }
      flagIssue |= binOp.leftOperand().is(Kind.STRING_LITERAL);
      if (!valueOfTrees.isEmpty()) {
        flagIssue |= binOp.rightOperand().is(Kind.STRING_LITERAL);
      }
      current = ((BinaryExpressionTree) current).leftOperand();
    }

    if (flagIssue) {
      for (MethodInvocationTree valueOfTree : valueOfTrees) {
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(valueOfTree)
          .withMessage(""Directly append the argument of String.valueOf()."")
          .withQuickFix(() -> createQuickFix(valueOfTree))
          .report();
      }
    }
    scan(current);
  }

  private JavaQuickFix createQuickFix(MethodInvocationTree invocationTree) {
    ExpressionTree argumentTree = invocationTree.arguments().get(0);
    String replacement = QuickFixHelper.contentForTree(argumentTree, context);

    if (argumentTree instanceof BinaryExpressionTree && !argumentTree.symbolType().is(""java.lang.String"")) {
      replacement = ""("" + replacement + "")"";
    }

    return JavaQuickFix.newQuickFix(""Remove redundant String.valueOf() wrapping"")
      .addTextEdit(JavaTextEdit.replaceTree(invocationTree, replacement))
      .build();
  }

  private static boolean isStringValueOf(ExpressionTree tree) {
    return tree.is(Kind.METHOD_INVOCATION) && isStringValueOf((MethodInvocationTree) tree);
  }

  private static boolean isStringValueOf(MethodInvocationTree tree) {
    return tree.methodSelect().is(Kind.MEMBER_SELECT) && isStringValueOf((MemberSelectExpressionTree) tree.methodSelect()) && matchArgument(tree.arguments());
  }

  private static boolean matchArgument(Arguments args) {
    return args.size() == 1 && !args.get(0).symbolType().isUnknown() && !args.get(0).symbolType().is(""char[]"");
  }

  private static boolean isStringValueOf(MemberSelectExpressionTree tree) {
    return tree.expression().is(Kind.IDENTIFIER) && ""valueOf"".equals(tree.identifier().name()) && ""String"".equals(((IdentifierTree) tree.expression()).name());
  }

}
"
S1155,CODE_SMELL,"""Collection.isEmpty()"" should be used to test for emptiness","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.collections.ListUtils;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@Rule(key = ""S1155"")
public class CollectionIsEmptyCheck extends IssuableSubscriptionVisitor {

  private enum EmptyComparisonType {
    EMPTY, NOT_EMPTY
  }

  private static final String JAVA_UTIL_COLLECTION = ""java.util.Collection"";
  private static final MethodMatchers SIZE_METHOD = MethodMatchers.create()
    .ofSubTypes(JAVA_UTIL_COLLECTION)
    .names(""size"")
    .addWithoutParametersMatcher()
    .build();
  private static final Tree.Kind[] TARGETED_BINARY_OPERATOR_TREES = {
    Tree.Kind.EQUAL_TO,
    Tree.Kind.NOT_EQUAL_TO,
    Tree.Kind.LESS_THAN,
    Tree.Kind.LESS_THAN_OR_EQUAL_TO,
    Tree.Kind.GREATER_THAN,
    Tree.Kind.GREATER_THAN_OR_EQUAL_TO
  };
  private static final Tree.Kind[] CLASS_TREES = {
    Tree.Kind.CLASS,
    Tree.Kind.ENUM,
    Tree.Kind.INTERFACE,
    Tree.Kind.RECORD,
    Tree.Kind.ANNOTATION_TYPE
  };
  private static final Deque<Boolean> IS_COLLECTION_ENCLOSING_TYPES_STACK = new LinkedList<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return ListUtils.concat(Arrays.asList(CLASS_TREES), Arrays.asList(TARGETED_BINARY_OPERATOR_TREES));
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    // in case of polluted state
    IS_COLLECTION_ENCLOSING_TYPES_STACK.clear();
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(CLASS_TREES)) {
      handleClassTree((ClassTree) tree);
    } else {
      // Necessarily a BinaryExpressionTree - the rule only raises issues on size() comparisons
      // are ""poorly"" used from something which is NOT a Collection
      handleBinaryExpressionTree((BinaryExpressionTree) tree);
    }
  }

  private static void handleClassTree(ClassTree tree) {
    Symbol.TypeSymbol symbol = tree.symbol();
    boolean isCollection = symbol.type().isSubtypeOf(JAVA_UTIL_COLLECTION);
    if (isInnerClassOfCollection(symbol)) {
      // inner classes which might be related to its parent collection
      isCollection = true;
    }
    IS_COLLECTION_ENCLOSING_TYPES_STACK.push(isCollection);
  }

  private static boolean isInnerClassOfCollection(Symbol.TypeSymbol symbol) {
    return Boolean.TRUE.equals(IS_COLLECTION_ENCLOSING_TYPES_STACK.peek()) && !symbol.isStatic();
  }

  private void handleBinaryExpressionTree(BinaryExpressionTree tree) {
    if (isInCollectionType()) {
      return;
    }
    getCallToSizeInvocation(tree).ifPresent(callToSizeInvocation ->
      getEmptyComparisonType(tree).ifPresent(comparisonType -> QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(tree)
        .withMessage(""Use isEmpty() to check whether the collection is empty or not."")
        .withQuickFix(() -> getQuickFix(tree, callToSizeInvocation, comparisonType))
        .report()));
  }

  private static boolean isInCollectionType() {
    return Boolean.TRUE.equals(IS_COLLECTION_ENCLOSING_TYPES_STACK.peek());
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(CLASS_TREES)) {
      IS_COLLECTION_ENCLOSING_TYPES_STACK.pop();
    }
  }

  private static JavaQuickFix getQuickFix(BinaryExpressionTree tree, MethodInvocationTree callToSizeInvocation, EmptyComparisonType emptyComparisonType) {
    IdentifierTree sizeCallIdentifier = ExpressionUtils.methodName(callToSizeInvocation);
    // We want to keep the object on which ""size"" is called, we therefore replace everything before with ! (if needed) and after with ""isEmpty()"".
    JavaQuickFix.Builder builder = JavaQuickFix.newQuickFix(""Use \""isEmpty()\"""");

    AnalyzerMessage.TextSpan textSpan = textSpanBetween(tree.firstToken(), true, callToSizeInvocation, false);
    String replacement = emptyComparisonType == EmptyComparisonType.EMPTY ? """" : ""!"";
    if (!(textSpan.isEmpty() && replacement.isEmpty())) {
      builder.addTextEdit(JavaTextEdit.replaceTextSpan(textSpan, replacement));
    }

    builder.addTextEdit(JavaTextEdit.replaceTextSpan(textSpanBetween(sizeCallIdentifier, true, tree.lastToken(), true), ""isEmpty()""));
    return builder.build();
  }

  private static Optional<MethodInvocationTree> getCallToSizeInvocation(BinaryExpressionTree tree) {
    return getCallToSizeInvocation(tree.leftOperand())
      // we stop at the first match
      .or(() -> getCallToSizeInvocation(tree.rightOperand()));
  }

  private static Optional<MethodInvocationTree> getCallToSizeInvocation(ExpressionTree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree invocationTree = (MethodInvocationTree) tree;
      if (SIZE_METHOD.matches(invocationTree)) {
        return Optional.of(invocationTree);
      }
    }
    return Optional.empty();
  }

  private static Optional<EmptyComparisonType> getEmptyComparisonType(BinaryExpressionTree tree) {
    boolean leftIsZero = LiteralUtils.isZero(tree.leftOperand());
    boolean leftIsOne = LiteralUtils.isOne(tree.leftOperand());
    boolean rightIsZero = LiteralUtils.isZero(tree.rightOperand());
    boolean rightIsOne = LiteralUtils.isOne(tree.rightOperand());
    boolean anyZero = leftIsZero || rightIsZero;

    if (isEmptyComparison(tree, leftIsZero, leftIsOne, rightIsZero, rightIsOne, anyZero)) {
      return Optional.of(EmptyComparisonType.EMPTY);
    }
    if (isNotEmptyComparison(tree, leftIsZero, leftIsOne, rightIsZero, rightIsOne, anyZero)) {
      return Optional.of(EmptyComparisonType.NOT_EMPTY);
    }
    return Optional.empty();
  }

  private static boolean isEmptyComparison(BinaryExpressionTree tree, boolean leftIsZero, boolean leftIsOne, boolean rightIsZero, boolean rightIsOne, boolean anyZero) {
    // size == 0, 0 == size
    return (tree.is(Tree.Kind.EQUAL_TO) && anyZero)
      // size > 1
      || (tree.is(Tree.Kind.LESS_THAN) && rightIsOne)
      // size <= 0
      || (tree.is(Tree.Kind.LESS_THAN_OR_EQUAL_TO) && rightIsZero)
      // 1 > size
      || (tree.is(Tree.Kind.GREATER_THAN) && leftIsOne)
      // 0 >= size
      || (tree.is(Tree.Kind.GREATER_THAN_OR_EQUAL_TO) && leftIsZero);
  }

  private static boolean isNotEmptyComparison(BinaryExpressionTree tree, boolean leftIsZero, boolean leftIsOne, boolean rightIsZero, boolean rightIsOne, boolean anyZero) {
    // size != 0, 0 != size
    return (tree.is(Tree.Kind.NOT_EQUAL_TO) && anyZero)
      // size > 0
      || (tree.is(Tree.Kind.GREATER_THAN) && rightIsZero)
      // size >= 1
      || (tree.is(Tree.Kind.GREATER_THAN_OR_EQUAL_TO) && rightIsOne)
      // 0 < size
      || (tree.is(Tree.Kind.LESS_THAN) && leftIsZero)
      // 1 <= size
      || (tree.is(Tree.Kind.LESS_THAN_OR_EQUAL_TO) && leftIsOne);
  }

}
"
S1157,CODE_SMELL,Case insensitive string comparisons should be made without intermediate upper or lower casing,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1157"")
public class CaseInsensitiveComparisonCheck extends AbstractMethodDetection {

  private static final MethodMatchers TO_LOWER_UPPER_CASE = MethodMatchers.create()
    .ofSubTypes(""java.lang.String"")
    .names(""toLowerCase"", ""toUpperCase"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofAnyType()
      .names(""equals"")
      .addParametersMatcher(""java.lang.Object"")
      .build();
  }

  @Override
  public void onMethodInvocationFound(MethodInvocationTree tree) {
    if (tree.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) tree.methodSelect();
      if (ignoresCase(memberSelect.expression(), tree.arguments().get(0))) {
        reportIssue(tree, ""Replace these toUpperCase()/toLowerCase() and equals() calls with a single equalsIgnoreCase() call."");
      }
    }
  }

  private static boolean ignoresCase(ExpressionTree lhs, ExpressionTree rhs) {
    boolean lhsConverted = isToUpperCaseOrToLowerCase(lhs);
    boolean rhsConverted = isToUpperCaseOrToLowerCase(rhs);
    return (lhsConverted && (rhsConverted || isStringConstant(rhs))) || (rhsConverted && isStringConstant(lhs));
  }

  private static boolean isStringConstant(ExpressionTree expression) {
    return expression.asConstant(String.class).isPresent();
  }

  private static boolean isToUpperCaseOrToLowerCase(ExpressionTree expression) {
    if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree methodInvocation = (MethodInvocationTree) expression;
      return TO_LOWER_UPPER_CASE.matches(methodInvocation);
    }
    return false;
  }

}
"
S1158,CODE_SMELL,"Primitive wrappers should not be instantiated only for ""toString"" or ""compareTo"" calls","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@Rule(key = ""S1158"")
public class ToStringUsingBoxingCheck extends IssuableSubscriptionVisitor {

  private static final String[] PRIMITIVE_WRAPPERS = new String[]{
    ""java.lang.Byte"",
    ""java.lang.Character"",
    ""java.lang.Short"",
    ""java.lang.Integer"",
    ""java.lang.Long"",
    ""java.lang.Float"",
    ""java.lang.Double"",
    ""java.lang.Boolean""
  };

  private static final MethodMatchers PRIMITIVE_CONSTRUCTOR = MethodMatchers.create()
    .ofTypes(PRIMITIVE_WRAPPERS)
    .constructor()
    .addParametersMatcher(MethodMatchers.ANY)
    .build();
  private static final MethodMatchers PRIMITIVE_VALUE_OF = MethodMatchers.create()
    .ofTypes(PRIMITIVE_WRAPPERS)
    .names(""valueOf"")
    .addParametersMatcher(MethodMatchers.ANY)
    .build();
  private static final MethodMatchers TO_STRING = MethodMatchers.create()
    // We are interested in any implementation of ""toString"", including the one from Integer
    .ofAnyType()
    .names(""toString"")
    .withAnyParameters()
    .build();
  private static final MethodMatchers COMPARE_TO = MethodMatchers.create()
    .ofSubTypes(""java.lang.Comparable"")
    .names(""compareTo"")
    .addParametersMatcher(MethodMatchers.ANY)
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;
    ExpressionTree methodSelect = mit.methodSelect();
    if (!methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      return;
    }
    ExpressionTree memberSelectExpression = ((MemberSelectExpressionTree) methodSelect).expression();
    getArgumentOfPrimitiveWrapper(memberSelectExpression)
      .filter(arg -> arg.symbolType().isPrimitive())
      .ifPresent(arg -> reportIfCompareToOrToString(mit, memberSelectExpression, memberSelectExpression.symbolType().toString(), arg));
  }

  private static Optional<ExpressionTree> getArgumentOfPrimitiveWrapper(ExpressionTree memberSelectExpression) {
    if (memberSelectExpression.is(Tree.Kind.NEW_CLASS) && PRIMITIVE_CONSTRUCTOR.matches((NewClassTree) memberSelectExpression)) {
      return Optional.of(((NewClassTree) memberSelectExpression).arguments().get(0));
    } else if (memberSelectExpression.is(Tree.Kind.METHOD_INVOCATION) && PRIMITIVE_VALUE_OF.matches((MethodInvocationTree) memberSelectExpression)) {
      return Optional.of(((MethodInvocationTree) memberSelectExpression).arguments().get(0));
    }
    return Optional.empty();
  }

  private void reportIfCompareToOrToString(MethodInvocationTree mit, ExpressionTree memberSelectExpression, String boxedType, Tree argument) {
    Supplier<JavaQuickFix> quickFix;
    String replacementMethod;
    if (TO_STRING.matches(mit)) {
      replacementMethod = ""toString"";
      if (mit.arguments().isEmpty()) {
        quickFix = toStringQuickFix(mit, boxedType, argument);
      } else {
        // The actual Integer.toString(...) is called, we want to keep the same arguments but change the first part
        quickFix = toStringWithArgumentQuickFix(memberSelectExpression, boxedType);
      }
    } else if (COMPARE_TO.matches(mit)) {
      replacementMethod = ""compare"";
      quickFix = compareToQuickFix(mit, boxedType, argument, mit.arguments().get(0));
    } else {
      return;
    }

    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(mit)
      .withMessage(String.format(""Call the static method %s.%s(...) instead of instantiating a temporary object."", boxedType, replacementMethod))
      .withQuickFix(quickFix)
      .report();
  }

  private static Supplier<JavaQuickFix> toStringQuickFix(MethodInvocationTree mit, String boxedType, Tree argument) {
    String replacement = String.format(""%s.toString("", boxedType);
    return () ->
      JavaQuickFix.newQuickFix(String.format(""Use %s...) instead"", replacement))
        .addTextEdit(
          JavaTextEdit.replaceTextSpan(textSpanBetween(mit, true, argument, false), replacement),
          JavaTextEdit.replaceTextSpan(textSpanBetween(argument, false, mit, true), "")"")
        ).build();
  }


  private static Supplier<JavaQuickFix> toStringWithArgumentQuickFix(ExpressionTree memberSelectExpression, String type) {
    return () ->
      JavaQuickFix.newQuickFix(String.format(""Use %s.toString(...) instead"", type))
        .addTextEdit(
          JavaTextEdit.replaceTree(memberSelectExpression, type)
        ).build();
  }

  private static Supplier<JavaQuickFix> compareToQuickFix(MethodInvocationTree mit, String type, Tree firstArgument, Tree secondArgument) {
    String replacement = String.format(""%s.compare("", type);
    return () ->
      JavaQuickFix.newQuickFix(String.format(""Use %s...) instead"", replacement))
        .addTextEdit(
          JavaTextEdit.replaceTextSpan(textSpanBetween(mit, true, firstArgument, false), replacement),
          JavaTextEdit.replaceTextSpan(textSpanBetween(firstArgument, false, secondArgument, false), "", "")
        ).build();
  }

}
"
S116,CODE_SMELL,Field names should comply with a naming convention,"package org.sonar.java.checks.naming;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.AbstractBadFieldNameChecker;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00116"", repositoryKey = ""squid"")
@Rule(key = ""S116"")
public class BadFieldNameCheck extends AbstractBadFieldNameChecker {

  @RuleProperty(
    key = DEFAULT_FORMAT_KEY,
    description = DEFAULT_FORMAT_DESCRIPTION,
    defaultValue = DEFAULT_FORMAT_VALUE)
  public String format = DEFAULT_FORMAT_VALUE;

  @Override
  protected String getFormat() {
    return format;
  }

  @Override
  protected boolean isFieldModifierConcernedByRule(ModifiersTree modifier) {
    return !ModifiersUtils.hasModifier(modifier, Modifier.STATIC);
  }

}
"
S1160,CODE_SMELL,Public methods should throw at most one checked exception,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1160"")
public class ThrowsSeveralCheckedExceptionCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (isPublic(methodTree) && !MethodTreeUtils.isMainMethod(methodTree)) {
      List<String> thrownCheckedExceptions = getThrownCheckedExceptions(methodTree);
      if (thrownCheckedExceptions.size() > 1 && isNotOverridden(methodTree)) {
        reportIssue(methodTree.simpleName(), ""Refactor this method to throw at most one checked exception instead of: "" + String.join("", "", thrownCheckedExceptions));
      }
    }
  }

  private static boolean isNotOverridden(MethodTree methodTree) {
    return Boolean.FALSE.equals(methodTree.isOverriding());
  }

  private static boolean isPublic(MethodTree methodTree) {
    return methodTree.symbol().isPublic();
  }

  private static List<String> getThrownCheckedExceptions(MethodTree methodTree) {
    return methodTree.symbol().thrownTypes().stream()
      .filter(type -> !type.isUnknown() && !isSubClassOfRuntimeException(type))
      .map(Type::fullyQualifiedName)
      .toList();
  }

  private static boolean isSubClassOfRuntimeException(Type thrownClass) {
    Symbol.TypeSymbol typeSymbol = thrownClass.symbol();
    while (typeSymbol != null) {
      if (isRuntimeException(typeSymbol.type())) {
        return true;
      }
      Type superType = typeSymbol.superClass();
      if (superType == null) {
        typeSymbol = null;
      } else {
        typeSymbol = superType.symbol();
      }
    }
    return false;
  }

  private static boolean isRuntimeException(Type thrownClass) {
    return thrownClass.is(""java.lang.RuntimeException"");
  }

}
"
S1161,CODE_SMELL,"""@Override"" should be used on overriding and implementing methods","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.LineUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1161"")
public class OverrideAnnotationCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    if (isExcludedByVersion(context.getJavaVersion())) {
      return;
    }
    MethodTree methodTree = (MethodTree) tree;
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();
    List<Symbol.MethodSymbol> overriddenSymbols = methodSymbol.overriddenSymbols();
    if (overriddenSymbols.isEmpty()) {
      return;
    }
    Symbol.MethodSymbol overriddenSymbol = overriddenSymbols.get(0);
    if (!overriddenSymbol.isAbstract()
      && !isObjectMethod(overriddenSymbol)
      && !isAnnotatedOverride(methodSymbol)) {
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(methodTree.simpleName())
        .withMessage(""Add the \""@Override\"" annotation above this method signature"")
        .withQuickFix(() -> quickFix(methodTree))
        .report();
    }
  }

  private static boolean isExcludedByVersion(JavaVersion javaVersion) {
    if (javaVersion.isNotSet()) {
      return false;
    }
    return javaVersion.asInt() <= 4;
  }

  private static boolean isObjectMethod(Symbol.MethodSymbol method) {
    return method.owner().type().is(""java.lang.Object"");
  }

  private static boolean isAnnotatedOverride(Symbol.MethodSymbol method) {
    return method.metadata().isAnnotatedWith(""java.lang.Override"");
  }private JavaQuickFix quickFix(MethodTree methodTree) {
    ModifiersTree modifiersTree = methodTree.modifiers();
    Tree targetTree = modifiersTree.isEmpty() ? QuickFixHelper.nextToken(modifiersTree) : modifiersTree.get(0);
    String insertedText;
    if (somethingBeforeOnSameLine(methodTree)) {
      // strangely formated code: everything on the same line?
      insertedText = ""@Override "";
    } else {
      insertedText = ""@Override\n"" + padding(targetTree);
    }
    return JavaQuickFix
      .newQuickFix(""Add \""@Override\"" annotation"")
      .addTextEdit(JavaTextEdit.insertBeforeTree(targetTree, insertedText))
      .build();
  }

  private static boolean somethingBeforeOnSameLine(Tree tree) {
    return LineUtils.startLine(QuickFixHelper.previousToken(tree)) == LineUtils.startLine(tree);
  }

  private String padding(Tree tree) {
    Position start = Position.startOf(tree);
    return context.getFileLines()
      .get(start.lineOffset())
      .substring(0, start.columnOffset());
  }
}
"
S1162,CODE_SMELL,Checked exceptions should not be thrown,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

@Rule(key = ""S1162"")
public class ThrowCheckedExceptionCheck extends IssuableSubscriptionVisitor {

  private Deque<MethodTree> methods = new LinkedList<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.THROW_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      methods.push((MethodTree) tree);
    } else {
      ThrowStatementTree throwStatementTree = (ThrowStatementTree) tree;
      Type symbolType = throwStatementTree.expression().symbolType();
      if (symbolType.isSubtypeOf(""java.lang.Exception"") && !symbolType.isSubtypeOf(""java.lang.RuntimeException"") && !isFromMethodOverride(symbolType)) {
        reportIssue(throwStatementTree.expression(), ""Remove the usage of the checked exception '"" + symbolType.name() + ""'."");
      }
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      methods.pop();
    }
  }

  private boolean isFromMethodOverride(Type exceptionType) {
    if (!methods.isEmpty()) {
      MethodTree method = methods.peek();
      if (isOverriding(method) && isCompatibleWithThrows(exceptionType, method.throwsClauses())) {
        return true;
      }
    }
    return false;
  }

  private static boolean isCompatibleWithThrows(Type exceptionType, List<TypeTree> throwsClauses) {
    for (TypeTree typeTree : throwsClauses) {
      if (exceptionType.isSubtypeOf(typeTree.symbolType())) {
        return true;
      }
    }
    return false;
  }

  private static boolean isOverriding(MethodTree methodTree) {
    return Boolean.TRUE.equals(methodTree.isOverriding());
  }
}
"
S1163,CODE_SMELL,Exceptions should not be thrown in finally blocks,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.TryStatementTree;

@Rule(key = ""S1163"")
public class ThrowsFromFinallyCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  private int finallyLevel = 0;
  private boolean isInMethodWithinFinally;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitTryStatement(TryStatementTree tree) {
    scan(tree.resourceList());
    scan(tree.block());
    scan(tree.catches());
    finallyLevel++;
    scan(tree.finallyBlock());
    finallyLevel--;
  }

  @Override
  public void visitThrowStatement(ThrowStatementTree tree) {
    if(isInFinally() && !isInMethodWithinFinally){
      context.reportIssue(this, tree, ""Refactor this code to not throw exceptions in finally blocks."");
    }
    super.visitThrowStatement(tree);
  }

  @Override
  public void visitMethod(MethodTree tree) {
    isInMethodWithinFinally = isInFinally();
    super.visitMethod(tree);
    isInMethodWithinFinally = false;
  }

  private boolean isInFinally(){
    return finallyLevel>0;
  }

}
"
S1165,CODE_SMELL,Exception classes should have final fields,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1165"")
public class ExceptionsShouldBeImmutableCheck extends IssuableSubscriptionVisitor {

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (isException(classTree)) {
      for (Tree member : classTree.members()) {
        if (member.is(Tree.Kind.VARIABLE) && !isFinal((VariableTree) member)) {
          IdentifierTree simpleName = ((VariableTree) member).simpleName();
          reportIssue(simpleName, ""Make this \"""" + simpleName.name() + ""\"" field final."");
        }
      }
    }
  }

  private static boolean isFinal(VariableTree member) {
    return ModifiersUtils.hasModifier(member.modifiers(), Modifier.FINAL);
  }

  private static boolean isException(ClassTree classTree) {
    return classTree.simpleName() != null && classTree.symbol().type().isSubtypeOf(""java.lang.Throwable"");
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }
}
"
S1166,CODE_SMELL,Exception handlers should preserve the original exceptions,"package org.sonar.java.checks;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ParenthesizedTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.UnionTypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.model.ExpressionUtils.skipParentheses;

@Rule(key = ""S1166"")
public class CatchUsesExceptionWithContextCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final MethodMatchers GET_MESSAGE_METHODS = MethodMatchers.create()
    .ofSubTypes(""java.lang.Throwable"")
    .names(""getMessage"", ""getLocalizedMessage"")
    .addWithoutParametersMatcher()
    .build();

  private static final String JAVA_UTIL_LOGGING_LOGGER = ""java.util.logging.Logger"";
  private static final String SLF4J_LOGGER = ""org.slf4j.Logger"";

  private static final MethodMatchers JAVA_UTIL_LOG_METHOD = MethodMatchers.create()
    .ofTypes(JAVA_UTIL_LOGGING_LOGGER).names(""log"").withAnyParameters().build();

  private static final MethodMatchers JAVA_UTIL_LOGP_METHOD = MethodMatchers.create()
    .ofTypes(JAVA_UTIL_LOGGING_LOGGER).names(""logp"").withAnyParameters().build();

  private static final MethodMatchers JAVA_UTIL_LOGRB_METHOD = MethodMatchers.create()
    .ofTypes(JAVA_UTIL_LOGGING_LOGGER).names(""logrb"").withAnyParameters().build();

  private static final MethodMatchers LOGGING_METHODS = MethodMatchers.or(
    MethodMatchers.create().ofAnyType().name(CatchUsesExceptionWithContextCheck::containsLogIgnoreCase).withAnyParameters().build(),
    MethodMatchers.create().ofType(type -> containsLogIgnoreCase(type.name())).anyName().withAnyParameters().build(),
    MethodMatchers.create()
      .ofTypes(JAVA_UTIL_LOGGING_LOGGER).names(""config"", ""fine"", ""finer"", ""finest"", ""info"", ""severe"", ""warning"").withAnyParameters().build(),
    JAVA_UTIL_LOG_METHOD,
    JAVA_UTIL_LOGP_METHOD,
    JAVA_UTIL_LOGRB_METHOD,
    MethodMatchers.create()
      .ofTypes(SLF4J_LOGGER).names(""debug"", ""error"", ""info"", ""trace"", ""warn"").withAnyParameters().build());

  private static final String EXCLUDED_EXCEPTION_TYPE = ""java.lang.InterruptedException, "" +
      ""java.lang.NumberFormatException, "" +
      ""java.lang.NoSuchMethodException, "" +
      ""java.text.ParseException, "" +
      ""java.net.MalformedURLException, "" +
      ""java.time.format.DateTimeParseException"";

  @RuleProperty(
      key = ""exceptions"",
      description = ""List of exceptions which should not be checked. Use a simple dash ('-') character to check all exceptions."",
      defaultValue = """" + EXCLUDED_EXCEPTION_TYPE)
  public String exceptionsCommaSeparated = EXCLUDED_EXCEPTION_TYPE;

  private JavaFileScannerContext context;
  private Deque<UsageStatus> usageStatusStack;
  private Set<String> exceptions;
  private Set<String> exceptionIdentifiers;
  private Set<CatchTree> excludedCatchTrees = new HashSet<>();

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    usageStatusStack = new ArrayDeque<>();
    if (context.getSemanticModel() != null) {
      scan(context.getTree());
    }
    excludedCatchTrees.clear();
  }

  @Override
  public void visitTryStatement(TryStatementTree tree) {
    if (containsEnumValueOf(tree.block())) {
      tree.catches().stream()
        .filter(c -> c.parameter().symbol().type().is(""java.lang.IllegalArgumentException""))
        .findAny()
        .ifPresent(excludedCatchTrees::add);
    }
    super.visitTryStatement(tree);
  }

  private static boolean containsEnumValueOf(Tree tree) {
    EnumValueOfVisitor visitor = new EnumValueOfVisitor();
    tree.accept(visitor);
    return visitor.hasEnumValueOf;
  }

  private static boolean containsLogIgnoreCase(String name) {
    return StringUtils.containsIgnoreCase(name, ""log"");
  }

  private static class EnumValueOfVisitor extends BaseTreeVisitor {

    private static final MethodMatchers ENUM_VALUE_OF = MethodMatchers.create()
      .ofSubTypes(""java.lang.Enum"")
      .names(""valueOf"")
      .withAnyParameters()
      .build();

    private boolean hasEnumValueOf = false;

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (ENUM_VALUE_OF.matches(tree)) {
        hasEnumValueOf = true;
      }
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitClass(ClassTree tree) {
      // skip anonymous classes
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // skip lambdas
    }
  }

  @Override
  public void visitCatch(CatchTree tree) {
    if (!isExcludedType(tree.parameter().type()) && !excludedCatchTrees.contains(tree)) {
      Symbol exception = tree.parameter().symbol();
      usageStatusStack.addFirst(new UsageStatus(exception.usages()));
      super.visitCatch(tree);
      if (usageStatusStack.pop().isInvalid()) {
        context.reportIssue(this, tree.parameter(), ""Either log or rethrow this exception."");
      }
    }
  }

  @Override
  public void visitMethodInvocation(MethodInvocationTree mit) {
    super.visitMethodInvocation(mit);
    if (LOGGING_METHODS.matches(mit) || mit.methodSymbol().isUnknown()) {
      usageStatusStack.forEach(usageStatus -> usageStatus.addLoggingMethodInvocation(mit));
    }
  }

  @Override
  public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
    final IdentifierTree identifier;
    ExpressionTree expression = tree.expression();
    if (expression.is(Kind.IDENTIFIER)) {
      identifier = (IdentifierTree) expression;
    } else if (expression.is(Kind.PARENTHESIZED_EXPRESSION) && ((ParenthesizedTree) expression).expression().is(Kind.IDENTIFIER)) {
      identifier = (IdentifierTree) ((ParenthesizedTree) expression).expression();
    } else {
      identifier = null;
    }

    if (!usageStatusStack.isEmpty() && identifier != null) {
      usageStatusStack.forEach(usageStatus -> usageStatus.addInvalidUsage(identifier));
    }
    super.visitMemberSelectExpression(tree);

  }

  private boolean isExcludedType(Tree tree) {
    if (tree.is(Kind.UNION_TYPE)) {
      return ((UnionTypeTree) tree).typeAlternatives().stream().allMatch(this::isExcludedType);
    }
    return isUnqualifiedExcludedType(tree) ||
      isQualifiedExcludedType(tree);
  }

  private boolean isUnqualifiedExcludedType(Tree tree) {
    return tree.is(Kind.IDENTIFIER) &&
      getExceptionIdentifiers().contains(((IdentifierTree) tree).name());
  }

  private boolean isQualifiedExcludedType(Tree tree) {
    if (!tree.is(Kind.MEMBER_SELECT)) {
      return false;
    }
    return getExceptions().contains(ExpressionsHelper.concatenate((MemberSelectExpressionTree) tree));
  }

  private Set<String> getExceptions() {
    if (exceptions == null) {
      if (""-"".equals(exceptionsCommaSeparated.trim())) {
        // explicitly handle '-' as discarding character
        exceptions = Collections.emptySet();
      } else {
        exceptions = Stream.of(exceptionsCommaSeparated.split("","")).map(String::trim).collect(Collectors.toSet());
      }
    }
    return exceptions;
  }

  private Set<String> getExceptionIdentifiers() {
    if (exceptionIdentifiers == null) {
      exceptionIdentifiers = getExceptions().stream()
        .map(exception -> exception.substring(exception.lastIndexOf('.') + 1))
        .collect(Collectors.toSet());
    }
    return exceptionIdentifiers;
  }

  private static class UsageStatus {
    private final Collection<IdentifierTree> validUsages;
    private final List<MethodInvocationTree> loggingMethodInvocations;

    UsageStatus(Collection<IdentifierTree> usages) {
      validUsages = new ArrayList<>(usages);
      loggingMethodInvocations = new ArrayList<>();
    }

    public void addInvalidUsage(IdentifierTree exceptionIdentifier) {
      validUsages.remove(exceptionIdentifier);
    }

    public void addLoggingMethodInvocation(MethodInvocationTree mit) {
      loggingMethodInvocations.add(mit);
    }

    public boolean isInvalid() {
      return validUsages.isEmpty() && !isMessageLoggedWithAdditionalContext();
    }

    private boolean isMessageLoggedWithAdditionalContext() {
      return loggingMethodInvocations.stream().anyMatch(mit -> hasGetMessageInvocation(mit) && hasDynamicExceptionMessageUsage(mit));
    }

    private static boolean hasGetMessageInvocation(MethodInvocationTree mit) {
      return hasGetMessageMethodInvocation(mit) || isGetMessageReferencedByIdentifiers(mit);
    }

    private static boolean isGetMessageReferencedByIdentifiers(MethodInvocationTree mit) {
      ChildrenIdentifierCollector visitor = new ChildrenIdentifierCollector();
      mit.accept(visitor);

      boolean invocationInInitializer = visitor.identifiersChildren.stream()
        .map(UsageStatus::getVariableInitializer)
        .distinct()
        .anyMatch(UsageStatus::hasGetMessageMethodInvocation);

      return invocationInInitializer || visitor.identifiersChildren.stream()
        .map(IdentifierTree::symbol)
        .map(Symbol::usages)
        .flatMap(usagesList -> getAssignments(usagesList).stream())
        .anyMatch(assignment -> hasGetMessageMethodInvocation(assignment.expression()));
    }

    private static boolean hasGetMessageMethodInvocation(@Nullable Tree tree) {
      if (tree == null) {
        return false;
      }
      GetExceptionMessageVisitor visitor = new GetExceptionMessageVisitor();
      tree.accept(visitor);
      return visitor.hasGetMessageCall;
    }

    private static boolean hasDynamicExceptionMessageUsage(MethodInvocationTree mit) {
      Arguments arguments = mit.arguments();
      int argumentsCount = arguments.size();
      if (argumentsCount == 0) {
        return true;
      }
      ExpressionTree firstArg = arguments.get(0);
      ExpressionTree argumentToCheck;
      if (mit.methodSymbol().owner().type().is(SLF4J_LOGGER)) {
        if (argumentsCount == 1) {
          argumentToCheck = firstArg;
        } else if (argumentsCount == 2 && firstArg.symbolType().is(""org.slf4j.Marker"")) {
          argumentToCheck = arguments.get(1);
        } else {
          argumentToCheck = null;
        }
      } else if (JAVA_UTIL_LOG_METHOD.matches(mit) && argumentsCount == 2) {
        argumentToCheck = arguments.get(1);
      } else if (JAVA_UTIL_LOGP_METHOD.matches(mit) && argumentsCount == 4) {
        argumentToCheck = arguments.get(3);
      } else if (JAVA_UTIL_LOGRB_METHOD.matches(mit) && argumentsCount == 5) {
        argumentToCheck = arguments.get(4);
      } else {
        argumentToCheck = firstArg;
      }

      return argumentToCheck == null || !isSimpleExceptionMessage(argumentToCheck);
    }

    private static boolean isSimpleExceptionMessage(ExpressionTree expressionTree) {
      ExpressionTree innerExpression = skipParentheses(expressionTree);
      if (innerExpression.is(Kind.IDENTIFIER)) {
        IdentifierTree variable = (IdentifierTree) innerExpression;
        List<AssignmentExpressionTree> assignments = getAssignments(variable.symbol().usages());
        ExpressionTree initializer = getVariableInitializer(variable);
        return assignments.isEmpty() && initializer != null && isSimpleExceptionMessage(initializer);
      } else if (innerExpression.is(Kind.METHOD_INVOCATION)) {
        return GET_MESSAGE_METHODS.matches(((MethodInvocationTree) innerExpression));
      }
      return false;
    }

    private static List<AssignmentExpressionTree> getAssignments(List<IdentifierTree> usages) {
      return usages.stream().map(UsageStatus::getAssignmentToIdentifier).filter(Objects::nonNull).toList();
    }

    @CheckForNull
    private static AssignmentExpressionTree getAssignmentToIdentifier(IdentifierTree usage) {
      Tree parent = usage.parent();
      while (parent != null) {
        if (parent.is(Kind.ASSIGNMENT, Kind.PLUS_ASSIGNMENT)) {
          AssignmentExpressionTree assignmentExpressionTree = (AssignmentExpressionTree) parent;
          if (assignmentExpressionTree.variable().equals(usage)) {
            return assignmentExpressionTree;
          } else {
            return null;
          }
        }
        parent = parent.parent();
      }

      return null;
    }

    @CheckForNull
    private static ExpressionTree getVariableInitializer(IdentifierTree variable) {
      Tree declaration = variable.symbol().declaration();
      if (declaration != null && declaration.is(Kind.VARIABLE)) {
        return ((VariableTree) declaration).initializer();
      }
      return null;
    }
  }

  private static class GetExceptionMessageVisitor extends BaseTreeVisitor {
    boolean hasGetMessageCall = false;

    @Override
    public void visitMethodInvocation(MethodInvocationTree mit) {
      if (!hasGetMessageCall && GET_MESSAGE_METHODS.matches(mit)) {
        hasGetMessageCall = true;
      }
      super.visitMethodInvocation(mit);
    }

    @Override
    public void visitNewClass(NewClassTree newClassTree) {
      // skip method invocations found in a NewClassTree
    }
  }

  private static class ChildrenIdentifierCollector extends BaseTreeVisitor {
    Set<IdentifierTree> identifiersChildren = new HashSet<>();

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      identifiersChildren.add(tree);
    }
  }

}
"
S1168,CODE_SMELL,Empty arrays and collections should be returned instead of null,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1168"")
public class ReturnEmptyArrayNotNullCheck extends IssuableSubscriptionVisitor {

  private final Deque<ReturnKind> returnKinds = new LinkedList<>();
  private QuickFixHelper.ImportSupplier importSupplier;

  private enum Returns {
    ARRAY, COLLECTION, MAP, OTHER;
  }

  private static class ReturnKind {
    private static final ReturnKind OTHER = new ReturnKind(Returns.OTHER, null);

    private final Returns kind;
    @Nullable
    private final Type type;

    private ReturnKind(Returns kind, @Nullable Type type) {
      this.kind = kind;
      this.type = type;
    }

    public static ReturnKind forType(Type type) {
      if (type.isUnknown()) {
        return OTHER;
      }
      if (type.isArray()) {
        return new ReturnKind(Returns.ARRAY, type);
      }
      if (type.isSubtypeOf(""java.util.Collection"")) {
        return new ReturnKind(Returns.COLLECTION, type);
      }
      if (type.isSubtypeOf(""java.util.Map"")) {
        return new ReturnKind(Returns.MAP, type);
      }
      return OTHER;
    }
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    super.setContext(context);
    reset();
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    reset();
  }

  private void reset() {
    returnKinds.clear();
    importSupplier = null;
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR, Tree.Kind.RETURN_STATEMENT, Tree.Kind.LAMBDA_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      MethodTree methodTree = (MethodTree) tree;
      SymbolMetadata metadata = methodTree.symbol().metadata();
      if (metadata.nullabilityData().isNullable(SymbolMetadata.NullabilityLevel.PACKAGE, false, true) || requiresReturnNull(methodTree)) {
        returnKinds.push(ReturnKind.OTHER);
      } else {
        returnKinds.push(ReturnKind.forType(methodTree.returnType().symbolType()));
      }
    } else if (tree.is(Tree.Kind.CONSTRUCTOR, Tree.Kind.LAMBDA_EXPRESSION)) {
      returnKinds.push(ReturnKind.OTHER);
    } else {
      checkForIssue((ReturnStatementTree) tree);
    }
  }

  private void checkForIssue(ReturnStatementTree returnStatement) {
    if (!isReturningNull(returnStatement)) {
      return;
    }
    ReturnKind returnKind = returnKinds.peek();
    if (returnKind.kind == Returns.OTHER) {
      return;
    }
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(returnStatement.expression())
      .withMessage(""Return an empty %s instead of null."", returnKind.kind.name().toLowerCase(Locale.ROOT))
      .withQuickFixes(() -> quickFix(returnStatement))
      .report();
  }

  @Override
  public void leaveNode(Tree tree) {
    if (!tree.is(Tree.Kind.RETURN_STATEMENT)) {
      returnKinds.pop();
    }
  }

  private static boolean isReturningNull(ReturnStatementTree tree) {
    ExpressionTree expression = tree.expression();
    return expression != null && expression.is(Tree.Kind.NULL_LITERAL);
  }

  private static boolean requiresReturnNull(MethodTree methodTree) {
    Symbol owner = methodTree.symbol().owner();
    if (owner == null || !owner.isTypeSymbol()) {
      // Unknown hierarchy, consider it as requires null to avoid FP
      // At this point, owner should never be null, defensive programming
      return true;
    }
    List<Type> interfaces = ((Symbol.TypeSymbol) owner).interfaces();
    return isOverriding(methodTree) && interfaces.stream().anyMatch(Type::isUnknown);
  }

  private static boolean isOverriding(MethodTree tree) {
    return Boolean.TRUE.equals(tree.isOverriding());
  }

  private List<JavaQuickFix> quickFix(ReturnStatementTree returnStatement) {
    ReturnKind returnKind = returnKinds.peek();
    // can only be ARRAY or COLLECTION
    if (returnKind.kind == Returns.ARRAY) {
      return Collections.singletonList(JavaQuickFix.newQuickFix(""Replace \""null\"" with an empty array"")
        .addTextEdit(JavaTextEdit.replaceTree(returnStatement.expression(), emptyArrayString((Type.ArrayType) returnKind.type)))
        .build());
    }
    Optional<CollectionType> candidate = CollectionType.forType(returnKind.type);
    if (!candidate.isPresent()) {
      return Collections.emptyList();
    }
    CollectionType collectionType = candidate.get();

    JavaQuickFix.Builder builder = JavaQuickFix.newQuickFix(""Replace \""null\"" with an empty %s"", collectionType.typeName)
      .addTextEdit(JavaTextEdit.replaceTree(returnStatement.expression(), collectionType.replacement));

    if (importSupplier == null) {
      importSupplier = QuickFixHelper.newImportSupplier(context);
    }
    importSupplier.newImportEdit(collectionType.requiredType)
      .ifPresent(builder::addTextEdit);

    return Collections.singletonList(builder.build());
  }

  private static String emptyArrayString(Type.ArrayType arrayType) {
    return String.format(""new %s"", arrayType.name()
      .replace(""[]"", ""[0]"")
      .replaceAll(""<.+>"", """"));
  }

  private enum CollectionType {
    COLLECTION(""Collection"", ""Collections.emptyList()""),
    LIST(""List"", ""Collections.emptyList()""),
    ARRAY_LIST(""ArrayList""),
    LINKED_LIST(""LinkedList""),
    SET(""Set"", ""Collections.emptySet()""),
    HASH_SET(""HashSet""),
    TREE_SET(""TreeSet""),
    SORTED_SET(""SortedSet"", ""Collections.emptySortedSet()""),
    NAVIGABLE_SET(""NavigableSet"", ""Collections.emptyNavigableSet()""),
    MAP(""Map"", ""Collections.emptyMap()""),
    HASH_MAP(""HashMap""),
    TREE_MAP(""TreeMap""),
    SORTED_MAP(""SortedMap"", ""Collections.emptySortedMap()""),
    NAVIGABLE_MAP(""NavigableMap"", ""Collections.emptyNavigableMap()"");

    private final String fullyQualifiedName;
    private final String replacement;
    private final String typeName;
    private final String requiredType;

    CollectionType(String typeName) {
      this.typeName = typeName;
      this.replacement = String.format(""new %s<>()"", typeName);
      this.fullyQualifiedName = String.format(""java.util.%s"", typeName);
      this.requiredType = fullyQualifiedName;
    }

    CollectionType(String typeName, String replacement) {
      this.typeName = typeName;
      this.replacement = replacement;
      this.fullyQualifiedName = String.format(""java.util.%s"", typeName);
      this.requiredType = ""java.util.Collections"";
    }

    private static Optional<CollectionType> forType(Type type) {
      Type erasure = type.erasure();
      for (CollectionType collectionType : CollectionType.values()) {
        if (erasure.is(collectionType.fullyQualifiedName)) {
          return Optional.of(collectionType);
        }
      }
      return Optional.empty();
    }
  }
}
"
S117,CODE_SMELL,Local variable and method parameter names should comply with a naming convention,"package org.sonar.java.checks.naming;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.regex.Pattern;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00117"", repositoryKey = ""squid"")
@Rule(key = ""S117"")
public class BadLocalVariableNameCheck  extends BaseTreeVisitor implements JavaFileScanner {

  private static final String DEFAULT_FORMAT = ""^[a-z][a-zA-Z0-9]*$"";

  @RuleProperty(
    key = ""format"",
    description = ""Regular expression used to check the names against."",
    defaultValue = """" + DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;

  private Pattern pattern = null;
  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    if (pattern == null) {
      pattern = Pattern.compile(format, Pattern.DOTALL);
    }
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    for (Tree member : tree.members()) {
      if (member.is(Tree.Kind.VARIABLE)) {
        // skip check of field
        scan(((VariableTree) member).initializer());
      } else {
        scan(member);
      }
    }
  }

  @Override
  public void visitForStatement(ForStatementTree tree) {
    scan(tree.statement());
  }

  @Override
  public void visitForEachStatement(ForEachStatement tree) {
    scan(tree.statement());
  }

  @Override
  public void visitCatch(CatchTree tree) {
    VariableTree parameter = tree.parameter();
    if (parameter.simpleName().name().length() > 1) {
      scan(parameter);
    }
    scan(tree.block());
  }

  @Override
  public void visitVariable(VariableTree tree) {
    if (!pattern.matcher(tree.simpleName().name()).matches() && !isLocalConstant(tree)) {
      context.reportIssue(this, tree.simpleName(), ""Rename this local variable to match the regular expression '"" + format + ""'."");
    }
    super.visitVariable(tree);
  }

  private boolean isLocalConstant(VariableTree tree) {
    return context.getSemanticModel() != null && isConstantType(tree.symbol().type()) && tree.symbol().isFinal();
  }

  private static boolean isConstantType(Type symbolType) {
    return symbolType.isPrimitive() || symbolType.is(""java.lang.String"") || symbolType.isPrimitiveWrapper();
  }

}
"
S1170,CODE_SMELL,"Public constants and fields initialized at declaration should be ""static final"" rather than merely ""final""","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.function.Predicate;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.JavaTree;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1170"")
public class ConstantsShouldBeStaticFinalCheck extends IssuableSubscriptionVisitor {

  private int nestedClassesLevel;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    nestedClassesLevel = 0;
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    nestedClassesLevel++;
    for (Tree member : ((ClassTree) tree).members()) {
      if (member.is(Tree.Kind.VARIABLE)) {
        VariableTree variableTree = (VariableTree) member;
        if (staticNonFinal(variableTree) && hasConstantInitializer(variableTree) && !isObjectInInnerClass(variableTree)) {
          reportIssue(variableTree.simpleName(), ""Make this final field static too."");
        }
      }
    }
  }

  private boolean isObjectInInnerClass(VariableTree variableTree) {
    if (nestedClassesLevel > 1) {
      ExpressionTree initializer = variableTree.initializer();
      return !((variableTree.type().is(Tree.Kind.PRIMITIVE_TYPE) || variableTree.symbol().type().is(""java.lang.String""))
        && initializer != null && initializer.asConstant().isPresent());
    }
    return false;
  }

  private static boolean staticNonFinal(VariableTree variableTree) {
    return isFinal(variableTree) && !isStatic(variableTree);
  }

  @Override
  public void leaveNode(Tree tree) {
    nestedClassesLevel--;
  }

  private static boolean hasConstantInitializer(VariableTree variableTree) {
    ExpressionTree init = variableTree.initializer();
    if (init == null) {
      return false;
    }

    var deparenthesized = ExpressionUtils.skipParentheses(init);

    if (deparenthesized instanceof MethodReferenceTree methodRef && isInstanceIdentifier(methodRef.expression())) {
      return false;
    }
    return !containsChildMatchingPredicate((JavaTree) deparenthesized,
      (ConstantsShouldBeStaticFinalCheck::isNonStaticOrFinal));
  }

  private static boolean isNonStaticOrFinal(Tree tree) {
    return switch (tree.kind()) {
      case METHOD_INVOCATION, NEW_CLASS, NEW_ARRAY, ARRAY_ACCESS_EXPRESSION -> true;
      case IDENTIFIER -> {
        String name = ((IdentifierTree) tree).name();
        if (""super"".equals(name) || ""this"".equals(name)) {
          yield true;
        } else {
          var symbol = ((IdentifierTree) tree).symbol();
          yield symbol.isVariableSymbol() && !(symbol.isStatic() && symbol.isFinal());
        }
      }
      default -> false;
    };
  }

  private static boolean isInstanceIdentifier(Tree expression) {
    return expression.is(Tree.Kind.IDENTIFIER) && !((IdentifierTree) expression).symbol().isStatic();
  }

  private static boolean containsChildMatchingPredicate(JavaTree tree, Predicate<Tree> predicate) {
    if (predicate.test(tree)) {
      return true;
    }
    if (!tree.isLeaf()) {
      for (Tree javaTree : tree.getChildren()) {
        if (javaTree != null && containsChildMatchingPredicate((JavaTree) javaTree, predicate)) {
          return true;
        }
      }
    }
    return false;
  }

  private static boolean isFinal(VariableTree variableTree) {
    return ModifiersUtils.hasModifier(variableTree.modifiers(), Modifier.FINAL);
  }

  private static boolean isStatic(VariableTree variableTree) {
    return ModifiersUtils.hasModifier(variableTree.modifiers(), Modifier.STATIC);
  }
}
"
S1171,CODE_SMELL,Only static class initializers should be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1171"")
public class NonStaticClassInitializerCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.INITIALIZER);
  }

  @Override
  public void visitNode(Tree tree) {
    reportIssue(((BlockTree) tree).openBraceToken(), ""Move the contents of this initializer to a standard constructor or to field initializers."");
  }
}
"
S1172,CODE_SMELL,Unused method parameters should be removed,"package org.sonar.java.checks.unused;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.Javadoc;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.helpers.UnresolvedIdentifiersVisitor;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonarsource.analyzer.commons.collections.SetUtils;

import static org.sonar.java.checks.helpers.AnnotationsHelper.hasUnknownAnnotation;

@Rule(key = ""S1172"")
public class UnusedMethodParameterCheck extends IssuableSubscriptionVisitor {
  private static final String PRIMARY_SINGULAR_MESSAGE_FORMAT = ""Remove this unused method parameter %s."";
  private static final String PRIMARY_PLURAL_MESSAGE_FORMAT = ""Remove these unused method parameters %s."";
  private static final String SECONDARY_MESSAGE_FORMAT = ""Parameter \""%s\"""";
  private static final String QUICK_FIX_MESSAGE = ""Remove \""%s\"""";

  private static final Set<String> AUTHORIZED_ANNOTATIONS = Set.of(""javax.enterprise.event.Observes"", ""jakarta.enterprise.event.Observes"");
  private static final String SUPPRESS_WARNINGS_ANNOTATION = ""java.lang.SuppressWarnings"";
  private static final Set<String> EXCLUDED_WARNINGS_SUPPRESSIONS = SetUtils.immutableSetOf(""\""rawtypes\"""", ""\""unchecked\"""");
  private static final MethodMatchers SERIALIZABLE_METHODS = MethodMatchers.or(
    MethodMatchers.create().ofAnyType().names(""writeObject"").addParametersMatcher(""java.io.ObjectOutputStream"").build(),
    MethodMatchers.create().ofAnyType().names(""readObject"").addParametersMatcher(""java.io.ObjectInputStream"").build());
  private static final String STRUTS_ACTION_SUPERCLASS = ""org.apache.struts.action.Action"";
  private static final Set<String> EXCLUDED_STRUTS_ACTION_PARAMETER_TYPES = Set.of(
    ""org.apache.struts.action.ActionMapping"",
    ""org.apache.struts.action.ActionForm"",
    ""javax.servlet.http.HttpServletRequest"",
    ""javax.servlet.http.HttpServletResponse"",
    ""jakarta.servlet.http.HttpServletRequest"",
    ""jakarta.servlet.http.HttpServletResponse"");

  private static final UnresolvedIdentifiersVisitor UNRESOLVED_IDENTIFIERS_VISITOR = new UnresolvedIdentifiersVisitor();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (methodTree.block() == null || methodTree.parameters().isEmpty() || isExcluded(methodTree)) {
      return;
    }
    Set<String> undocumentedParameters = new HashSet<>(new Javadoc(methodTree).undocumentedParameters());
    boolean overridableMethod = methodTree.symbol().isOverridable();
    List<IdentifierTree> unused = new ArrayList<>();
    for (VariableTree parameter : methodTree.parameters()) {
      Symbol symbol = parameter.symbol();
      if (symbol.usages().isEmpty()
        && !isAnnotatedWithAuthorizedAnnotation(symbol)
        && !isStrutsActionParameter(parameter)
        && (!overridableMethod || undocumentedParameters.contains(symbol.name()))) {
        unused.add(parameter.simpleName());
      }
    }
    Set<String> unresolvedIdentifierNames = UNRESOLVED_IDENTIFIERS_VISITOR.check(methodTree.block());
    // kill the noise regarding unresolved identifiers, and remove the one with matching names from the list of unused
    unused = unused.stream()
      .filter(id -> !unresolvedIdentifierNames.contains(id.name()))
      .toList();
    if (!unused.isEmpty()) {
      reportUnusedParameters(methodTree, unused);
    }
  }

  private static boolean isAnnotatedWithAuthorizedAnnotation(Symbol symbol) {
    SymbolMetadata metadata = symbol.metadata();
    return AUTHORIZED_ANNOTATIONS.stream().anyMatch(metadata::isAnnotatedWith) || hasUnknownAnnotation(metadata);
  }

  private void reportUnusedParameters(MethodTree methodTree, List<IdentifierTree> unused) {
    IdentifierTree firstUnused = unused.get(0);
    List<JavaFileScannerContext.Location> secondaryLocations = unused.stream()
      .skip(1)
      .map(identifier -> new JavaFileScannerContext.Location(String.format(SECONDARY_MESSAGE_FORMAT, identifier.name()), identifier))
      .toList();
    String parameterNames = unused.stream().map(identifier -> ""\"""" + identifier.name() + ""\"""").collect(Collectors.joining("", ""));
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(firstUnused)
      .withMessage(unused.size() > 1 ? PRIMARY_PLURAL_MESSAGE_FORMAT : PRIMARY_SINGULAR_MESSAGE_FORMAT, parameterNames)
      .withSecondaries(secondaryLocations)
      .withQuickFixes(() -> createQuickFixes(methodTree, unused))
      .report();
  }

  private static List<JavaQuickFix> createQuickFixes(MethodTree methodTree, List<IdentifierTree> unused) {
    List<JavaQuickFix> quickFixes = new ArrayList<>();
    List<VariableTree> parameters = methodTree.parameters();
    for (int i = 0; i < parameters.size(); i++) {
      VariableTree parameter = parameters.get(i);
      if (unused.contains(parameter.simpleName())) {
        boolean isFirst = i == 0;
        boolean isLast = i == parameters.size() - 1;
        AnalyzerMessage.TextSpan textSpanToRemove;
        if (isFirst && isLast) {
          // no need to remove any comma
          textSpanToRemove = AnalyzerMessage.textSpanBetween(methodTree.openParenToken(), false, methodTree.closeParenToken(), false);
        } else if (isLast) {
          // also remove the previous comma and spaces between previousParameter and parameter
          VariableTree previousParameter = parameters.get(i - 1);
          textSpanToRemove = AnalyzerMessage.textSpanBetween(previousParameter.endToken(), true, methodTree.closeParenToken(), false);
        } else {
          // also remove the next comma and spaces between parameter and nextParameter
          VariableTree nextParameter = parameters.get(i + 1);
          textSpanToRemove = AnalyzerMessage.textSpanBetween(parameter, true, nextParameter, false);
        }
        quickFixes.add(JavaQuickFix.newQuickFix(QUICK_FIX_MESSAGE, parameter.simpleName().name())
          .addTextEdit(JavaTextEdit.removeTextSpan(textSpanToRemove))
          .build());
      }
    }
    return quickFixes;
  }

  private static boolean isExcluded(MethodTree tree) {
    return MethodTreeUtils.isMainMethod(tree)
      || isAnnotated(tree)
      || isOverriding(tree)
      || isSerializableMethod(tree)
      || isDesignedForExtension(tree)
      || isUsedAsMethodReference(tree);
  }

  private static boolean isAnnotated(MethodTree tree) {
    // If any annotation doesn't match the @SuppressWarning then mark the method as annotated.
    return tree.modifiers().annotations().stream().anyMatch(annotation -> !isExcludedLiteral(annotation));
  }

  private static boolean isExcludedLiteral(Tree tree) {
    if (tree.is(Tree.Kind.ANNOTATION)) {
      AnnotationTree annotationTree = (AnnotationTree) tree;
      return annotationTree.annotationType().symbolType().is(SUPPRESS_WARNINGS_ANNOTATION)
        && annotationTree.arguments().stream().allMatch(UnusedMethodParameterCheck::isExcludedLiteral);
    }
    if (tree.is(Tree.Kind.STRING_LITERAL)) {
      return EXCLUDED_WARNINGS_SUPPRESSIONS.contains(((LiteralTree) tree).value());
    }
    if (tree.is(Tree.Kind.NEW_ARRAY)) {
      return ((NewArrayTree) tree).initializers().stream().allMatch(UnusedMethodParameterCheck::isExcludedLiteral);
    }

    // If it is some type we don't expect, then return false to avoid FP.
    return false;
  }

  private static boolean isDesignedForExtension(MethodTree tree) {
    if (tree.symbol().enclosingClass().isFinal()) {
      // methods of final class can not be overridden, because the class can not be extended
      return false;
    }
    ModifiersTree modifiers = tree.modifiers();
    return ModifiersUtils.hasModifier(modifiers, Modifier.DEFAULT)
      || (!ModifiersUtils.hasModifier(modifiers, Modifier.PRIVATE) && isEmptyOrThrowStatement(tree.block()));
  }

  private static boolean isStrutsActionParameter(VariableTree variableTree) {
    Type superClass = variableTree.symbol().enclosingClass().superClass();
    return superClass != null && superClass.isSubtypeOf(STRUTS_ACTION_SUPERCLASS)
      && EXCLUDED_STRUTS_ACTION_PARAMETER_TYPES.contains(variableTree.symbol().type().fullyQualifiedName());
  }

  private static boolean isEmptyOrThrowStatement(BlockTree block) {
    return block.body().isEmpty() || (block.body().size() == 1 && block.body().get(0).is(Tree.Kind.THROW_STATEMENT));
  }

  private static boolean isSerializableMethod(MethodTree methodTree) {
    return ModifiersUtils.hasModifier(methodTree.modifiers(), Modifier.PRIVATE) && SERIALIZABLE_METHODS.matches(methodTree);
  }

  private static boolean isOverriding(MethodTree tree) {
    // if overriding cannot be determined, we consider it is overriding to avoid FP.
    return !Boolean.FALSE.equals(tree.isOverriding());
  }

  private static boolean isUsedAsMethodReference(MethodTree tree) {
    return tree.symbol().usages().stream()
      // no need to check which side of method reference, from an identifierTree, it's the only possibility as direct parent
      .anyMatch(identifier -> identifier.parent().is(Tree.Kind.METHOD_REFERENCE));
  }

}
"
S1174,CODE_SMELL,"""Object.finalize()"" should remain protected (versus public) when overriding","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1174"")
public class ObjectFinalizeOverridenNotPublicCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (isFinalize(methodTree) && isPublic(methodTree)) {
      reportIssue(methodTree.simpleName(), ""Make this finalize() method protected."");
    }
  }

  private static boolean isPublic(MethodTree methodTree) {
    return ModifiersUtils.hasModifier(methodTree.modifiers(), Modifier.PUBLIC);
  }

  private static boolean isFinalize(MethodTree methodTree) {
    return ""finalize"".equals(methodTree.simpleName().name()) && methodTree.parameters().isEmpty();
  }
}
"
S1175,BUG,"The signature of ""finalize()"" should match that of ""Object.finalize()""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.PrimitiveTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1175"")
public class ObjectFinalizeOverloadedCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (isFinalizeOverload(methodTree)) {
      reportIssue(methodTree.simpleName(), ""Rename this method to avoid any possible confusion with Object.finalize()."");
    }
  }

  private static boolean isFinalizeOverload(MethodTree methodTree) {
    return isNamedFinalize(methodTree) && !(hasNoParameter(methodTree) && isVoid(methodTree));
  }

  private static boolean isNamedFinalize(MethodTree methodTree) {
    return ""finalize"".equals(methodTree.simpleName().name());
  }

  private static boolean hasNoParameter(MethodTree methodTree) {
    return methodTree.parameters().isEmpty();
  }

  private static boolean isVoid(MethodTree methodTree) {
    TypeTree typeTree = methodTree.returnType();
    return typeTree.is(Tree.Kind.PRIMITIVE_TYPE) && ""void"".equals(((PrimitiveTypeTree) typeTree).keyword().text());
  }
}
"
S1176,CODE_SMELL,"Public types, methods and fields (API) should be documented with Javadoc","package org.sonar.java.checks;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.sonar.api.utils.WildcardPattern;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.ast.visitors.PublicApiChecker;
import org.sonar.java.checks.helpers.Javadoc;
import org.sonar.java.model.PackageUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.PrimitiveTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""UndocumentedApi"", repositoryKey = ""squid"")
@Rule(key = ""S1176"")
public class UndocumentedApiCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final Kind[] CLASS_KINDS = PublicApiChecker.classKinds();
  private static final Kind[] METHOD_KINDS = PublicApiChecker.methodKinds();

  private static final String DEFAULT_FOR_CLASSES = ""**.api.**"";
  private static final String DEFAULT_EXCLUSION = ""**.internal.**"";

  @RuleProperty(
    key = ""forClasses"",
    description = ""Pattern of classes which should adhere to this constraint. Ex : **.api.**"",
    defaultValue = DEFAULT_FOR_CLASSES)
  public String forClasses = DEFAULT_FOR_CLASSES;

  @RuleProperty(
    key = ""exclusion"",
    description = ""Pattern of classes which are excluded from adhering to this constraint."",
    defaultValue = DEFAULT_EXCLUSION)
  public String exclusion = DEFAULT_EXCLUSION;

  private WildcardPattern[] inclusionPatterns;
  private WildcardPattern[] exclusionPatterns;

  private final Deque<ClassTree> classTrees = new LinkedList<>();
  private final Deque<Tree> currentParents = new LinkedList<>();

  private String packageName;
  private final Pattern setterPattern = Pattern.compile(""set[A-Z].*"");
  private final Pattern getterPattern = Pattern.compile(""(get|is)[A-Z].*"");
  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    if (context.getSemanticModel() == null) {
      return;
    }
    classTrees.clear();
    currentParents.clear();
    packageName = """";
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitCompilationUnit(CompilationUnitTree tree) {
    packageName = PackageUtils.packageName(tree.packageDeclaration(), ""."");
    super.visitCompilationUnit(tree);
  }

  @Override
  public void visitNewClass(NewClassTree tree) {
    // don't visit anonymous classes, nothing in an anonymous class is part of public api.
  }

  @Override
  public void visitClass(ClassTree tree) {
    // No anonymous class, no visit of new class trees.
    visitNode(tree, tree.simpleName(), tree.symbol().metadata());
    super.visitClass(tree);
    classTrees.pop();
    currentParents.pop();
  }

  @Override
  public void visitVariable(VariableTree tree) {
    visitNode(tree, tree.simpleName(), tree.symbol().metadata());
    super.visitVariable(tree);
  }

  @Override
  public void visitMethod(MethodTree tree) {
    visitNode(tree, tree.simpleName(), tree.symbol().metadata());
    super.visitMethod(tree);
    currentParents.pop();
  }

  private void visitNode(Tree tree, Tree reportTree, SymbolMetadata symbolMetadata) {
    if (!isExcluded(tree, symbolMetadata)) {
      Javadoc javadoc = new Javadoc(tree);
      if (javadoc.noMainDescription() && !isNonVoidMethodWithNoParameter(tree, javadoc)) {
        context.reportIssue(this, reportTree, ""Document this public "" + getType(tree) + "" by adding an explicit description."");
      } else {
        Set<String> undocumentedParameters = javadoc.undocumentedParameters();
        if (!undocumentedParameters.isEmpty()) {
          context.reportIssue(this, reportTree, ""Document the parameter(s): "" + undocumentedParameters.stream().collect(Collectors.joining("", "")));
        }
        if (hasNonVoidReturnType(tree) && javadoc.noReturnDescription()) {
          context.reportIssue(this, reportTree, ""Document this method return value."");
        }
        Set<String> undocumentedExceptions = javadoc.undocumentedThrownExceptions();
        if (!undocumentedExceptions.isEmpty()) {
          context.reportIssue(this, reportTree, ""Document this method thrown exception(s): "" + undocumentedExceptions.stream().collect(Collectors.joining("", "")));
        }
      }
    }
  }

  private boolean isNonVoidMethodWithNoParameter(Tree tree, Javadoc javadoc) {
    if (!tree.is(Tree.Kind.METHOD)) {
      return false;
    }

    return hasNonVoidReturnType(tree)
      && ((MethodTree) tree).parameters().isEmpty()
      // if return description is there, then it will be validated later
      && !javadoc.noReturnDescription();
  }

  private static String getType(Tree tree) {
    switch (tree.kind()) {
      case CONSTRUCTOR:
        return ""constructor"";
      case METHOD:
        return ""method"";
      case VARIABLE:
        return ""field"";
      case ANNOTATION_TYPE:
        return ""annotation"";
      case CLASS:
      case INTERFACE:
      case ENUM:
      case RECORD:
        return ((ClassTree) tree).declarationKeyword().text();
      default:
        return """";
    }
  }

  private boolean isExcluded(Tree tree, SymbolMetadata symbolMetadata) {
    return !isPublicApi(tree)
      || isAccessor(tree)
      || !isMatchingInclusionPattern()
      || isMatchingExclusionPattern()
      || isOverridingMethod(tree)
      || isVisibleForTestingMethod(tree, symbolMetadata)
      || hasDeprecatedAnnotation(symbolMetadata);
  }

  private boolean isAccessor(Tree tree) {
    if (!classTrees.isEmpty() && tree.is(Tree.Kind.METHOD)) {
      MethodTree methodTree = (MethodTree) tree;
      String name = methodTree.simpleName().name();
      return (setterPattern.matcher(name).matches() && methodTree.parameters().size() == 1) ||
        (getterPattern.matcher(name).matches() && methodTree.parameters().isEmpty());
    }
    return false;
  }

  private boolean isPublicApi(Tree tree) {
    Tree currentParent = currentParents.peek();
    if (tree.is(CLASS_KINDS)) {
      classTrees.push((ClassTree) tree);
      currentParents.push(tree);
    } else if (tree.is(METHOD_KINDS)) {
      currentParents.push(tree);
    }

    return PublicApiChecker.isPublicApi(currentParent, tree);
  }

  private boolean isMatchingInclusionPattern() {
    return WildcardPattern.match(getInclusionPatterns(), className());
  }

  private boolean isMatchingExclusionPattern() {
    return WildcardPattern.match(getExclusionPatterns(), className());
  }

  private static boolean isOverridingMethod(Tree tree) {
    // Annotation can be in a parent. If unknown (isOverriding returns null), consider has override to avoid FP.
    return tree.is(Tree.Kind.METHOD) && !Boolean.FALSE.equals(((MethodTree) tree).isOverriding());
  }

  private static boolean isVisibleForTestingMethod(Tree tree, SymbolMetadata symbolMetadata) {
    return tree.is(Tree.Kind.METHOD)
      && (symbolMetadata.isAnnotatedWith(""org.fest.util.VisibleForTesting"") || symbolMetadata.isAnnotatedWith(""com.google.common.annotations.VisibleForTesting""));
  }

  private static boolean hasDeprecatedAnnotation(SymbolMetadata symbolMetadata) {
    return symbolMetadata.isAnnotatedWith(""java.lang.Deprecated"");
  }

  private String className() {
    String className = packageName;
    IdentifierTree identifierTree = classTrees.peek().simpleName();
    if (identifierTree != null) {
      className += ""."" + identifierTree.name();
    }
    return className;
  }

  private WildcardPattern[] getInclusionPatterns() {
    if (inclusionPatterns == null) {
      if (StringUtils.isEmpty(forClasses)) {
        forClasses = ""**"";
      }

      inclusionPatterns = PatternUtils.createPatterns(forClasses);
    }
    return inclusionPatterns;
  }

  private WildcardPattern[] getExclusionPatterns() {
    if (exclusionPatterns == null) {
      if (StringUtils.isEmpty(exclusion)) {
        exclusionPatterns = new WildcardPattern[0];
      } else {
        exclusionPatterns = PatternUtils.createPatterns(exclusion);
      }
    }
    return exclusionPatterns;
  }

  private boolean hasNonVoidReturnType(Tree tree) {
    // Backward compatibility : ignore methods from annotations.
    if (tree.is(Tree.Kind.METHOD) && !classTrees.peek().is(Tree.Kind.ANNOTATION_TYPE)) {
      Tree returnType = ((MethodTree) tree).returnType();
      return returnType == null || !(returnType.is(Tree.Kind.PRIMITIVE_TYPE) && ""void"".equals(((PrimitiveTypeTree) returnType).keyword().text()));
    }
    return false;
  }

}
"
S118,CODE_SMELL,Abstract class names should comply with a naming convention,"package org.sonar.java.checks.naming;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.regex.Pattern;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00118"", repositoryKey = ""squid"")
@Rule(key = ""S118"")
public class BadAbstractClassNameCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String DEFAULT_FORMAT = ""^Abstract[A-Z][a-zA-Z0-9]*$"";

  @RuleProperty(
    key = ""format"",
    description = ""Regular expression used to check the abstract class names against."",
    defaultValue = """" + DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;

  private Pattern pattern = null;
  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    if (pattern == null) {
      pattern = Pattern.compile(format, Pattern.DOTALL);
    }
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    IdentifierTree simpleName = tree.simpleName();
    if (tree.is(Tree.Kind.CLASS) && simpleName != null) {
      if (pattern.matcher(simpleName.name()).matches()) {
        if (!isAbstract(tree)) {
          context.reportIssue(this, simpleName, ""Make this class abstract or rename it, since it matches the regular expression '"" + format + ""'."");
        }
      } else {
        if (isAbstract(tree)) {
          context.reportIssue(this, simpleName, ""Rename this abstract class name to match the regular expression '"" + format + ""'."");
        }
      }
    }
    super.visitClass(tree);
  }

  private static boolean isAbstract(ClassTree tree) {
    return ModifiersUtils.hasModifier(tree.modifiers(), Modifier.ABSTRACT);
  }

}
"
S1181,CODE_SMELL,Throwable and Error should not be caught,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.UnionTypeTree;

@Rule(key = ""S1181"")
public class CatchOfThrowableOrErrorCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_LANG_THROWABLE = ""java.lang.Throwable"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRY_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    TryStatementTree tryStatement = (TryStatementTree) tree;
    TryBlockVisitor tryBlockVisitor = new TryBlockVisitor();
    tryStatement.block().accept(tryBlockVisitor);
    if (tryBlockVisitor.containsExplicitThrowable || tryBlockVisitor.containsUnresolvableCall) {
      return;
    }
    for (CatchTree catchTree : tryStatement.catches()) {
      TypeTree typeTree = catchTree.parameter().type();
      if (typeTree.is(Tree.Kind.UNION_TYPE)) {
        for (TypeTree alternativeTypeTree : ((UnionTypeTree) typeTree).typeAlternatives()) {
          checkType(alternativeTypeTree, catchTree);
        }
      } else {
        checkType(typeTree, catchTree);
      }
    }
  }

  private void checkType(TypeTree typeTree, CatchTree catchTree) {
    Type type = typeTree.symbolType();
    if (type.is(""java.lang.Error"")) {
      insertIssue(typeTree, type);
    } else if (type.is(JAVA_LANG_THROWABLE)) {
      ReThrowVisitor visitor = new ReThrowVisitor(catchTree.parameter().symbol());
      catchTree.block().accept(visitor);
      if (!visitor.foundRethrow) {
        insertIssue(typeTree, type);
      }
    }
  }

  private void insertIssue(TypeTree typeTree, Type type) {
    reportIssue(typeTree, ""Catch Exception instead of "" + type.name() + ""."");
  }

  private static class ReThrowVisitor extends BaseTreeVisitor {
    private static final String JAVA_LANG_CLASS = ""java.lang.Class"";
    private static final MethodMatchers MATCHERS = MethodMatchers.create()
      .ofTypes(""com.google.common.io.Closer"")
      .names(""rethrow"")
      .addParametersMatcher(JAVA_LANG_THROWABLE)
      .addParametersMatcher(JAVA_LANG_THROWABLE, JAVA_LANG_CLASS)
      .addParametersMatcher(JAVA_LANG_THROWABLE, JAVA_LANG_CLASS, JAVA_LANG_CLASS)
      .build();

    private boolean foundRethrow = false;
    private final Symbol exceptionSymbol;

    public ReThrowVisitor(Symbol exceptionSymbol) {
      this.exceptionSymbol = exceptionSymbol;
    }

    @Override
    public void visitThrowStatement(ThrowStatementTree tree) {
      ExpressionTree expression = tree.expression();
      if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree mit = (MethodInvocationTree) expression;
        // In case of broken semantics, the method matcher cannot identify the method invocation.
        // To avoid raising FPs in these cases, we accept it as is and move on.
        if (mit.methodSymbol().isUnknown() || isGuavaCloserRethrow(mit)) {
          foundRethrow = true;
        }
      }
    }

    private boolean isGuavaCloserRethrow(MethodInvocationTree mit) {
      if (!MATCHERS.matches(mit)) {
        return false;
      }
      ExpressionTree firstArgument = mit.arguments().get(0);
      return firstArgument.is(Tree.Kind.IDENTIFIER) && exceptionSymbol.equals(((IdentifierTree) firstArgument).symbol());
    }
  }

  private static class TryBlockVisitor extends BaseTreeVisitor {
    private boolean containsExplicitThrowable = false;
    private boolean containsUnresolvableCall = false;

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      checkIfThrowThrowable(tree.methodSymbol());
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      checkIfThrowThrowable(tree.methodSymbol());
      super.visitNewClass(tree);
    }

    private void checkIfThrowThrowable(Symbol.MethodSymbol symbol) {
      if (containsExplicitThrowable || containsUnresolvableCall) {
        return;
      }
      if (symbol.isUnknown()) {
        containsUnresolvableCall = true;
        return;
      }
      for (Type type : symbol.thrownTypes()) {
        if (type.is(JAVA_LANG_THROWABLE)) {
          containsExplicitThrowable = true;
          return;
        }
      }
    }
  }
}
"
S1182,CODE_SMELL,"Classes that override ""clone"" should be ""Cloneable"" and call ""super.clone()""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S1182"")
public class CloneMethodCallsSuperCloneCheck extends IssuableSubscriptionVisitor {

  private boolean foundSuperClone;

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Kind.METHOD, Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (isCloneMethod(tree)) {
      foundSuperClone = false;
    } else if (isSuperCloneCall(tree)) {
      foundSuperClone = true;
    }

  }

  @Override
  public void leaveNode(Tree tree) {
    if (isCloneMethod(tree) && !foundSuperClone) {
      reportIssue(((MethodTree) tree).simpleName(), ""Use super.clone() to create and seed the cloned instance to be returned."");
    }
  }

  private static boolean isCloneMethod(Tree tree) {
    if (!tree.is(Kind.METHOD)) {
      return false;
    }
    MethodTree methodTree = (MethodTree) tree;
    return ""clone"".equals(methodTree.simpleName().name()) && methodTree.parameters().isEmpty() && methodTree.block() != null;
  }

  private static boolean isSuperCloneCall(Tree tree) {
    if (!tree.is(Kind.METHOD_INVOCATION)) {
      return false;
    }

    MethodInvocationTree mit = (MethodInvocationTree) tree;

    return mit.arguments().isEmpty() &&
      mit.methodSelect().is(Kind.MEMBER_SELECT) &&
      isSuperClone((MemberSelectExpressionTree) mit.methodSelect());
  }

  private static boolean isSuperClone(MemberSelectExpressionTree tree) {
    return ""clone"".equals(tree.identifier().name()) &&
      tree.expression().is(Kind.IDENTIFIER) &&
      ""super"".equals(((IdentifierTree) tree.expression()).name());
  }

}
"
S1185,CODE_SMELL,Overriding methods should do more than simply call the same method in the super class ,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.PrimitiveTypeTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1185"")
public class MethodOnlyCallsSuperCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers ALLOWED_METHODS = MethodMatchers.or(
    MethodMatchers.create().ofAnyType().names(""toString"", ""hashCode"").addWithoutParametersMatcher().build(),
    MethodMatchers.create().ofAnyType().names(""equals"").addParametersMatcher(""java.lang.Object"").build());

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (ALLOWED_METHODS.matches(methodTree)) {
      return;
    }
    if (isSingleStatementMethod(methodTree)
      && isUselessSuperCall(methodTree)
      && !hasAnnotationDifferentFromOverride(methodTree.modifiers().annotations())
      && !isFinalOrSynchronizedOrStrictFP(methodTree)
      && !isClassAnnotatedWithTransactional(methodTree)) {
      reportIssue(methodTree.simpleName(), ""Remove this method to simply inherit it."");
    }
  }

  private static boolean isFinalOrSynchronizedOrStrictFP(MethodTree methodTree) {
    return ModifiersUtils.hasAnyOf(methodTree.modifiers(), Modifier.FINAL, Modifier.SYNCHRONIZED, Modifier.STRICTFP);
  }

  private static boolean isSingleStatementMethod(MethodTree methodTree) {
    BlockTree block = methodTree.block();
    return block != null && block.body().size() == 1;
  }

  private static boolean isUselessSuperCall(MethodTree methodTree) {
    ExpressionTree callToSuper = null;
    StatementTree statementTree = methodTree.block().body().get(0);
    if (returnsVoid(methodTree) && statementTree.is(Tree.Kind.EXPRESSION_STATEMENT)) {
      callToSuper = ((ExpressionStatementTree) statementTree).expression();
    } else if (statementTree.is(Tree.Kind.RETURN_STATEMENT)) {
      callToSuper = ((ReturnStatementTree) statementTree).expression();
    }
    if (callToSuper == null || !isCallToSuper(methodTree, callToSuper)) {
      return false;
    }
    Symbol parentMethod = ((MethodInvocationTree) callToSuper).methodSymbol();
    if (parentMethod.isUnknown()) {
      return false;
    }
    return sameVisibility(methodTree.symbol(), parentMethod);
  }

  private static boolean sameVisibility(Symbol.MethodSymbol method, Symbol parentMethod) {
    return bothPackage(method, parentMethod)
      || bothProtected(method, parentMethod)
      || bothPublic(method, parentMethod);
  }

  private static boolean bothPackage(Symbol.MethodSymbol method, Symbol parentMethod) {
    return method.isPackageVisibility() && parentMethod.isPackageVisibility();
  }

  private static boolean bothProtected(Symbol.MethodSymbol method, Symbol parentMethod) {
    return method.isProtected() && parentMethod.isProtected();
  }

  private static boolean bothPublic(Symbol.MethodSymbol method, Symbol parentMethod) {
    return method.isPublic() && parentMethod.isPublic();
  }

  private static boolean isCallToSuper(MethodTree methodTree, Tree callToSuper) {
    if (callToSuper.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree methodInvocationTree = (MethodInvocationTree) callToSuper;
      if (methodInvocationTree.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree mset = (MemberSelectExpressionTree) methodInvocationTree.methodSelect();
        if (callSuperMethodWithSameName(mset, methodTree) && callsWithSameParameters(methodInvocationTree.arguments(), methodTree.parameters())) {
          return true;
        }
      }
    }
    return false;
  }

  private static boolean callSuperMethodWithSameName(MemberSelectExpressionTree mset, MethodTree methodTree) {
    return mset.expression().is(Tree.Kind.IDENTIFIER)
      && ""super"".equals(((IdentifierTree) mset.expression()).name())
      && mset.identifier().name().equals(methodTree.simpleName().name());
  }

  private static boolean callsWithSameParameters(List<ExpressionTree> arguments, List<VariableTree> parameters) {
    if (arguments.size() != parameters.size()) {
      return false;
    }
    for (int i = 0; i < arguments.size(); i++) {
      ExpressionTree arg = arguments.get(i);
      VariableTree param = parameters.get(i);
      if (!(arg.is(Tree.Kind.IDENTIFIER) && ((IdentifierTree) arg).name().equals(param.simpleName().name()))) {
        return false;
      }
    }
    return true;
  }

  private static boolean returnsVoid(MethodTree methodTree) {
    Tree returnType = methodTree.returnType();
    return returnType != null && returnType.is(Tree.Kind.PRIMITIVE_TYPE) && ""void"".equals(((PrimitiveTypeTree) returnType).keyword().text());
  }

  private static boolean hasAnnotationDifferentFromOverride(List<AnnotationTree> annotations) {
    for (AnnotationTree annotation : annotations) {
      if (!(annotation.annotationType().is(Tree.Kind.IDENTIFIER) && ""Override"".equals(((IdentifierTree) annotation.annotationType()).name()))) {
        return true;
      }
    }
    return false;
  }

  private static boolean isClassAnnotatedWithTransactional(MethodTree methodTree) {
    return methodTree.symbol().enclosingClass().metadata().isAnnotatedWith(""javax.transaction.Transactional"");
  }

}
"
S1186,CODE_SMELL,Methods should not be empty,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.LineUtils;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S1186"")
public class EmptyMethodsCheck extends IssuableSubscriptionVisitor {

  // Some methods may legitimately be left empty, e.g. methods annotated with org.aspectj.lang.annotation.Pointcut. We ignore them here.
  private static final String IGNORED_METHODS_ANNOTATION = ""org.aspectj.lang.annotation.Pointcut"";
  private static final String IGNORED_METHODS_ANNOTATION_UNQUALIFIED = ""Pointcut"";

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.ENUM, Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (!ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.ABSTRACT)) {
      List<Tree> members = classTree.members();
      checkMethods(members);
      checkConstructors(members);
    }
  }

  private void checkMethods(List<Tree> members) {
    members.stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .filter(methodTree -> {
        var annotations = methodTree.modifiers().annotations();
        return annotations.isEmpty() || annotations.stream().noneMatch(EmptyMethodsCheck::isExceptedAnnotation);
      })
      .forEach(this::checkMethod);
  }private static boolean isExceptedAnnotation(AnnotationTree annotationTree) {
    return annotationTree.symbolType().is(IGNORED_METHODS_ANNOTATION) ||
      (annotationTree.symbolType().isUnknown() && annotationTree.symbolType().name().equals(IGNORED_METHODS_ANNOTATION_UNQUALIFIED));
  }

  private void checkConstructors(List<Tree> members) {
    List<MethodTree> constructors = members.stream()
      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR))
      .map(MethodTree.class::cast)
      .toList();
    if (constructors.size() == 1 && isPublicNoArgConstructor(constructors.get(0))) {
      // In case that there is only a single public default constructor with empty body, we raise an issue, as this is equivalent to not
      // defining a constructor at all and hence redundant.
      checkMethod(constructors.get(0));
    } else if(constructors.size() > 1) {
      // If there are several constructors, it may be valid to have a no-args constructor with an empty body. However, constructors that
      // take arguments should do something with those or say why they don't using a comment.
      constructors.stream()
        .filter(constructor -> !constructor.parameters().isEmpty())
        .forEach(this::checkMethod);
    }
  }

  private static boolean isPublicNoArgConstructor(MethodTree constructor) {
    return ModifiersUtils.hasModifier(constructor.modifiers(), Modifier.PUBLIC) && constructor.parameters().isEmpty();
  }

  private void checkMethod(MethodTree methodTree) {
    BlockTree block = methodTree.block();
    if (block != null && isEmpty(block) && !containsComment(block)) {
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(methodTree.simpleName())
        .withMessage(""Add a nested comment explaining why this method is empty, throw an UnsupportedOperationException or complete the implementation."")
        .withQuickFix(() -> computeQuickFix(methodTree))
        .report();
    }
  }

  private static boolean isEmpty(BlockTree block) {
    List<StatementTree> body = block.body();
    return body.isEmpty() || body.stream().allMatch(stmt -> stmt.is(Kind.EMPTY_STATEMENT));
  }

  private static boolean containsComment(BlockTree block) {
    return !block.closeBraceToken().trivias().isEmpty();
  }

  private static JavaQuickFix computeQuickFix(MethodTree method) {
    String commentFormat;
    if (LineUtils.startLine(method.block().openBraceToken()) == LineUtils.startLine(method.block().closeBraceToken())) {
      commentFormat = """";
    } else {
      String methodPadding = computePadding(method);
      commentFormat = ""\n"" + methodPadding + ""  // TODO document why this %s is empty\n"" + methodPadding;
    }

    String comment = String.format(commentFormat, method.is(Kind.CONSTRUCTOR) ? ""constructor"" : ""method"");

    AnalyzerMessage.TextSpan textSpan = AnalyzerMessage.textSpanBetween(
      method.block().openBraceToken(), false,
      method.block().closeBraceToken(), false
    );

    return JavaQuickFix.newQuickFix(""Insert placeholder comment"")
      .addTextEdit(JavaTextEdit.replaceTextSpan(textSpan, comment))
      .build();
  }

  private static String computePadding(MethodTree method) {
    int spaces = Position.startOf(method).columnOffset();
    // This loop and return call can be replaced with a call to "" "".repeat(spaces) in Java 11
    StringBuilder padding = new StringBuilder("""");
    for (int i = 0; i < spaces; i++) {
      padding.append("" "");
    }
    return padding.toString();
  }
}
"
S1188,CODE_SMELL,Anonymous classes should not have too many lines,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.ast.visitors.LinesOfCodeVisitor;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.EnumConstantTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1188"")
public class AnonymousClassesTooBigCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final int DEFAULT_MAX = 20;

  @RuleProperty(key = ""Max"",
    description = ""Maximum allowed lines in an anonymous class"",
    defaultValue = """" + DEFAULT_MAX)
  public int max = DEFAULT_MAX;

  private JavaFileScannerContext context;private boolean isEnumConstantBody;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    isEnumConstantBody = false;
    scan(context.getTree());
  }

  @Override
  public void visitNewClass(NewClassTree tree) {
    if (tree.classBody() != null && !isEnumConstantBody) {
      int lines = getNumberOfLines(tree.classBody());
      if (lines > max) {
        context.reportIssue(this, tree.newKeyword(), tree.identifier(),
          ""Reduce this anonymous class number of lines from "" + lines + "" to at most "" + max + "", or make it a named class."");
      }
    }
    isEnumConstantBody = false;
    super.visitNewClass(tree);
  }

  @Override
  public void visitEnumConstant(EnumConstantTree tree) {
    isEnumConstantBody = true;
    super.visitEnumConstant(tree);
  }

  private static int getNumberOfLines(Tree tree) {
    return new LinesOfCodeVisitor().linesOfCode(tree);
  }
}
"
S119,CODE_SMELL,Type parameter names should comply with a naming convention,"package org.sonar.java.checks.naming;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeParameterTree;

import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00119"", repositoryKey = ""squid"")
@Rule(key = ""S119"")
public class BadTypeParameterNameCheck extends IssuableSubscriptionVisitor {

  private static final String DEFAULT_FORMAT = ""^[A-Z][0-9]?$"";

  @RuleProperty(
      key = ""format"",
      description = ""Regular expression used to check the type parameter names against."",
      defaultValue = """" + DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;
  private Pattern pattern = null;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TYPE_PARAMETER);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    if(pattern == null) {
      pattern = Pattern.compile(format, Pattern.DOTALL);
    }
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    IdentifierTree identifier = ((TypeParameterTree) tree).identifier();
    if (!pattern.matcher(identifier.name()).matches()) {
      reportIssue(identifier, ""Rename this generic name to match the regular expression '"" + format + ""'."");
    }
  }
}
"
S1190,CODE_SMELL,Future keywords should not be used as names,"package org.sonar.java.checks.naming;

import java.util.Set;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1190"")
public class KeywordAsIdentifierCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  private static final Set<String> FORBIDDEN_IDENTIFIERS = SetUtils.immutableSetOf(""enum"", ""_"",""assert"");

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitVariable(VariableTree tree) {
    IdentifierTree simpleName = tree.simpleName();
    if (FORBIDDEN_IDENTIFIERS.contains(simpleName.name())) {
      context.reportIssue(this, simpleName, ""Use a different name than \"""" + simpleName.name() + ""\""."");
    }
    super.visitVariable(tree);
  }

}
"
S1191,CODE_SMELL,"Classes from ""sun.*"" packages should not be used","package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1191"")
public class SunPackagesUsedCheck extends BaseTreeVisitor implements JavaFileScanner {

  private List<Tree> reportedTrees = new ArrayList<>();

  private static final String DEFAULT_EXCLUDE = """";

  @RuleProperty(
      key = ""Exclude"",
      description = ""Comma separated list of Sun packages to be ignored by this rule. Example: sun.misc,sun.security.validator"",
      defaultValue = """" + DEFAULT_EXCLUDE)
  public String exclude = DEFAULT_EXCLUDE;
  private String[] excludePackages = null;
  

  @Override
  public void scanFile(JavaFileScannerContext context) {
    reportedTrees.clear();
    excludePackages = exclude.split("","");
    scan(context.getTree());

    if (!reportedTrees.isEmpty()) {
      reportIssueWithSecondaries(context);
    }
  }

  private void reportIssueWithSecondaries(JavaFileScannerContext context) {
    List<JavaFileScannerContext.Location> secondaries = reportedTrees.stream()
      .skip(1)
      .map(tree -> new JavaFileScannerContext.Location(""Replace also this \""Sun\"" reference."", tree))
      .toList();

    int effortToFix = reportedTrees.size();
    context.reportIssue(this, reportedTrees.get(0), ""Use classes from the Java API instead of Sun classes."", secondaries, effortToFix);
  }

  @Override
  public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
    String reference = ExpressionsHelper.concatenate(tree);
    if (!isExcluded(reference) && isSunClass(reference)) {
      reportedTrees.add(tree);
    }
  }

  private static boolean isSunClass(String reference) {
    return reference.startsWith(""sun."");
  }

  private boolean isExcluded(String reference) {
    for (String str : excludePackages) {
      if (!str.isEmpty() && reference.startsWith(str)) {
        return true;
      }
    }
    return false;
  }
}
"
S1192,CODE_SMELL,String literals should not be duplicated,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.LiteralUtils;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1192"")
public class StringLiteralDuplicatedCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final int DEFAULT_THRESHOLD = 3;

  // String literals include quotes, so this means length 5 as defined in RSPEC
  private static final int MINIMAL_LITERAL_LENGTH = 7;

  @RuleProperty(
    key = ""threshold"",
    description = ""Number of times a literal must be duplicated to trigger an issue"",
    defaultValue = """" + DEFAULT_THRESHOLD)
  public int threshold = DEFAULT_THRESHOLD;

  private final Map<String, List<LiteralTree>> occurrences = new HashMap<>();
  private final Map<String, VariableTree> constants = new HashMap<>();

  @Override
  public void scanFile(JavaFileScannerContext context) {
    occurrences.clear();
    constants.clear();
    scan(context.getTree());
    occurrences.forEach((key, literalTrees) -> {
      int literalOccurrence = literalTrees.size();
      if (constants.containsKey(key)) {
        VariableTree constant = constants.get(key);
        List<LiteralTree> duplications = literalTrees.stream().filter(literal -> literal.parent() != constant).toList();
        context.reportIssue(this, duplications.iterator().next(),
          ""Use already-defined constant '"" + constant.simpleName() + ""' instead of duplicating its value here."",
          secondaryLocations(duplications.subList(1, duplications.size())), literalOccurrence);
      } else if (literalOccurrence >= threshold) {
        LiteralTree literalTree = literalTrees.iterator().next();
        String message = literalTree.is(Tree.Kind.TEXT_BLOCK) ? (""Define a constant instead of duplicating this text block "" + literalOccurrence + "" times."")
          : (""Define a constant instead of duplicating this literal \"""" + key + ""\"" "" + literalOccurrence + "" times."");
        context.reportIssue(
          this,
          literalTree,
          message,
          secondaryLocations(literalTrees), literalOccurrence);
      }
    });
  }

  private static List<JavaFileScannerContext.Location> secondaryLocations(Collection<LiteralTree> literalTrees) {
    return literalTrees.stream().map(element -> new JavaFileScannerContext.Location(""Duplication"", element)).toList();
  }

  @Override
  public void visitLiteral(LiteralTree tree) {
    if (tree.is(Tree.Kind.STRING_LITERAL, Tree.Kind.TEXT_BLOCK)) {
      String literal = tree.value();
      if (literal.length() >= MINIMAL_LITERAL_LENGTH && !isStringLiteralFragment(tree)) {
        String stringValue = LiteralUtils.getAsStringValue(tree).replace(""\\n"", ""\n"");
        occurrences.computeIfAbsent(stringValue, key -> new ArrayList<>()).add(tree);
      }
    }
  }

  private static boolean isStringLiteralFragment(ExpressionTree tree) {
    return isStringLiteral(tree) && (isStringLiteral(getNextOperand(tree)) || isStringLiteral(getPreviousOperand(tree)));
  }

  private static boolean isStringLiteral(@Nullable Tree tree) {
    return tree != null && tree.is(Tree.Kind.STRING_LITERAL);
  }

  @Nullable
  private static ExpressionTree getNextOperand(ExpressionTree tree) {
    var binary = asPlusExpression(tree.parent());
    if (binary == null) {
      return null;
    }
    if (tree == binary.leftOperand()) {
      return binary.rightOperand();
    } else {
      binary = asPlusExpression(binary.parent());
      return binary != null ? binary.rightOperand() : null;
    }
  }

  @Nullable
  private static ExpressionTree getPreviousOperand(ExpressionTree tree) {
    var binary = asPlusExpression(tree.parent());
    if (binary == null) {
      return null;
    }
    if (tree == binary.leftOperand()) {
      return null;
    } else {
      var left = binary.leftOperand();
      binary = asPlusExpression(left);
      return binary != null ? binary.rightOperand() : binary;
    }
  }

  @Nullable
  private static BinaryExpressionTree asPlusExpression(Tree tree) {
    return tree.is(Tree.Kind.PLUS) ? (BinaryExpressionTree) tree : null;
  }

  @Override
  public void visitVariable(VariableTree tree) {
    ExpressionTree initializer = tree.initializer();
    if (initializer != null && initializer.is(Tree.Kind.STRING_LITERAL, Tree.Kind.TEXT_BLOCK)
      && ModifiersUtils.hasAll(tree.modifiers(), Modifier.STATIC, Modifier.FINAL)) {
      String stringValue = LiteralUtils.getAsStringValue((LiteralTree) initializer).replace(""\\n"", ""\n"");
      constants.putIfAbsent(stringValue, tree);
      return;
    }
    super.visitVariable(tree);
  }

  @Override
  public void visitMethod(MethodTree tree) {
    if (ModifiersUtils.hasModifier(tree.modifiers(), Modifier.DEFAULT)) {
      //Ignore default methods to avoid catch-22 with S1214
      return;
    }
    super.visitMethod(tree);
  }

  @Override
  public void visitAnnotation(AnnotationTree annotationTree) {
    //Ignore literals within annotation
  }
}
"
S1193,CODE_SMELL,"Exception types should not be tested using ""instanceof"" in catch blocks","package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.InstanceOfTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1193"")
public class InstanceofUsedOnExceptionCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CATCH);
  }

  @Override
  public void visitNode(Tree tree) {
    CatchTree catchTree = ((CatchTree) tree);

    String caughtVariable = catchTree.parameter().simpleName().name();

    List<StatementTree> body = catchTree.block().body();
    if (body.stream().allMatch(statement -> statement.is(Tree.Kind.RETURN_STATEMENT, Tree.Kind.THROW_STATEMENT, Tree.Kind.IF_STATEMENT))) {
      reportSimpleInstanceOf(body, caughtVariable);
    }
  }

  private void reportSimpleInstanceOf(List<StatementTree> body, String caughtVariable) {
    List<ExpressionTree> conditions = body.stream()
      .filter(statement -> statement.is(Tree.Kind.IF_STATEMENT))
      .map(IfStatementTree.class::cast)
      .flatMap(InstanceofUsedOnExceptionCheck::getFollowingElseIf)
      .map(IfStatementTree::condition)
      .toList();

    if (conditions.stream().allMatch(cond -> cond.is(Tree.Kind.INSTANCE_OF) && isLeftOperandAndException((InstanceOfTree) cond, caughtVariable))) {
      conditions.stream()
        .map(InstanceOfTree.class::cast)
        .forEach(instanceOfTree ->
          reportIssue(instanceOfTree.instanceofKeyword(), ""Replace the usage of the \""instanceof\"" operator by a catch block.""));
    }
  }

  private static boolean isLeftOperandAndException(InstanceOfTree instanceOfTree, String caughtVariable) {
    ExpressionTree expression = instanceOfTree.expression();
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      return caughtVariable.equals(((IdentifierTree) expression).name())
        && instanceOfTree.type().symbolType().isSubtypeOf(""java.lang.Throwable"");
    }
    return false;
  }

  private static Stream<IfStatementTree> getFollowingElseIf(IfStatementTree ifStatementTree) {
    List<IfStatementTree> ifStatements = new ArrayList<>();
    ifStatements.add(ifStatementTree);

    StatementTree elseStatement = ifStatementTree.elseStatement();
    while (elseStatement != null) {
      if (elseStatement.is(Tree.Kind.IF_STATEMENT)) {
        IfStatementTree elseIfStatement = (IfStatementTree) elseStatement;
        ifStatements.add(elseIfStatement);
        elseStatement = elseIfStatement.elseStatement();
      } else {
        elseStatement = null;
      }
    }

    return ifStatements.stream();
  }
}
"
S1194,CODE_SMELL,"""java.lang.Error"" should not be extended","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

@Rule(key = ""S1194"")
public class ErrorClassExtendedCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    TypeTree superClass = ((ClassTree) tree).superClass();
    if (superClass != null && superClass.symbolType().isSubtypeOf(""java.lang.Error"")) {
      reportIssue(superClass, ""Extend \""java.lang.Exception\"" or one of its subclasses."");
    }
  }

}
"
S1195,CODE_SMELL,"Array designators ""[]"" should be located after the type in method signatures","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.ArrayDesignatorOnVariableCheck.MisplacedArray;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.ArrayDesignatorOnVariableCheck.createQuickFix;

@Rule(key = ""S1195"")
public class ArrayDesignatorAfterTypeCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    MisplacedArray.find(methodTree.returnType(), methodTree.simpleName().identifierToken())
      .ifPresent(misplaced -> QuickFixHelper.newIssue(context)
        .forRule(this)
        .onRange(misplaced.firstArray.openBracketToken(), misplaced.lastArray.closeBracketToken())
        .withMessage(""Move the array designators "" + misplaced.replacement + "" to the end of the return type."")
        .withQuickFix(() -> createQuickFix(misplaced, ""return type""))
        .report());
  }

}
"
S1197,CODE_SMELL,"Array designators ""[]"" should be on the type, not the variable","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.ArrayTypeTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1197"")
public class ArrayDesignatorOnVariableCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.VARIABLE);
  }

  @Override
  public void visitNode(Tree tree) {
    VariableTree variableTree = (VariableTree) tree;
    IdentifierTree identifierTree = variableTree.simpleName();
    MisplacedArray.find(variableTree.type(), identifierTree.identifierToken())
      .ifPresent(misplaced -> QuickFixHelper.newIssue(context)
        .forRule(this)
        .onRange(identifierTree, misplaced.lastArray.closeBracketToken())
        .withMessage(""Move the array designators "" + misplaced.replacement + "" to the type."")
        .withQuickFixes(() -> isDeclarationTypeUsedBySeveralVariable(variableTree)
          ? Collections.emptyList()
          : Collections.singletonList(createQuickFix(misplaced, ""variable type"")))
        .report());
  }

  static JavaQuickFix createQuickFix(MisplacedArray misplaced, String type) {
    return JavaQuickFix.newQuickFix(""Move "" + misplaced.replacement + "" to the "" + type)
      .addTextEdit(JavaTextEdit.removeBetweenTree(
        misplaced.firstArray.openBracketToken(),
        misplaced.lastArray.closeBracketToken()))
      .addTextEdit(JavaTextEdit.insertAfterTree(
        misplaced.firstArray.type(),
        misplaced.replacement))
      .build();
  }

  private static boolean isDeclarationTypeUsedBySeveralVariable(VariableTree current) {
    return QuickFixHelper.previousVariable(current).isPresent() || QuickFixHelper.nextVariable(current).isPresent();
  }

  static class MisplacedArray {
    ArrayTypeTree firstArray;
    ArrayTypeTree lastArray;
    String replacement;

    private MisplacedArray(ArrayTypeTree lastArrayType, SyntaxToken identifierToken) {
      firstArray = lastArrayType;
      lastArray = lastArrayType;
      StringBuilder replacementBuilder = new StringBuilder(""[]"");
      while (firstArray.type().is(Tree.Kind.ARRAY_TYPE)) {
        ArrayTypeTree previous = (ArrayTypeTree) firstArray.type();
        if (!isInvalidPosition(previous, identifierToken)) {
          break;
        }
        replacementBuilder.append(""[]"");
        firstArray = previous;
      }
      replacement = replacementBuilder.toString();
    }

    static Optional<MisplacedArray> find(@Nullable TypeTree type, SyntaxToken identifierToken) {
      return Optional.ofNullable(type)
        .filter(t -> t.is(Tree.Kind.ARRAY_TYPE))
        .map(ArrayTypeTree.class::cast)
        .filter(arrayType -> isInvalidPosition(arrayType, identifierToken))
        .map(arrayType -> new MisplacedArray(arrayType, identifierToken));
    }

    private static boolean isInvalidPosition(ArrayTypeTree arrayTypeTree, SyntaxToken identifierToken) {
      SyntaxToken openBracketToken = arrayTypeTree.openBracketToken();
      return openBracketToken != null && Position.startOf(identifierToken).isBefore(Position.startOf(openBracketToken));
    }

  }

}
"
S1199,CODE_SMELL,Nested code blocks should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.List;

@Rule(key = ""S1199"")
public class NestedBlocksCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitCaseGroup(CaseGroupTree tree) {
    List<StatementTree> body = tree.body();
    int statementsInBody = body.size();
    if (statementsInBody == 0) {
      return;
    }

    if (isTerminalStatement(body.get(statementsInBody - 1))) {
      // If the last statement is a break, yield or return, we do not count it
      statementsInBody--;
    }

    if (statementsInBody > 1) {
      checkStatements(tree.body());
    }

    super.visitCaseGroup(tree);
  }

  @Override
  public void visitBlock(BlockTree tree) {
    checkStatements(tree.body());
    super.visitBlock(tree);
  }

  private static boolean isTerminalStatement(StatementTree statementTree) {
    return statementTree.is(Tree.Kind.YIELD_STATEMENT, Tree.Kind.BREAK_STATEMENT, Tree.Kind.RETURN_STATEMENT);
  }

  private void checkStatements(List<StatementTree> statements) {
    for (StatementTree statement : statements) {
      if (statement.is(Tree.Kind.BLOCK)) {
        context.reportIssue(this, ((BlockTree) statement).openBraceToken(), ""Extract this nested code block into a method."");
      }
    }
  }

}
"
S120,CODE_SMELL,Package names should comply with a naming convention,"package org.sonar.java.checks.naming;

import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.PackageUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00120"", repositoryKey = ""squid"")
@Rule(key = ""S120"")
public class BadPackageNameCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String DEFAULT_FORMAT = ""^[a-z_]+(\\.[a-z_][a-z0-9_]*)*$"";

  @RuleProperty(
    key = ""format"",
    description = ""Regular expression used to check the package names against."",
    defaultValue = DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;

  private Pattern pattern = null;
  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    if (pattern == null) {
      pattern = Pattern.compile(format, Pattern.DOTALL);
    }
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitCompilationUnit(CompilationUnitTree tree) {
    if (tree.packageDeclaration() != null) {
      String name = PackageUtils.packageName(tree.packageDeclaration(), ""."");
      if (!pattern.matcher(name).matches()) {
        context.reportIssue(this, tree.packageDeclaration().packageName(), ""Rename this package name to match the regular expression '"" + format + ""'."");
      }
    }
  }

}
"
S1200,CODE_SMELL,Classes should not be coupled to too many other classes,"package org.sonar.java.checks.design;

import java.util.HashSet;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1200"")
public class ClassCouplingCheck extends AbstractCouplingChecker {

  private static final int DEFAULT_MAX = 20;

  @RuleProperty(
    key = ""max"",
    description = ""Maximum number of classes a single class is allowed to depend upon"",
    defaultValue = """" + DEFAULT_MAX)
  public int max = DEFAULT_MAX;

  @Override
  public void visitClass(ClassTree tree) {
    if (tree.is(Tree.Kind.CLASS) && tree.simpleName() != null) {
      nesting.push(types);
      types = new HashSet<>();
    }
    checkTypes(tree.superClass(), types);
    checkTypes(tree.superInterfaces());
    super.visitClass(tree);
    if (tree.is(Tree.Kind.CLASS) && tree.simpleName() != null) {
      if (types.size() > max) {
        context.reportIssue(
          this,
          tree.simpleName(),
          ""Split this class into smaller and more specialized ones to reduce its dependencies on other classes from "" +
            types.size() + "" to the maximum authorized "" + max + "" or less."");
      }
      types = nesting.pop();
    }
  }

  @Override
  public void checkTypes(@Nullable Tree type, @Nullable Set<String> types) {
    if (type == null || types == null) {
      return;
    }
    if (type.is(Tree.Kind.IDENTIFIER)) {
      types.add(((IdentifierTree) type).name());
    } else if (type.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mse = (MemberSelectExpressionTree) type;
      String concatenated = ExpressionsHelper.concatenate(mse);
      types.add(concatenated);
    }
  }
}
"
S1201,BUG,"""equals"" method overrides should accept ""Object"" parameters","package org.sonar.java.checks.naming;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1201"")
public class MethodNamedEqualsCheck extends IssuableSubscriptionVisitor {

  private static final String EQUALS = ""equals"";
  private static final MethodMatchers EQUALS_MATCHER = MethodMatchers.create().ofAnyType().names(EQUALS).addParametersMatcher(""java.lang.Object"").build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (equalsWithSingleParam(methodTree) && !hasProperEquals(methodTree)) {
      reportIssue(methodTree.simpleName(), ""Either override Object.equals(Object), or rename the method to prevent any confusion."");
    }
  }

  private static boolean equalsWithSingleParam(MethodTree methodTree) {
    return EQUALS.equalsIgnoreCase(methodTree.simpleName().name()) && methodTree.parameters().size() == 1;
  }

  private static boolean hasProperEquals(MethodTree methodTree) {
    Symbol.TypeSymbol enclosingClass = methodTree.symbol().enclosingClass();
    return enclosingClass != null && enclosingClass.lookupSymbols(EQUALS).stream().anyMatch(EQUALS_MATCHER::matches);
  }

}
"
S1206,BUG,"""equals(Object obj)"" and ""hashCode()"" should be overridden in pairs","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

@Rule(key = ""S1206"")
public class EqualsOverridenWithHashCodeCheck extends IssuableSubscriptionVisitor {

  private static final String HASHCODE = ""hashCode"";
  private static final String EQUALS = ""equals"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    List<MethodTree> methods = ((ClassTree) tree).members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .toList();

    Optional<MethodTree> equalsMethod = methods.stream().filter(EqualsOverridenWithHashCodeCheck::isEquals).findAny();
    Optional<MethodTree> hashCodeMethod = methods.stream().filter(EqualsOverridenWithHashCodeCheck::isHashCode).findAny();

    if (equalsMethod.isPresent() && !hashCodeMethod.isPresent()) {
      reportIssue(equalsMethod.get().simpleName(), getMessage(EQUALS, HASHCODE));
    } else if (hashCodeMethod.isPresent() && !equalsMethod.isPresent()) {
      reportIssue(hashCodeMethod.get().simpleName(), getMessage(HASHCODE, EQUALS));
    }
  }

  private static boolean isEquals(MethodTree methodTree) {
    return MethodTreeUtils.isEqualsMethod(methodTree);
  }

  private static boolean isHashCode(MethodTree methodTree) {
    return HASHCODE.equals(methodTree.simpleName().name()) && methodTree.parameters().isEmpty() && returnsInt(methodTree);
  }

  private static boolean returnsInt(MethodTree tree) {
    TypeTree typeTree = tree.returnType();
    return typeTree != null && typeTree.symbolType().isPrimitive(org.sonar.plugins.java.api.semantic.Type.Primitives.INT);
  }

  private static String getMessage(String overridenMethod, String methodToOverride) {
    return ""This class overrides \"""" + overridenMethod + ""()\"" and should therefore also override \"""" + methodToOverride + ""()\""."";
  }

}
"
S121,CODE_SMELL,Control structures should use curly braces,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.DoWhileStatementTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

import java.util.Arrays;
import java.util.List;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00121"", repositoryKey = ""squid"")
@Rule(key = ""S121"")
public class MissingCurlyBracesCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.IF_STATEMENT, Tree.Kind.FOR_EACH_STATEMENT, Tree.Kind.FOR_STATEMENT, Tree.Kind.WHILE_STATEMENT, Tree.Kind.DO_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    switch (tree.kind()) {
      case WHILE_STATEMENT:
        WhileStatementTree whileStatementTree = (WhileStatementTree) tree;
        checkStatement(whileStatementTree.whileKeyword(), whileStatementTree.statement());
        break;
      case DO_STATEMENT:
        DoWhileStatementTree doWhileStatementTree = (DoWhileStatementTree) tree;
        checkStatement(doWhileStatementTree.doKeyword(), doWhileStatementTree.statement());
        break;
      case FOR_STATEMENT:
        ForStatementTree forStatementTree = (ForStatementTree) tree;
        checkStatement(forStatementTree.forKeyword(), forStatementTree.statement());
        break;
      case FOR_EACH_STATEMENT:
        ForEachStatement forEachStatement = (ForEachStatement) tree;
        checkStatement(forEachStatement.forKeyword(), forEachStatement.statement());
        break;
      case IF_STATEMENT:
        checkIfStatement((IfStatementTree) tree);
        break;
      default:
        break;
    }
  }

  private void checkIfStatement(IfStatementTree ifStmt) {
    StatementTree thenStatement = ifStmt.thenStatement();
    StatementTree elseStmt = ifStmt.elseStatement();
    boolean haveElse = elseStmt != null;
    if (!isException(thenStatement, LineUtils.startLine(ifStmt.ifKeyword()), haveElse)) {
      checkStatement(ifStmt.ifKeyword(), thenStatement);
    }
    if (haveElse && !elseStmt.is(Tree.Kind.IF_STATEMENT)) {
      checkStatement(ifStmt.elseKeyword(), elseStmt);
    }
  }

  private static boolean isException(StatementTree statementTree, int ifLine, boolean haveElse) {
    if (haveElse || !statementTree.is(Tree.Kind.RETURN_STATEMENT, Tree.Kind.CONTINUE_STATEMENT, Tree.Kind.BREAK_STATEMENT)) {
      return false;
    }
    return LineUtils.startLine(statementTree) == ifLine;
  }

  private void checkStatement(SyntaxToken reportToken, StatementTree statement) {
    if (!statement.is(Tree.Kind.BLOCK)) {
      reportIssue(reportToken, ""Missing curly brace."");
    }
  }
}
"
S1210,CODE_SMELL,"""equals(Object obj)"" should be overridden along with the ""compareTo(T obj)"" method","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S1210"")
public class EqualsNotOverridenWithCompareToCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (!isComparable(classTree)) {
      return;
    }
    boolean hasEquals = false;
    MethodTree compare = null;

    for (Tree member : classTree.members()) {
      if (member.is(Tree.Kind.METHOD)) {
        MethodTree method = (MethodTree) member;

        if (isEqualsMethod(method)) {
          hasEquals = true;
        } else if (isCompareToMethod(method)) {
          compare = method;
        }
      }
    }

    if (compare != null && !hasEquals) {
      reportIssue(compare.simpleName(), ""Override \""equals(Object obj)\"" to comply with the contract of the \""compareTo(T o)\"" method."");
    }
  }

  private static boolean isCompareToMethod(MethodTree method) {
    String name = method.simpleName().name();
    return ""compareTo"".equals(name) && returnsInt(method) && method.parameters().size() == 1;
  }

  private static boolean isEqualsMethod(MethodTree method) {
    return MethodTreeUtils.isEqualsMethod(method);
  }

  private static boolean isComparable(ClassTree tree) {
    for (Type type : tree.symbol().interfaces()) {
      if (type.is(""java.lang.Comparable"")) {
        return true;
      }
    }
    return false;
  }

  private static boolean returnsInt(MethodTree tree) {
    TypeTree typeTree = tree.returnType();
    return typeTree != null && typeTree.symbolType().isPrimitive(Type.Primitives.INT);
  }

}
"
S1213,CODE_SMELL,The members of an interface or class declaration should appear in a pre-defined order,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1213"")
public class IncorrectOrderOfMembersCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String[] NAMES = {""static variable"", ""variable"", ""constructor"", ""method""};

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    int prev = 0;
    for (int i = 0; i < tree.members().size(); i++) {
      final Tree member = tree.members().get(i);
      final int priority;
      IdentifierTree identifier;
      if (member.is(Tree.Kind.VARIABLE)) {
        VariableTree variable = ((VariableTree) member);
        if (variable.symbol().isStatic()) {
          priority = 0;
        } else {
          priority = 1;
        }
        identifier = variable.simpleName();
      } else if (member.is(Tree.Kind.CONSTRUCTOR)) {
        priority = 2;
        identifier = ((MethodTree) member).simpleName();
      } else if (member.is(Tree.Kind.METHOD)) {
        priority = 3;
        identifier = ((MethodTree) member).simpleName();
      } else {
        continue;
      }
      if (priority < prev) {
        context.reportIssue(this, identifier, ""Move this "" + NAMES[priority] + "" to comply with Java Code Conventions."");
      } else {
        prev = priority;
      }
    }

    super.visitClass(tree);
  }

}
"
S1214,CODE_SMELL,Interfaces should not solely consist of constants,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1214"")
public class InterfaceAsConstantContainerCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.INTERFACE);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (!classTree.superInterfaces().isEmpty()) {
      return;
    }
    List<JavaFileScannerContext.Location> constantsLocation = collectConstantsLocation(classTree);
    if (!constantsLocation.isEmpty()) {
      reportIssue(classTree.simpleName(), ""Move constants defined in this interfaces to another class or enum."", constantsLocation, null);
    }
  }

  private static List<JavaFileScannerContext.Location> collectConstantsLocation(ClassTree tree) {
    List<JavaFileScannerContext.Location> constantLocations = new ArrayList<>();
    for (Tree member : tree.members()) {
      if (!member.is(Tree.Kind.VARIABLE, Tree.Kind.EMPTY_STATEMENT)) {
        // the interface doesn't hold only constants
        return Collections.emptyList();
      }
      if (member.is(Tree.Kind.EMPTY_STATEMENT)) {
        continue;
      }
      constantLocations.add(new JavaFileScannerContext.Location("""", ((VariableTree) member).simpleName()));
    }
    return constantLocations;
  }
}
"
S1215,CODE_SMELL,Execution of the Garbage Collector should be triggered only by the JVM,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1215"")
public class GarbageCollectorCalledCheck extends IssuableSubscriptionVisitor {
  private static final MethodMatchers GC_METHOD_MATCHER = MethodMatchers.create()
    .ofTypes(""java.lang.Runtime"", ""java.lang.System"")
    .names(""gc"", ""runFinalization"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;
    if (GC_METHOD_MATCHER.matches(mit)) {
      reportIssue(ExpressionUtils.methodName(mit), ""Don't try to be smarter than the JVM, remove this call to run the garbage collector."");
    }
  }
}
"
S1217,BUG,"""Thread.run()"" should not be called directly","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1217"")
public class ThreadRunCheck extends AbstractMethodDetection {

  private static final MethodMatchers THREAD_RUN_METHOD_MATCHER = MethodMatchers.create()
    .ofSubTypes(""java.lang.Thread"")
    .names(""run"")
    .withAnyParameters()
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return THREAD_RUN_METHOD_MATCHER;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    Tree parent = mit.parent();
    while (parent != null && !parent.is(Tree.Kind.METHOD)) {
      parent = parent.parent();
    }
    if (parent != null && THREAD_RUN_METHOD_MATCHER.matches((MethodTree) parent)) {
      return;
    }

    IdentifierTree methodName = ExpressionUtils.methodName(mit);
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(methodName)
      .withMessage(""Call the method Thread.start() to execute the content of the run() method in a dedicated thread."")
      .withQuickFix(() -> computeQuickFix(methodName))
      .report();
  }

  private static JavaQuickFix computeQuickFix(IdentifierTree methodName) {
    return JavaQuickFix.newQuickFix(""Replace run() with start()"")
      .addTextEdit(JavaTextEdit.replaceTree(methodName, ""start""))
      .build();
  }
}
"
S1219,CODE_SMELL,"""switch"" statements should not contain non-case labels","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LabeledStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.plugins.java.api.tree.Tree.Kind.BLOCK;
import static org.sonar.plugins.java.api.tree.Tree.Kind.CASE_GROUP;
import static org.sonar.plugins.java.api.tree.Tree.Kind.LABELED_STATEMENT;

@Rule(key = ""S1219"")
public class SwitchWithLabelsCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(CASE_GROUP);
  }

  @Override
  public void visitNode(Tree tree) {
    CaseGroupTree cgt = (CaseGroupTree) tree;
    cgt.body().stream()
      .flatMap(SwitchWithLabelsCheck::getStatementTreeStream)
      .map(LabeledStatementTree.class::cast)
      .forEach(this::reportLabeledStatement);
  }

  private static Stream<StatementTree> getStatementTreeStream(StatementTree statementTree) {
    if (statementTree.is(LABELED_STATEMENT)) {
      return Stream.of(statementTree);
    }
    if (statementTree.is(BLOCK)) {
      return ((BlockTree) statementTree).body().stream()
        .filter(st -> st.is(LABELED_STATEMENT));
    }
    return Stream.empty();
  }

  private void reportLabeledStatement(LabeledStatementTree statementTree) {
    IdentifierTree label = statementTree.label();
    reportIssue(label, ""Remove this misleading \"""" + label.name() + ""\"" label."");
  }
}
"
S122,CODE_SMELL,Statements should be on separate lines,"package org.sonar.java.checks;

import java.util.HashMap;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AssertStatementTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.BreakStatementTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ContinueStatementTree;
import org.sonar.plugins.java.api.tree.DoWhileStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SwitchStatementTree;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

import java.util.Arrays;
import java.util.List;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""S00122"", repositoryKey = ""squid"")
@Rule(key = ""S122"")
public class TooManyStatementsPerLineCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR, Tree.Kind.STATIC_INITIALIZER, Kind.INITIALIZER);
  }

  @Override
  public void visitNode(Tree tree) {
    BlockTree block;
    if (tree.is(Tree.Kind.STATIC_INITIALIZER, Kind.INITIALIZER)) {
      block = (BlockTree) tree;
    } else {
      block = ((MethodTree) tree).block();
    }
    if (block != null) {
      StatementVisitor visitor = new StatementVisitor();
      block.accept(visitor);
      visitor.statementsPerLine.forEach((line, count) -> {
        if (count > 1) {
          addIssue(line, ""At most one statement is allowed per line, but "" + count + "" statements were found on this line."");
        }
      });
    }
  }

  private static class StatementVisitor extends BaseTreeVisitor {
    private final Map<Integer, Integer> statementsPerLine = new HashMap<>();

    @Override
    public void visitClass(ClassTree tree) {
      // do nothing, as inner class will be visited later
    }

    @Override
    public void visitAssertStatement(AssertStatementTree tree) {
      addLines(tree.assertKeyword(), tree.semicolonToken());
    }

    @Override
    public void visitBreakStatement(BreakStatementTree tree) {
      addLines(tree.breakKeyword(), tree.semicolonToken());
    }

    @Override
    public void visitContinueStatement(ContinueStatementTree tree) {
      addLines(tree.continueKeyword(), tree.semicolonToken());
    }

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      addLines(tree.returnKeyword(), tree.semicolonToken());
    }

    @Override
    public void visitThrowStatement(ThrowStatementTree tree) {
      addLines(tree.throwKeyword(), tree.semicolonToken());
    }

    @Override
    public void visitExpressionStatement(ExpressionStatementTree tree) {
      SyntaxToken firstToken = tree.firstToken();
      if (firstToken != null) {
        addLines(firstToken, tree.semicolonToken());
      } else {
        addLine(tree.semicolonToken());
      }
    }

    @Override
    public void visitIfStatement(IfStatementTree tree) {
      addLine(tree.ifKeyword());
      StatementTree thenStatement = tree.thenStatement();
      StatementTree elseStatement = tree.elseStatement();
      scan(thenStatement);
      scan(elseStatement);
      if (elseStatement == null) {
        addLineOfCloseBrace(tree.ifKeyword(), thenStatement);
      } else {
        addLineOfCloseBrace(tree.ifKeyword(), elseStatement);
      }
    }

    private void addLineOfCloseBrace(SyntaxToken startToken, StatementTree tree) {
      if (tree.is(Tree.Kind.BLOCK)) {
        SyntaxToken closeBraceToken = ((BlockTree) tree).closeBraceToken();
        if (LineUtils.startLine(startToken) != LineUtils.startLine(closeBraceToken) &&
          !statementsPerLine.containsKey(LineUtils.startLine(closeBraceToken))) {
          addLine(closeBraceToken);
        }
      }
    }

    @Override
    public void visitSynchronizedStatement(SynchronizedStatementTree tree) {
      addLine(tree.synchronizedKeyword());
      addLineOfCloseBrace(tree.synchronizedKeyword(), tree.block());
      scan(tree.block());
    }

    @Override
    public void visitSwitchStatement(SwitchStatementTree tree) {
      addLines(tree.switchKeyword(), tree.openBraceToken());
      scan(tree.cases());
      addLine(tree.closeBraceToken());
    }

    @Override
    public void visitVariable(VariableTree tree) {
      SyntaxToken endToken = tree.endToken();
      if (endToken != null && "";"".equals(endToken.text())) {
        addLine(endToken);
      }
    }

    @Override
    public void visitWhileStatement(WhileStatementTree tree) {
      // do not scan the condition
      addLines(tree.whileKeyword(), tree.closeParenToken());
      addLineOfCloseBrace(tree.whileKeyword(), tree.statement());
      scan(tree.statement());
    }

    @Override
    public void visitDoWhileStatement(DoWhileStatementTree tree) {
      // do not scan the condition
      addLine(tree.doKeyword());
      if (LineUtils.startLine(tree.doKeyword()) != LineUtils.startLine(tree.whileKeyword())) {
        addLines(tree.whileKeyword(), tree.semicolonToken());
      }
      scan(tree.statement());
    }

    @Override
    public void visitForStatement(ForStatementTree tree) {
      // do not scan the initializer, updater and condition
      addLines(tree.forKeyword(), tree.closeParenToken());
      addLineOfCloseBrace(tree.forKeyword(), tree.statement());
      scan(tree.statement());
    }

    @Override
    public void visitForEachStatement(ForEachStatement tree) {
      // do not scan the variable and expression
      addLines(tree.forKeyword(), tree.closeParenToken());
      addLineOfCloseBrace(tree.forKeyword(), tree.statement());
      scan(tree.statement());
    }

    @Override
    public void visitTryStatement(TryStatementTree tree) {
      // do not scan resources
      if (tree.resourceList().isEmpty()) {
        addLine(tree.tryKeyword());
      } else {
        addLines(tree.tryKeyword(), tree.closeParenToken());
      }
      scan(tree.block());
      scan(tree.catches());
      if (tree.finallyKeyword() != null) {
        addLine(tree.finallyKeyword());
      }
      scan(tree.finallyBlock());
    }

    private void addLine(SyntaxToken token) {
      statementsPerLine.compute(LineUtils.startLine(token), (k, v) -> (v == null) ? 1 : (v + 1));
    }

    private void addLines(SyntaxToken startToken, SyntaxToken endToken) {
      addLine(startToken);
      if (LineUtils.startLine(startToken) != LineUtils.startLine(endToken)) {
        addLine(endToken);
      }
    }
  }
}
"
S1220,CODE_SMELL,The default unnamed package should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;

@Rule(key = ""S1220"")
public class DefaultPackageCheck implements JavaFileScanner {

  @Override
  public void scanFile(JavaFileScannerContext context) {
    if (context.fileParsed()) {
      CompilationUnitTree cut = context.getTree();
      if (cut.moduleDeclaration() == null && cut.packageDeclaration() == null) {
        context.addIssueOnFile(this, ""Move this file to a named package."");
      }
    }
  }

}
"
S1221,BUG,"Methods should not be named ""tostring"", ""hashcode"" or ""equal""","package org.sonar.java.checks.naming;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1221"")
public class MethodNamedHashcodeOrEqualCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree method = (MethodTree) tree;
    IdentifierTree methodIdentifier = method.simpleName();
    switch (methodIdentifier.name()) {
      case ""hashcode"":
        reportIfNotOverriding(method, ""hashCode()"");
        break;
      case ""equal"":
        reportIfNotOverriding(method, ""equals(Object obj)"");
        break;
      case ""tostring"":
        reportIfNotOverriding(method, ""toString()"");
        break;
      default:
        // do nothing
        break;
    }
  }

  private void reportIfNotOverriding(MethodTree method, String substitute) {
    if (notOverriding(method)) {
      reportIssue(method.simpleName(), ""Either override Object."" + substitute + "", or totally rename the method to prevent any confusion."");
    }
  }

  private static boolean notOverriding(MethodTree method) {
    return Boolean.FALSE.equals(method.isOverriding());
  }
}
"
S1223,CODE_SMELL,Non-constructor methods should not have the same name as the enclosing class,"package org.sonar.java.checks.naming;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1223"")
public class MethodNameSameAsClassCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    super.visitClass(tree);
    IdentifierTree classSimpleName = tree.simpleName();
    if (classSimpleName == null) {
      return;
    }
    String className = classSimpleName.name();
    for (Tree member : tree.members()) {
      if (member.is(Tree.Kind.METHOD)) {
        IdentifierTree simpleName = ((MethodTree) member).simpleName();
        if (className.equals(simpleName.name())) {
          context.reportIssue(this, simpleName, ""Rename this method to prevent any misunderstanding or make it a constructor."");
        }
      }
    }
  }

}
"
S1226,BUG,"Method parameters, caught exceptions and foreach variables' initial values should not be ignored","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.cfg.CFG;
import org.sonar.java.cfg.LiveVariables;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

@Rule(key = ""S1226"")
public class ParameterReassignedToCheck extends BaseTreeVisitor implements JavaFileScanner {

  private final Set<Symbol> variables = new HashSet<>();

  private JavaFileScannerContext context;

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    this.context = context;
    variables.clear();
    if (context.getSemanticModel() != null) {
      scan(context.getTree());
    }
  }

  @Override
  public void visitMethod(MethodTree tree) {
    BlockTree block = tree.block();
    if(block == null) {
      return;
    }
    CFG cfg = (CFG) tree.cfg();
    LiveVariables analyze = LiveVariables.analyze(cfg);
    Set<Symbol> live = analyze.getIn(cfg.entryBlock());
    for (VariableTree parameterTree : tree.parameters()) {
      if(!live.contains(parameterTree.symbol())) {
        variables.add(parameterTree.symbol());
      }
    }
    super.visitMethod(tree);
    for (VariableTree parameterTree : tree.parameters()) {
      if(!live.contains(parameterTree.symbol())) {
        variables.remove(parameterTree.symbol());
      }
    }
  }

  @Override
  public void visitCatch(CatchTree tree) {
    CFG cfg = CFG.buildCFG(tree.block().body(), true);
    Symbol variable = tree.parameter().symbol();
    boolean liveVar = true;
    if(variable.owner().isMethodSymbol()) {
      cfg.setMethodSymbol((Symbol.MethodSymbol) variable.owner());
      LiveVariables analyze = LiveVariables.analyze(cfg);
      Set<Symbol> live = analyze.getIn(cfg.entryBlock());
      liveVar = live.contains(variable);
    }
    if(!liveVar) {
      variables.add(variable);
    }
    super.visitCatch(tree);
    if(!liveVar) {
      variables.remove(variable);
    }
  }

  @Override
  public void visitForEachStatement(ForEachStatement tree) {
    CFG cfg = CFG.buildCFG(Collections.singletonList(tree), true);
    Symbol variable = tree.variable().symbol();
    boolean liveVar = true;
    if(variable.owner().isMethodSymbol()) {
      cfg.setMethodSymbol((Symbol.MethodSymbol) variable.owner());
      LiveVariables analyze = LiveVariables.analyze(cfg);
      Set<Symbol> live = analyze.getOut(cfg.reversedBlocks().get(1));
      liveVar = live.contains(variable);
    }
    if(!liveVar) {
      variables.add(variable);
    }
    super.visitForEachStatement(tree);
    if(!liveVar) {
      variables.remove(variable);
    }
  }

  @Override
  public void visitAssignmentExpression(AssignmentExpressionTree tree) {
    ExpressionTree variable = tree.variable();
    if (variable.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) variable;
      Symbol reference = identifier.symbol();
      if (reference.isVariableSymbol() && variables.contains(reference)) {
        context.reportIssue(this, identifier, ""Introduce a new variable instead of reusing the parameter \"""" + identifier.name() + ""\""."");
      }
    }
  }

}
"
S1228,CODE_SMELL,Packages should have a javadoc file 'package-info.java',"package org.sonar.java.checks;

import java.io.File;
import java.util.HashSet;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.annotations.VisibleForTesting;
import org.sonar.plugins.java.api.InputFileScannerContext;
import org.sonar.plugins.java.api.ModuleScannerContext;

@Rule(key = ""S1228"")
public class MissingPackageInfoCheck extends AbstractPackageInfoChecker {

  @VisibleForTesting
  final Set<String> missingPackageWithoutPackageFile = new HashSet<>();
  private final Set<String> knownPackageWithPackageFile = new HashSet<>();

  @Override
  protected void processFile(InputFileScannerContext context, String packageName) {
    if (knownPackageWithPackageFile.contains(packageName)) {
      return;
    }

    File parentFile = context.getInputFile().file().getParentFile();
    if (!new File(parentFile, ""package-info.java"").isFile()) {
      missingPackageWithoutPackageFile.add(packageName);
    } else {
      knownPackageWithPackageFile.add(packageName);
    }
  }

  @Override
  public void endOfAnalysis(ModuleScannerContext context) {
    missingPackageWithoutPackageFile.removeAll(knownPackageWithPackageFile);
    for (String missingPackageInfo : missingPackageWithoutPackageFile) {
      context.addIssueOnProject(this, ""Add a 'package-info.java' file to document the '"" + missingPackageInfo + ""' package"");
    }
  }
}
"
S124,CODE_SMELL,Track comments matching a regular expression,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.IllegalRuleParameterException;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S124"")
public class CommentRegularExpressionCheck extends IssuableSubscriptionVisitor {

  private static final String DEFAULT_REGULAR_EXPRESSION = """";
  private static final String DEFAULT_MESSAGE = ""The regular expression matches this comment."";

  @Nullable
  private Pattern pattern = null;

  @RuleProperty(
    key = ""regularExpression"",
    description = ""The regular expression"",
    defaultValue = """" + DEFAULT_REGULAR_EXPRESSION)
  public String regularExpression = DEFAULT_REGULAR_EXPRESSION;

  @RuleProperty(
    key = ""message"",
    description = ""The issue message"",
    defaultValue = """" + DEFAULT_MESSAGE)
  public String message = DEFAULT_MESSAGE;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRIVIA);
  }

  @Override
  public void visitTrivia(SyntaxTrivia syntaxTrivia) {
    if (pattern == null && !isNullOrEmpty(regularExpression)) {
      try {
        pattern = Pattern.compile(regularExpression, Pattern.DOTALL);
      } catch (RuntimeException e) {
        throw new IllegalRuleParameterException(""Unable to compile regular expression: "" + regularExpression, e);
      }
    }
    if (pattern != null && pattern.matcher(syntaxTrivia.comment()).matches()) {
      addIssue(LineUtils.startLine(syntaxTrivia), message);
    }
  }

  private static boolean isNullOrEmpty(@Nullable String string) {
    return string == null || string.isEmpty();
  }
}
"
S1244,BUG,Floating point numbers should not be tested for equality,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1244"")
public class FloatEqualityCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers EQUALS_MATCHER = MethodMatchers.create()
    .ofTypes(""java.lang.Double"", ""java.lang.Float"")
    .names(""equals"")
    .addParametersMatcher(""java.lang.Object"")
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO, Tree.Kind.CONDITIONAL_AND, Tree.Kind.CONDITIONAL_OR, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if(tree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      if (EQUALS_MATCHER.matches(mit)) {
        reportIssue(mit.methodSelect(), ""Equality tests should not be made with floating point values."");
      }
      return;
    }

    BinaryExpressionTree binaryExpressionTree = (BinaryExpressionTree) tree;
    if (binaryExpressionTree.is(Tree.Kind.CONDITIONAL_AND, Tree.Kind.CONDITIONAL_OR) && isIndirectEquality(binaryExpressionTree)) {
      binaryExpressionTree = (BinaryExpressionTree) binaryExpressionTree.leftOperand();
    }
    if ((hasFloatingType(binaryExpressionTree.leftOperand()) || hasFloatingType(binaryExpressionTree.rightOperand())) && !isNanTest(binaryExpressionTree)) {
      reportIssue(binaryExpressionTree.operatorToken(), ""Equality tests should not be made with floating point values."");
    }
  }

  private static boolean isIndirectEquality(BinaryExpressionTree binaryExpressionTree) {
    return isIndirectEquality(binaryExpressionTree, Tree.Kind.CONDITIONAL_AND, Tree.Kind.GREATER_THAN_OR_EQUAL_TO, Tree.Kind.LESS_THAN_OR_EQUAL_TO)
      || isIndirectEquality(binaryExpressionTree, Tree.Kind.CONDITIONAL_OR, Tree.Kind.GREATER_THAN, Tree.Kind.LESS_THAN);
  }

  private static boolean isIndirectEquality(BinaryExpressionTree binaryExpressionTree, Tree.Kind indirectOperator, Tree.Kind comparator1, Tree.Kind comparator2) {
    if (binaryExpressionTree.is(indirectOperator) && binaryExpressionTree.leftOperand().is(comparator1, comparator2)) {
      BinaryExpressionTree leftOp = (BinaryExpressionTree) binaryExpressionTree.leftOperand();
      if (binaryExpressionTree.rightOperand().is(comparator1, comparator2)) {
        BinaryExpressionTree rightOp = (BinaryExpressionTree) binaryExpressionTree.rightOperand();
        if (leftOp.kind().equals(rightOp.kind())) {
          //same operator
          return SyntacticEquivalence.areEquivalent(leftOp.leftOperand(), rightOp.rightOperand())
            && SyntacticEquivalence.areEquivalent(leftOp.rightOperand(), rightOp.leftOperand());
        } else {
          //different operator
          return SyntacticEquivalence.areEquivalent(leftOp.leftOperand(), rightOp.leftOperand())
            && SyntacticEquivalence.areEquivalent(leftOp.rightOperand(), rightOp.rightOperand());
        }
      }
    }
    return false;
  }


  private static boolean isNanTest(BinaryExpressionTree binaryExpressionTree) {
    return SyntacticEquivalence.areEquivalent(binaryExpressionTree.leftOperand(), binaryExpressionTree.rightOperand());
  }

  private static boolean hasFloatingType(ExpressionTree expressionTree) {
    return expressionTree.symbolType().isPrimitive(Type.Primitives.FLOAT) || expressionTree.symbolType().isPrimitive(Type.Primitives.DOUBLE);
  }

}
"
S125,CODE_SMELL,Sections of code should not be commented out,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.annotation.Nullable;
import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.java.model.DefaultJavaFileScannerContext;
import org.sonar.java.model.LineUtils;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;
import org.sonarsource.analyzer.commons.recognizers.CodeRecognizer;

@DeprecatedRuleKey(ruleKey = ""CommentedOutCodeLine"", repositoryKey = ""squid"")
@Rule(key = ""S125"")
public class CommentedOutCodeLineCheck extends IssuableSubscriptionVisitor {

  private static final double THRESHOLD = 0.9;
  private static final String START_JSNI = """";
  private static final String MESSAGE = ""This block of commented-out lines of code should be removed."";

  private final CodeRecognizer codeRecognizer;

  public CommentedOutCodeLineCheck() {
    codeRecognizer = new CodeRecognizer(THRESHOLD, new JavaFootprint());
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TOKEN);
  }

  @Override
  public void visitToken(SyntaxToken syntaxToken) {
    List<AnalyzerMessage> issues = new ArrayList<>();
    AnalyzerMessage previousRelatedIssue = null;
    int previousCommentLine = -1;
    for (SyntaxTrivia syntaxTrivia : syntaxToken.trivias()) {
      int currentCommentLine = LineUtils.startLine(syntaxTrivia);
      if (currentCommentLine != previousCommentLine + 1 &&
        currentCommentLine != previousCommentLine) {
        previousRelatedIssue = null;
      }
      if (!isHeader(syntaxTrivia) && !isJavadoc(syntaxTrivia.comment()) && !isJSNI(syntaxTrivia.comment())) {
        previousRelatedIssue = collectIssues(issues, syntaxTrivia, previousRelatedIssue);
        previousCommentLine = currentCommentLine;
      }
    }
    DefaultJavaFileScannerContext scannerContext = (DefaultJavaFileScannerContext) this.context;
    issues.forEach(scannerContext::reportIssue);
  }

  public AnalyzerMessage collectIssues(List<AnalyzerMessage> issues, SyntaxTrivia syntaxTrivia, @Nullable AnalyzerMessage previousRelatedIssue) {
    String[] lines = syntaxTrivia.comment().split(""\r\n?|\n"");
    AnalyzerMessage issue = previousRelatedIssue;
    for (int lineOffset = 0; lineOffset < lines.length; lineOffset++) {
      String line = lines[lineOffset];
      if (!isJavadocLink(line) && codeRecognizer.isLineOfCode(line)) {
        int startLine = LineUtils.startLine(syntaxTrivia) + lineOffset;
        int startColumnOffset = (lineOffset == 0 ? Position.startOf(syntaxTrivia).columnOffset() : 0);
        if (issue != null) {
          issue.flows.add(Collections.singletonList(createAnalyzerMessage(startLine, startColumnOffset, line, ""Code"")));
        } else {
          issue = createAnalyzerMessage(startLine, startColumnOffset, line, MESSAGE);
          issues.add(issue);
        }
      }
    }
    return issue;
  }

  private AnalyzerMessage createAnalyzerMessage(int startLine, int startColumn, String line, String message) {
    String lineWithoutCommentPrefix = line.replaceFirst(""^(//|/\\*\\*?|[ \t]*\\*)?[ \t]*+"", """");
    int prefixSize = line.length() - lineWithoutCommentPrefix.length();
    String lineWithoutCommentPrefixAndSuffix = removeCommentSuffix(lineWithoutCommentPrefix);

    AnalyzerMessage.TextSpan textSpan = new AnalyzerMessage.TextSpan(
      startLine,
      startColumn + prefixSize,
      startLine,
      startColumn + prefixSize + lineWithoutCommentPrefixAndSuffix.length());

    return new AnalyzerMessage(this, context.getInputFile(), textSpan, message, 0);
  }

  private static String removeCommentSuffix(String line) {
    // We do not use a regex for this task, to avoid ReDoS.
    if (line.endsWith(""*/"")) {
      line = line.substring(0, line.length() - 2);
    }
    return line.stripTrailing();
  }private static boolean isHeader(SyntaxTrivia syntaxTrivia) {
    return LineUtils.startLine(syntaxTrivia) == 1;
  }

  private static boolean isJavadocLink(String line) {
    return line.contains(""{@link"");
  }private static boolean isJavadoc(String comment) {
    return StringUtils.startsWith(comment, ""private static boolean isJSNI(String comment) {
    return StringUtils.startsWith(comment, START_JSNI) && StringUtils.endsWith(comment, END_JSNI);
  }

}
"
S1258,CODE_SMELL,Classes and enums with private members should have a constructor,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.checks.helpers.AnnotationsHelper.hasUnknownAnnotation;

@Rule(key = ""S1258"")
public class AtLeastOneConstructorCheck extends IssuableSubscriptionVisitor {

  private static final List<String> EXCLUDED_ANNOTATIONS = Arrays.asList(
    ""javax.annotation.ManagedBean"",
    ""javax.ejb.MessageDriven"",
    ""javax.ejb.Singleton"",
    ""javax.ejb.Stateful"",
    ""javax.ejb.Stateless"",
    ""javax.jws.WebService"",
    ""javax.servlet.annotation.WebFilter"",
    ""javax.servlet.annotation.WebServlet"",
    ""org.apache.maven.plugins.annotations.Mojo"",
    ""org.codehaus.plexus.component.annotations.Component"",
    ""lombok.Builder"");

  private static final List<String> AUTOWIRED_ANNOTATIONS = Arrays.asList(
    ""javax.annotation.Resource"",
    ""javax.ejb.EJB"",
    ""javax.inject.Inject"",
    ""org.apache.maven.plugins.annotations.Component"",
    ""org.apache.maven.plugins.annotations.Parameter"",
    ""org.codehaus.plexus.component.annotations.Requirement"",
    ""org.codehaus.plexus.component.annotations.Configuration""
    );

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Kind.CLASS, Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    checkClassTree((ClassTree) tree);
  }

  private void checkClassTree(ClassTree tree) {
    IdentifierTree simpleName = tree.simpleName();
    if (simpleName != null && !ModifiersUtils.hasModifier(tree.modifiers(), Modifier.ABSTRACT)
      && !isAnnotationExcluded(tree.symbol())
      && !isBuilderPatternName(simpleName.name())) {
      List<JavaFileScannerContext.Location> uninitializedVariables = new ArrayList<>();
      for (Tree member : tree.members()) {
        if (member.is(Kind.CONSTRUCTOR)) {
          // there is a constructor, no need to check further
          return;
        } else if (member.is(Kind.VARIABLE) && requiresInitialization((VariableTree) member)) {
          uninitializedVariables.add(new JavaFileScannerContext.Location(""Uninitialized field"", member));
        }
      }
      if (!uninitializedVariables.isEmpty()) {
        reportIssue(simpleName, ""Add a constructor to the "" + tree.declarationKeyword().text() + "", or provide default values."", uninitializedVariables, null);
      }
    }
  }

  private static boolean requiresInitialization(VariableTree variable) {
    Symbol symbol = variable.symbol();
    return variable.initializer() == null && symbol.isPrivate() && !symbol.isStatic() && !isAutowired(symbol);
  }

  private static boolean isAutowired(Symbol symbol) {
    SymbolMetadata metadata = symbol.metadata();
    return hasUnknownAnnotation(metadata) || AUTOWIRED_ANNOTATIONS.stream().anyMatch(metadata::isAnnotatedWith);
  }

  private static boolean isAnnotationExcluded(Symbol symbol) {
    SymbolMetadata metadata = symbol.metadata();
    return hasUnknownAnnotation(metadata) || EXCLUDED_ANNOTATIONS.stream().anyMatch(metadata::isAnnotatedWith);
  }

  private static boolean isBuilderPatternName(String name) {
    return name.endsWith(""Builder"");
  }

}
"
S126,CODE_SMELL,"""if ... else if"" constructs should end with ""else"" clauses","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S126"")
public class IfElseIfStatementEndsWithElseCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.IF_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    IfStatementTree treeIfStmt = (IfStatementTree) tree;
    StatementTree elseStmt = treeIfStmt.elseStatement();
    if (elseStmt != null && elseStmt.is(Tree.Kind.IF_STATEMENT)) {
      IfStatementTree ifStmt = (IfStatementTree) elseStmt;
      if (ifStmt.elseStatement() == null) {
        reportIssue(treeIfStmt.elseKeyword(), ifStmt.ifKeyword(), ""\""if ... else if\"" constructs should end with \""else\"" clauses."");
      }
    }
  }
}
"
S1264,CODE_SMELL,"A ""while"" loop should be used instead of a ""for"" loop","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1264"")
public class ForLoopUsedAsWhileLoopCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.FOR_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ForStatementTree forStatementTree = (ForStatementTree) tree;
    if (forStatementTree.initializer().isEmpty() && forStatementTree.update().isEmpty() && forStatementTree.condition() != null) {
      context.reportIssue(this, forStatementTree.forKeyword(), ""Replace this \""for\"" loop with a \""while\"" loop."");
    }
  }
}
"
S127,CODE_SMELL,"""for"" loop stop conditions should be invariant","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.HashSet;
import java.util.Set;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""ForLoopCounterChangedCheck"", repositoryKey = ""squid"")
@Rule(key = ""S127"")
public class ForLoopCounterChangedCheck extends BaseTreeVisitor implements JavaFileScanner {

  private final Set<String> loopCounters = new HashSet<>();
  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    loopCounters.clear();
    scan(context.getTree());
  }

  @Override
  public void visitForStatement(ForStatementTree tree) {
    Set<String> pendingLoopCounters = new HashSet<>();
    for (StatementTree statementTree : tree.initializer()) {
      if (statementTree.is(Tree.Kind.VARIABLE)) {
        pendingLoopCounters.add(((VariableTree) statementTree).simpleName().name());
      }
    }
    scan(tree.initializer());
    scan(tree.condition());
    scan(tree.update());
    loopCounters.addAll(pendingLoopCounters);
    scan(tree.statement());
    loopCounters.removeAll(pendingLoopCounters);
  }

  @Override
  public void visitAssignmentExpression(AssignmentExpressionTree tree) {
    if (tree.variable().is(Tree.Kind.IDENTIFIER)) {
      checkIdentifier((IdentifierTree) tree.variable());
    }
    super.visitAssignmentExpression(tree);
  }

  @Override
  public void visitUnaryExpression(UnaryExpressionTree tree) {
    if ((isIncrement(tree) || isDecrement(tree)) && tree.expression().is(Tree.Kind.IDENTIFIER)) {
      checkIdentifier((IdentifierTree) tree.expression());
    }
    super.visitUnaryExpression(tree);
  }

  private static boolean isIncrement(UnaryExpressionTree tree) {
    return tree.is(Tree.Kind.PREFIX_INCREMENT) || tree.is(Tree.Kind.POSTFIX_INCREMENT);
  }

  private static boolean isDecrement(UnaryExpressionTree tree) {
    return tree.is(Tree.Kind.POSTFIX_DECREMENT) || tree.is(Tree.Kind.PREFIX_DECREMENT);
  }

  private void checkIdentifier(IdentifierTree identifierTree) {
    if (loopCounters.contains(identifierTree.name())) {
      context.reportIssue(this, identifierTree, ""Refactor the code in order to not assign to this loop counter from within the loop body."");
    }
  }

}
"
S128,CODE_SMELL,"Switch cases should end with an unconditional ""break"" statement","package org.sonar.java.checks;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.ast.visitors.SubscriptionVisitor;
import org.sonar.java.cfg.CFG;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.SwitchStatementTree;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S128"")
public class SwitchCaseWithoutBreakCheck extends IssuableSubscriptionVisitor {
  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.SWITCH_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree;
    Set<CaseGroupTree> caseGroupTrees = new HashSet<>(switchStatementTree.cases());
    CFG cfg = CFG.buildCFG(Collections.singletonList(tree), true);
    Set<CFG.Block> switchSuccessors = cfg.entryBlock().successors();

    Map<CFG.Block, CaseGroupTree> cfgBlockToCaseGroupMap = createMapping(switchSuccessors, caseGroupTrees);
    switchSuccessors.stream()
      .filter(cfgBlockToCaseGroupMap.keySet()::contains)
      .flatMap(cfgBlock -> getForbiddenCaseGroupPredecessors(cfgBlock, cfgBlockToCaseGroupMap))
      .map(CaseGroupTree::labels)
      .map(caseGroupLabels -> caseGroupLabels.get(caseGroupLabels.size() - 1))
      .forEach(label -> reportIssue(label, ""End this switch case with an unconditional break, return or throw statement.""));
  }

  private static Map<CFG.Block, CaseGroupTree> createMapping(Set<CFG.Block> switchSuccessors, Set<CaseGroupTree> caseGroupTrees) {
    return switchSuccessors.stream()
      .filter(cfgBlock -> cfgBlock.caseGroup() != null && caseGroupTrees.contains(cfgBlock.caseGroup()))
      .collect(
        Collectors.toMap(
          Function.identity(),
          CFG.Block::caseGroup));
  }

  private static Stream<CaseGroupTree> getForbiddenCaseGroupPredecessors(CFG.Block cfgBlock, Map<CFG.Block, CaseGroupTree> cfgBlockToCaseGroupMap) {
    CaseGroupTree caseGroup = cfgBlockToCaseGroupMap.get(cfgBlock);
    return cfgBlock.predecessors().stream()
      .map(predecessor -> getForbiddenCaseGroupPredecessor(predecessor, cfgBlockToCaseGroupMap, new HashSet<>()))
      .filter(Objects::nonNull)
      .filter(predecessor -> !intentionalFallThrough(predecessor, caseGroup))
      .distinct();
  }

  @Nullable
  private static CaseGroupTree getForbiddenCaseGroupPredecessor(CFG.Block predecessor, Map<CFG.Block, CaseGroupTree> cfgBlockToCaseGroupMap, Set<CFG.Block> seen) {
    if (cfgBlockToCaseGroupMap.get(predecessor) != null) {
      return cfgBlockToCaseGroupMap.get(predecessor);
    }

    if (seen.contains(predecessor)) {
      return null;
    }

    seen.add(predecessor);
    return predecessor.predecessors().stream()
      .map(previousPredecessors -> getForbiddenCaseGroupPredecessor(previousPredecessors, cfgBlockToCaseGroupMap, seen))
      .filter(Objects::nonNull)
      .findFirst()
      .orElse(null);
  }

  private static boolean intentionalFallThrough(Tree caseGroup, Tree nextCaseGroup) {
    // Check first token of next case group when comment is last element of case group it is attached to next group.
    FallThroughCommentVisitor visitor = new FallThroughCommentVisitor();
    CaseGroupTree caseGroupTree = (CaseGroupTree) caseGroup;
    List<Tree> treesToScan = Stream.of(caseGroupTree.body(), Collections.singletonList(nextCaseGroup.firstToken()))
      .flatMap(List::stream)
      .collect(Collectors.toList());
    visitor.scan(treesToScan);
    return visitor.hasComment;
  }

  private static class FallThroughCommentVisitor extends SubscriptionVisitor {
    private static final Pattern FALL_THROUGH_PATTERN = Pattern.compile(""falls?[\\-\\s]?thro?u[gh]?"", Pattern.CASE_INSENSITIVE);
    boolean hasComment = false;

    @Override
    public List<Tree.Kind> nodesToVisit() {
      return Collections.singletonList(Tree.Kind.TRIVIA);
    }

    @Override
    public void visitTrivia(SyntaxTrivia syntaxTrivia) {
      if (!hasComment && FALL_THROUGH_PATTERN.matcher(syntaxTrivia.comment()).find()) {
        hasComment = true;
      }
    }

    private void scan(List<Tree> trees) {
      for (Tree tree : trees) {
        if (hasComment) {
          return;
        }
        scanTree(tree);
      }
    }
  }
}
"
S1301,CODE_SMELL,"""switch"" statements should have at least 3 ""case"" clauses","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.SwitchStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.List;

@Rule(key = ""S1301"")
public class SwitchAtLeastThreeCasesCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.SWITCH_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree;
    int count = 0;
    for (CaseGroupTree caseGroup : switchStatementTree.cases()) {
      // whenever there is a type, record or guarded pattern, it would decrease readability to replace the switch by if
      // so we don't raise an issue
      if (hasLabelWithAllowedPattern(caseGroup)) {
        return;
      }
      count += caseGroup.labels().size();
    }
    if (count < 3) {
      reportIssue(switchStatementTree.switchKeyword(), ""Replace this \""switch\"" statement by \""if\"" statements to increase readability."");
    }
  }

  private static boolean hasLabelWithAllowedPattern(CaseGroupTree caseGroupTree) {
    return caseGroupTree.labels().stream()
      .flatMap(label -> label.expressions().stream())
      .anyMatch(expression -> expression.is(Tree.Kind.TYPE_PATTERN, Tree.Kind.RECORD_PATTERN, Tree.Kind.GUARDED_PATTERN));
  }

}
"
S1309,CODE_SMELL,"Track uses of ""@SuppressWarnings"" annotations","package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1309"")
public class SuppressWarningsCheck extends IssuableSubscriptionVisitor {

  private static final Pattern FORMER_REPOSITORY_PREFIX = Pattern.compile(""^squid:"");
  private static final String NEW_REPOSITORY_PREFIX = ""java:"";

  @RuleProperty(
    key = ""listOfWarnings"",
    description = ""Comma separated list of warnings that can be suppressed (example: unchecked, cast, boxing). An empty list means that no warning can be suppressed."",
    defaultValue = """")
  public String warningsCommaSeparated = """";

  private Set<String> allowedWarnings;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.ANNOTATION);
  }

  @Override
  public void visitNode(Tree tree) {
    AnnotationTree annotationTree = (AnnotationTree) tree;
    Set<String> ruleWarnings = getAllowedWarnings();

    if (isJavaLangSuppressWarnings(annotationTree)) {
      if (ruleWarnings.isEmpty()) {
        reportIssue(annotationTree.annotationType(), ""Suppressing warnings is not allowed"");
      } else {
        List<String> suppressedWarnings = getSuppressedWarnings(annotationTree.arguments().get(0));
        List<String> issues = suppressedWarnings.stream()
          .filter(currentWarning -> !ruleWarnings.contains(currentWarning))
          .toList();
        if (!issues.isEmpty()) {
          StringBuilder sb = new StringBuilder(""Suppressing the '"").append(String.join("", "", issues))
            .append(""' warning"").append(issues.size() > 1 ? ""s"" : """").append("" is not allowed"");
          reportIssue(annotationTree.annotationType(), sb.toString());
        }
      }
    }
  }

  private static boolean isJavaLangSuppressWarnings(AnnotationTree tree) {
    return tree.symbolType().is(""java.lang.SuppressWarnings"");
  }

  private Set<String> getAllowedWarnings() {
    if (allowedWarnings != null) {
      return allowedWarnings;
    }

    allowedWarnings = Arrays.stream(warningsCommaSeparated.split("",""))
      .filter(StringUtils::isNotBlank)
      .map(SuppressWarningsCheck::replaceFormerRepositoryPrefix)
      .collect(Collectors.toSet());

    return allowedWarnings;
  }

  private static List<String> getSuppressedWarnings(ExpressionTree argument) {
    List<String> result = new ArrayList<>();
    if (argument.is(Tree.Kind.STRING_LITERAL)) {
      result.add(getAnnotationArgument((LiteralTree) argument));
    } else if (argument.is(Tree.Kind.NEW_ARRAY)) {
      NewArrayTree array = (NewArrayTree) argument;
      for (ExpressionTree expressionTree : array.initializers()) {
        if (expressionTree.is(Tree.Kind.STRING_LITERAL)) {
          result.add(getAnnotationArgument((LiteralTree) expressionTree));
        }
      }
    }
    return result;
  }

  private static String getAnnotationArgument(LiteralTree argument) {
    return replaceFormerRepositoryPrefix(LiteralUtils.trimQuotes(argument.value()));
  }

  private static String replaceFormerRepositoryPrefix(String value) {
    return FORMER_REPOSITORY_PREFIX.matcher(value.trim()).replaceFirst(NEW_REPOSITORY_PREFIX);
  }

}
"
S131,CODE_SMELL,"""switch"" statements should have ""default"" clauses","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.java.ast.api.JavaKeyword;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.CaseLabelTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.SwitchStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""SwitchLastCaseIsDefaultCheck"", repositoryKey = ""squid"")
@Rule(key = ""S131"")
public class SwitchLastCaseIsDefaultCheck extends IssuableSubscriptionVisitor {

  private static final String DEFAULT_LABEL_STRING = JavaKeyword.DEFAULT.getValue();
  
  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.SWITCH_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree;
    if (missesDefaultLabel(switchStatementTree) && !isSwitchOnTypePattern(switchStatementTree)) {
      if (!isSwitchOnEnum(switchStatementTree)) {
        reportIssue(switchStatementTree.switchKeyword(), ""Add a default case to this switch."");
      } else if (missingCasesOfEnum(switchStatementTree)) {
        reportIssue(switchStatementTree.switchKeyword(), ""Complete cases by adding the missing enum constants or add a default case to this switch."");
      }
    }
  }

  private static boolean missesDefaultLabel(SwitchStatementTree switchStatementTree) {
    return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault);
  }

  private static boolean isDefault(CaseLabelTree caseLabelTree) {
    if (equalsDefaultKeyword(caseLabelTree.caseOrDefaultKeyword().text())) {
      return true;
    }
    return caseLabelTree.expressions().stream().anyMatch(expr -> expr.is(Tree.Kind.DEFAULT_PATTERN));
  }

  private static boolean isSwitchOnTypePattern(SwitchStatementTree switchStatementTree) {
    return allExpressions(switchStatementTree)
      .anyMatch(expression -> expression.is(Tree.Kind.TYPE_PATTERN, Tree.Kind.RECORD_PATTERN, Tree.Kind.GUARDED_PATTERN));
  }

  private static boolean equalsDefaultKeyword(String text) {
    return DEFAULT_LABEL_STRING.equals(text);
  }

  private static boolean isSwitchOnEnum(SwitchStatementTree switchStatementTree) {
    Symbol.TypeSymbol symbol = switchStatementTree.expression().symbolType().symbol();
    return symbol.isEnum() || symbol.isUnknown();
  }

  private static boolean missingCasesOfEnum(SwitchStatementTree switchStatementTree) {
    return numberConstants(switchStatementTree) > allExpressions(switchStatementTree).count();
  }

  private static Stream<CaseLabelTree> allLabels(SwitchStatementTree switchStatementTree) {
    return switchStatementTree.cases().stream().flatMap(caseGroup -> caseGroup.labels().stream());
  }

  private static Stream<ExpressionTree> allExpressions(SwitchStatementTree switchStatementTree) {
    return allLabels(switchStatementTree).flatMap(caseLabel -> caseLabel.expressions().stream());
  }

  private static long numberConstants(SwitchStatementTree switchStatementTree) {
    return switchStatementTree.expression().symbolType().symbol().memberSymbols().stream()
      .filter(Symbol::isVariableSymbol)
      .filter(Symbol::isEnum)
      .count();
  }
}
"
S1310,CODE_SMELL,"Track uses of ""NOPMD"" suppression comments ","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1310"")
public class NoPmdTagPresenceCheck extends IssuableSubscriptionVisitor {

  private static final String PATTERN = ""NOPMD"";
  private static final String MESSAGE = ""Remove usage of this \""NOPMD\"" suppression comment filter."";

  private final CommentContainsPatternChecker checker = new CommentContainsPatternChecker(this, PATTERN, MESSAGE);

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRIVIA);
  }

  @Override
  public void visitTrivia(SyntaxTrivia syntaxTrivia) {
    checker.checkTrivia(syntaxTrivia);
  }

}
"
S1312,CODE_SMELL,"Loggers should be ""private static final"" and should share a naming convention","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.regex.Pattern;

@Rule(key = ""S1312"")
public class LoggersDeclarationCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String DEFAULT_FORMAT = ""LOG(?:GER)?"";

  @RuleProperty(
    key = ""format"",
    description = ""Regular expression used to check the logger names against."",
    defaultValue = """" + DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;

  private Pattern pattern = null;
  private JavaFileScannerContext context;

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    if (context.getSemanticModel() != null) {
      if (pattern == null) {
        pattern = Pattern.compile(format);
      }
      this.context = context;
      scan(context.getTree());
    }
  }

  private static boolean isPrivateStaticFinal(ModifiersTree tree) {
    return ModifiersUtils.hasAll(tree, Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL);
  }

  private boolean isValidLoggerName(String name) {
    return pattern.matcher(name).matches();
  }

  @Override
  public void visitMethod(MethodTree tree) {
    // only scan body of the method and avoid looking at parameters
    scan(tree.block());
  }

  @Override
  public void visitVariable(VariableTree tree) {
    super.visitVariable(tree);
    if (tree.symbol().type().is(""org.apache.maven.plugin.logging.Log"")) {
      return;
    }
    if (isLoggerType(tree.type())) {
      boolean isPrivateStaticFinal = isPrivateStaticFinal(tree.modifiers());
      IdentifierTree variableIdentifier = tree.simpleName();
      String name = variableIdentifier.name();
      boolean hasValidLoggerName = isValidLoggerName(name);

      if (!isPrivateStaticFinal && !hasValidLoggerName) {
        context.reportIssue(this, variableIdentifier, getPrivateStaticFinalMessage(name) + "" and rename it to comply with the format \"""" + format + ""\""."");
      } else if (!isPrivateStaticFinal) {
        context.reportIssue(this, variableIdentifier, getPrivateStaticFinalMessage(name) + ""."");
      } else if (!hasValidLoggerName) {
        context.reportIssue(this, variableIdentifier, ""Rename the \"""" + variableIdentifier + ""\"" logger to comply with the format \"""" + format + ""\""."");
      }
    }
  }

  private static String getPrivateStaticFinalMessage(String simpleName) {
    return ""Make the \"""" + simpleName + ""\"" logger private static final"";
  }

  private static boolean isLoggerType(Tree tree) {
    IdentifierTree identifierTree = null;
    if (tree.is(Tree.Kind.IDENTIFIER)) {
      identifierTree = (IdentifierTree) tree;
    } else if (tree.is(Tree.Kind.MEMBER_SELECT)) {
      identifierTree = ((MemberSelectExpressionTree) tree).identifier ();
    } else {
      return false;
    }

    return ""Log"".equals(identifierTree.name()) ||
      ""Logger"".equals(identifierTree.name());
  }

}
"
S1313,SECURITY_HOTSPOT,Using hardcoded IP addresses is security-sensitive,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1313"")
public class HardcodedIpCheck extends BaseTreeVisitor implements JavaFileScanner {
  private static final String PROTOCOL_URL = ""([^\\d.]*/)"";
  private static final String PORT_URL = ""(:\\d{1,5})?"";
  private static final String PATH_URL = ""((?![\\d.]))(/.*)?"";
  private static final String END_URL = PORT_URL + PATH_URL;

  private static final String IP_V4_ALONE = ""(?<ipv4>(?:\\d{1,3}\\.){3}\\d{1,3})"";
  private static final String IP_V4_MAPPED_IP_V6 = ""(::ffff:0:|::ffff:|0:0:0:0:0:ffff:0:|0:0:0:0:0:0:ffff:)"" + IP_V4_ALONE;
  private static final String IP_V4_URL = (PROTOCOL_URL + ""?"") + IP_V4_ALONE + END_URL;

  private static final List<Pattern> IP_V4_REGEX_LIST = Arrays.asList(
    Pattern.compile(IP_V4_ALONE),
    Pattern.compile(IP_V4_URL),
    Pattern.compile(IP_V4_MAPPED_IP_V6));


  private static final String IP_V6_WITH_FIRST_PART = ""(\\p{XDigit}{1,4}::?){1,7}\\p{XDigit}{0,4}"";
  private static final String IP_V6_WITHOUT_FIRST_PART = ""::((\\p{XDigit}{1,4}:){0,6}\\p{XDigit}{1,4})?"";
  public static final String IP_V6_ALONE = (""(?<ip>"" + IP_V6_WITH_FIRST_PART + ""|"" + IP_V6_WITHOUT_FIRST_PART + "")"");
  private static final String IP_V6_BRACKET = ""\\["" + IP_V6_ALONE + ""\\]"";
  private static final String IP_V6_URL = PROTOCOL_URL + IP_V6_BRACKET + END_URL;

  private static final List<Pattern> IP_V6_REGEX_LIST = Arrays.asList(
    Pattern.compile(IP_V6_ALONE),
    Pattern.compile(IP_V6_BRACKET),
    Pattern.compile(IP_V6_URL));

  private static final Pattern IP_V6_LOOPBACK = Pattern.compile(""[0:]++0*+1"");
  private static final Pattern IP_V6_NON_ROUTABLE = Pattern.compile(""[0:]++"");

  private static final String MESSAGE = ""Make sure using this hardcoded IP address is safe here."";

  private JavaFileScannerContext context;

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitLiteral(LiteralTree tree) {
    if (tree.is(Tree.Kind.STRING_LITERAL)) {
      String value = LiteralUtils.trimQuotes(tree.value());
      extractIPV4(value).map(Optional::of).orElseGet(() -> extractIPV6(value))
        .filter(ip -> !isLoopbackAddress(ip) && !isNonRoutableAddress(ip) && !isBroadcastAddress(ip) && !isDocumentationRange(ip))
        .ifPresent(ip -> context.reportIssue(this, tree, MESSAGE));
    }
  }

  private static boolean isDocumentationRange(String ip) {
    return ip.startsWith(""192.0.2."") || ip.startsWith(""198.51.100."") || ip.startsWith(""203.0.113."") || ip.startsWith(""2001:db8:"");
  }

  private static boolean isLoopbackAddress(String ip) {
    return ip.startsWith(""127."") || IP_V6_LOOPBACK.matcher(ip).matches();
  }

  private static boolean isNonRoutableAddress(String ip) {
    return ""0.0.0.0"".equals(ip) || IP_V6_NON_ROUTABLE.matcher(ip).matches();
  }

  private static boolean isBroadcastAddress(String ip) {
    return ""255.255.255.255"".equals(ip);
  }

  private static Optional<String> extractIPV4(String value) {
    return IP_V4_REGEX_LIST.stream()
      .map(pattern -> pattern.matcher(value))
      .filter(Matcher::matches)
      .map(match -> match.group(""ipv4""))
      .filter(HardcodedIpCheck::isValidIPV4Parts)
      .filter(ip -> !looksLikeAsn1ObjectIdentifier(ip))
      .findFirst();
  }

  private static boolean looksLikeAsn1ObjectIdentifier(String ip) {
    return ip.startsWith(""2.5."");
  }

  private static boolean isValidIPV4Parts(String ip) {
    return Arrays.stream(ip.split(""\\.""))
      .mapToInt(Integer::parseInt)
      .allMatch(i -> i < 255);
  }

  private static Optional<String> extractIPV6(String value) {
    return IP_V6_REGEX_LIST.stream()
      .map(pattern -> pattern.matcher(value))
      .filter(Matcher::matches)
      .map(match -> match.group(""ip""))
      .filter(HardcodedIpCheck::isValidIPV6PartCount)
      .findFirst();
  }

  private static boolean isValidIPV6PartCount(String ip) {
    int partCount = ip.split(""::?"").length;
    int compressionSeparatorCount = StringUtils.countMatches(ip, ""::"");
    boolean validUncompressed = compressionSeparatorCount == 0 && partCount == 8;
    boolean validCompressed = compressionSeparatorCount == 1 && partCount <= 7;
    return validUncompressed || validCompressed;
  }

}
"
S1314,CODE_SMELL,Octal values should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1314"")
public class OctalValuesCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitLiteral(LiteralTree tree) {
    if (tree.is(Tree.Kind.INT_LITERAL) && isOctal(tree.value())) {
      context.reportIssue(this, tree, ""Use decimal values instead of octal ones."");
    }
  }

  private static boolean isOctal(String value) {
    return value.charAt(0) == '0'  && !""0"".equals(value) && !isHexadecimal(value) && !isBinary(value);
  }

  private static boolean isHexadecimal(String value) {
    return value.startsWith(""0x"") || value.startsWith(""0X"");
  }

  private static boolean isBinary(String value) {
    return value.startsWith(""0b"") || value.startsWith(""0B"");
  }

}
"
S1315,CODE_SMELL,"Track uses of ""CHECKSTYLE:OFF"" suppression comments","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1315"")
public class NoCheckstyleTagPresenceCheck extends IssuableSubscriptionVisitor {

  private static final String PATTERN = ""CHECKSTYLE:OFF"";
  private static final String MESSAGE = ""Remove usage of this \""CHECKSTYLE:OFF\"" suppression comment filter."";

  private final CommentContainsPatternChecker checker = new CommentContainsPatternChecker(this, PATTERN, MESSAGE);

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRIVIA);
  }

  @Override
  public void visitTrivia(SyntaxTrivia syntaxTrivia) {
    checker.checkTrivia(syntaxTrivia);
  }
}
"
S1317,BUG,"""StringBuilder"" and ""StringBuffer"" should not be instantiated with a character ","package org.sonar.java.checks;

import java.util.Set;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1317"")
public class StringBufferAndBuilderWithCharCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;
  private static final Set<String> TARGETED_CLASS = SetUtils.immutableSetOf(""StringBuilder"", ""StringBuffer"");

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitNewClass(NewClassTree tree) {
    if (TARGETED_CLASS.contains(getClassName(tree)) && tree.arguments().size() == 1) {
      ExpressionTree argument = tree.arguments().get(0);

      if (argument.is(Tree.Kind.CHAR_LITERAL)) {
        String character = ((LiteralTree) argument).value();
        context.reportIssue(this, argument, ""Replace the constructor character parameter "" + character + "" with string parameter "" + character.replace(""'"", ""\"""") + ""."");
      }
    }
  }

  private static String getClassName(NewClassTree newClasstree) {
    if (newClasstree.identifier().is(Tree.Kind.MEMBER_SELECT)) {
      return ((MemberSelectExpressionTree) newClasstree.identifier()).identifier().name();
    } else if (newClasstree.identifier().is(Tree.Kind.IDENTIFIER)) {
      return ((IdentifierTree) newClasstree.identifier()).name();
    }
    return null;
  }

}
"
S1319,CODE_SMELL,"Declarations should use Java collection interfaces such as ""List"" rather than specific implementation classes such as ""LinkedList""","package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonarsource.analyzer.commons.collections.SetUtils;

@Rule(key = ""S1319"")
public class CollectionImplementationReferencedCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String LIST = ""java.util.List"";
  private static final String DEQUE = ""java.util.Deque"";
  private static final String QUEUE = ""java.util.Queue"";
  private static final String SET = ""java.util.Set"";
  private static final String SORTED_SET = ""java.util.SortedSet"";
  private static final String MAP = ""java.util.Map"";
  private static final String CONCURRENT_MAP = ""java.util.concurrent.ConcurrentMap"";
  private static final String SORTED_MAP = ""java.util.SortedMap"";

  private static final Map<String, String> SUGGESTED_INTERFACE_BY_COLLECTION_CLASS = MapBuilder.<String, String>newMap()
    .put(""java.util.ArrayDeque"", DEQUE)
    .put(""java.util.concurrent.ConcurrentLinkedDeque"", DEQUE)

    .put(""java.util.AbstractList"", LIST)
    .put(""java.util.AbstractSequentialList"", LIST)
    .put(""java.util.ArrayList"", LIST)
    .put(""java.util.LinkedList"", LIST)
    .put(""java.util.concurrent.CopyOnWriteArrayList"", LIST)

    .put(""java.util.AbstractMap"", MAP)
    .put(""java.util.EnumMap"", MAP)
    .put(""java.util.HashMap"", MAP)
    .put(""java.util.Hashtable"", MAP)
    .put(""java.util.IdentityHashMap"", MAP)
    .put(""java.util.LinkedHashMap"", MAP)
    .put(""java.util.WeakHashMap"", MAP)

    .put(""java.util.concurrent.ConcurrentHashMap"", CONCURRENT_MAP)
    .put(""java.util.concurrent.ConcurrentSkipListMap"", CONCURRENT_MAP)

    .put(""java.util.AbstractQueue"", QUEUE)
    .put(""java.util.concurrent.ConcurrentLinkedQueue"", QUEUE)
    .put(""java.util.concurrent.SynchronousQueue"", QUEUE)

    .put(""java.util.AbstractSet"", SET)
    .put(""java.util.concurrent.CopyOnWriteArraySet"", SET)
    .put(""java.util.EnumSet"", SET)
    .put(""java.util.HashSet"", SET)
    .put(""java.util.LinkedHashSet"", SET)

    .put(""java.util.TreeMap"", SORTED_MAP)

    .put(""java.util.TreeSet"", SORTED_SET)
    .build();

  private static final Set<String> COLLECTION_METHODS = Set.of(
    ""add"",
    ""addAll"",
    ""clear"",
    ""contains"",
    ""containsAll"",
    ""equals"",
    ""forEach"",
    ""hashCode"",
    ""isEmpty"",
    ""iterator"",
    ""parallelStream"",
    ""remove"",
    ""removeAll"",
    ""removeIf"",
    ""retainAll"",
    ""size"",
    ""spliterator"",
    ""stream"",
    ""toArray""
  );

  @SuppressWarnings(""squid:S1192"")
  private static final Set<String> LIST_METHODS = SetUtils.concat(COLLECTION_METHODS, Set.of(
    ""copyOf"",
    ""get"",
    ""indexOf"",
    ""lastIndexOf"",
    ""listIterator"",
    ""replaceAll"",
    ""set"",
    ""sort"",
    ""subList""
  ));

  private static final Set<String> QUEUE_METHODS = SetUtils.concat(COLLECTION_METHODS, Set.of(
    ""element"",
    ""offer"",
    ""peek"",
    ""poll""
  ));

  private static final Set<String> DEQUE_METHODS = SetUtils.concat(QUEUE_METHODS, Set.of(
    ""addFirst"",
    ""addLast"",
    ""descendingIterator"",
    ""getFirst"",
    ""getLast"",
    ""offerFirst"",
    ""offerLast"",
    ""peekFirst"",
    ""peekLast"",
    ""pollFirst"",
    ""pollLast"",
    ""pop"",
    ""push"",
    ""removeFirst"",
    ""removeFirstOccurrence"",
    ""removeLast"",
    ""removeLastOccurrence""
  ));

  private static final Set<String> SET_METHODS = SetUtils.concat(COLLECTION_METHODS, Set.of(
    ""copyOf""
  ));

  private static final Set<String> SORTED_SET_METHODS = SetUtils.concat(SET_METHODS, Set.of(
    ""comparator"",
    ""first"",
    ""headSet"",
    ""last"",
    ""subSet"",
    ""tailSet""
  ));

  private static final Set<String> MAP_METHODS = Set.of(
    ""clear"",
    ""compute"",
    ""computeIfAbsent"",
    ""computeIfPresent"",
    ""containsKey"",
    ""containsValue"",
    ""copyOf"",
    ""entry"",
    ""entrySet"",
    ""equals"",
    ""forEach"",
    ""get"",
    ""getOrDefault"",
    ""hashCode"",
    ""isEmpty"",
    ""keySet"",
    ""of"",
    ""ofEntries"",
    ""put"",
    ""putAll"",
    ""putIfAbsent"",
    ""remove"",
    ""replace"",
    ""replaceAll"",
    ""size"",
    ""values""
  );

  private static final Set<String> CONCURRENT_MAP_METHODS = SetUtils.concat(MAP_METHODS, Set.of(
    ""merge""
  ));

  private static final Set<String> SORTED_MAP_METHODS = SetUtils.concat(MAP_METHODS, Set.of(
    ""comparator"",
    ""firstKey"",
    ""headMap"",
    ""lastKey"",
    ""subMap"",
    ""tailMap""
  ));

  private static final Map<String, Set<String>> METHODS_BY_INTERFACE = Map.of(
    LIST, LIST_METHODS,
    QUEUE, QUEUE_METHODS,
    DEQUE, DEQUE_METHODS,
    SET, SET_METHODS,
    SORTED_SET, SORTED_SET_METHODS,
    MAP, MAP_METHODS,
    CONCURRENT_MAP, CONCURRENT_MAP_METHODS,
    SORTED_MAP, SORTED_MAP_METHODS
  );

  private JavaFileScannerContext context;
  private QuickFixHelper.ImportSupplier importSupplier;

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    this.context = context;
    this.importSupplier = null;
    scan(context.getTree());
  }

  @Override
  public void visitVariable(VariableTree tree) {
    super.visitVariable(tree);
    if (isPublic(tree.modifiers())) {
      checkIfAllowed(tree.type(), String.format(""The type of \""%s\"""", tree.simpleName()));
    }
  }

  @Override
  public void visitMethod(MethodTree tree) {
    super.visitMethod(tree);
    boolean isNotPublic = !isPublic(tree.modifiers());
    boolean isOverridingMethod = !Boolean.FALSE.equals(tree.isOverriding());
    if (isNotPublic || isOverridingMethod) {
      return;
    }

    checkIfAllowed(tree.returnType(), ""The return type of this method"");
    List<VariableTree> candidateParameters = tree.parameters().stream()
      .filter(it -> getSuggestedInterface(it.type()) != null)
      .toList();
    if (candidateParameters.isEmpty()) {
      return;
    }

    var reportParameters = candidateParameters.stream();
    var block = tree.block();
    if (block != null) {
      var visitor = new MethodBodyVisitor(candidateParameters);
      block.accept(visitor);
      reportParameters = reportParameters.filter(it -> !visitor.excludedParameters.contains(it));
    }
    reportParameters.forEach(it -> report(it.type(), String.format(""The type of \""%s\"""", it.simpleName())));
  }

  private void checkIfAllowed(@Nullable TypeTree tree, String messagePrefix) {
    if (getSuggestedInterface(tree) != null) {
      report(tree, messagePrefix);
    }
  }

  @Nullable
  private static String getSuggestedInterface(@Nullable TypeTree tree) {
    if (tree == null) {
      return null;
    }
    String className = tree.symbolType().erasure().fullyQualifiedName();
    return SUGGESTED_INTERFACE_BY_COLLECTION_CLASS.get(className);
  }

  private void report(TypeTree tree, String messagePrefix) {
    TypeTree reportTree;
    if (tree.is(Tree.Kind.PARAMETERIZED_TYPE)) {
      reportTree = ((ParameterizedTypeTree) tree).type();
    } else {
      reportTree = tree;
    }

    String className = tree.symbolType().erasure().fullyQualifiedName();
    String targetCollection = SUGGESTED_INTERFACE_BY_COLLECTION_CLASS.get(className);
    String usedCollectionSimpleName = toSimpleName(className);
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(reportTree)
      .withMessage(""%s should be an interface such as \""%s\"" rather than the implementation \""%s\""."",
        messagePrefix,
        toSimpleName(targetCollection),
        usedCollectionSimpleName)
      .withQuickFix(() -> quickFix(reportTree, usedCollectionSimpleName, targetCollection))
      .report();
  }

  private JavaQuickFix quickFix(TypeTree typeTree, String usedCollection, String targetedCollection) {
    String targetedCollectionSimpleName = toSimpleName(targetedCollection);
    List<JavaTextEdit> edits = new ArrayList<>();
    edits.add(JavaTextEdit.replaceTree(typeTree, targetedCollectionSimpleName));

    getImportSupplier()
      .newImportEdit(targetedCollection)
      .ifPresent(edits::add);

    return JavaQuickFix.newQuickFix(""Replace \""%s\"" by \""%s\"""", usedCollection, targetedCollectionSimpleName)
      .addTextEdits(edits)
      .build();
  }

  private QuickFixHelper.ImportSupplier getImportSupplier() {
    if (importSupplier == null) {
      importSupplier = QuickFixHelper.newImportSupplier(context);
    }
    return importSupplier;
  }

  private static String toSimpleName(String fullyQualifiedName) {
    return fullyQualifiedName.substring(fullyQualifiedName.lastIndexOf('.') + 1);
  }

  private static boolean isPublic(ModifiersTree modifiers) {
    return ModifiersUtils.hasModifier(modifiers, Modifier.PUBLIC);
  }

  private static class MethodBodyVisitor extends BaseTreeVisitor {

    private final Map<String, VariableTree> candidateParametersByName = new HashMap<>();

    public final Set<VariableTree> excludedParameters = new HashSet<>();

    public MethodBodyVisitor(List<VariableTree> candidateParameters) {
      for (var variableTree : candidateParameters) {
        candidateParametersByName.put(variableTree.simpleName().name(), variableTree);
      }
    }

    @Override
    public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
      super.visitMemberSelectExpression(tree);
      if (!(tree.expression() instanceof IdentifierTree)) {
        return;
      }

      var variableName = ((IdentifierTree) tree.expression()).name();
      var variableTree = candidateParametersByName.get(variableName);
      if (variableTree == null) {
        return;
      }

      var memberName = tree.identifier().name();
      var interfaceName = getSuggestedInterface(variableTree.type());
      if (!METHODS_BY_INTERFACE.get(interfaceName).contains(memberName)) {
        excludedParameters.add(variableTree);
      }
    }
  }
}
"
S134,CODE_SMELL,"Control flow statements ""if"", ""for"", ""while"", ""switch"" and ""try"" should not be nested too deeply","package org.sonar.java.checks;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.DoWhileStatementTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SwitchExpressionTree;
import org.sonar.plugins.java.api.tree.SwitchStatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

@Rule(key = ""S134"")
public class NestedIfStatementsCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final int DEFAULT_MAX = 3;

  @RuleProperty(
    description = ""Maximum allowed control flow statement nesting depth."",
    defaultValue = """" + DEFAULT_MAX)
  public int max = DEFAULT_MAX;

  private JavaFileScannerContext context;
  private Deque<Tree> nestingLevel;

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    this.context = context;
    this.nestingLevel = new ArrayDeque<>();
    scan(context.getTree());
  }

  @Override
  public void visitIfStatement(IfStatementTree tree) {
    SyntaxToken ifKeyword = tree.ifKeyword();
    checkNesting(ifKeyword);
    nestingLevel.push(ifKeyword);
    visit(tree);
    nestingLevel.pop();
  }

  @Override
  public void visitForStatement(ForStatementTree tree) {
    SyntaxToken forKeyword = tree.forKeyword();
    checkNesting(forKeyword);
    nestingLevel.push(forKeyword);
    super.visitForStatement(tree);
    nestingLevel.pop();
  }

  @Override
  public void visitForEachStatement(ForEachStatement tree) {
    SyntaxToken forKeyword = tree.forKeyword();
    checkNesting(forKeyword);
    nestingLevel.push(forKeyword);
    super.visitForEachStatement(tree);
    nestingLevel.pop();
  }

  @Override
  public void visitWhileStatement(WhileStatementTree tree) {
    SyntaxToken whileKeyword = tree.whileKeyword();
    checkNesting(whileKeyword);
    nestingLevel.push(whileKeyword);
    super.visitWhileStatement(tree);
    nestingLevel.pop();
  }

  @Override
  public void visitDoWhileStatement(DoWhileStatementTree tree) {
    SyntaxToken doKeyword = tree.doKeyword();
    checkNesting(doKeyword);
    nestingLevel.push(doKeyword);
    super.visitDoWhileStatement(tree);
    nestingLevel.pop();
  }

  @Override
  public void visitSwitchStatement(SwitchStatementTree tree) {
    SyntaxToken switchKeyword = tree.switchKeyword();
    checkNesting(switchKeyword);
    nestingLevel.push(switchKeyword);
    super.visitSwitchStatement(tree);
    nestingLevel.pop();
  }

  @Override
  public void visitSwitchExpression(SwitchExpressionTree tree) {
    SyntaxToken switchKeyword = tree.switchKeyword();
    checkNesting(switchKeyword);
    nestingLevel.push(switchKeyword);
    super.visitSwitchExpression(tree);
    nestingLevel.pop();
  }

  @Override
  public void visitTryStatement(TryStatementTree tree) {
    SyntaxToken tryKeyword = tree.tryKeyword();
    checkNesting(tryKeyword);
    nestingLevel.push(tryKeyword);
    scan(tree.block());
    nestingLevel.pop();
    scan(tree.resourceList());
    scan(tree.catches());
    scan(tree.finallyBlock());
  }

  private void checkNesting(Tree tree) {
    int size = nestingLevel.size();
    if (size == max) {
      List<JavaFileScannerContext.Location> secondary = new ArrayList<>(size);
      for (Tree element : nestingLevel) {
        secondary.add(new JavaFileScannerContext.Location(""Nesting + 1"", element));
      }
      context.reportIssue(this, tree, ""Refactor this code to not nest more than "" + max + "" if/for/while/switch/try statements."", secondary, null);
    }
  }

  private void visit(IfStatementTree tree) {
    scan(tree.condition());
    scan(tree.thenStatement());

    StatementTree elseStatementTree = tree.elseStatement();
    if (elseStatementTree != null && elseStatementTree.is(Tree.Kind.IF_STATEMENT)) {
      visit((IfStatementTree) elseStatementTree);
    } else {
      scan(elseStatementTree);
    }
  }

}
"
S135,CODE_SMELL,"Loops should not contain more than a single ""break"" or ""continue"" statement","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BreakStatementTree;
import org.sonar.plugins.java.api.tree.ContinueStatementTree;
import org.sonar.plugins.java.api.tree.DoWhileStatementTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.SwitchStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

@Rule(key = ""S135"")
public class SeveralBreakOrContinuePerLoopCheck extends BaseTreeVisitor implements JavaFileScanner {

  private final Deque<List<Tree>> breakAndContinueCounter = new ArrayDeque<>();
  private final Deque<Boolean> currentScopeIsSwitch = new ArrayDeque<>();
  private int loopCount;

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    loopCount = 0;
    scan(context.getTree());
  }

  @Override
  public void visitForStatement(ForStatementTree tree) {
    enterLoop();
    super.visitForStatement(tree);
    leaveLoop(tree.forKeyword());
  }

  @Override
  public void visitForEachStatement(ForEachStatement tree) {
    enterLoop();
    super.visitForEachStatement(tree);
    leaveLoop(tree.forKeyword());
  }

  @Override
  public void visitWhileStatement(WhileStatementTree tree) {
    enterLoop();
    super.visitWhileStatement(tree);
    leaveLoop(tree.whileKeyword());
  }

  @Override
  public void visitDoWhileStatement(DoWhileStatementTree tree) {
    enterLoop();
    super.visitDoWhileStatement(tree);
    leaveLoop(tree.doKeyword());
  }

  @Override
  public void visitBreakStatement(BreakStatementTree tree) {
    if (isInLoop() && !isInSwitch()) {
      incrementBreakCounter(tree);
    }
    super.visitBreakStatement(tree);
  }

  @Override
  public void visitContinueStatement(ContinueStatementTree tree) {
    if (isInLoop()) {
      incrementBreakCounter(tree);
    }
    super.visitContinueStatement(tree);
  }

  private boolean isInLoop() {
    return loopCount > 0;
  }

  private boolean isInSwitch() {
    return currentScopeIsSwitch.peek();
  }

  private void incrementBreakCounter(Tree tree) {
    if (!breakAndContinueCounter.isEmpty()) {
      breakAndContinueCounter.peek().add(tree);
    }
  }

  @Override
  public void visitSwitchStatement(SwitchStatementTree tree) {
    currentScopeIsSwitch.push(true);
    super.visitSwitchStatement(tree);
    currentScopeIsSwitch.pop();
  }

  private void enterLoop() {
    loopCount++;
    breakAndContinueCounter.push(new ArrayList<>());
    currentScopeIsSwitch.push(false);
  }

  private void leaveLoop(Tree primaryLocationTree) {
    List<Tree> breakAndContinues = new ArrayList<>();
    if (!breakAndContinueCounter.isEmpty()) {
      breakAndContinues = breakAndContinueCounter.pop();
    }
    if (breakAndContinues.size() > 1) {
      int effortToFix = breakAndContinues.size() - 1;

      List<JavaFileScannerContext.Location> secondaryLocations = breakAndContinues.stream()
          .map(t -> new JavaFileScannerContext.Location(String.format(""\""%s\"" statement."", t.is(Tree.Kind.BREAK_STATEMENT) ? ""break"" : ""continue""), t))
        .toList();

      context.reportIssue(this, primaryLocationTree,
        ""Reduce the total number of break and continue statements in this loop to use at most one."",
        secondaryLocations,
        effortToFix);
    }
    loopCount--;
    currentScopeIsSwitch.pop();
  }
}
"
S138,CODE_SMELL,Methods should not have too many lines,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.metrics.MetricsScannerContext;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S138"")
public class MethodTooBigCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_MAX = 75;

  @RuleProperty(description = ""Maximum authorized lines in a method"", defaultValue = """" + DEFAULT_MAX)
  public int max = DEFAULT_MAX;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    BlockTree block = methodTree.block();
    if (block != null) {
      var metricsComputer = ((MetricsScannerContext)context).getMetricsComputer();
      int lines = metricsComputer.getLinesOfCode(block);
      if (lines > max) {
        reportIssue(methodTree.simpleName(),
          ""This method has "" + lines + "" lines, which is greater than the "" + max + "" lines authorized. Split it into smaller methods."");
      }
    }
  }
}
"
S139,CODE_SMELL,Comments should not be located at the end of lines of code,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""TrailingCommentCheck"", repositoryKey = ""squid"")
@Rule(key = ""S139"")
public class TrailingCommentCheck extends IssuableSubscriptionVisitor {

  private static final String DEFAULT_LEGAL_COMMENT_PATTERN = ""^\\s*+[^\\s]++$"";
  private static final List<String> EXCLUDED_PATTERNS = Arrays.asList(""NOSONAR"", ""NOPMD"", ""CHECKSTYLE:"", ""$NON-NLS"");

  @RuleProperty(
    key = ""legalTrailingCommentPattern"",
    description = ""Description Pattern for text of trailing comments that are allowed. By default, comments containing only one word."",
    defaultValue = DEFAULT_LEGAL_COMMENT_PATTERN)
  public String legalCommentPattern = DEFAULT_LEGAL_COMMENT_PATTERN;

  private Pattern pattern;
  private boolean ignoreMultipleOccurences;
  private Set<SyntaxToken> visitedTokens;
  private int previousTokenLine;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.TOKEN,
      Tree.Kind.VARIABLE);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    previousTokenLine = -1;
    if (pattern == null) {
      pattern = Pattern.compile(legalCommentPattern);
    }
    visitedTokens = new HashSet<>();
    super.setContext(context);
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    visitedTokens.clear();
  }

  @Override
  public void visitNode(Tree tree) {
    ignoreMultipleOccurences = true;
  }

  @Override
  public void leaveNode(Tree tree) {
    ignoreMultipleOccurences = false;
  }

  @Override
  public void visitToken(SyntaxToken syntaxToken) {
    if (ignoreMultipleOccurences && !visitedTokens.add(syntaxToken)) {
      return;
    }
    int tokenLine = LineUtils.startLine(syntaxToken);
    if (tokenLine != previousTokenLine) {
      syntaxToken.trivias().stream()
        .filter(trivia -> LineUtils.startLine(trivia) == previousTokenLine)
        .map(SyntaxTrivia::comment)
        .map(comment -> comment.startsWith(""//"") ? comment.substring(2) : comment.substring(2, comment.length() - 2))
        .map(String::trim)
        .filter(comment -> !pattern.matcher(comment).matches() && !containsExcludedPattern(comment))
        .forEach(comment -> addIssue(previousTokenLine, ""Move this trailing comment on the previous empty line.""));
    }

    previousTokenLine = tokenLine;
  }

  private static boolean containsExcludedPattern(String comment) {
    for (String excludePattern : EXCLUDED_PATTERNS) {
      if (StringUtils.containsIgnoreCase(comment, excludePattern)) {
        return true;
      }
    }
    return false;
  }
}
"
S1444,CODE_SMELL,"""public static"" fields should be constant","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1444"")
public class PublicStaticFieldShouldBeFinalCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    if (tree.is(Tree.Kind.CLASS) || tree.is(Tree.Kind.ENUM)) {
      for (Tree member : tree.members()) {
        if (member.is(Tree.Kind.VARIABLE) && isPublicStaticNotFinal((VariableTree) member)) {
          context.reportIssue(this, ((VariableTree) member).simpleName(), ""Make this \""public static "" + ((VariableTree) member).simpleName() + ""\"" field final"");
        }
      }
    }
    super.visitClass(tree);
  }

  private static boolean isPublicStaticNotFinal(VariableTree tree) {
    boolean isPublic = false;
    boolean isStatic = false;
    boolean isFinal = false;

    for (ModifierKeywordTree modifierKeywordTree : tree.modifiers().modifiers()) {
      Modifier modifier = modifierKeywordTree.modifier();
      if (modifier == Modifier.PUBLIC) {
        isPublic = true;
      } else if (modifier == Modifier.STATIC) {
        isStatic = true;
      } else if (modifier == Modifier.FINAL) {
        isFinal = true;
      }
    }
    return isPublic && isStatic && !isFinal;
  }
}
"
S1448,CODE_SMELL,Classes should not have too many methods,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

@Rule(key = ""S1448"")
public class TooManyMethodsCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_MAXIMUM = 35;

  @RuleProperty(
    key = ""maximumMethodThreshold"",
    description = ""The maximum number of methods authorized in a class."",
    defaultValue = """" + DEFAULT_MAXIMUM
  )
  public int maximumMethodThreshold = DEFAULT_MAXIMUM;

  @RuleProperty(
    key = ""countNonpublicMethods"",
    description = ""Whether or not to include non-public methods in the count."",
    defaultValue = ""true""
  )
  public boolean countNonPublic = true;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.ENUM, Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE, Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    List<MethodTree> methods = classTree.members()
      .stream()
      .filter(member -> member.is(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR))
      .map(MethodTree.class::cast)
      .filter(method -> countNonPublic || method.symbol().isPublic())
      .toList();

    if(shouldNotReportIssue(classTree, methods)) {
      return;
    }

    List<JavaFileScannerContext.Location> secondary = methods.stream()
      .map(method -> new JavaFileScannerContext.Location(""Method + 1"", method.simpleName()))
      .toList();

    TypeTree reportTree = ExpressionsHelper.reportOnClassTree(classTree);
    String classType;
    String newTypes;
    if (isAnonnymousClass(classTree)) {
      classType = ""Anonymous class"";
      newTypes = ""classes"";
    } else {
      classType = classTree.declarationKeyword().text();
      newTypes = classType + (tree.is(Tree.Kind.CLASS) ? ""es"" : ""s"");
    }
    reportIssue(
      reportTree,
      String.format(""%s \""%s\"" has %d%s methods, which is greater than the %d authorized. Split it into smaller %s."",
        classType, reportTree.symbolType().name(), methods.size(), countNonPublic ? """" : "" public"", maximumMethodThreshold, newTypes),
      secondary,
      null);
  }

  private boolean shouldNotReportIssue(ClassTree classTree, List<MethodTree> methods) {
    return methods.size() <= maximumMethodThreshold
      || (isAnonnymousClass(classTree) && methods.stream().allMatch(TooManyMethodsCheck::isOverriding));
  }

  private static boolean isAnonnymousClass(ClassTree classTree) {
    return classTree.simpleName() == null;
  }

  private static boolean isOverriding(MethodTree methodTree) {
    // When it cannot be decided, isOverriding will return null, we consider it as an override
    return !Boolean.FALSE.equals(methodTree.isOverriding());
  }

}
"
S1449,CODE_SMELL,String operations should not rely on the default system locale,"package org.sonar.java.checks;

import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1449"")
public class StringMethodsWithLocaleCheck extends AbstractMethodDetection {

  private static final String STRING = ""java.lang.String"";
  private static final MethodMatchers STRING_FORMAT = MethodMatchers.create().ofTypes(STRING).names(""format"").withAnyParameters().build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofTypes(STRING).names(""toUpperCase"", ""toLowerCase"").addWithoutParametersMatcher().build(),
      STRING_FORMAT
    );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    Tree report = mit.methodSelect();
    if (STRING_FORMAT.matches(mit) && (isLocaleVariant(mit) || !usesLocaleDependentFormatteer(mit.arguments().get(0)))) {
      return;
    }
    if (report.is(Tree.Kind.MEMBER_SELECT)) {
      report = ((MemberSelectExpressionTree) report).identifier();
    }
    reportIssue(report, ""Define the locale to be used in this String operation."");
  }

  private static boolean isLocaleVariant(MethodInvocationTree mit) {
    return mit.methodSymbol().parameterTypes().get(0).is(""java.util.Locale"");
  }

  private static boolean usesLocaleDependentFormatteer(ExpressionTree firstArg) {
    FormatterVisitor visitor = new FormatterVisitor();
    firstArg.accept(visitor);
    return visitor.hasLocaleDependantFormatter;
  }

  private static class FormatterVisitor extends BaseTreeVisitor {

    // source: https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax
    private static final String ARGUMENT_INDEX = ""(\\d+\\$)?"";
    private static final String FLAGS = ""[-,#+ 0(]*"";
    private static final String FLAGS_WITH_FORCED_COMMA = ""([-#+ 0(]*,[-#+ 0(]*)"";
    private static final String WIDTH = ""((?:[1-9]\\d*)?(?:\\.\\d*)?)"";
    private static final String INTEGER_LOCAL_SPECIFIC_FORMAT = FLAGS_WITH_FORCED_COMMA + WIDTH + ""d"";
    private static final String DATE_TIME_FLOATING_POINT_LOCAL_SPECIFIC_FORMAT = FLAGS + WIDTH + ""[eEfgGaAtT]"";

    private static final Pattern LOCALE_DEPENDENT_FORMATTERS = Pattern
      .compile(""%"" + ARGUMENT_INDEX + ""("" + INTEGER_LOCAL_SPECIFIC_FORMAT + ""|"" + DATE_TIME_FLOATING_POINT_LOCAL_SPECIFIC_FORMAT + "")"");

    private boolean hasLocaleDependantFormatter = false;

    @Override
    public void visitLiteral(LiteralTree tree) {
      String value = tree.value().replace(""%%"", """");
      if (tree.is(Tree.Kind.STRING_LITERAL) && LOCALE_DEPENDENT_FORMATTERS.matcher(value).find()) {
        hasLocaleDependantFormatter = true;
      }
      super.visitLiteral(tree);
    }
  }
}
"
S1450,CODE_SMELL,Private fields only used as local variables in methods should become local variables,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.cfg.CFG;
import org.sonar.java.cfg.LiveVariables;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Symbol.TypeSymbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.checks.helpers.QuickFixHelper.contentForRange;@Rule(key = ""S1450"")
public class PrivateFieldUsedLocallyCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Remove the \""%s\"" field and declare it as a local variable in the relevant methods."";
  private static final String QUICK_FIX_MESSAGE = ""Move this field to the only method where it is used"";

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    TypeSymbol classSymbol = ((ClassTree) tree).symbol();
    Set<Symbol> fieldsReadOnAnotherInstance = FieldsReadOnAnotherInstanceVisitor.getFrom(tree);

    classSymbol.memberSymbols().stream()
      .filter(PrivateFieldUsedLocallyCheck::isPrivateField)
      .filter(s -> !isAConstant(s))
      .filter(s -> !hasAnnotation(s))
      .filter(s -> !s.usages().isEmpty())
      .filter(s -> !fieldsReadOnAnotherInstance.contains(s))
      .forEach(s -> checkPrivateField(s, classSymbol));
  }

  private static boolean isAConstant(Symbol s) {
    return s.isFinal() && s.isStatic();
  }

  private static boolean hasAnnotation(Symbol s) {
    return !s.metadata().annotations().isEmpty();
  }

  private void checkPrivateField(Symbol privateFieldSymbol, TypeSymbol classSymbol) {
    MethodTree methodWhereUsed = usedInOneMethodOnly(privateFieldSymbol, classSymbol);

    if (methodWhereUsed != null && !isLiveInMethodEntry(privateFieldSymbol, methodWhereUsed)) {
      VariableTree declaration = (VariableTree) privateFieldSymbol.declaration();
      IdentifierTree declarationIdentifier = declaration.simpleName();
      String message = String.format(MESSAGE, privateFieldSymbol.name());
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(declarationIdentifier)
        .withMessage(message)
        .withQuickFixes(() -> computeQuickFix((Symbol.VariableSymbol) privateFieldSymbol, declaration, methodWhereUsed))
        .report();
    }
  }

  private List<JavaQuickFix> computeQuickFix(Symbol.VariableSymbol symbol, VariableTree declaration, MethodTree methodWhereUsed) {
    if (wouldRelocationClashWithLocalVariables(symbol, methodWhereUsed)) {
      return Collections.emptyList();
    }
    BlockTree block = methodWhereUsed.block();
    SyntaxToken openingBrace = block.openBraceToken();

    String padding = generateLeftPadding(block);
    String declarationMinusModifiers = contentForRange(declaration.type().firstToken(), declaration.endToken(), context);
    String newDeclaration = ""\n"" + padding + declarationMinusModifiers;

    return List.of(
      JavaQuickFix.newQuickFix(QUICK_FIX_MESSAGE)
        .addTextEdits(editUsagesWithThis(symbol))
        .addTextEdit(JavaTextEdit.insertAfterTree(openingBrace, newDeclaration))
        .addTextEdit(JavaTextEdit.removeTree(declaration))
        .build()
    );
  }private static boolean wouldRelocationClashWithLocalVariables(Symbol.VariableSymbol symbol, MethodTree method) {
    LocalVariableCollector collector = new LocalVariableCollector();
    method.accept(collector);
    if (collector.variables.isEmpty()) {
      return false;
    }
    return collector.variables
      .stream()
      .anyMatch(variable -> variable.symbol().name().equals(symbol.name()));
  }

  private static String generateLeftPadding(BlockTree block) {
    int spacesOnTheLeft = Math.max(0, block.body().get(0).firstToken().range().start().column() - 1);
    return "" "".repeat(spacesOnTheLeft);
  }private static List<JavaTextEdit> editUsagesWithThis(Symbol symbol) {
    return symbol.usages().stream()
      .map(Tree::parent)
      .filter(parent -> parent.is(Kind.MEMBER_SELECT))
      .map(MemberSelectExpressionTree.class::cast)
      .filter(memberSelect -> ExpressionUtils.isThis(memberSelect.expression()))
      .map(memberSelect -> JavaTextEdit.removeBetweenTree(memberSelect.expression(), memberSelect.operatorToken()))
      .toList();
  }

  private static boolean isLiveInMethodEntry(Symbol privateFieldSymbol, MethodTree methodTree) {
    CFG cfg = (CFG) methodTree.cfg();
    LiveVariables liveVariables = LiveVariables.analyzeWithFields(cfg);
    return liveVariables.getIn(cfg.entryBlock()).contains(privateFieldSymbol);
  }

  private static boolean isPrivateField(Symbol memberSymbol) {
    return memberSymbol.isPrivate() && memberSymbol.isVariableSymbol();
  }@CheckForNull
  private static MethodTree usedInOneMethodOnly(Symbol privateFieldSymbol, TypeSymbol classSymbol) {
    MethodTree method = null;

    for (IdentifierTree usageIdentifier : privateFieldSymbol.usages()) {
      MethodTree enclosingMethod = (MethodTree) ExpressionUtils.getEnclosingTree(usageIdentifier, Kind.METHOD);

      if (enclosingMethod == null
        || !enclosingMethod.symbol().owner().equals(classSymbol)
        || (method != null && !method.equals(enclosingMethod))) {
        return null;
      } else {
        method = enclosingMethod;
      }
    }

    return method;
  }

  private static class FieldsReadOnAnotherInstanceVisitor extends BaseTreeVisitor {

    private final Set<Symbol> fieldsReadOnAnotherInstance = new HashSet<>();

    static Set<Symbol> getFrom(Tree classTree) {
      FieldsReadOnAnotherInstanceVisitor fieldsReadOnAnotherInstanceVisitor = new FieldsReadOnAnotherInstanceVisitor();
      fieldsReadOnAnotherInstanceVisitor.scan(classTree);
      return fieldsReadOnAnotherInstanceVisitor.fieldsReadOnAnotherInstance;
    }

    @Override
    public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
      Symbol symbol = tree.identifier().symbol();
      if (isField(symbol)) {
        if (tree.expression().is(Kind.IDENTIFIER)) {
          if (!ExpressionUtils.isThis(tree.expression())) {
            fieldsReadOnAnotherInstance.add(symbol);
          }
        } else {
          fieldsReadOnAnotherInstance.add(symbol);
        }
      }

      super.visitMemberSelectExpression(tree);
    }
  }

  private static class LocalVariableCollector extends BaseTreeVisitor {
    private final Set<VariableTree> variables = new HashSet<>();

    @Override
    public void visitVariable(VariableTree tree) {
      variables.add(tree);
    }
  }

  public static boolean isField(Symbol symbol) {
    return symbol.isVariableSymbol()
      && !symbol.isStatic()
      && !symbol.owner().isMethodSymbol();
  }

}
"
S1451,CODE_SMELL,Track lack of copyright and license headers,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Rule(key = ""S1451"")
public class FileHeaderCheck extends IssuableSubscriptionVisitor {

  private static final String DEFAULT_HEADER_FORMAT = """";
  private static final String MESSAGE = ""Add or update the header of this file."";

  @RuleProperty(
    key = ""headerFormat"",
    description = ""Expected copyright and license header"",
    defaultValue = DEFAULT_HEADER_FORMAT,
    type = ""TEXT"")
  public String headerFormat = DEFAULT_HEADER_FORMAT;

  @RuleProperty(
    key = ""isRegularExpression"",
    description = ""Whether the headerFormat is a regular expression"",
    defaultValue = ""false"")
  public boolean isRegularExpression = false;

  private String[] expectedLines;
  private Pattern searchPattern = null;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.emptyList();
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    super.context = context;
    if (isRegularExpression) {
      if (searchPattern == null) {
        try {
          searchPattern = Pattern.compile(getHeaderFormat(), Pattern.DOTALL);
        } catch (IllegalArgumentException e) {
          throw new IllegalArgumentException(""["" + getClass().getSimpleName() + ""] Unable to compile the regular expression: "" + headerFormat, e);
        }
      }
    } else {
      expectedLines = headerFormat.split(""(?:\r)?\n|\r"");
    }
    visitFile();
  }

  private String getHeaderFormat() {
    String format = headerFormat;
    if(format.charAt(0) != '^') {
      format = ""^"" + format;
    }
    return format;
  }

  private void visitFile() {
    if (isRegularExpression) {
      checkRegularExpression(context.getFileContent());
    } else {
      if (!matches(expectedLines, context.getFileLines())) {
        addIssueOnFile(MESSAGE);
      }
    }
  }

  private void checkRegularExpression(String fileContent) {
    Matcher matcher = searchPattern.matcher(fileContent);
    if (!matcher.find() || matcher.start() != 0) {
      addIssueOnFile(MESSAGE);
    }
  }

  private static boolean matches(String[] expectedLines, List<String> lines) {
    boolean result;

    if (expectedLines.length <= lines.size()) {
      result = true;

      Iterator<String> it = lines.iterator();
      for (int i = 0; i < expectedLines.length; i++) {
        String line = it.next();
        if (!line.equals(expectedLines[i])) {
          result = false;
          break;
        }
      }
    } else {
      result = false;
    }

    return result;
  }

}
"
S1452,CODE_SMELL,Generic wildcard types should not be used in return types,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeArguments;
import org.sonar.plugins.java.api.tree.WildcardTree;

@Rule(key = ""S1452"")
public class WildcardReturnParameterTypeCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (!isPrivate(methodTree) && isNotOverriding(methodTree)) {
      methodTree.returnType().accept(new CheckWildcard());
    }
  }

  private static boolean isPrivate(MethodTree methodTree) {
    return ModifiersUtils.hasModifier(methodTree.modifiers(), Modifier.PRIVATE);
  }

  private static boolean isNotOverriding(MethodTree tree) {
    return Boolean.FALSE.equals(tree.isOverriding());
  }

  private class CheckWildcard extends BaseTreeVisitor {

    @Override
    public void visitParameterizedType(ParameterizedTypeTree tree) {
      Type symbolType = tree.type().symbolType();
      TypeArguments typeArguments = tree.typeArguments();

      if (typeArguments.size() == 3 && symbolType.is(""java.util.stream.Collector"")) {
        // Second type parameter of Collector is ignored as it is an implementation detail
        reportIfWildcard(typeArguments.get(0));
        reportIfWildcard(typeArguments.get(2));
      } else if (!symbolType.is(""java.lang.Class"") && !symbolType.isUnknown()) {
        typeArguments.forEach(this::reportIfWildcard);
      }
      super.visitParameterizedType(tree);
    }

    private void reportIfWildcard(Tree tree) {
      if (tree.is(Tree.Kind.EXTENDS_WILDCARD, Tree.Kind.UNBOUNDED_WILDCARD, Tree.Kind.SUPER_WILDCARD)) {
        reportIssue(((WildcardTree) tree).queryToken(), ""Remove usage of generic wildcard type."");
      }
    }
  }

}
"
S1479,CODE_SMELL,"""switch"" statements should not have too many ""case"" clauses","package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.SwitchTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1479"")
public class SwitchWithTooManyCasesCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_MAXIMUM_CASES = 30;

  @RuleProperty(
    key = ""maximum"",
    description = ""Maximum number of case"",
    defaultValue = """" + DEFAULT_MAXIMUM_CASES)
  public int maximumCases = DEFAULT_MAXIMUM_CASES;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.SWITCH_STATEMENT, Tree.Kind.SWITCH_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    SwitchTree switchTree = (SwitchTree) tree;
    if (isSwitchOverEnum(switchTree)) {
      return;
    }

    List<CaseGroupTree> cases = switchTree.cases();
    int size = cases.size();
    if (size > maximumCases) {
      List<JavaFileScannerContext.Location> secondary = new ArrayList<>();
      for (CaseGroupTree element : cases) {
        secondary.add(new JavaFileScannerContext.Location(""+1"", element.labels().get(0)));
      }
      reportIssue(switchTree.switchKeyword(),
        String.format(""Reduce the number of non-empty switch cases from %d to at most %d."", size, maximumCases),
        secondary, null);
    }
  }

  private static boolean isSwitchOverEnum(SwitchTree switchStatementTree) {
    Type type = switchStatementTree.expression().symbolType();
    return type.symbol().isEnum();
  }
}
"
S1481,CODE_SMELL,Unused local variables should be removed,"package org.sonar.java.checks.unused;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.helpers.UnresolvedIdentifiersVisitor;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.CaseLabelTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ListTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1481"")
public class UnusedLocalVariableCheck extends IssuableSubscriptionVisitor {

  private static final Tree.Kind[] INCREMENT_KINDS = {
    Tree.Kind.POSTFIX_DECREMENT,
    Tree.Kind.POSTFIX_INCREMENT,
    Tree.Kind.PREFIX_DECREMENT,
    Tree.Kind.PREFIX_INCREMENT
  };

  private static final String MESSAGE = ""Remove this unused \""%s\"" local variable."";

  private static final UnresolvedIdentifiersAndSwitchCaseVisitor UNRESOLVED_IDENTIFIERS_AND_SWITCH_CASE_VISITOR =
    new UnresolvedIdentifiersAndSwitchCaseVisitor();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.COMPILATION_UNIT, Tree.Kind.VARIABLE);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      UNRESOLVED_IDENTIFIERS_AND_SWITCH_CASE_VISITOR.check(tree);
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.VARIABLE)) {
      VariableTree variable = (VariableTree) tree;
      String name = variable.simpleName().name();
      boolean unresolved = UNRESOLVED_IDENTIFIERS_AND_SWITCH_CASE_VISITOR.isUnresolved(name);
      if (!unresolved && isProperLocalVariable(variable) && isUnused(variable.symbol())) {
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(variable.simpleName())
          .withMessage(String.format(MESSAGE, name))
          .withQuickFixes(() -> computeQuickFix(variable))
          .report();
      }
    }

  }

  private static boolean isUnused(Symbol symbol) {
    return symbol.usages().stream().noneMatch(UnusedLocalVariableCheck::isRValue);
  }private static boolean isRValue(IdentifierTree tree) {
    Tree parent = skipParenthesesUpwards(tree.parent());
    if (parent instanceof AssignmentExpressionTree assignment) {
      return assignment.variable() != tree;
    }
    // Note that an expression statement can't be a parenthesized expression, so we don't need to skip parentheses here
    return !(parent.is(INCREMENT_KINDS) && parent.parent().is(Tree.Kind.EXPRESSION_STATEMENT));
  }

  private static Tree skipParenthesesUpwards(Tree tree) {
    while (tree.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {
      tree = tree.parent();
    }
    return tree;
  }

  private static boolean isProperLocalVariable(VariableTree variable) {
    Symbol symbol = variable.symbol();
    return symbol.isLocalVariable()
      && !symbol.isParameter()
      && !isDefinedInCatchClause(variable)
      && !isTryResource(variable)
      && !UNRESOLVED_IDENTIFIERS_AND_SWITCH_CASE_VISITOR.isSwitchPatternVariable(variable);
  }

  private static boolean isDefinedInCatchClause(VariableTree variable) {
    return variable.parent().is(Tree.Kind.CATCH);
  }

  private static boolean isTryResource(VariableTree variable) {
    return variable.parent().is(Tree.Kind.LIST) && variable.parent().parent().is(Tree.Kind.TRY_STATEMENT);
  }

  private static List<JavaQuickFix> computeQuickFix(VariableTree variable) {
    return getQuickFixTextSpan(variable).map(textSpan -> Collections.singletonList(
        JavaQuickFix.newQuickFix(""Remove unused local variable"")
          .addTextEdit(JavaTextEdit.removeTextSpan(textSpan))
          .build()
      )
    ).orElseGet(Collections::emptyList);
  }

  private static Optional<AnalyzerMessage.TextSpan> getQuickFixTextSpan(VariableTree variable) {
    if (!variable.symbol().usages().isEmpty()) {
      return Optional.empty();
    }
    Tree parent = variable.parent();
    SyntaxToken lastToken = variable.lastToken();
    if (parent.is(Tree.Kind.BLOCK, Tree.Kind.INITIALIZER, Tree.Kind.STATIC_INITIALIZER)) {
      // If the variable is in the declaration list but is not the last one, we also need to include the following comma
      Optional<VariableTree> followingVariable = QuickFixHelper.nextVariable(variable);
      if (followingVariable.isPresent()) {
        return Optional.of(AnalyzerMessage.textSpanBetween(variable.simpleName(), true, followingVariable.get().simpleName(), false));
      }
      // If the variable is last in the declaration, we need to retrieve the preceding comma
      Optional<SyntaxToken> precedingComma = getPrecedingComma(variable);
      if (precedingComma.isPresent()) {
        AnalyzerMessage.TextSpan value = AnalyzerMessage.textSpanBetween(precedingComma.get(), true, lastToken, false);
        return Optional.of(value);
      }
      return Optional.of(AnalyzerMessage.textSpanBetween(variable.firstToken(), lastToken));
    } else if (parent.is(Tree.Kind.LIST)) {
      ListTree<VariableTree> variables = (ListTree<VariableTree>) parent;
      // If the variable is the only one in the list we can include the entire list
      if (variables.size() == 1) {
        return Optional.of(AnalyzerMessage.textSpanFor(variable));
      }
      // If the variable is not the last one in the list we can include the following comma
      if ("","".equals(lastToken.text())) {
        return Optional.of(AnalyzerMessage.textSpanBetween(variable.simpleName(), lastToken));
      }
      // If the variable is last in the list, we need to retrieve the preceding comma
      SyntaxToken precedingComma = variables.get(variables.indexOf(variable) - 1).lastToken();
      return Optional.of(AnalyzerMessage.textSpanBetween(precedingComma, lastToken));
    } else if (parent.is(Tree.Kind.TYPE_PATTERN)) {
      return Optional.of(AnalyzerMessage.textSpanFor(lastToken));
    }
    return Optional.empty();
  }

  private static Optional<SyntaxToken> getPrecedingComma(VariableTree variable) {
    return QuickFixHelper.previousVariable(variable).map(VariableTree::lastToken);
  }

  private static class UnresolvedIdentifiersAndSwitchCaseVisitor extends UnresolvedIdentifiersVisitor {
    private final Set<VariableTree> switchPatternVariables = new HashSet<>();
    private boolean withinCaseLabel = false;

    @Override
    public Set<String> check(Tree tree) {
      switchPatternVariables.clear();
      withinCaseLabel = false;
      return super.check(tree);
    }

    public boolean isSwitchPatternVariable(VariableTree variable) {
      return switchPatternVariables.contains(variable);
    }

    @Override
    public void visitCaseLabel(CaseLabelTree tree) {
      withinCaseLabel = true;
      super.visitCaseLabel(tree);
      withinCaseLabel = false;
    }

    @Override
    public void visitVariable(VariableTree tree) {
      if (withinCaseLabel) {
        switchPatternVariables.add(tree);
      }
      super.visitVariable(tree);
    }
  }
}
"
S1488,CODE_SMELL,Local variables should not be declared and then immediately returned or thrown,"package org.sonar.java.checks;

import java.util.List;
import java.util.Map;
import javax.annotation.CheckForNull;
import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@Rule(key = ""S1488"")
public class ImmediatelyReturnedVariableCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final Map<Kind, String> MESSAGE_KEYS = MapBuilder.<Kind, String>newMap()
    .put(Kind.THROW_STATEMENT, ""throw"")
    .put(Kind.RETURN_STATEMENT, ""return"")
    .build();

  private JavaFileScannerContext context;
  private String lastTypeForMessage;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitBlock(BlockTree tree) {
    super.visitBlock(tree);
    List<StatementTree> statements = tree.body();
    int size = statements.size();
    if (size < 2) {
      return;
    }
    StatementTree butLastStatement = statements.get(size - 2);
    if (butLastStatement.is(Kind.VARIABLE)) {
      VariableTree variableTree = (VariableTree) butLastStatement;
      if(!variableTree.modifiers().annotations().isEmpty()) {
        return;
      }
      StatementTree lastStatement = statements.get(size - 1);
      String lastStatementIdentifier = getReturnOrThrowIdentifier(lastStatement);
      if (lastStatementIdentifier != null) {
        String identifier = variableTree.simpleName().name();
        if (StringUtils.equals(lastStatementIdentifier, identifier)) {
          ExpressionTree initializer = variableTree.initializer();
          if (initializer == null) {
            // Can only happen for non-compilable code, still, we should not report anything.
            return;
          }
          QuickFixHelper.newIssue(context)
            .forRule(this)
            .onTree(initializer)
            .withMessage(""Immediately %s this expression instead of assigning it to the temporary variable \""%s\""."", lastTypeForMessage, identifier)
            .withQuickFix(() -> quickFix(butLastStatement, lastStatement, variableTree, lastTypeForMessage))
            .report();
        }
      }
    }
  }

  private static JavaQuickFix quickFix(StatementTree butLastStatement, StatementTree lastStatement, VariableTree variableTree, String lastTypeForMessage) {
    // Equal token can not be null at this point, we checked before the presence of the initializer
    return JavaQuickFix.newQuickFix(""Inline expression"")
      .addTextEdit(
        JavaTextEdit.replaceTextSpan(textSpanBetween(variableTree.modifiers(), true, variableTree.initializer(), false), lastTypeForMessage + "" ""),
        JavaTextEdit.removeTextSpan(textSpanBetween(butLastStatement, false, lastStatement, true)))
      .build();
  }

  @CheckForNull
  private String getReturnOrThrowIdentifier(StatementTree lastStatementOfBlock) {
    lastTypeForMessage = null;
    ExpressionTree expr = null;
    if (lastStatementOfBlock.is(Kind.THROW_STATEMENT)) {
      lastTypeForMessage = MESSAGE_KEYS.get(Kind.THROW_STATEMENT);
      expr = ((ThrowStatementTree) lastStatementOfBlock).expression();
    } else if (lastStatementOfBlock.is(Kind.RETURN_STATEMENT)) {
      lastTypeForMessage = MESSAGE_KEYS.get(Kind.RETURN_STATEMENT);
      expr = ((ReturnStatementTree) lastStatementOfBlock).expression();
    }
    if (expr != null && expr.is(Kind.IDENTIFIER)) {
      return ((IdentifierTree) expr).name();
    }
    return null;
  }
}
"
S1541,CODE_SMELL,Methods should not be too complex,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.metrics.MetricsScannerContext;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""MethodCyclomaticComplexity"", repositoryKey = ""squid"")
@Rule(key = ""S1541"")
public class MethodComplexityCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_MAX = 10;

  @RuleProperty(
    key = ""Threshold"",
    description = ""The maximum authorized complexity."",
    defaultValue = """" + DEFAULT_MAX)
  private int max = DEFAULT_MAX;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (isExcluded(methodTree)) {
      return;
    }
    var metricsComputer = ((MetricsScannerContext)context).getMetricsComputer();
    List<Tree> complexity = metricsComputer.getComplexityNodes(methodTree);
    int size = complexity.size();
    if (size > max) {
      List<JavaFileScannerContext.Location> flow = new ArrayList<>();
      for (Tree element : complexity) {
        flow.add(new JavaFileScannerContext.Location(""+1"", element));
      }
      reportIssue(
        methodTree.simpleName(),
        ""The Cyclomatic Complexity of this method \"""" + methodTree.simpleName().name() + ""\"" is "" + size + "" which is greater than "" + max + "" authorized."",
        flow,
        size - max);
    }
  }

  private static boolean isExcluded(MethodTree methodTree) {
    return MethodTreeUtils.isEqualsMethod(methodTree) || MethodTreeUtils.isHashCodeMethod(methodTree);
  }

  public void setMax(int max) {
    this.max = max;
  }
}
"
S1596,CODE_SMELL,"""Collections.EMPTY_LIST"", ""EMPTY_MAP"", and ""EMPTY_SET"" should not be used","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Map;

@Rule(key = ""S1596"")
public class CollectionsEmptyConstantsCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final Map<String, String> IDENTIFIER_REPLACEMENT = MapBuilder.<String, String>newMap()
    .put(""EMPTY_LIST"", ""emptyList()"")
    .put(""EMPTY_MAP"", ""emptyMap()"")
    .put(""EMPTY_SET"", ""emptySet()"")
    .build();

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
    super.visitMemberSelectExpression(tree);
    String identifier = tree.identifier().name();
    boolean isCollectionsCall = tree.expression().is(Kind.IDENTIFIER) && ""Collections"".equals(((IdentifierTree) tree.expression()).name());
    boolean callEmptyConstant = identifier.startsWith(""EMPTY_"");
    if (isCollectionsCall && callEmptyConstant) {
      context.reportIssue(this, tree, ""Replace \""Collections."" + identifier + ""\"" by \""Collections."" + IDENTIFIER_REPLACEMENT.get(identifier) + ""\""."");
    }
  }

}
"
S1598,CODE_SMELL,Package declaration should match source file directory,"package org.sonar.java.checks;

import java.io.File;
import java.text.MessageFormat;
import org.sonar.check.Rule;
import org.sonar.java.model.PackageUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonar.plugins.java.api.tree.PackageDeclarationTree;

@Rule(key = ""S1598"")
public class MismatchPackageDirectoryCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;
  private static final String MESSAGE = ""This file \""{0}\"" should be located in \""{1}\"" directory, not in \""{2}\"""";

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitCompilationUnit(CompilationUnitTree tree) {
    PackageDeclarationTree packageDeclaration = tree.packageDeclaration();
    if (packageDeclaration != null) {
      String packageName = PackageUtils.packageName(packageDeclaration, File.separator);
      File javaFile = context.getInputFile().file();
      String dir = javaFile.getParent();
      if (!dir.endsWith(packageName)) {
        String dirWithoutDots = dir.replace(""."", File.separator);
        String issueMessage = MessageFormat.format(MESSAGE, javaFile.getName(), packageName, dir);
        if (dirWithoutDots.endsWith(packageName)) {
          context.reportIssue(this, packageDeclaration.packageName(), issueMessage + ""(Do not use dots in directory names)."");
        } else {
          context.reportIssue(this, packageDeclaration.packageName(), issueMessage + ""."");
        }
      }
    }
  }

}
"
S1602,CODE_SMELL,Lambdas containing only one statement should not nest this statement in a block,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1602"")
public class LambdaSingleExpressionCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava8Compatible();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.LAMBDA_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    LambdaExpressionTree lambdaExpressionTree = (LambdaExpressionTree) tree;
    Tree lambdaBody = lambdaExpressionTree.body();
    if (isBlockWithOneStatement(lambdaBody)) {
      String message = ""Remove useless curly braces around statement"";
      if (singleStatementIsReturn(lambdaExpressionTree)) {
        message += "" and then remove useless return keyword"";
      }
      reportIssue(((BlockTree) lambdaBody).openBraceToken(), message + context.getJavaVersion().java8CompatibilityMessage());
    }
  }

  private static boolean isBlockWithOneStatement(Tree tree) {
    boolean result = false;
    if (tree.is(Tree.Kind.BLOCK)) {
      List<StatementTree> blockBody = ((BlockTree) tree).body();
      result = blockBody.size() == 1 && isRefactorizable(blockBody.get(0));
    }
    return result;
  }

  private static boolean isRefactorizable(StatementTree statementTree) {
    return isBlockWithOneStatement(statementTree) || statementTree.is(Tree.Kind.EXPRESSION_STATEMENT) || isReturnStatement(statementTree);
  }

  private static boolean singleStatementIsReturn(LambdaExpressionTree lambdaExpressionTree) {
    return isReturnStatement(((BlockTree) lambdaExpressionTree.body()).body().get(0));
  }

  private static boolean isReturnStatement(Tree tree) {
    return tree.is(Tree.Kind.RETURN_STATEMENT);
  }
}
"
S1604,CODE_SMELL,Anonymous inner classes containing only one method should become lambdas,"package org.sonar.java.checks;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Symbol.MethodSymbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.EnumConstantTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

@Rule(key = ""S1604"")
public class AnonymousClassShouldBeLambdaCheck extends BaseTreeVisitor implements JavaFileScanner, JavaVersionAwareVisitor {

  private static final String JAVA_LANG_OBJECT = ""java.lang.Object"";
  private JavaFileScannerContext context;
  private final Set<IdentifierTree> enumConstants = new HashSet<>();

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava8Compatible();
  }

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    enumConstants.clear();
    scan(context.getTree());
  }

  @Override
  public void visitEnumConstant(EnumConstantTree tree) {
    enumConstants.add(tree.simpleName());
    super.visitEnumConstant(tree);
    enumConstants.remove(tree.simpleName());
  }

  @Override
  public void visitNewClass(NewClassTree tree) {
    super.visitNewClass(tree);
    ClassTree classBody = tree.classBody();
    if (classBody != null) {
      TypeTree identifier = tree.identifier();
      if (!useThisInstance(classBody) && !enumConstants.contains(identifier) && isSAM(classBody)) {
        context.reportIssue(this, identifier, ""Make this anonymous inner class a lambda"" + context.getJavaVersion().java8CompatibilityMessage());
      }
    }
  }

  private static boolean isSAM(ClassTree classBody) {
    if (hasOnlyOneMethod(classBody.members())) {
      // When overriding only one method of a functional interface, it can only be the single abstract method
      // and not one of the default methods. No need to check that the method signature matches.
      Symbol.TypeSymbol symbol = classBody.symbol();
      // should be anonymous class of interface and not abstract class
      return symbol.interfaces().size() == 1
        && symbol.superClass().is(JAVA_LANG_OBJECT)
        && hasSingleAbstractMethodInHierarchy(symbol.superTypes());
    }
    return false;
  }

  private static boolean hasSingleAbstractMethodInHierarchy(Set<Type> superTypes) {
    return superTypes.stream()
      .filter(type -> !type.is(JAVA_LANG_OBJECT))
      .map(Type::symbol)
      // collect all the methods declared in hierarchy
      .flatMap(superType -> superType.memberSymbols().stream().filter(Symbol::isMethodSymbol).filter(Symbol::isAbstract))
      .map(Symbol.MethodSymbol.class::cast)
      // remove objects methods redefined in interfaces
      .filter(symbol -> !isObjectMethod(symbol))
      // remove generic methods, which can not be written as lambda (JLS-11 15.27)
      .filter(symbol -> !symbol.isParametrizedMethod())
      // always take same symbol if method is redeclared over and over in hierarchy
      .map(AnonymousClassShouldBeLambdaCheck::overridenSymbolIfAny)
      .collect(Collectors.toSet())
      .size() == 1;
  }

  private static Symbol.MethodSymbol overridenSymbolIfAny(MethodSymbol symbol) {
    return symbol.overriddenSymbols().stream()
      .findFirst()
      .orElse(symbol);
  }

  private static boolean isObjectMethod(Symbol.MethodSymbol methodSymbol) {
    return methodSymbol.overriddenSymbols().stream()
      .map(Symbol::owner)
      .map(Symbol::type)
      .anyMatch(t -> t.is(JAVA_LANG_OBJECT));
  }

  private static boolean hasOnlyOneMethod(List<Tree> members) {
    MethodTree methodTree = null;
    for (Tree tree : members) {
      if (!tree.is(Tree.Kind.EMPTY_STATEMENT, Tree.Kind.METHOD)) {
        return false;
      }
      if (tree.is(Tree.Kind.METHOD)) {
        if (methodTree != null) {
          return false;
        }
        methodTree = (MethodTree) tree;

      }
    }

    return methodTree != null && canRefactorMethod(methodTree);
  }

  private static boolean canRefactorMethod(MethodTree methodTree) {
    // if overriden method declares to throw an exception, refactoring to a lambda might prove tricky
    // if it is annotated with something else than @Override, it is not possible to refactor the code
    return methodTree.throwsClauses().isEmpty()
      && methodTree.symbol().metadata().annotations().stream()
      .allMatch(annotation -> annotation.symbol().type().is(""java.lang.Override""));
  }

  private static boolean useThisInstance(ClassTree body) {
    UsesThisInstanceVisitor visitor = new UsesThisInstanceVisitor(body.symbol().type());
    body.accept(visitor);
    return visitor.usesThisInstance;
  }

  private static class UsesThisInstanceVisitor extends BaseTreeVisitor {
    private final Type instanceType;
    boolean usesThisInstance = false;
    boolean visitedClassTree = false;

    public UsesThisInstanceVisitor(Type instanceType) {
      this.instanceType = instanceType;
    }

    @Override
    public void visitClass(ClassTree tree) {
      // visit the class body but ignore inner classes
      if (!visitedClassTree) {
        visitedClassTree = true;
        super.visitClass(tree);
      }
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      // ignore anonymous classes
    }

    @Override
    public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
      scan(tree.expression());
      // ignore identifier, because if it is this, it is a qualified this.
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (tree.methodSelect().is(Tree.Kind.IDENTIFIER)) {
        Symbol symbol = ((IdentifierTree) tree.methodSelect()).symbol();
        usesThisInstance |= symbol.isMethodSymbol() &&
          !symbol.isStatic() &&
          instanceType.isSubtypeOf(symbol.owner().type());
      }
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      usesThisInstance |= ""this"".equals(tree.name());
    }
  }

}
"
S1607,CODE_SMELL,JUnit4 @Ignored and JUnit5 @Disabled annotations should be used to disable tests and should provide a rationale,"package org.sonar.java.checks.tests;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1607"")
public class IgnoredTestsCheck extends IssuableSubscriptionVisitor {

  private static final String ORG_JUNIT_ASSUME = ""org.junit.Assume"";
  private static final String BOOLEAN_TYPE = ""boolean"";

  private static final MethodMatchers ASSUME_METHODS = MethodMatchers.create()
    .ofTypes(ORG_JUNIT_ASSUME).names(""assumeTrue"", ""assumeFalse"").addParametersMatcher(BOOLEAN_TYPE).build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    SymbolMetadata symbolMetadata = methodTree.symbol().metadata();
    // check for @Ignore or @Disabled annotations
    boolean hasIgnoreAnnotation = isSilentlyIgnored(symbolMetadata, ""org.junit.Ignore"");
    boolean hasDisabledAnnotation = isSilentlyIgnored(symbolMetadata, ""org.junit.jupiter.api.Disabled"");
    if (hasIgnoreAnnotation || hasDisabledAnnotation) {
      reportIssue(methodTree.simpleName(), String.format(""Either add an explanation about why this test is skipped or remove the "" +
        ""\""@%s\"" annotation."", hasIgnoreAnnotation ? ""Ignore"" : ""Disabled""));
    }

    // check for ""assumeFalse(true)"" and ""assumeTrue(false)""-calls, which may also result in permanent skipping of the given test
    BlockTree block = methodTree.block();
    if (block != null) {
      block.body().stream()
        .filter(s -> s.is(Tree.Kind.EXPRESSION_STATEMENT))
        .map(s -> ((ExpressionStatementTree) s).expression())
        .filter(s -> s.is(Tree.Kind.METHOD_INVOCATION))
        .map(MethodInvocationTree.class::cast)
        .filter(ASSUME_METHODS::matches)
        .filter(IgnoredTestsCheck::hasConstantOppositeArg)
        .forEach(mit -> {
          List<JavaFileScannerContext.Location> secondaryLocation = Collections.singletonList(new JavaFileScannerContext.Location(
            ""A constant boolean value is passed as argument, causing this test to always be skipped."", mit.arguments()));

          reportIssue(ExpressionUtils.methodName(mit), ""This assumption is called with a boolean constant; remove it or, to skip this "" +
              ""test use an @Ignore/@Disabled annotation in combination with an explanation about why it is skipped."",
            secondaryLocation, null);
        });
    }
  }

  private static boolean isSilentlyIgnored(SymbolMetadata symbolMetadata, String fullyQualifiedName) {
    // This code duplicates the behavior of SymbolMetadata.valuesForAnnotation but checks for broken semantics
    for (SymbolMetadata.AnnotationInstance annotation : symbolMetadata.annotations()) {
      Type type = annotation.symbol().type();
      // In case of broken semantics, the annotation may match the fully qualified name but still miss the type binding.
      // As a consequence, fetching the values from the annotation returns an empty list, as if there were no value, even though there might be one or more.
      // In such cases, it is best to consider that the test is not ignored.
      if (type.isUnknown()) {
        return false;
      }
      if (type.is(fullyQualifiedName)) {
        return annotation.values().isEmpty();
      }
    }
    return false;
  }

  private static boolean hasConstantOppositeArg(MethodInvocationTree mit) {
    Optional<Boolean> result = mit.arguments().get(0).asConstant(Boolean.class);
    return result.isPresent() && !result.get().equals(mit.methodSymbol().name().contains(""True""));
  }
}
"
S1610,CODE_SMELL,Abstract classes without fields should be converted to interfaces,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1610"")
public class AbstractClassNoFieldShouldBeInterfaceCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  private static final String IMMUTABLE_ANNOTATION = ""org.immutables.value.Value$Immutable"";

  private int javaVersionAsInt;

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava8Compatible();
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    javaVersionAsInt = context.getJavaVersion().asInt();
    super.setContext(context);
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (classTree.superClass() == null
      && classIsAbstract(classTree)
      && classHasNoFieldAndProtectedMethod(classTree)
      && classHasNoImmutableAnnotation(classTree)
      && supportPrivateMethod(classTree)) {
      IdentifierTree simpleName = classTree.simpleName();
      reportIssue(
        simpleName,
        ""Convert the abstract class \"""" + simpleName.name() + ""\"" into an interface."" + context.getJavaVersion().java8CompatibilityMessage());
    }
  }

  private static boolean classIsAbstract(ClassTree tree) {
    return ModifiersUtils.hasModifier(tree.modifiers(), Modifier.ABSTRACT);
  }private boolean supportPrivateMethod(ClassTree tree) {
    return !hasPrivateMethod(tree) || javaVersionAsInt >= 9;
  }

  private static boolean hasPrivateMethod(ClassTree tree) {
    return tree.members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .anyMatch(member -> ModifiersUtils.hasModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE));
  }

  private static boolean classHasNoFieldAndProtectedMethod(ClassTree tree) {
    return tree.members().stream()
      .noneMatch(member -> member.is(Tree.Kind.VARIABLE) || (member.is(Tree.Kind.METHOD) && isProtectedOrOverriding((MethodTree) member)));
  }

  private static boolean isProtectedOrOverriding(MethodTree member) {
    return ModifiersUtils.hasModifier(member.modifiers(), Modifier.PROTECTED) || !Boolean.FALSE.equals(member.isOverriding());
  }

  private static boolean classHasNoImmutableAnnotation(ClassTree tree) {
    List<SymbolMetadata.AnnotationInstance> annotations = tree.symbol().metadata().annotations();
    if (annotations.isEmpty()) {
      return true;
    }
    for (SymbolMetadata.AnnotationInstance annotation : annotations) {
      // If semantic is incomplete, we may not be able to resolve the full name on the class annotation.
      // To reduce FPs, we test for a match on the end of the annotation names
      Symbol symbol = annotation.symbol();
      if (symbol.isUnknown() || symbol.type().is(IMMUTABLE_ANNOTATION)) {
        return false;
      }
    }
    return true;
  }
}
"
S1611,CODE_SMELL,Parentheses should be removed from a single lambda parameter when its type is inferred,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Collections;
import java.util.List;


@Rule(key = ""S1611"")
public class LambdaOptionalParenthesisCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.LAMBDA_EXPRESSION);
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava8Compatible();
  }

  @Override
  public void visitNode(Tree tree) {
    LambdaExpressionTree let = (LambdaExpressionTree) tree;
    SyntaxToken openParenToken = let.openParenToken();
    if (openParenToken != null && let.parameters().size() == 1) {
      VariableTree param = let.parameters().get(0);
      String identifier = param.simpleName().name();
      if (param.type().is(Tree.Kind.INFERED_TYPE)) {
        reportIssue(openParenToken, ""Remove the parentheses around the \"""" + identifier + ""\"" parameter"" + context.getJavaVersion().java8CompatibilityMessage());
      }
    }
  }
}
"
S1612,CODE_SMELL,Lambdas should be replaced with method references,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.IntStream;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.JUtils;
import org.sonar.java.model.LineUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ArrayTypeTree;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.InstanceOfTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.PrimitiveTypeTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1612"")
public class ReplaceLambdaByMethodRefCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.LAMBDA_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    visitLambdaExpression((LambdaExpressionTree) tree);
  }

  private void visitLambdaExpression(LambdaExpressionTree tree) {
    getPossibleReplacement(tree)
      .filter(replacement -> isReplacementMoreConcise(tree, replacement))
      .ifPresent(replacement ->
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(tree.arrowToken())
          .withMessage(""Replace this lambda with method reference '%s'.%s"", replacement, context.getJavaVersion().java8CompatibilityMessage())
          .withQuickFix(() -> JavaQuickFix.newQuickFix(""Replace with \""%s\"""", replacement)
            .addTextEdit(JavaTextEdit.replaceTree(tree, replacement))
            .build())
          .report()
      );
  }

  private static boolean isReplacementMoreConcise(LambdaExpressionTree tree, String replacement) {
    SyntaxToken first = Objects.requireNonNull(tree.firstToken());
    SyntaxToken last = Objects.requireNonNull(tree.lastToken());
    boolean multiline = LineUtils.startLine(first) != LineUtils.endLine(last);
    boolean shorter = replacement.length() <= Position.endOf(last).column() - Position.startOf(first).column();
    return multiline || shorter;
  }

  private static Optional<String> getPossibleReplacement(LambdaExpressionTree tree) {
    Optional<String> typeCastOrInstanceOf = getTypeCastOrInstanceOf(tree);
    if (typeCastOrInstanceOf.isPresent()) {
      return typeCastOrInstanceOf;
    }
    Optional<String> nullCheck = getNullCheck(tree);
    if (nullCheck.isPresent()) {
      return nullCheck;
    }
    Optional<String> methodInvocationOrNewClass = getMethodInvocationOrNewClass(tree.body(), tree);
    if (methodInvocationOrNewClass.isPresent()) {
      return methodInvocationOrNewClass;
    }
    return getBodyBlockInvokingMethodOrNewClass(tree);
  }

  private static Optional<String> getNullCheck(LambdaExpressionTree lambda) {
    return getLambdaSingleParamSymbol(lambda).flatMap(symbol -> {
      Tree lambdaBody = lambda.body();
      return (isBlockWithOneStatement(lambdaBody)) ?
        getNullCheckFromReturn(((BlockTree) lambdaBody).body().get(0), symbol) :
        getNullCheck(lambdaBody, symbol);
    });
  }

  private static Optional<String> getNullCheckFromReturn(Tree statement, Symbol paramSymbol) {
    return statement.is(Tree.Kind.RETURN_STATEMENT) ?
      getNullCheck(((ReturnStatementTree) statement).expression(), paramSymbol) :
      Optional.empty();
  }

  private static Optional<String> getNullCheck(@Nullable Tree statement, Symbol paramSymbol) {
    return expressionWithoutParentheses(statement).flatMap(expr -> {
      if (expr.is(Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO)) {
        BinaryExpressionTree bet = (BinaryExpressionTree) expr;
        ExpressionTree leftOperand = ExpressionUtils.skipParentheses(bet.leftOperand());
        ExpressionTree rightOperand = ExpressionUtils.skipParentheses(bet.rightOperand());
        if (nullAgainstParam(leftOperand, rightOperand, paramSymbol) || nullAgainstParam(rightOperand, leftOperand, paramSymbol)) {
          return Optional.of(expr.is(Tree.Kind.EQUAL_TO) ? ""Objects::isNull"" : ""Objects::nonNull"");
        }
      }
      return Optional.empty();
    });
  }

  private static boolean nullAgainstParam(ExpressionTree o1, ExpressionTree o2, Symbol paramSymbol) {
    return o1.is(Tree.Kind.NULL_LITERAL) &&
      o2.is(Tree.Kind.IDENTIFIER) &&
      paramSymbol.equals(((IdentifierTree) o2).symbol());
  }

  private static Optional<String> getTypeCastOrInstanceOf(LambdaExpressionTree lambda) {
    return getLambdaSingleParamSymbol(lambda).flatMap(symbol -> {
      Tree lambdaBody = lambda.body();
      return isBlockWithOneStatement(lambdaBody) ?
        getTypeCastOrInstanceOfFromReturn(((BlockTree) lambdaBody).body().get(0), symbol) :
        getTypeCastOrInstanceOf(lambdaBody, symbol);
    });
  }

  private static Optional<String> getTypeCastOrInstanceOfFromReturn(Tree statement, Symbol symbol) {
    return statement.is(Tree.Kind.RETURN_STATEMENT) ?
      getTypeCastOrInstanceOf(((ReturnStatementTree) statement).expression(), symbol) :
      Optional.empty();
  }

  private static Optional<String> getTypeCastOrInstanceOf(@Nullable Tree statement, Symbol symbol) {
    return statement == null ?
      Optional.empty() :
      expressionWithoutParentheses(statement).flatMap(expr -> getTypeCastOrInstanceOfName(symbol, expr));
  }

  private static Optional<String> getTypeCastOrInstanceOfName(Symbol symbol, ExpressionTree expr) {
    if (expr.is(Tree.Kind.TYPE_CAST)) {
      TypeCastTree typeCastTree = (TypeCastTree) expr;
      if (isSingleParamExpression(typeCastTree.expression(), symbol) && !symbol.type().isPrimitive()) {
        return getTypeName(typeCastTree.type())
          .map(s -> s + "".class::cast"");
      }
    } else if (expr.is(Tree.Kind.INSTANCE_OF)) {
      InstanceOfTree instanceOfTree = (InstanceOfTree) expr;
      if (isSingleParamExpression(instanceOfTree.expression(), symbol)) {
        return getTypeName(instanceOfTree.type())
          .map(s -> s + "".class::isInstance"");
      }
    }
    return Optional.empty();
  }

  private static Optional<String> getTypeName(TypeTree type) {
    if (type.is(Tree.Kind.IDENTIFIER) && !isGeneric((IdentifierTree) type)) {
      return Optional.of(((IdentifierTree) type).name());
    }
    if (type.is(Tree.Kind.ARRAY_TYPE)) {
      return getTypeName(((ArrayTypeTree) type).type()).map(x -> x + ""[]"");
    }
    if (type.is(Tree.Kind.PRIMITIVE_TYPE)) {
      return Optional.of(((PrimitiveTypeTree) type).keyword().text());
    }
    return Optional.empty();
  }

  private static boolean isGeneric(IdentifierTree identifierTree) {
    return identifierTree.symbolType().isTypeVar();
  }

  private static boolean isSingleParamExpression(ExpressionTree expression, Symbol symbol) {
    return expression.is(Tree.Kind.IDENTIFIER) && symbol.equals(((IdentifierTree) expression).symbol());
  }

  private static Optional<Symbol> getLambdaSingleParamSymbol(LambdaExpressionTree tree) {
    List<VariableTree> parameters = tree.parameters();
    return parameters.size() == 1 ? Optional.of(parameters.get(0).symbol()) : Optional.empty();
  }

  private static Optional<String> getBodyBlockInvokingMethodOrNewClass(LambdaExpressionTree lambdaTree) {
    Tree lambdaBody = lambdaTree.body();
    if (isBlockWithOneStatement(lambdaBody)) {
      Tree statement = ((BlockTree) lambdaBody).body().get(0);
      return getExpressionOrReturnStatementInvokingMethod(statement, lambdaTree);
    }
    return Optional.empty();
  }

  private static boolean isBlockWithOneStatement(Tree tree) {
    return tree.is(Tree.Kind.BLOCK) && ((BlockTree) tree).body().size() == 1;
  }

  private static Optional<String> getExpressionOrReturnStatementInvokingMethod(Tree statement, LambdaExpressionTree lambdaTree) {
    if (statement.is(Tree.Kind.EXPRESSION_STATEMENT)) {
      return getMethodInvocationOrNewClass(((ExpressionStatementTree) statement).expression(), lambdaTree);
    } else if (statement.is(Tree.Kind.RETURN_STATEMENT)) {
      return getMethodInvocationOrNewClass(((ReturnStatementTree) statement).expression(), lambdaTree);
    }
    return Optional.empty();
  }

  private static Optional<String> getMethodInvocationOrNewClass(@Nullable Tree tree, LambdaExpressionTree lambdaTree) {
    if (tree != null) {
      List<VariableTree> parameters = lambdaTree.parameters();

      if (tree.is(Tree.Kind.NEW_CLASS)) {
        // x -> new Foo(x) becomes Foo::new
        return getNewClass(((NewClassTree) tree), parameters);
      } else if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree mit = (MethodInvocationTree) tree;
        if (mit.methodSymbol().isUnknown() || hasMethodInvocationInMethodSelect(mit) || hasNonFinalFieldInMethodSelect(mit)) {
          return Optional.empty();
        }
        if (matchingParameters(mit.arguments(), parameters)) {
          // x -> foo(x) becomes y::foo or Owner::foo or this::foo or Owner.this::foo
          return getReplacementForMethodInvocation(mit);
        }
        if (isMethodCalledOnFirstParam(mit, parameters)) {
          // x -> x.foo() becomes Owner::foo
          return getUnambiguousReference(mit);
        }
      }
    }
    return Optional.empty();
  }

  private static Optional<String> getUnambiguousReference(MethodInvocationTree mit) {
    Symbol.MethodSymbol ms = mit.methodSymbol();
    ArrayList<Symbol.MethodSymbol> methodSymbols = new ArrayList<>(ms.overriddenSymbols());
    Collections.reverse(methodSymbols);
    methodSymbols.add(ms);
    return methodSymbols.stream()
      .filter(m -> m.thrownTypes().equals(ms.thrownTypes()))
      .filter(m -> !hasAmbiguousReference(m))
      .findFirst()
      .map(ReplaceLambdaByMethodRefCheck::getMethodReferenceFromSymbol);
  }

  private static boolean hasAmbiguousReference(Symbol.MethodSymbol ms) {
    return ((Symbol.TypeSymbol) ms.owner()).lookupSymbols(ms.name()).stream()
      .filter(Symbol::isMethodSymbol)
      .map(Symbol.MethodSymbol.class::cast)
      .filter(m -> m.isStatic() != ms.isStatic())
      .anyMatch(m -> m.isStatic() ? methodsHaveSameReference(m, ms) : methodsHaveSameReference(ms, m));
  }

  private static boolean methodsHaveSameReference(Symbol.MethodSymbol mStatic, Symbol.MethodSymbol mNotStatic) {
    Type ownerType = mStatic.owner().type();
    return mStatic.parameterTypes().size() == mNotStatic.parameterTypes().size() + 1 &&
           isArgumentCompatible(ownerType, mStatic.parameterTypes().get(0));
  }

  private static Optional<String> getNewClass(NewClassTree newClassTree, List<VariableTree> parameters) {
    if (newClassTree.classBody() == null && matchingParameters(newClassTree.arguments(), parameters)) {
      TypeTree identifier = newClassTree.identifier();
      if (identifier.is(Tree.Kind.MEMBER_SELECT, Tree.Kind.IDENTIFIER)) {
        String className = ExpressionsHelper.concatenate((ExpressionTree) identifier);
        return Optional.of(className + ""::new"");
      }
    }
    return Optional.empty();
  }

  private static Optional<String> getReplacementForMethodInvocation(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    Symbol.MethodSymbol symbol = mit.methodSymbol();
    if (symbol.isStatic()) {
      return getUnambiguousReference(mit);
    }
    if (methodSelect.is(Tree.Kind.IDENTIFIER)) {
      MethodTree enclosingMethod = ExpressionUtils.getEnclosingMethod(mit);
      Symbol symbolOwner = symbol.owner();
      if (enclosingMethod != null) {
        Symbol expressionOwner = enclosingMethod.symbol().owner();
        if (symbolOwner.equals(expressionOwner)) {
          return Optional.of(""this::"" + symbol.name());
        }
      }
      return Optional.of(symbolOwner.name() + "".this::"" + symbol.name());
    }
    MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) methodSelect;
    return Optional.of(ExpressionsHelper.concatenate(memberSelect.expression()) + ""::"" + memberSelect.identifier().name());
  }

  private static String getMethodReferenceFromSymbol(Symbol symbol) {
    return symbol.owner().name() + ""::"" + symbol.name();
  }

  private static boolean hasMethodInvocationInMethodSelect(MethodInvocationTree mit) {
    MemberSelectExpressionTree mse = getMemberSelect(mit);
    while (mse != null) {
      ExpressionTree expression = mse.expression();
      if (expression.is(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS)) {
        return true;
      }
      if (expression.is(Tree.Kind.MEMBER_SELECT)) {
        mse = (MemberSelectExpressionTree) expression;
      } else {
        mse = null;
      }
    }
    return false;
  }

  @CheckForNull
  private static MemberSelectExpressionTree getMemberSelect(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    if (!methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      return null;
    }
    return (MemberSelectExpressionTree) methodSelect;
  }

  private static boolean hasNonFinalFieldInMethodSelect(MethodInvocationTree mit) {
    MemberSelectExpressionTree mse = getMemberSelect(mit);
    if (mse == null) {
      return false;
    }
    ExpressionTree expression = ExpressionUtils.skipParentheses(mse.expression());
    Symbol symbol = null;
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      symbol = ((IdentifierTree) expression).symbol();
    } else if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      symbol = ((MemberSelectExpressionTree) expression).identifier().symbol();
    }
    return symbol != null &&
      symbol.owner().isTypeSymbol()
      && !isThisOrSuper(symbol.name())
      && !symbol.isFinal();
  }

  private static boolean isThisOrSuper(String name) {
    return ""this"".equals(name) || ""super"".equals(name);
  }

  private static boolean matchingParameters(Arguments arguments, List<VariableTree> parameters) {
    return arguments.size() == parameters.size() &&
      IntStream.range(0, arguments.size()).allMatch(i -> {
        List<IdentifierTree> usages = parameters.get(i).symbol().usages();
        return usages.size() == 1 && usages.get(0).equals(arguments.get(i));
      });
  }private static boolean isMethodCalledOnFirstParam(MethodInvocationTree mit, List<VariableTree> parameters) {
    if (!parameters.isEmpty() && mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree expression = ((MemberSelectExpressionTree) mit.methodSelect()).expression();
      Symbol parameterSymbol = parameters.get(0).symbol();
      return expression.is(Tree.Kind.IDENTIFIER) &&
        !parameterSymbol.isUnknown() &&
        parameterSymbol.equals(((IdentifierTree) expression).symbol()) &&
        matchingParameters(mit.arguments(), parameters.subList(1, parameters.size()));
    }
    return false;
  }

  public static Optional<ExpressionTree> expressionWithoutParentheses(@Nullable Tree tree) {
    if (!(tree instanceof ExpressionTree)) {
      return Optional.empty();
    }
    ExpressionTree result = ((ExpressionTree) tree);
    return Optional.of(ExpressionUtils.skipParentheses(result));
  }

  private static boolean isArgumentCompatible(Type argumentType, Type parameterType) {
    return argumentType.isSubtypeOf(parameterType)
      || JUtils.wrapTypeIfPrimitive(argumentType).equals(JUtils.wrapTypeIfPrimitive(parameterType));
  }
}
"
S1640,CODE_SMELL,Maps with keys that are enum values should use the EnumMap implementation,"package org.sonar.java.checks;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1640"")
public class EnumMapCheck extends BaseTreeVisitor implements JavaFileScanner {
  private JavaFileScannerContext context;
  private static final String JAVA_UTIL_MAP = ""java.util.Map"";
  private static final MethodMatchers mapPut = MethodMatchers.create().ofTypes(JAVA_UTIL_MAP).names(""put"").withAnyParameters().build();

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitVariable(VariableTree tree) {
    if (tree.type().symbolType().isSubtypeOf(JAVA_UTIL_MAP)) {
      ExpressionTree initializer = tree.initializer();
      if (initializer != null && !usesNullKey(tree.symbol())) {
        checkNewMap(initializer, hasEnumKey(tree.type().symbolType()));
      }
    } else {
      super.visitVariable(tree);
    }
  }

  private static boolean usesNullKey(Symbol symbol) {
    List<IdentifierTree> usages = symbol.usages();
    for (IdentifierTree usage : usages) {
      if (MethodTreeUtils.consecutiveMethodInvocation(usage)
        .filter(mit -> mapPut.matches(mit) && mit.arguments().get(0).is(Tree.Kind.NULL_LITERAL))
        .isPresent()) {
        return true;
      }
    }
    return false;
  }

  @Override
  public void visitAssignmentExpression(AssignmentExpressionTree tree) {
    if (tree.variable().symbolType().isSubtypeOf(JAVA_UTIL_MAP)) {
      checkNewMap(tree.expression(), hasEnumKey(tree.variable().symbolType()));
    } else {
      super.visitAssignmentExpression(tree);
    }
  }

  @Override
  public void visitNewClass(NewClassTree tree) {
    if (isUnorderedMap(tree.symbolType()) && hasEnumKey(tree.identifier().symbolType())) {
      addIssue(tree);
    } else {
      super.visitNewClass(tree);
    }
  }

  private void checkNewMap(ExpressionTree given, boolean useEnumKey) {
    ExpressionTree expression = ExpressionUtils.skipParentheses(given);
    if (expression.is(Tree.Kind.NEW_CLASS)) {
      NewClassTree newClassTree = (NewClassTree) expression;
      if (isUnorderedMap(newClassTree.symbolType()) && (useEnumKey || hasEnumKey(newClassTree.identifier().symbolType()))) {
        addIssue(newClassTree);
      }
    }
  }

  private static boolean isUnorderedMap(Type type) {
    return type.isSubtypeOf(""java.util.HashMap"") &&
      !type.isSubtypeOf(""java.util.LinkedHashMap"");
  }

  private static boolean hasEnumKey(Type type) {
    return type.isParameterized() && type.typeArguments().get(0).symbol().isEnum();
  }

  private void addIssue(Tree typeTree) {
    context.reportIssue(this, typeTree, ""Convert this Map to an EnumMap."");
  }

}
"
S1641,CODE_SMELL,Sets with elements that are enum values should be replaced with EnumSet,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1641"")
public class EnumSetCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers COLLECTIONS_UNMODIFIABLE = MethodMatchers.create()
    .ofTypes(""java.util.Collections"")
    .names(""unmodifiableSet"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers SET_CREATION_METHODS = MethodMatchers.or(
    // Java 9 factory methods
    MethodMatchers.create().ofTypes(""java.util.Set"").names(""of"").withAnyParameters().build(),
    // guava
    MethodMatchers.create().ofTypes(""com.google.common.collect.ImmutableSet"").names(""of"").withAnyParameters().build(),
    MethodMatchers.create().ofTypes(""com.google.common.collect.Sets"").anyName().withAnyParameters().build());

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.VARIABLE);
  }

  @Override
  public void visitNode(Tree tree) {
    VariableTree variableTree = (VariableTree) tree;
    ExpressionTree initializer = variableTree.initializer();
    if (initializer == null) {
      return;
    }
    if (initializer.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) initializer;
      if (COLLECTIONS_UNMODIFIABLE.matches(mit)) {
        // check the collection used as parameter
        initializer = mit.arguments().get(0);
      } else if (!SET_CREATION_METHODS.matches(mit) || ""immutableEnumSet"".equals(mit.methodSymbol().name())) {
        // Methods from Guava 'Sets' except 'immutableEnumSet' should be checked,
        // but discard any other method invocations (killing the noise)
        return;
      }
    }
    if (!initializer.is(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS)) {
      // We are not trying to compute the exact type of more complex expressions
      return;
    }
    checkIssue(initializer.symbolType(), initializer);
  }

  private void checkIssue(Type type, Tree reportTree) {
    if (type.isSubtypeOf(""java.util.Set"") && !type.isSubtypeOf(""java.util.EnumSet"") && type.isParameterized()) {
      Type typeArgument = type.typeArguments().get(0);
      if (typeArgument != null && typeArgument.symbol().isEnum()) {
        reportIssue(reportTree, ""Convert this Set to an EnumSet."");
      }
    }
  }

}
"
S1643,CODE_SMELL,Strings should not be concatenated using '+' in a loop,"package org.sonar.java.checks;

import java.util.Deque;
import java.util.LinkedList;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.ArrayAccessExpressionTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.DoWhileStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

@Rule(key = ""S1643"")
public class StringConcatenationInLoopCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;
  private Deque<Tree> loopLevel = new LinkedList<>();

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    loopLevel.clear();
    scan(context.getTree());
  }

  @Override
  public void visitAssignmentExpression(AssignmentExpressionTree tree) {
    if (!loopLevel.isEmpty() && isStringConcatenation(tree) && isNotLoopLocalVar(tree) && isNotArrayAccess(tree)) {
      context.reportIssue(this, tree.variable(), ""Use a StringBuilder instead."");
    }
    super.visitAssignmentExpression(tree);
  }

  private boolean isNotLoopLocalVar(AssignmentExpressionTree tree) {
    IdentifierTree idTree = getIdentifierTree(tree.variable());
    if (idTree == null) {
      return false;
    }
    Tree declaration = idTree.symbol().declaration();
    if (declaration == null) {
      return true;
    }
    Tree parent = declaration.parent();
    Tree parentLoop = loopLevel.peek();
    while (parent != null && !parent.equals(parentLoop)) {
      if (parent.is(
        Tree.Kind.CLASS,
        Tree.Kind.ENUM,
        Tree.Kind.INTERFACE,
        Tree.Kind.METHOD,
        Tree.Kind.LAMBDA_EXPRESSION)) {
        // declaration is necessarily not part of a loop
        return true;
      }
      parent = parent.parent();
    }
    return parent == null;
  }

  private static boolean isNotArrayAccess(AssignmentExpressionTree tree) {
    return !tree.variable().is(Tree.Kind.ARRAY_ACCESS_EXPRESSION);
  }

  @Nullable
  private static IdentifierTree getIdentifierTree(ExpressionTree tree) {
    tree = ExpressionUtils.skipParentheses(tree);
    switch (tree.kind()) {
      case IDENTIFIER:
        return (IdentifierTree) tree;
      case MEMBER_SELECT:
        return getIdentifierTree(((MemberSelectExpressionTree) tree).expression());
      case ARRAY_ACCESS_EXPRESSION:
        return getIdentifierTree(((ArrayAccessExpressionTree) tree).expression());
      case METHOD_INVOCATION:
        return getIdentifierTree(((MethodInvocationTree) tree).methodSelect());
      default:
        // any other unsupported case
        return null;
    }
  }

  private static boolean isStringConcatenation(AssignmentExpressionTree tree) {
    return tree.symbolType().is(""java.lang.String"") && isConcatenation(tree);
  }

  private static boolean isConcatenation(AssignmentExpressionTree tree) {
    if (tree.is(Tree.Kind.ASSIGNMENT)) {
      ExpressionTree expressionTree = ExpressionUtils.skipParentheses(tree.expression());
      return expressionTree.is(Tree.Kind.PLUS) && concatenateVariable(tree.variable(), (BinaryExpressionTree) expressionTree);
    }
    return tree.is(Tree.Kind.PLUS_ASSIGNMENT);
  }

  private static boolean concatenateVariable(ExpressionTree variable, BinaryExpressionTree plus) {
    return concatenateVariable(variable, plus.leftOperand()) || concatenateVariable(variable, plus.rightOperand());
  }

  private static boolean concatenateVariable(ExpressionTree variable, ExpressionTree operand) {
    if (operand.is(Tree.Kind.PLUS)) {
      return concatenateVariable(variable, (BinaryExpressionTree) operand);
    }
    return SyntacticEquivalence.areEquivalent(variable, operand);
  }

  @Override
  public void visitForEachStatement(ForEachStatement tree) {
    loopLevel.push(tree);
    super.visitForEachStatement(tree);
    loopLevel.pop();
  }

  @Override
  public void visitForStatement(ForStatementTree tree) {
    loopLevel.push(tree);
    super.visitForStatement(tree);
    loopLevel.pop();
  }

  @Override
  public void visitWhileStatement(WhileStatementTree tree) {
    loopLevel.push(tree);
    super.visitWhileStatement(tree);
    loopLevel.pop();
  }

  @Override
  public void visitDoWhileStatement(DoWhileStatementTree tree) {
    loopLevel.push(tree);
    super.visitDoWhileStatement(tree);
    loopLevel.pop();
  }

}
"
S1656,BUG,Variables should not be self-assigned,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.JProblem;
import org.sonar.java.model.JWarning;
import org.sonar.java.model.JavaTree;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@Rule(key = ""S1656"")
public class SelfAssignementCheck extends IssuableSubscriptionVisitor {

  private static final String ISSUE_MESSAGE = ""Remove or correct this useless self-assignment."";
  private final Set<JWarning> warnings = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.COMPILATION_UNIT, Tree.Kind.ASSIGNMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      warnings.clear();
      warnings.addAll(((JavaTree.CompilationUnitTreeImpl) tree).warnings(JProblem.Type.ASSIGNMENT_HAS_NO_EFFECT));
      return;
    }
    AssignmentExpressionTree node = (AssignmentExpressionTree) tree;
    if (SyntacticEquivalence.areEquivalent(node.expression(), node.variable())) {
      if (node.parent().is(Tree.Kind.VARIABLE) || node.parent().is(Tree.Kind.ASSIGNMENT)) {
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(reportTree(node))
          .withMessage(ISSUE_MESSAGE)
          .report();
      } else {
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(reportTree(node))
          .withMessage(ISSUE_MESSAGE)
          .withQuickFix(() -> getQuickFix(node))
          .report();
      }
      updateWarnings(node);
    }
  }

  private static JavaQuickFix getQuickFix(AssignmentExpressionTree tree) {
    ClassTree classParent = (ClassTree) ExpressionUtils.getParentOfType(tree, Tree.Kind.CLASS, Tree.Kind.INTERFACE);
    MethodTree methodParent = (MethodTree) ExpressionUtils.getParentOfType(tree, Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
    String name = getName(tree.variable());

    boolean isMethodParameter = methodParent != null && methodParent.parameters().stream()
      .map(p -> p.simpleName().name())
      .anyMatch(p -> p.equals(name));

    if (isMethodParameter) {
      List<String> memberNames = classParent.members().stream()
        .filter(m -> m.is(Tree.Kind.VARIABLE))
        .map(VariableTree.class::cast)
        .map(m -> m.simpleName().name())
        .toList();

      if (memberNames.contains(name)) {
        return JavaQuickFix.newQuickFix(""Disambiguate this self-assignment"")
          .addTextEdit(JavaTextEdit.insertBeforeTree(tree.variable(), ""this.""))
          .build();
      }
    }

    return JavaQuickFix.newQuickFix(""Remove this useless self-assignment"")
      .addTextEdit(JavaTextEdit.removeTextSpan(textSpanBetween(tree, true,
        QuickFixHelper.nextToken(tree), true)))
      .build();
  }

  private static String getName(ExpressionTree variable) {
    if (variable.is(Tree.Kind.IDENTIFIER)) {
      return ((IdentifierTree) variable).name();
    }
    if (variable.is(Tree.Kind.MEMBER_SELECT)) {
      return ((MemberSelectExpressionTree) variable).identifier().name();
    }
    return """";
  }

  private static SyntaxToken reportTree(AssignmentExpressionTree node) {
    return node.operatorToken();
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      warnings.forEach(warning -> {
        AssignmentExpressionTree node = (AssignmentExpressionTree) warning.syntaxTree();
        if (node.parent().is(Tree.Kind.VARIABLE)) {
          return;
        }
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(reportTree(node))
          .withMessage(ISSUE_MESSAGE)
          .withQuickFix(() -> getQuickFix(node))
          .report();
      });
    }
  }

  private void updateWarnings(AssignmentExpressionTree tree) {
    warnings.removeIf(warning -> tree.equals(warning.syntaxTree()));
  }

}
"
S1659,CODE_SMELL,Multiple variables should not be declared on the same line,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.LineUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@Rule(key = ""S1659"")
public class OneDeclarationPerLineCheck extends IssuableSubscriptionVisitor {

  private static final Pattern INDENTATION_PATTERN = Pattern.compile(""^(\\s+)"");

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Kind.INTERFACE, Kind.CLASS, Kind.ENUM, Kind.ANNOTATION_TYPE, Kind.BLOCK, Kind.STATIC_INITIALIZER, Kind.CASE_GROUP);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Kind.INTERFACE, Kind.CLASS, Kind.ENUM, Kind.ANNOTATION_TYPE)) {
      // Field class declaration
      checkVariables(((ClassTree) tree).members());
    } else if (tree.is(Kind.BLOCK, Kind.STATIC_INITIALIZER)) {
      // Local variable declaration (in method, static initialization, ...)
      checkVariables(((BlockTree) tree).body());
    } else if (tree.is(Kind.CASE_GROUP)) {
      checkVariables(((CaseGroupTree) tree).body());
    }
  }

  private void checkVariables(List<? extends Tree> trees) {
    boolean varSameDeclaration = false;
    int lastVarLine = -1;
    List<VariableTree> nodesToReport = new ArrayList<>();

    for (Tree tree : trees) {
      if (tree.is(Tree.Kind.VARIABLE)) {
        VariableTree varTree = (VariableTree) tree;
        int line = LineUtils.startLine(varTree.simpleName().identifierToken());
        if (varSameDeclaration || lastVarLine == line) {
          nodesToReport.add(varTree);
        } else {
          reportIfIssue(nodesToReport);
        }
        varSameDeclaration = "","".equals(varTree.endToken().text());
        lastVarLine = line;
      }
    }
    reportIfIssue(nodesToReport);
  }

  private void reportIfIssue(List<VariableTree> nodesToReport) {
    if (!nodesToReport.isEmpty()) {
      IdentifierTree firstLocation = nodesToReport.get(0).simpleName();
      String moreThanOneMessage = nodesToReport.size() > 1 ? "" and all following declarations"" : """";
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(firstLocation)
        .withMessage(""Declare \""%s\""%s on a separate line."", firstLocation.name(), moreThanOneMessage)
        .withSecondaries(nodesToReport.stream().skip(1).map(lit -> new JavaFileScannerContext.Location("""", lit.simpleName())).toList())
        .withQuickFix(() -> getQuickFixes(nodesToReport))
        .report();

      nodesToReport.clear();
    }
  }

  private JavaQuickFix getQuickFixes(List<VariableTree> nodesToReport) {
    List<JavaTextEdit> edits = new ArrayList<>();
    SyntaxToken previousToken = QuickFixHelper.previousToken(nodesToReport.get(0));

    for (VariableTree variableTree : nodesToReport) {
      String indentationOfLine = indentationOfLine(variableTree);
      edits.add(getEditForVariable(variableTree, previousToken, indentationOfLine));
      previousToken = variableTree.lastToken();
    }

    return JavaQuickFix.newQuickFix(""Declare on separated lines"")
      .addTextEdits(edits)
      .build();
  }

  private JavaTextEdit getEditForVariable(VariableTree variableTree, SyntaxToken previousToken, String indentationOfLine) {
    if ("","".equals(previousToken.text())) {
      return JavaTextEdit.replaceTextSpan(textSpanBetween(previousToken, true, variableTree.simpleName(), false),
        String.format("";\n%s%s "", indentationOfLine, modifiersAndType(variableTree)));
    } else {
      return JavaTextEdit.replaceTextSpan(textSpanBetween(previousToken, false, variableTree, false),
        String.format(""\n%s"", indentationOfLine));
    }
  }

  private String modifiersAndType(VariableTree variableTree) {
    ModifiersTree modifiers = variableTree.modifiers();
    if (modifiers.isEmpty()) {
      return QuickFixHelper.contentForTree(variableTree.type(), context);
    }
    return QuickFixHelper.contentForRange(variableTree.modifiers().firstToken(), variableTree.type().lastToken(), context);
  }

  private String indentationOfLine(Tree tree) {
    Matcher matcher = INDENTATION_PATTERN.matcher(context.getFileLines()
      .get(LineUtils.startLine(tree) - 1));
    if (matcher.find()) {
      return matcher.group();
    }
    return """";
  }
}
"
S1694,CODE_SMELL,An abstract class should have both abstract and concrete methods,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

import java.util.Collection;
import java.util.Collections;
import java.util.List;

@Rule(key = ""S1694"")
public class AbstractClassWithoutAbstractMethodCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Symbol.TypeSymbol typeSymbol = classTree.symbol();
    if (typeSymbol.isAbstract()) {
      Collection<Symbol> members = typeSymbol.memberSymbols();
      int nbAbstractMethod = countAbstractMethods(members);
      // don't count this and super as members
      int nbOfMembers = members.size();
      if (hasDefaultConstructor(members)) {
        //remove default constructor from members
        nbOfMembers -=1;
      }
      if (isExtendingObject(classTree) && nbAbstractMethod == nbOfMembers) {
        // emtpy abstract class or only abstract method
        context.reportIssue(this, classTree.simpleName(), ""Convert this \"""" + typeSymbol.name() + ""\"" class to an interface"");
      }
      if (nbOfMembers > 0 && nbAbstractMethod == 0 && !isPartialImplementation(classTree)) {
        // Not empty abstract class with no abstract method
        context.reportIssue(this, classTree.simpleName(), ""Convert this \"""" + typeSymbol.name() + ""\"" class to a concrete class with a private constructor"");
      }
    }
  }

  private static boolean hasDefaultConstructor(Collection<Symbol> members) {
    for (Symbol member : members) {
      if (""<init>"".equals(member.name()) && member.declaration() == null) {
        return true;
      }
    }
    return false;
  }

  private static boolean isExtendingObject(ClassTree tree) {
    TypeTree superClass = tree.superClass();
    return superClass == null || superClass.symbolType().is(""java.lang.Object"");
  }

  private static boolean isPartialImplementation(ClassTree tree) {
    return tree.superClass() != null || !tree.superInterfaces().isEmpty();
  }

  private static int countAbstractMethods(Collection<? extends Symbol> symbols) {
    int abstractMethod = 0;
    for (Symbol sym : symbols) {
      if (isAbstractMethod(sym)) {
        abstractMethod++;
      }
    }
    return abstractMethod;
  }

  private static boolean isAbstractMethod(Symbol sym) {
    return sym.isMethodSymbol() && sym.isAbstract();
  }
}
"
S1695,CODE_SMELL,"""NullPointerException"" should not be explicitly thrown","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

@Rule(key = ""S1695"")
public class NPEThrowCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.THROW_STATEMENT, Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.THROW_STATEMENT)) {
      ExpressionTree expressionTree = ((ThrowStatementTree) tree).expression();
      raiseIssueOnNpe(expressionTree, expressionTree.symbolType());
    } else {
      for (TypeTree throwClause : ((MethodTree) tree).throwsClauses()) {
        raiseIssueOnNpe(throwClause, throwClause.symbolType());
      }
    }
  }

  private void raiseIssueOnNpe(Tree tree, Type type) {
    if (type.is(""java.lang.NullPointerException"")) {
      reportIssue(treeAtFault(tree), ""Throw some other exception here, such as \""IllegalArgumentException\""."");
    }
  }

  private static Tree treeAtFault(Tree tree) {
    return tree.is(Tree.Kind.NEW_CLASS) ? ((NewClassTree) tree).identifier() : tree;
  }

}
"
S1696,CODE_SMELL,"""NullPointerException"" should not be caught","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.UnionTypeTree;

@Rule(key = ""S1696"")
public class CatchNPECheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitCatch(CatchTree tree) {
    super.visitCatch(tree);

    Tree typeTree = tree.parameter().type();

    if (typeTree.is(Kind.UNION_TYPE)) {
      ((UnionTypeTree) typeTree).typeAlternatives().forEach(this::checkType);
    } else {
      checkType(typeTree);
    }
  }

  private void checkType(Tree tree) {
    if (tree.is(Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) tree;
      if (isNPE(identifier.name())) {
        addIssue(identifier);
      }
    } else if (tree.is(Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree memberSelectTree = (MemberSelectExpressionTree) tree;
      if (isNPE(memberSelectTree.identifier().name())) {
        checkJavaLangNPE(memberSelectTree);
      }
    }
  }

  private void checkJavaLangNPE(MemberSelectExpressionTree memberSelectTree) {
    ExpressionTree expression = memberSelectTree.expression();
    if (expression.is(Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mse = (MemberSelectExpressionTree) expression;
      if (""lang"".equals(mse.identifier().name()) && mse.expression().is(Kind.IDENTIFIER) && ""java"".equals(((IdentifierTree) mse.expression()).name())) {
        addIssue(memberSelectTree.identifier());
      }
    }
  }

  private static boolean isNPE(String name) {
    return ""NullPointerException"".equals(name);
  }

  private void addIssue(IdentifierTree tree) {
    context.reportIssue(this, tree, ""Avoid catching NullPointerException."");
  }

}
"
S1698,CODE_SMELL,"""=="" and ""!="" should not be used when ""equals"" is overridden","package org.sonar.java.checks;

import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;

@Rule(key = ""S1698"")
public class CompareObjectWithEqualsCheck extends CompareWithEqualsVisitor {

  private static final String JAVA_LANG_OBJECT = ""java.lang.Object"";
  private static final MethodMatchers EQUALS_MATCHER = MethodMatchers.create().ofAnyType().names(""equals"").addParametersMatcher(JAVA_LANG_OBJECT).build();

  @Override
  protected void checkEqualityExpression(BinaryExpressionTree tree) {
    ExpressionTree leftExpression = tree.leftOperand();
    ExpressionTree rightExpression = tree.rightOperand();
    Type leftOpType = leftExpression.symbolType();
    Type rightOpType = rightExpression.symbolType();
    if (!isExcluded(leftOpType, rightOpType) && hasObjectOperand(leftOpType, rightOpType)
      && neitherIsThis(leftExpression, rightExpression)
      && bothImplementsEqualsMethod(leftOpType, rightOpType)
      && neitherIsPublicStaticFinal(leftExpression, rightExpression)) {
      reportIssue(tree.operatorToken());
    }
  }

  private static boolean neitherIsThis(ExpressionTree leftExpression, ExpressionTree rightExpression) {
    return !ExpressionUtils.isThis(leftExpression) && !ExpressionUtils.isThis(rightExpression);
  }

  private static boolean neitherIsPublicStaticFinal(ExpressionTree leftOperand, ExpressionTree rightOperand) {
    if (compatibleTypes(leftOperand, rightOperand)) {
      return !isFinal(leftOperand) && !isFinal(rightOperand);
    }
    return true;
  }

  private static boolean compatibleTypes(ExpressionTree leftOperand, ExpressionTree rightOperand) {
    return leftOperand.symbolType().equals(rightOperand.symbolType());
  }

  private static boolean isFinal(ExpressionTree tree) {
    return symbol(tree)
      .filter(Symbol::isFinal)
      .isPresent();
  }

  private static Optional<Symbol> symbol(ExpressionTree tree) {
    switch (tree.kind()) {
      case IDENTIFIER:
        return Optional.of(((IdentifierTree) tree).symbol());
      case MEMBER_SELECT:
        return Optional.of(((MemberSelectExpressionTree) tree).identifier().symbol());
      default:
        return Optional.empty();
    }
  }

  private static boolean hasObjectOperand(Type leftOpType, Type rightOpType) {
    return isObject(leftOpType) || isObject(rightOpType);
  }

  private static boolean isExcluded(Type leftOpType, Type rightOpType) {
    return isNullComparison(leftOpType, rightOpType)
      || isNumericalComparison(leftOpType, rightOpType)
      || isJavaLangClassComparison(leftOpType, rightOpType)
      || isObjectType(leftOpType, rightOpType)
      || isStringType(leftOpType, rightOpType)
      || isBoxedType(leftOpType, rightOpType);
  }

  private static boolean isObjectType(Type leftOpType, Type rightOpType) {
    return leftOpType.is(JAVA_LANG_OBJECT) || rightOpType.is(JAVA_LANG_OBJECT);
  }

  private static boolean isObject(Type operandType) {
    return operandType.erasure().isClass() && !operandType.symbol().isEnum();
  }

  private static boolean isNumericalComparison(Type leftOperandType, Type rightOperandType) {
    return leftOperandType.isNumerical() || rightOperandType.isNumerical();
  }

  private static boolean isJavaLangClassComparison(Type leftOpType, Type rightOpType) {
    return leftOpType.is(""java.lang.Class"") || rightOpType.is(""java.lang.Class"");
  }

  private static boolean bothImplementsEqualsMethod(Type leftOpType, Type rightOpType) {
    return implementsEqualsMethod(leftOpType) && implementsEqualsMethod(rightOpType);
  }

  private static boolean implementsEqualsMethod(Type type) {
    Symbol.TypeSymbol symbol = type.symbol();
    return hasEqualsMethod(symbol) || parentClassImplementsEquals(symbol);
  }

  private static boolean parentClassImplementsEquals(Symbol.TypeSymbol symbol) {
    Type superClass = symbol.superClass();
    while (superClass != null && superClass.symbol().isTypeSymbol()) {
      Symbol.TypeSymbol superClassSymbol = superClass.symbol();
      if (!superClass.is(JAVA_LANG_OBJECT) && hasEqualsMethod(superClassSymbol)) {
        return true;
      }
      superClass = superClassSymbol.superClass();
    }
    return false;
  }

  private static boolean hasEqualsMethod(Symbol.TypeSymbol symbol) {
    return symbol.lookupSymbols(""equals"").stream().anyMatch(EQUALS_MATCHER::matches);
  }
}
"
S1699,CODE_SMELL,Constructors should only call non-overridable methods,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S1699"")
public class ConstructorCallingOverridableCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree m = (MethodTree) tree;
    Symbol.TypeSymbol constructorType = m.symbol().enclosingClass();
    if (!constructorType.isFinal()) {
      ((MethodTree) tree).block().accept(new ConstructorBodyVisitor(constructorType));
    }
  }

  private class ConstructorBodyVisitor extends BaseTreeVisitor {

    private Symbol.TypeSymbol constructorType;

    public ConstructorBodyVisitor(Symbol.TypeSymbol constructorType) {
      this.constructorType = constructorType;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      IdentifierTree methodIdentifier = null;
      boolean isInvocationOnSelf = false;
      ExpressionTree methodSelect = tree.methodSelect();
      if (methodSelect.is(Tree.Kind.IDENTIFIER)) {
        methodIdentifier = (IdentifierTree) methodSelect;
        isInvocationOnSelf = !isThisOrSuper(methodIdentifier);
      } else if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) methodSelect;
        methodIdentifier = memberSelect.identifier();
        isInvocationOnSelf = isThis(memberSelect.expression());
      }
      if (isInvocationOnSelf) {
        Symbol symbol = methodIdentifier.symbol();
        if (symbol.isMethodSymbol() && ((Symbol.MethodSymbol) symbol).isOverridable() && isMethodDefinedOnConstructedType(symbol)) {
          reportIssue(methodIdentifier, ""Remove this call from a constructor to the overridable \"""" + methodIdentifier.name() + ""\"" method."");
        }
      }
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // skip lambdas
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      // skip new class
    }

    private boolean is(ExpressionTree expression, String match) {
      if (expression.is(Tree.Kind.IDENTIFIER)) {
        String targetName = ((IdentifierTree) expression).name();
        return match.equals(targetName);
      }
      return false;
    }

    private boolean isThis(ExpressionTree expression) {
      return is(expression, ""this"");
    }

    private boolean isThisOrSuper(ExpressionTree expression) {
      return is(expression, ""this"") || is(expression, ""super"");
    }

    private boolean isMethodDefinedOnConstructedType(Symbol symbol) {
      Type typeDefiningMethod = symbol.enclosingClass().type().erasure();
      for (Type superType : constructorType.superTypes()) {
        if (superType.erasure().equals(typeDefiningMethod)) {
          return true;
        }
      }
      return constructorType.type().erasure().equals(typeDefiningMethod);
    }
  }

}
"
S1700,CODE_SMELL,A field should not duplicate the name of its containing class,"package org.sonar.java.checks.naming;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1700"")
public class FieldNameMatchingTypeNameCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;
  private String currentClassName;
  private final Set<Tree> fields = new HashSet<>();

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    currentClassName = """";
    fields.clear();
    if (context.getSemanticModel() != null) {
      scan(context.getTree());
    }
  }

  @Override
  public void visitClass(ClassTree tree) {
    IdentifierTree simpleName = tree.simpleName();
    if (simpleName != null) {
      Symbol.TypeSymbol classSymbol = tree.symbol();
      Collection<Symbol> members = classSymbol.memberSymbols();
      for (Symbol sym : members) {
        if (sym.isVariableSymbol() && !staticFieldSameType(classSymbol, sym)) {
          //Exclude static fields of the same type.
          fields.add(((Symbol.VariableSymbol) sym).declaration());
        }
      }
      currentClassName = simpleName.name();
    }
    super.visitClass(tree);
    currentClassName = """";
    fields.clear();
  }

  private static boolean staticFieldSameType(Symbol classSymbol, Symbol sym) {
    return sym.type().equals(classSymbol.type()) && sym.isStatic();
  }

  @Override
  public void visitVariable(VariableTree tree) {
    String name = tree.simpleName().name();
    if (fields.contains(tree) && currentClassName.equalsIgnoreCase(name)) {
      context.reportIssue(this, tree.simpleName(), ""Rename field \"""" + name + ""\"""");
    }
    super.visitVariable(tree);
  }
}
"
S1710,CODE_SMELL,Annotation repetitions should not be wrapped,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.List;

@Rule(key = ""S1710"")
public class RepeatAnnotationCheck extends BaseTreeVisitor implements JavaFileScanner, JavaVersionAwareVisitor {

  private JavaFileScannerContext context;

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava8Compatible();
  }

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitAnnotation(AnnotationTree annotationTree) {
    if (isArrayInitialized(annotationTree)) {
      NewArrayTree arrayTree = (NewArrayTree) annotationTree.arguments().get(0);
      if (isAllSameAnnotation(arrayTree.initializers()) && isAnnotationRepeatable(arrayTree.initializers().get(0))) {
        context.reportIssue(
          this,
          annotationTree.annotationType(),
          ""Remove the '"" + getAnnotationName(annotationTree) + ""' wrapper from this annotation group"" + context.getJavaVersion().java8CompatibilityMessage());
      }
    }
    super.visitAnnotation(annotationTree);
  }

  private static boolean isAnnotationRepeatable(ExpressionTree expressionTree) {
    return expressionTree.symbolType().symbol().metadata().isAnnotatedWith(""java.lang.annotation.Repeatable"");
  }

  private static boolean isAllSameAnnotation(List<ExpressionTree> initializers) {
    if (initializers.isEmpty()) {
      return false;
    }
    String annotationName = getAnnotationName(initializers.get(0));
    if(annotationName.isEmpty()){
      return false;
    }
    for (int i = 1; i < initializers.size(); i++) {
      if (!annotationName.equals(getAnnotationName(initializers.get(i)))) {
        return false;
      }
    }
    return true;
  }

  private static String getAnnotationName(ExpressionTree initializer) {
    String result = """";
    if (initializer.is(Tree.Kind.ANNOTATION)) {
      Tree annotationType = ((AnnotationTree) initializer).annotationType();
      if (annotationType.is(Tree.Kind.IDENTIFIER)) {
        result = ((IdentifierTree) annotationType).name();
      } else if (annotationType.is(Tree.Kind.MEMBER_SELECT)) {
        result = fullName((MemberSelectExpressionTree) annotationType);
      }
    }
    return result;
  }

  private static String fullName(MemberSelectExpressionTree tree) {
    if (tree.expression().is(Tree.Kind.IDENTIFIER)) {
      return ((IdentifierTree) tree.expression()).name() + ""."" + tree.identifier().name();
    }
    return fullName((MemberSelectExpressionTree) tree.expression()) + ""."" + tree.identifier().name();
  }

  private static boolean isArrayInitialized(AnnotationTree annotationTree) {
    return annotationTree.arguments().size() == 1 && annotationTree.arguments().get(0).is(Tree.Kind.NEW_ARRAY);
  }
}
"
S1711,CODE_SMELL,Standard functional interfaces should not be redefined,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Symbol.MethodSymbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1711"")
public class StandardFunctionalInterfaceCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers OBJECT_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofAnyType()
      .names(""equals"")
      .addParametersMatcher(""java.lang.Object"")
      .build(),
    MethodMatchers.create()
      .ofAnyType()
      .names(""getClass"", ""hashcode"", ""notify"", ""notifyAll"", ""toString"")
      .addWithoutParametersMatcher()
      .build(),
    MethodMatchers.create()
      .ofAnyType()
      .names(""wait"")
      .addWithoutParametersMatcher()
      .addParametersMatcher(""long"")
      .addParametersMatcher(""long"", ""int"")
      .build());

  private static final Set<String> STD_INTERFACE_NAMES = new HashSet<>();

  private static final Map<Integer, List<FunctionalInterface>> STD_INTERFACE_BY_PARAMETER_COUNT = new HashMap<>();

  static {
    registerInterface(""java.util.function.BiConsumer<T,U>"", ""void"", ""T"", ""U"");
    registerInterface(""java.util.function.BiFunction<T,U,R>"", ""R"", ""T"", ""U"");
    registerInterface(""java.util.function.BinaryOperator<T>"", ""T"", ""T"", ""T"");
    registerInterface(""java.util.function.BiPredicate<T,U>"", ""boolean"", ""T"", ""U"");
    registerInterface(""java.util.function.BooleanSupplier"", ""boolean"");
    registerInterface(""java.util.function.Consumer<T>"", ""void"", ""T"");
    registerInterface(""java.util.function.DoubleBinaryOperator"", ""double"", ""double"", ""double"");
    registerInterface(""java.util.function.DoubleConsumer"", ""void"", ""double"");
    registerInterface(""java.util.function.DoubleFunction<R>"", ""R"", ""double"");
    registerInterface(""java.util.function.DoublePredicate"", ""boolean"", ""double"");
    registerInterface(""java.util.function.DoubleSupplier"", ""double"");
    registerInterface(""java.util.function.DoubleToIntFunction"", ""int"", ""double"");
    registerInterface(""java.util.function.DoubleToLongFunction"", ""long"", ""double"");
    registerInterface(""java.util.function.DoubleUnaryOperator"", ""double"", ""double"");
    registerInterface(""java.util.function.Function<T,R>"", ""R"", ""T"");
    registerInterface(""java.util.function.IntBinaryOperator"", ""int"", ""int"", ""int"");
    registerInterface(""java.util.function.IntConsumer"", ""void"", ""int"");
    registerInterface(""java.util.function.IntFunction<R>"", ""R"", ""int"");
    registerInterface(""java.util.function.IntPredicate"", ""boolean"", ""int"");
    registerInterface(""java.util.function.IntSupplier"", ""int"");
    registerInterface(""java.util.function.IntToDoubleFunction"", ""double"", ""int"");
    registerInterface(""java.util.function.IntToLongFunction"", ""long"", ""int"");
    registerInterface(""java.util.function.IntUnaryOperator"", ""int"", ""int"");
    registerInterface(""java.util.function.LongBinaryOperator"", ""long"", ""long"", ""long"");
    registerInterface(""java.util.function.LongConsumer"", ""void"", ""long"");
    registerInterface(""java.util.function.LongFunction<R>"", ""R"", ""long"");
    registerInterface(""java.util.function.LongPredicate"", ""boolean"", ""long"");
    registerInterface(""java.util.function.LongSupplier"", ""long"");
    registerInterface(""java.util.function.LongToDoubleFunction"", ""double"", ""long"");
    registerInterface(""java.util.function.LongToIntFunction"", ""int"", ""long"");
    registerInterface(""java.util.function.LongUnaryOperator"", ""long"", ""long"");
    registerInterface(""java.util.function.ObjDoubleConsumer<T>"", ""void"", ""T"", ""double"");
    registerInterface(""java.util.function.ObjIntConsumer<T>"", ""void"", ""T"", ""int"");
    registerInterface(""java.util.function.ObjLongConsumer<T>"", ""void"", ""T"", ""long"");
    registerInterface(""java.util.function.Predicate<T>"", ""boolean"", ""T"");
    registerInterface(""java.util.function.Supplier<T>"", ""T"");
    registerInterface(""java.util.function.ToDoubleBiFunction<T,U>"", ""double"", ""T"", ""U"");
    registerInterface(""java.util.function.ToDoubleFunction<T>"", ""double"", ""T"");
    registerInterface(""java.util.function.ToIntBiFunction<T,U>"", ""int"", ""T"", ""U"");
    registerInterface(""java.util.function.ToIntFunction<T>"", ""int"", ""T"");
    registerInterface(""java.util.function.ToLongBiFunction<T,U>"", ""long"", ""T"", ""U"");
    registerInterface(""java.util.function.ToLongFunction<T>"", ""long"", ""T"");
    registerInterface(""java.util.function.UnaryOperator<T>"", ""T"", ""T"");

    // Each list of FunctionalInterface has to be sorted ascending by number of parametrized types so that smallest number
    // of parametrized types take precedence. For example UnaryOperator<String> and Function<String,String> are equivalent,
    // but UnaryOperator is preferred.
    STD_INTERFACE_BY_PARAMETER_COUNT.values().forEach(list -> list.sort((a, b) -> Integer.compare(a.getGenericTypeCount(), b.getGenericTypeCount())));
  }

  private static void registerInterface(String name, String returnType, String... parameters) {
    FunctionalInterface functionalInterface = new FunctionalInterface(name, returnType, parameters);
    STD_INTERFACE_NAMES.add(functionalInterface.getName());
    STD_INTERFACE_BY_PARAMETER_COUNT.computeIfAbsent(functionalInterface.getParameterCount(), key -> new ArrayList<>()).add(functionalInterface);
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.INTERFACE);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    // classTree.simpleName() never null for Tree.Kind.INTERFACE
    IdentifierTree issueLocation = classTree.simpleName();
    // The question ""Why we raise issue only for interface annotated with @FunctionalInterface?""
    // is discussed in comments of https://jira.sonarsource.com/browse/SONARJAVA-504
    Optional.of(classTree)
      .filter(StandardFunctionalInterfaceCheck::isFunctionalInterface)
      .filter(StandardFunctionalInterfaceCheck::isNonStandardFunctionalInterface)
      .filter(StandardFunctionalInterfaceCheck::hasNoExtension)
      .flatMap(StandardFunctionalInterfaceCheck::lookupFunctionalMethod)
      .flatMap(StandardFunctionalInterfaceCheck::lookupMatchingStandardInterface)
      .ifPresent(standardInterface -> reportIssue(issueLocation, buildIssueMessage(classTree, standardInterface.replace('$', '.'))));
  }

  private static boolean isFunctionalInterface(ClassTree tree) {
    return tree.symbol().metadata().isAnnotatedWith(""java.lang.FunctionalInterface"");
  }

  private static boolean isNonStandardFunctionalInterface(ClassTree tree) {
    return !STD_INTERFACE_NAMES.contains(tree.symbol().type().fullyQualifiedName());
  }

  private static boolean hasNoExtension(ClassTree tree) {
    return tree.superInterfaces().isEmpty();
  }

  private static Optional<MethodSymbol> lookupFunctionalMethod(ClassTree interfaceTree) {
    return interfaceTree.symbol().memberSymbols().stream()
        .filter(Symbol::isMethodSymbol)
        .map(MethodSymbol.class::cast)
        .filter(MethodSymbol::isAbstract)
        .filter(StandardFunctionalInterfaceCheck::isNotObjectMethod)
        .findFirst();
  }

  private static Optional<String> lookupMatchingStandardInterface(MethodSymbol functionalMethod) {
    MethodTree declaration = functionalMethod.declaration();
    if (!functionalMethod.thrownTypes().isEmpty() || (declaration != null && !declaration.typeParameters().isEmpty())) {
      return Optional.empty();
    }
    Type returnType = declaration != null ? declaration.returnType().symbolType() : functionalMethod.returnType().type();
    return STD_INTERFACE_BY_PARAMETER_COUNT.getOrDefault(functionalMethod.parameterTypes().size(), Collections.emptyList()).stream()
        .map(standardInterface -> standardInterface.matchingSpecialization(functionalMethod, returnType))
        .filter(Objects::nonNull)
        .findFirst();
  }

  private static String buildIssueMessage(ClassTree interfaceTree, String standardInterface) {
    if (interfaceTree.members().size() <= 1) {
      return ""Drop this interface in favor of \"""" + standardInterface + ""\""."";
    }
    return ""Make this interface extend \"""" + standardInterface + ""\"" and remove the functional method declaration."";
  }

  private static boolean isNotObjectMethod(MethodSymbol method) {
    MethodTree declaration = method.declaration();
    return declaration == null || !OBJECT_METHODS.matches(declaration);
  }

  private static class FunctionalInterface {

    private final String name;
    private final List<String> genericTypes;
    private final String returnType;
    private final List<String> parameters;

    private FunctionalInterface(String name, String returnType, String... parameters) {
      int genericStart = name.indexOf('<');
      if (genericStart != -1) {
        this.name = name.substring(0, genericStart);
        this.genericTypes = Arrays.asList(name.substring(genericStart + 1, name.length() - 1).split("",""));
      } else {
        this.name = name;
        this.genericTypes = Collections.emptyList();
      }
      this.returnType = returnType;
      this.parameters = Arrays.asList(parameters);
    }

    private String getName() {
      return name;
    }

    private int getGenericTypeCount() {
      return genericTypes.size();
    }

    private int getParameterCount() {
      return parameters.size();
    }

    @CheckForNull
    private String matchingSpecialization(MethodSymbol method, Type actualReturnType) {
      Map<String, String> genericTypeMapping = genericTypes.isEmpty() ? Collections.emptyMap() : new HashMap<>();
      String expectedReturnType = convertGenericType(returnType, actualReturnType, genericTypeMapping);
      if (!expectedReturnType.equals(actualReturnType.fullyQualifiedName())) {
        return null;
      }
      List<Type> methodParameters = method.parameterTypes();
      for (int i = 0; i < parameters.size(); i++) {
        Type actualType = methodParameters.get(i);
        String expectedType = convertGenericType(parameters.get(i), actualType, genericTypeMapping);
        if (!expectedType.equals(actualType.fullyQualifiedName())) {
          return null;
        }
      }
      return buildSpecializationName(genericTypeMapping);
    }

    private String convertGenericType(String expectedType, Type actualType, Map<String, String> genericTypeMapping) {
      if (genericTypes.isEmpty() || !genericTypes.contains(expectedType)) {
        return expectedType;
      }
      String convertedType = genericTypeMapping.get(expectedType);
      if (convertedType == null) {
        if (actualType.isPrimitive() || actualType.isVoid() || actualType.isArray() || actualType.isUnknown()) {
          return ""!unknown!"";
        }
        convertedType = actualType.fullyQualifiedName();
        genericTypeMapping.put(expectedType, convertedType);
      }
      return convertedType;
    }

    private String buildSpecializationName(Map<String, String> genericTypeMapping) {
      if (genericTypes.isEmpty()) {
        return name;
      }
      StringBuilder genericName = new StringBuilder();
      genericName.append(name);
      genericName.append('<');
      boolean addComma = false;
      for (String genericType : genericTypes) {
        if (addComma) {
          genericName.append(',');
        } else {
          addComma = true;
        }
        String typeName = genericTypeMapping.getOrDefault(genericType, genericType);
        int packageEnd = typeName.lastIndexOf('.');
        if (packageEnd != -1) {
          typeName = typeName.substring(packageEnd + 1);
        }
        genericName.append(typeName);
      }
      genericName.append('>');
      return genericName.toString();
    }

  }

}
"
S1751,BUG,Loops with at most one iteration should be refactored,"package org.sonar.java.checks;


import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.cfg.CFG;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.BreakStatementTree;
import org.sonar.plugins.java.api.tree.ContinueStatementTree;
import org.sonar.plugins.java.api.tree.DoWhileStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

@Rule(key = ""S1751"")
public class LoopExecutingAtMostOnceCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers NEXT_ELEMENT = MethodMatchers.or(
    MethodMatchers.create().ofSubTypes(""java.util.Enumeration"").names(""hasMoreElements"").addWithoutParametersMatcher().build(),
    MethodMatchers.create().ofSubTypes(""java.util.Iterator"").names(""hasNext"").addWithoutParametersMatcher().build());

  private static final Tree.Kind[] LOOP_KINDS = {
    Tree.Kind.DO_STATEMENT,
    Tree.Kind.WHILE_STATEMENT,
    Tree.Kind.FOR_STATEMENT,
    Tree.Kind.FOR_EACH_STATEMENT
  };

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.BREAK_STATEMENT,
      Tree.Kind.RETURN_STATEMENT,
      Tree.Kind.THROW_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    Tree parent = tree.parent();
    while (parent.is(Tree.Kind.BLOCK)) {
      parent = parent.parent();
    }

    if (!parent.is(LOOP_KINDS)) {
      return;
    }

    if (!isWhileNextElementLoop(parent) && !isEmptyConditionLoop(parent) && executeUnconditionnally(parent)) {
      SyntaxToken jumpKeyword = jumpKeyword(tree);
      reportIssue(jumpKeyword, String.format(""Remove this \""%s\"" statement or make it conditional."", jumpKeyword.text()));
    }
  }private static boolean isEmptyConditionLoop(Tree loopTree) {
    switch (loopTree.kind()) {
      case FOR_STATEMENT:
        ForStatementTree fst = (ForStatementTree) loopTree;
        return fst.initializer().isEmpty() && fst.condition() == null && fst.update().isEmpty();
      case WHILE_STATEMENT:
        // 'while(false)' does not compile, unreachable code
        return isTrue(((WhileStatementTree) loopTree).condition());
      case DO_STATEMENT:
        // only target true literal, which needs a break statement.
        // For a 'do {...} while (false);', loop the jump is useless and issue should be raised.
        return isTrue(((DoWhileStatementTree) loopTree).condition());
      default:
        // variable and expression of For-Each statement can not be empty
        return false;
    }
  }

  private static boolean isTrue(ExpressionTree expressionTree) {
    ExpressionTree expr = ExpressionUtils.skipParentheses(expressionTree);
    return LiteralUtils.isTrue(expr);
  }private static boolean isWhileNextElementLoop(Tree loopTree) {
    if (loopTree.is(Tree.Kind.WHILE_STATEMENT)) {
      ExpressionTree condition = ExpressionUtils.skipParentheses(((WhileStatementTree) loopTree).condition());
      return condition.is(Tree.Kind.METHOD_INVOCATION) && NEXT_ELEMENT.matches((MethodInvocationTree) condition);
    }
    return false;
  }

  private static boolean executeUnconditionnally(Tree loopTree) {
    CFG cfg = getCFG(loopTree);
    CFG.Block loopBlock = getLoopBlock(cfg, loopTree);
    // we cannot find a path in the CFG that goes twice through this instruction.
    return !hasPredecessorInBlock(loopBlock, loopTree);
  }

  private static CFG.Block getLoopBlock(CFG cfg, Tree loopTree) {
    return cfg.blocks().stream()
      .filter(block -> loopTree.equals(block.terminator()))
      .findFirst()
      .orElseThrow(() -> new IllegalStateException(""CFG necessarily contains the loop block.""));
  }

  private static boolean hasPredecessorInBlock(CFG.Block block, Tree loop) {
    for (CFG.Block predecessor : block.predecessors()) {
      List<Tree> predecessorElements = predecessor.elements();
      if (predecessorElements.isEmpty()) {
        return hasPredecessorInBlock(predecessor, loop);
      } else {
        Tree predecessorFirstElement = predecessorElements.get(0);

        if (isForStatementInitializer(predecessorFirstElement, loop)) {
          // skip 'for' loops initializers
          continue;
        }

        if (isForStatementUpdate(predecessorFirstElement, loop)) {
          // there is no way to reach the 'for' loop update
          return !predecessor.predecessors().isEmpty();
        }

        if (isDescendant(predecessorFirstElement, loop)) {
          return true;
        }
      }
    }
    return false;
  }

  private static boolean isForStatementInitializer(Tree lastElement, Tree loop) {
    if (loop.is(Tree.Kind.FOR_STATEMENT)) {
      return isDescendant(lastElement, ((ForStatementTree) loop).initializer());
    }
    return loop.is(Tree.Kind.FOR_EACH_STATEMENT) && isDescendant(lastElement, ((ForEachStatement) loop).expression());
  }

  private static boolean isForStatementUpdate(Tree lastElement, Tree loop) {
    return loop.is(Tree.Kind.FOR_STATEMENT) && isDescendant(lastElement, ((ForStatementTree) loop).update());
  }

  private static boolean isDescendant(Tree descendant, Tree target) {
    Tree parent = descendant;
    while (parent != null) {
      if (parent.equals(target)) {
        return true;
      }
      parent = parent.parent();
    }
    return false;
  }

  private static SyntaxToken jumpKeyword(Tree jumpStatement) {
    switch (jumpStatement.kind()) {
      case BREAK_STATEMENT:
        return ((BreakStatementTree) jumpStatement).breakKeyword();
      case CONTINUE_STATEMENT:
        return ((ContinueStatementTree) jumpStatement).continueKeyword();
      case RETURN_STATEMENT:
        return ((ReturnStatementTree) jumpStatement).returnKeyword();
      case THROW_STATEMENT:
        return ((ThrowStatementTree) jumpStatement).throwKeyword();
      default:
        throw new IllegalStateException(""Unexpected jump statement."");
    }
  }

  private static CFG getCFG(Tree loop) {
    Tree currentTree = loop;
    do {
      currentTree = currentTree.parent();
    } while (!currentTree.is(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR, Tree.Kind.LAMBDA_EXPRESSION, Tree.Kind.INITIALIZER, Tree.Kind.STATIC_INITIALIZER));

    switch(currentTree.kind()) {
      case METHOD:
      case CONSTRUCTOR:
        return (CFG) ((MethodTree) currentTree).cfg();
      case LAMBDA_EXPRESSION:
        return (CFG) ((LambdaExpressionTree) currentTree).cfg();
      default:
        return CFG.buildCFG(((BlockTree) currentTree).body());
    }
  }
}
"
S1764,BUG,Identical expressions should not be used on both sides of a binary operator,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1764"")
public class IdenticalOperandOnBinaryExpressionCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_LANG_OBJECT = ""java.lang.Object"";
  private static final String SECONDARY_MESSAGE = ""Identical sub-expression."";

  private static final MethodMatchers EQUALS_MATCHER = MethodMatchers.create()
    .ofAnyType()
    .names(""equals"")
    .addParametersMatcher(JAVA_LANG_OBJECT)
    .build();

  private static final MethodMatchers OBJECTS_EQUALS_MATCHER = MethodMatchers.create()
    .ofTypes(""java.util.Objects"")
    .names(""equals"", ""deepEquals"")
    .addParametersMatcher(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT)
    .build();private static final Set<Tree.Kind> SYMMETRIC_OPERATORS = SetUtils.immutableSetOf(
    Tree.Kind.EQUAL_TO,
    Tree.Kind.NOT_EQUAL_TO,
    Tree.Kind.AND,
    Tree.Kind.XOR,
    Tree.Kind.OR,
    Tree.Kind.CONDITIONAL_AND,
    Tree.Kind.CONDITIONAL_OR);

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.DIVIDE,
      Tree.Kind.REMAINDER,
      Tree.Kind.MINUS,
      Tree.Kind.LEFT_SHIFT,
      Tree.Kind.RIGHT_SHIFT,
      Tree.Kind.UNSIGNED_RIGHT_SHIFT,
      Tree.Kind.LESS_THAN,
      Tree.Kind.GREATER_THAN,
      Tree.Kind.LESS_THAN_OR_EQUAL_TO,
      Tree.Kind.GREATER_THAN_OR_EQUAL_TO,
      Tree.Kind.EQUAL_TO,
      Tree.Kind.NOT_EQUAL_TO,
      Tree.Kind.AND,
      Tree.Kind.XOR,
      Tree.Kind.OR,
      Tree.Kind.CONDITIONAL_AND,
      Tree.Kind.CONDITIONAL_OR,
      Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      checkEqualsMethods(mit);
      return;
    }
    BinaryExpressionTree binaryExpressionTree = (BinaryExpressionTree) tree;
    ExpressionTree rightOperand = binaryExpressionTree.rightOperand();
    ExpressionTree equivalentOperand = equivalentOperand(binaryExpressionTree, rightOperand);
    if (equivalentOperand != null) {
      reportIssue(
        rightOperand,
        ""Correct one of the identical sub-expressions on both sides of operator \"""" + binaryExpressionTree.operatorToken().text() + ""\"""",
        Collections.singletonList(new JavaFileScannerContext.Location(SECONDARY_MESSAGE, equivalentOperand)),
        null);
    }
  }

  private void checkEqualsMethods(MethodInvocationTree mit) {
    if(EQUALS_MATCHER.matches(mit)) {
      if(mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
        ExpressionTree leftOp = ((MemberSelectExpressionTree) mit.methodSelect()).expression();
        ExpressionTree rightOp = mit.arguments().get(0);
        if(SyntacticEquivalence.areEquivalent(leftOp, rightOp)) {
          reportIssue(
            rightOp,
            ""Correct one of the identical sub-expressions on both sides of equals."",
            Collections.singletonList(new JavaFileScannerContext.Location(SECONDARY_MESSAGE, leftOp)),
            null);
        }
      }
    } else if (OBJECTS_EQUALS_MATCHER.matches(mit)) {
      ExpressionTree leftOp = mit.arguments().get(0);
      ExpressionTree rightOp = mit.arguments().get(1);
      if(SyntacticEquivalence.areEquivalent(leftOp, rightOp)) {
        reportIssue(
          rightOp,
          ""Correct one of the identical argument sub-expressions."",
          Collections.singletonList(new JavaFileScannerContext.Location(SECONDARY_MESSAGE, leftOp)),
          null);
      }
    }
  }

  @CheckForNull
  public static ExpressionTree equivalentOperand(BinaryExpressionTree tree, ExpressionTree rightOperand) {
    if (isNanTest(tree) || isLeftShiftOnOne(tree)) {
      return null;
    }
    return equivalentOperand(tree.leftOperand(), rightOperand, tree.kind());
  }

  public static ExpressionTree equivalentOperand(ExpressionTree left, ExpressionTree right, Tree.Kind binaryKind) {
    if (SyntacticEquivalence.areEquivalent(left, right)) {
      return left;
    }
    // Check other operands if operator is symmetric.
    if (SYMMETRIC_OPERATORS.contains(binaryKind) && left.is(binaryKind)) {
      ExpressionTree equivalent = equivalentOperand(((BinaryExpressionTree) left).leftOperand(), right, binaryKind);
      if (equivalent != null) {
        return equivalent;
      }
      return equivalentOperand(((BinaryExpressionTree) left).rightOperand(), right, binaryKind);
    }
    return null;
  }

  private static boolean isNanTest(BinaryExpressionTree tree) {
    Type leftOperandType = tree.leftOperand().symbolType();
    return tree.is(Tree.Kind.NOT_EQUAL_TO) && (leftOperandType.isPrimitive(Type.Primitives.FLOAT) || leftOperandType.isPrimitive(Type.Primitives.DOUBLE));
  }

  private static boolean isLeftShiftOnOne(BinaryExpressionTree tree) {
    // 1 << 1 is used for bit masks construction and should be excluded.
    if (tree.is(Tree.Kind.LEFT_SHIFT) && tree.leftOperand().is(Tree.Kind.INT_LITERAL) && tree.rightOperand().is(Tree.Kind.INT_LITERAL)) {
      String left = ((LiteralTree) tree.leftOperand()).value();
      String right = ((LiteralTree) tree.rightOperand()).value();
      if (""1"".equals(right) && ""1"".equals(left)) {
        return true;
      }
    }
    return false;
  }

}
"
S1774,CODE_SMELL,The ternary operator should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1774"")
public class TernaryOperatorCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CONDITIONAL_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    reportIssue(((ConditionalExpressionTree) tree).questionToken(), ""Convert this usage of the ternary operator to an \""if\""/\""else\"" structure."");
  }
}
"
S1820,CODE_SMELL,Classes should not have too many fields,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Arrays;
import java.util.List;

import static org.sonar.java.checks.helpers.ExpressionsHelper.reportOnClassTree;

@Rule(key = ""S1820"")
public class ClassFieldCountCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_THRESHOLD = 20;
  private static final boolean DEFAULT_COUNT_NON_PUBLIC_FIELDS = true;

  @RuleProperty(key = ""maximumFieldThreshold"", description = ""The maximum number of fields"", defaultValue = """" + DEFAULT_THRESHOLD)
  private int threshold = DEFAULT_THRESHOLD;

  @RuleProperty(key = ""countNonpublicFields"", description = ""Whether or not to include non-public fields in the count"", defaultValue = """" + DEFAULT_COUNT_NON_PUBLIC_FIELDS)
  private boolean countNonPublicFields = DEFAULT_COUNT_NON_PUBLIC_FIELDS;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.INTERFACE, Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    long fieldCount = classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.VARIABLE) && shouldBeCounted((VariableTree) member))
      .count();
    if (fieldCount > threshold) {
      String message = String.format(""Refactor this class so it has no more than %d %sfields, rather than the %d it currently has."", threshold,
        countNonPublicFields ? """" : ""public "", fieldCount);
      reportIssue(reportOnClassTree(classTree), message);
    }
  }

  private boolean shouldBeCounted(VariableTree variableTree) {
    Symbol symbol = variableTree.symbol();
    if (symbol.isStatic() && symbol.isFinal()) {
      return false;
    }
    return countNonPublicFields || symbol.isPublic();
  }

  public void setThreshold(int threshold) {
    this.threshold = threshold;
  }

  public void setCountNonPublicFields(boolean countNonPublicFields) {
    this.countNonPublicFields = countNonPublicFields;
  }
}
"
S1821,CODE_SMELL,"""switch"" statements and expressions should not be nested","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.SwitchExpressionTree;
import org.sonar.plugins.java.api.tree.SwitchStatementTree;
import org.sonar.plugins.java.api.tree.SwitchTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1821"")
public class NestedSwitchCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.SWITCH_STATEMENT, Tree.Kind.SWITCH_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    NestedSwitchVisitor visitor = new NestedSwitchVisitor();
    ((SwitchTree) tree).cases()
      .forEach(c -> c.accept(visitor));
  }

  private class NestedSwitchVisitor extends BaseTreeVisitor {

    @Override
    public void visitClass(ClassTree tree) {
      // skip nested and anonymous Classes
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // skip Lambdas
    }

    @Override
    public void visitSwitchStatement(SwitchStatementTree tree) {
      reportNestedSwitch(tree);
    }

    @Override
    public void visitSwitchExpression(SwitchExpressionTree tree) {
      reportNestedSwitch(tree);
    }

    private void reportNestedSwitch(SwitchTree switchTree) {
      reportIssue(switchTree.switchKeyword(), ""Refactor the code to eliminate this nested \""switch\""."");
    }
  }
}
"
S1844,CODE_SMELL,"""Object.wait"" should not be called on objects that implement ""java.util.concurrent.locks.Condition""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;

@Rule(key = ""S1844"")
public class WaitOnConditionCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofSubTypes(""java.util.concurrent.locks.Condition"")
      .names(""wait"")
      .addWithoutParametersMatcher()
      .addParametersMatcher(""long"")
      .addParametersMatcher(""long"", ""int"")
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""The \""Condition.await(...)\"" method should be used instead of \""Object.wait(...)\"""");
  }

  @Override
  protected void onMethodReferenceFound(MethodReferenceTree methodReferenceTree) {
    reportIssue(methodReferenceTree.method(), ""The \""Condition.await(...)\"" method should be used instead of \""Object.wait(...)\"""");
  }
}
"
S1845,CODE_SMELL,Methods and field names should not be the same or differ only by capitalization,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1845"")
public class MembersDifferOnlyByCapitalizationCheck extends IssuableSubscriptionVisitor {

  private static final String ISSUE_MESSAGE = ""Rename %s \""%s\"" to prevent any misunderstanding/clash with %s \""%s\""%s."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.INTERFACE, Tree.Kind.ENUM, Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    List<Symbol> allMembers = retrieveMembers(classTree.symbol());
    Map<String, List<Symbol>> membersByName = allMembers.stream().collect(Collectors.groupingBy(Symbol::name));
    for (Tree member : classTree.members()) {
      if (member.is(Tree.Kind.METHOD)) {
        MethodTree methodTree = (MethodTree) member;
        checkForIssue(methodTree.symbol(), methodTree.simpleName(), membersByName);
      } else if (member.is(Tree.Kind.VARIABLE)) {
        VariableTree variableTree = (VariableTree) member;
        checkForIssue(variableTree.symbol(), variableTree.simpleName(), membersByName);
      }
    }
  }

  private void checkForIssue(Symbol symbol, IdentifierTree reportTree, Map<String, List<Symbol>> membersByName) {
    String name = symbol.name();
    for (Map.Entry<String, List<Symbol>> knownMemberName : membersByName.entrySet()) {
      if (name.equalsIgnoreCase(knownMemberName.getKey())) {
        Optional<Symbol> firstConflict = knownMemberName.getValue().stream()
          .filter(knownMemberSymbol -> !symbol.equals(knownMemberSymbol) && isValidIssueLocation(symbol, knownMemberSymbol) && isInvalidMember(symbol, knownMemberSymbol))
          .findFirst();

        if (firstConflict.isPresent()) {
          Symbol conflictingSymbol = firstConflict.get();
          reportIssue(reportTree, issueMessage(symbol, knownMemberName, conflictingSymbol), declarationTree(conflictingSymbol), null);
          // We report one issue per problematic member, with a single secondary location.
          break;
        }
      }
    }
  }

  private static String issueMessage(Symbol symbol, Map.Entry<String, List<Symbol>> knownMemberName, Symbol conflictingSymbol) {
    return String.format(ISSUE_MESSAGE,
      getSymbolKindName(symbol),
      symbol.name(),
      getSymbolKindName(conflictingSymbol),
      knownMemberName.getKey(),
      getDefinitionPlace(symbol, conflictingSymbol));
  }

  private static List<JavaFileScannerContext.Location> declarationTree(Symbol symbol) {
    Tree reportTree = null;
    if (symbol.isMethodSymbol()) {
      MethodTree declaration = ((Symbol.MethodSymbol) symbol).declaration();
      if (declaration != null) {
        reportTree = declaration.simpleName();
      }
    } else if (symbol.isVariableSymbol()) {
      VariableTree declaration = ((Symbol.VariableSymbol) symbol).declaration();
      if (declaration != null) {
        reportTree = declaration.simpleName();
      }
    }
    if (reportTree == null) {
      return Collections.emptyList();
    }
    return Collections.singletonList(new JavaFileScannerContext.Location(""Conflicting identifier"", reportTree));
  }

  private static boolean isOverriding(Symbol symbol) {
    if (symbol.isMethodSymbol()) {
      MethodTree methodDeclaration = (MethodTree) symbol.declaration();
      return methodDeclaration != null && Boolean.TRUE.equals(methodDeclaration.isOverriding());
    }
    return false;
  }

  private static boolean isInvalidMember(Symbol currentMember, Symbol knownMember) {
    if (!isOverriding(currentMember)) {
      return differentSymbolKinds(currentMember, knownMember) ? invalidMethodAndVariable(currentMember, knownMember) : !sameName(currentMember, knownMember);
    }
    return false;
  }

  private static boolean invalidMethodAndVariable(Symbol currentMember, Symbol knownMember) {
    if (!sameVisibilityNotPrivate(currentMember, knownMember)) {
      return false;
    }
    Symbol methodSymbol = currentMember.isMethodSymbol() ? currentMember : knownMember;
    Symbol variableSymbol = methodSymbol == currentMember ? knownMember : currentMember;
    return !methodReturningVariableWithSameName(methodSymbol, variableSymbol)
      && !isBuilderPattern(methodSymbol, variableSymbol);
  }

  private static boolean isBuilderPattern(Symbol methodSymbol, Symbol variableSymbol) {
    return methodSymbol.owner().name().endsWith(""Builder"") && sameName(methodSymbol, variableSymbol);
  }

  private static boolean methodReturningVariableWithSameName(Symbol methodSymbol, Symbol variableSymbol) {
    if (!sameName(variableSymbol, methodSymbol)) {
      return false;
    }
    Tree declaration = methodSymbol.declaration();
    if (declaration != null) {
      ReturnVisitor returnVisitor = new ReturnVisitor(variableSymbol);
      declaration.accept(returnVisitor);
      return returnVisitor.singleReturnWithVariableSymbol();
    }
    return false;
  }

  private static boolean isValidIssueLocation(Symbol currentMember, Symbol knownMember) {
    return !sameOwner(currentMember, knownMember) || isOverriding(knownMember) || getDeclarationLine(currentMember) > getDeclarationLine(knownMember);
  }

  private static boolean sameVisibilityNotPrivate(Symbol s1, Symbol s2) {
    return bothPublic(s1, s2) || bothProtected(s1, s2) || bothPackageVisibility(s1, s2);
  }

  private static boolean bothPackageVisibility(Symbol s1, Symbol s2) {
    return s1.isPackageVisibility() && s2.isPackageVisibility();
  }

  private static boolean bothProtected(Symbol s1, Symbol s2) {
    return s1.isProtected() && s2.isProtected();
  }

  private static boolean bothPublic(Symbol s1, Symbol s2) {
    return s1.isPublic() && s2.isPublic();
  }

  private static boolean sameOwner(Symbol currentMember, Symbol knownMember) {
    return currentMember.owner().equals(knownMember.owner());
  }

  private static boolean sameName(Symbol currentMember, Symbol knownMember) {
    return currentMember.name().equals(knownMember.name());
  }

  private static boolean differentSymbolKinds(Symbol s1, Symbol s2) {
    return variableAndMethod(s1, s2) || variableAndMethod(s2, s1);
  }

  private static boolean variableAndMethod(Symbol s1, Symbol s2) {
    return s1.isVariableSymbol() && s2.isMethodSymbol();
  }

  private static String getDefinitionPlace(Symbol symbol, Symbol knownMemberSymbol) {
    if (sameOwner(symbol, knownMemberSymbol)) {
      return """";
    }
    Symbol owner = knownMemberSymbol.owner();
    return "" defined in "" + (owner.isInterface() ? ""interface"" : ""superclass"") + "" \"""" + owner.type().fullyQualifiedName() + ""\"""";
  }

  private static int getDeclarationLine(Symbol symbol) {
    if (symbol.declaration() == null) {
      return -1;
    }
    if (symbol.isVariableSymbol()) {
      return LineUtils.startLine(((Symbol.VariableSymbol) symbol).declaration().simpleName().identifierToken());
    }
    return LineUtils.startLine(((Symbol.MethodSymbol) symbol).declaration().simpleName().identifierToken());
  }

  private static String getSymbolKindName(Symbol symbol) {
    return symbol.isMethodSymbol() ? ""method"" : ""field"";
  }

  private static List<Symbol> retrieveMembers(Symbol.TypeSymbol classSymbol) {
    List<Symbol> results = new LinkedList<>();
    results.addAll(extractMembers(classSymbol, false));

    for (Type parentInterface : classSymbol.interfaces()) {
      results.addAll(extractMembers(parentInterface.symbol(), true));
    }
    Type superClass = classSymbol.superClass();
    if (superClass != null) {
      results.addAll(extractMembers(superClass.symbol(), true));
    }

    return results;
  }

  private static List<Symbol> extractMembers(Symbol.TypeSymbol classSymbol, boolean ignorePrivate) {
    List<Symbol> results = new LinkedList<>();
    for (Symbol symbol : classSymbol.memberSymbols()) {
      if ((isVariableToExtract(symbol) || isMethodToExtract(symbol)) && !(symbol.isPrivate() && ignorePrivate)) {
        results.add(symbol);
      }
    }
    return results;
  }

  private static boolean isVariableToExtract(Symbol symbol) {
    String name = symbol.name();
    return !symbol.isEnum() && symbol.isVariableSymbol() && !""this"".equals(name) && !""super"".equals(name);
  }

  private static boolean isMethodToExtract(Symbol symbol) {
    return symbol.isMethodSymbol() && !""<init>"".equals(symbol.name());
  }

  private static class ReturnVisitor extends BaseTreeVisitor {

    private final Symbol variableSymbol;
    private boolean returnsVariable;
    private int returnCount;

    ReturnVisitor(Symbol variableSymbol) {
      this.variableSymbol = variableSymbol;
    }

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      returnCount++;
      ExpressionTree returnExpression = tree.expression();
      if (returnExpression != null && returnExpression.is(Tree.Kind.IDENTIFIER)) {
        returnsVariable = ((IdentifierTree) returnExpression).symbol().equals(variableSymbol);
      }
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // not interested in returns in lambda bodies
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      // not interested in anonymous class bodies
    }

    boolean singleReturnWithVariableSymbol() {
      return returnCount == 1 && returnsVariable;
    }
  }
}
"
S1849,BUG,"""Iterator.hasNext()"" should not call ""Iterator.next()""","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S1849"")
public class HasNextCallingNextCheck extends IssuableSubscriptionVisitor {

  private HasNextBodyVisitor hasNextBodyVisitor = new HasNextBodyVisitor();

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (methodTree.block() != null && isHasNextMethod(methodTree)) {
      hasNextBodyVisitor.setHasNextOwner(methodTree.symbol().owner());
      methodTree.block().accept(hasNextBodyVisitor);
    }
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    super.setContext(context);
    hasNextBodyVisitor.clearHasNextOwner();
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    hasNextBodyVisitor.clearHasNextOwner();
  }

  private static boolean isHasNextMethod(MethodTree methodTree) {
    return ""hasNext"".equals(methodTree.simpleName().name()) && methodTree.parameters().isEmpty() && isIteratorMethod(methodTree.symbol());
  }

  private static boolean isIteratorMethod(Symbol method) {
    Type type = method.owner().enclosingClass().type();
    return !type.is(""java.util.Iterator"") && type.isSubtypeOf(""java.util.Iterator"");
  }

  private class HasNextBodyVisitor extends BaseTreeVisitor {

    private Symbol hasNextOwner;

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      Symbol method = tree.methodSymbol();
      if (""next"".equals(method.name())
        && tree.arguments().isEmpty()
        && isIteratorMethod(method)
        && (hasNextOwner == method.owner() || hasNextOwner.type().isSubtypeOf(method.owner().type()))) {
        reportIssue(ExpressionUtils.methodName(tree), ""Refactor the implementation of this \""Iterator.hasNext()\"" method to not call \""Iterator.next()\""."");
      }
      super.visitMethodInvocation(tree);
    }

    public void setHasNextOwner(Symbol hasNextOwner) {
      this.hasNextOwner = hasNextOwner;
    }

    public void clearHasNextOwner() {
      this.hasNextOwner = null;
    }

    @Override
    public void visitClass(ClassTree tree) {
      // Don't visit nested classes
    }

  }

}
"
S1854,CODE_SMELL,Unused assignments should be removed,"package org.sonar.java.checks;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.cfg.CFG;
import org.sonar.java.cfg.LiveVariables;
import org.sonar.java.cfg.VariableReadExtractor;
import org.sonar.java.checks.helpers.UnresolvedIdentifiersVisitor;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1854"")
public class DeadStoreCheck extends IssuableSubscriptionVisitor {

  private static final UnresolvedIdentifiersVisitor UNRESOLVED_IDENTIFIERS_VISITOR = new UnresolvedIdentifiersVisitor();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (methodTree.block() == null) {
      return;
    }

    // TODO(npe) Exclude try statements with finally as CFG is incorrect for those and lead to false positive
    if (hasTryFinallyWithLocalVar(methodTree.block(), methodTree.symbol())) {
      return;
    }

    UNRESOLVED_IDENTIFIERS_VISITOR.check(methodTree);

    Symbol.MethodSymbol methodSymbol = methodTree.symbol();
    CFG cfg = (CFG) methodTree.cfg();
    LiveVariables liveVariables = LiveVariables.analyze(cfg);
    // Liveness analysis provides information only for block boundaries, so we should do analysis between elements within blocks
    for (CFG.Block block : cfg.blocks()) {
      checkElements(block, liveVariables.getOut(block), methodSymbol);
    }
  }

  private void checkElements(CFG.Block block, Set<Symbol> blockOut, Symbol.MethodSymbol methodSymbol) {
    Set<Symbol> out = new HashSet<>(blockOut);
    Set<Tree> assignmentLHS = new HashSet<>();
    new ArrayDeque<>(block.elements()).descendingIterator().forEachRemaining(
      element -> checkElement(methodSymbol, out, assignmentLHS, element)
    );
  }

  private Set<Symbol> checkElement(Symbol.MethodSymbol methodSymbol, Set<Symbol> outVar, Set<Tree> assignmentLHS, Tree element) {
    Set<Symbol> out = outVar;
    switch (element.kind()) {
      case PLUS_ASSIGNMENT:
      case DIVIDE_ASSIGNMENT:
      case MINUS_ASSIGNMENT:
      case MULTIPLY_ASSIGNMENT:
      case OR_ASSIGNMENT:
      case XOR_ASSIGNMENT:
      case AND_ASSIGNMENT:
      case LEFT_SHIFT_ASSIGNMENT:
      case RIGHT_SHIFT_ASSIGNMENT:
      case UNSIGNED_RIGHT_SHIFT_ASSIGNMENT:
      case REMAINDER_ASSIGNMENT:
      case ASSIGNMENT:
        handleAssignment(out, assignmentLHS, (AssignmentExpressionTree) element);
        break;
      case IDENTIFIER:
        handleIdentifier(out, assignmentLHS, (IdentifierTree) element);
        break;
      case VARIABLE:
        handleVariable(out, (VariableTree) element);
        break;
      case NEW_CLASS:
        handleNewClass(out, methodSymbol, (NewClassTree) element);
        break;
      case LAMBDA_EXPRESSION:
        LambdaExpressionTree lambda = (LambdaExpressionTree) element;
        out.addAll(getUsedLocalVarInSubTree(lambda.body(), methodSymbol));
        break;
      case METHOD_REFERENCE:
        MethodReferenceTree methodRef = (MethodReferenceTree) element;
        out.addAll(getUsedLocalVarInSubTree(methodRef.expression(), methodSymbol));
        break;
      case TRY_STATEMENT:
        handleTryStatement(out, methodSymbol, (TryStatementTree) element);
        break;
      case PREFIX_DECREMENT:
      case PREFIX_INCREMENT:
        handlePrefixExpression(out, (UnaryExpressionTree) element);
        break;
      case POSTFIX_INCREMENT:
      case POSTFIX_DECREMENT:
        handlePostfixExpression(out, (UnaryExpressionTree) element);
        break;
      case CLASS:
      case ENUM:
      case ANNOTATION_TYPE:
      case INTERFACE:
        ClassTree classTree = (ClassTree) element;
        out.addAll(getUsedLocalVarInSubTree(classTree, methodSymbol));
        break;
      default:
        // Ignore instructions that does not affect liveness of variables
    }
    return out;
  }

  private void handleAssignment(Set<Symbol> out, Set<Tree> assignmentLHS, AssignmentExpressionTree element) {
    ExpressionTree lhs = ExpressionUtils.skipParentheses(element.variable());
    if (lhs.is(Tree.Kind.IDENTIFIER)) {
      Symbol symbol = ((IdentifierTree) lhs).symbol();
      if (symbol.isLocalVariable()
        && !out.contains(symbol)
        && (element.is(Tree.Kind.ASSIGNMENT) || isParentExpressionStatement(element))
        && !UNRESOLVED_IDENTIFIERS_VISITOR.isUnresolved(symbol.name())) {
        createIssue(element.operatorToken(), element.expression(), symbol);
      }
      assignmentLHS.add(lhs);
      if (element.is(Tree.Kind.ASSIGNMENT)) {
        out.remove(symbol);
      } else {
        out.add(symbol);
      }
    }
  }

  private static boolean isParentExpressionStatement(Tree element) {
    return element.parent().is(Tree.Kind.EXPRESSION_STATEMENT);
  }

  private static void handleIdentifier(Set<Symbol> out, Set<Tree> assignmentLHS, IdentifierTree element) {
    Symbol symbol = element.symbol();
    if (!assignmentLHS.contains(element) && symbol.isLocalVariable()) {
      out.add(symbol);
    }
  }

  private void handleVariable(Set<Symbol> out, VariableTree localVar) {
    Symbol symbol = localVar.symbol();
    ExpressionTree initializer = localVar.initializer();
    if (initializer != null
      && !isUsualDefaultValue(initializer)
      && !out.contains(symbol)
      && !UNRESOLVED_IDENTIFIERS_VISITOR.isUnresolved(symbol.name())) {
      createIssue(localVar.equalToken(), initializer, symbol);
    }
    out.remove(symbol);
  }

  private static boolean isUsualDefaultValue(ExpressionTree tree) {
    ExpressionTree expr = ExpressionUtils.skipParentheses(tree);
    switch (expr.kind()) {
      case BOOLEAN_LITERAL:
      case NULL_LITERAL:
        return true;
      case STRING_LITERAL:
        return LiteralUtils.isEmptyString(expr);
      case INT_LITERAL:
        String value = ((LiteralTree) expr).value();
        return ""0"".equals(value) || ""1"".equals(value);
      case UNARY_MINUS:
      case UNARY_PLUS:
        return isUsualDefaultValue(((UnaryExpressionTree) expr).expression());
      default:
        return false;
    }
  }

  private static void handleNewClass(Set<Symbol> out, Symbol.MethodSymbol methodSymbol, NewClassTree element) {
    ClassTree body = element.classBody();
    if (body != null) {
      out.addAll(getUsedLocalVarInSubTree(body, methodSymbol));
    }
  }

  private static void handleTryStatement(Set<Symbol> out, Symbol.MethodSymbol methodSymbol, TryStatementTree element) {
    AssignedLocalVarVisitor visitor = new AssignedLocalVarVisitor();
    element.block().accept(visitor);
    out.addAll(visitor.assignedLocalVars);
    for (CatchTree catchTree : element.catches()) {
      out.addAll(getUsedLocalVarInSubTree(catchTree, methodSymbol));
    }
  }

  private void handlePrefixExpression(Set<Symbol> out, UnaryExpressionTree element) {
    // within each block, each produced value is consumed or by following elements or by terminator
    ExpressionTree expression = element.expression();
    if (isParentExpressionStatement(element) && expression.is(Tree.Kind.IDENTIFIER)) {
      Symbol symbol = ((IdentifierTree) expression).symbol();
      if (symbol.isLocalVariable() && !out.contains(symbol)) {
        createIssue(element, symbol);
      }
    }
  }

  private void handlePostfixExpression(Set<Symbol> out, UnaryExpressionTree element) {
    ExpressionTree expression = ExpressionUtils.skipParentheses(element.expression());
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      Symbol symbol = ((IdentifierTree) expression).symbol();
      if (symbol.isLocalVariable() && !out.contains(symbol)) {
        createIssue(element, symbol);
      }
    }
  }

  private void createIssue(Tree element, Symbol symbol) {
    reportIssue(element, getMessage(symbol));
  }

  private void createIssue(Tree startTree, Tree endTree, Symbol symbol) {
    reportIssue(startTree, endTree, getMessage(symbol));
  }

  private static String getMessage(Symbol symbol) {
    return ""Remove this useless assignment to local variable \"""" + symbol.name() + ""\""."";
  }

  private static Set<Symbol> getUsedLocalVarInSubTree(Tree tree, Symbol.MethodSymbol methodSymbol) {
    VariableReadExtractor localVarExtractor = new VariableReadExtractor(methodSymbol, false);
    tree.accept(localVarExtractor);
    return localVarExtractor.usedVariables();
  }

  private static boolean hasTryFinallyWithLocalVar(BlockTree block, Symbol.MethodSymbol methodSymbol) {
    TryVisitor tryVisitor = new TryVisitor(methodSymbol);
    block.accept(tryVisitor);
    return tryVisitor.hasTryFinally;
  }

  private static class TryVisitor extends BaseTreeVisitor {

    boolean hasTryFinally = false;
    Symbol.MethodSymbol methodSymbol;

    TryVisitor(Symbol.MethodSymbol methodSymbol) {
      this.methodSymbol = methodSymbol;
    }

    @Override
    public void visitTryStatement(TryStatementTree tree) {
      BlockTree finallyBlock = tree.finallyBlock();
      hasTryFinally |= (finallyBlock != null && !getUsedLocalVarInSubTree(finallyBlock, methodSymbol).isEmpty()) || !tree.resourceList().isEmpty();
      if (!hasTryFinally) {
        super.visitTryStatement(tree);
      }
    }

    @Override
    public void visitClass(ClassTree tree) {
      // ignore inner classes
    }
  }

  private static class AssignedLocalVarVisitor extends BaseTreeVisitor {
    List<Symbol> assignedLocalVars = new ArrayList<>();

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      ExpressionTree lhs = ExpressionUtils.skipParentheses(tree.variable());
      if (lhs.is(Tree.Kind.IDENTIFIER)) {
        Symbol symbol = ((IdentifierTree) lhs).symbol();
        if (symbol.isLocalVariable()) {
          assignedLocalVars.add(symbol);
        }
        super.visitAssignmentExpression(tree);
      }
    }
  }
}
"
S1858,CODE_SMELL,"""toString()"" should never be called on a String object","package org.sonar.java.checks;

import java.util.Objects;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ArrayAccessExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.ParenthesizedTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@Rule(key = ""S1858"")
public class StringToStringCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.lang.String"")
      .names(""toString"")
      .addWithoutParametersMatcher()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree tree) {
    ExpressionTree expressionRaw = ((MemberSelectExpressionTree) tree.methodSelect()).expression();
    ExpressionTree expressionTree = extractBaseExpression(expressionRaw);
    Tree reportTree = null;
    String message = null;
    if (expressionTree.is(Tree.Kind.IDENTIFIER)) {
      reportTree = expressionTree;
      message = String.format(""\""%s\"" is already a string, there's no need to call \""toString()\"" on it."",
        ((IdentifierTree) expressionTree).identifierToken().text());
    } else if (expressionTree.is(Tree.Kind.STRING_LITERAL)) {
      reportTree = expressionTree;
      message = ""there's no need to call \""toString()\"" on a string literal."";
    } else if (expressionTree.is(Tree.Kind.TEXT_BLOCK)) {
      reportTree = expressionTree;
      message =  ""there's no need to call \""toString()\"" on a text block."";
    } else if (expressionTree.is(Tree.Kind.METHOD_INVOCATION)) {
      IdentifierTree methodName = ExpressionUtils.methodName((MethodInvocationTree) expressionTree);
      reportTree = methodName;
      message = ""\"""" + methodName + ""\"" returns a string, there's no need to call \""toString()\""."";
    } else if (expressionTree.is(Tree.Kind.ARRAY_ACCESS_EXPRESSION)) {
      ArrayAccessExpressionTree arrayAccess = (ArrayAccessExpressionTree) expressionTree;
      IdentifierTree name = extractName(arrayAccess.expression());
      if (name == null) {
        reportTree = arrayAccess.expression();
        message = ""There's no need to call \""toString()\"" on an array of String."";
      } else {
        reportTree = name;
        message = String.format(""\""%s\"" is an array of strings, there's no need to call \""toString()\""."", name.identifierToken().text());
      }
    }
    reportIssue(reportTree, message, tree, expressionRaw);
  }

  private void reportIssue(@Nullable Tree reportTree, @Nullable String message, MethodInvocationTree toStringInvocation, ExpressionTree baseExpression) {
    if (reportTree != null) {
      Objects.requireNonNull(message, ""Message should always be set with a report tree."");
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(reportTree)
        .withMessage(message)
        .withQuickFix(() -> JavaQuickFix.newQuickFix(""Remove \""toString()\"""")
          .addTextEdit(JavaTextEdit.removeTextSpan(textSpanBetween(baseExpression, false, toStringInvocation, true)))
          .build())
        .report();
    }
  }

  private static ExpressionTree extractBaseExpression(ExpressionTree tree) {
    ExpressionTree expressionTree = tree;
    while (true) {
      if (expressionTree.is(Tree.Kind.MEMBER_SELECT)) {
        expressionTree = ((MemberSelectExpressionTree) expressionTree).identifier();
      } else if (expressionTree.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {
        expressionTree = ((ParenthesizedTree) expressionTree).expression();
      } else if (expressionTree.is(Tree.Kind.TYPE_CAST)) {
        expressionTree = ((TypeCastTree) expressionTree).expression();
      } else {
        return expressionTree;
      }
    }
  }

  private static IdentifierTree extractName(ExpressionTree tree) {
    ExpressionTree expressionTree = extractBaseExpression(tree);
    if (expressionTree.is(Tree.Kind.IDENTIFIER)) {
      return (IdentifierTree) expressionTree;
    }
    return null;
  }

}
"
S1860,BUG,Synchronization should not be done on instances of value-based classes,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S1860"")
public class SynchronizationOnStringOrBoxedCheck extends IssuableSubscriptionVisitor {
  
  private static final MethodMatchers FORBIDDEN_MATCHERS = MethodMatchers.create()
    .ofTypes(""java.util.List"", ""java.util.Map"", ""java.util.Set"")
    .names(""of"", ""copyOf"", ""ofEntries"", ""entry"")
    .withAnyParameters()
    .build();
  
  private static final List<String> FORBIDDEN_SUBTYPES = Collections.singletonList(""java.lang.ProcessHandle"");
  
  private static final Set<String> FORBIDDEN_TYPES = SetUtils.immutableSetOf(
    ""java.lang.Boolean"",
    ""java.lang.Byte"",
    ""java.lang.Character"",
    ""java.lang.Double"",
    ""java.lang.Float"",
    ""java.lang.Integer"",
    ""java.lang.Long"",
    ""java.lang.Short"",
    ""java.lang.String"",
    ""java.lang.Runtime.Version"",
    ""java.util.Optional"",
    ""java.util.OptionalInt"",
    ""java.util.OptionalLong"",
    ""java.util.OptionalDouble"",
    ""java.time.Instant"",
    ""java.time.LocalDate"",
    ""java.time.LocalTime"",
    ""java.time.LocalDateTime"",
    ""java.time.ZonedDateTime"",
    ""java.time.ZoneId"",
    ""java.time.OffsetTime"",
    ""java.time.OffsetDateTime"",
    ""java.time.ZoneOffset"",
    ""java.time.Duration"",
    ""java.time.Period"",
    ""java.time.Year"",
    ""java.time.YearMonth"",
    ""java.time.MonthDay"",
    ""java.time.chrono.MinguoDate"",
    ""java.time.chrono.HijrahDate"",
    ""java.time.chrono.ThaiBuddhistDate""
    );

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.SYNCHRONIZED_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    SynchronizedStatementTree syncStatement = (SynchronizedStatementTree) tree;
    ExpressionTree expression = syncStatement.expression();
    Type expressionType = expression.symbolType();
    if (expressionType.isPrimitive() || isForbiddenType(expressionType) || isInitializedWithImmutable(expression)) {
      reportIssue(expression, ""Synchronize on a new \""Object\"" instead."");
    }
  }

  private static boolean isForbiddenType(Type expressionType) {
    return FORBIDDEN_TYPES.contains(expressionType.fullyQualifiedName()) 
      || FORBIDDEN_SUBTYPES.stream().anyMatch(expressionType::isSubtypeOf);
  }
  
  private static boolean isInitializedWithImmutable(ExpressionTree tree) {
    if (tree.is(Kind.METHOD_INVOCATION)) {
      return FORBIDDEN_MATCHERS.matches(((MethodInvocationTree) tree));
    } else if (tree.is(Kind.IDENTIFIER)) {
      IdentifierTree identifierTree = (IdentifierTree) tree;
      return Optional.ofNullable(identifierTree.symbol().declaration())
        .filter(decl -> decl.is(Kind.VARIABLE))
        .map(VariableTree.class::cast)
        .flatMap(variable -> Optional.ofNullable(variable.initializer()))
        .filter(init -> init.is(Kind.METHOD_INVOCATION) && FORBIDDEN_MATCHERS.matches(((MethodInvocationTree) init)))
        .isPresent();
    }
    return false;
  }

}
"
S1862,BUG,"Related ""if/else if"" statements should not have the same condition","package org.sonar.java.checks;

import java.util.Collections;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1862"")
public class DuplicateConditionIfElseIfCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;

    scan(context.getTree());
  }

  @Override
  public void visitIfStatement(IfStatementTree tree) {
    ExpressionTree condition = tree.condition();

    StatementTree statement = tree.elseStatement();
    while (statement != null && statement.is(Tree.Kind.IF_STATEMENT)) {
      IfStatementTree ifStatement = (IfStatementTree) statement;
      if (areTriviallyEquivalent(condition, ifStatement.condition())) {
        context.reportIssue(
          this,
          ifStatement.condition(),
          ""This branch can not be reached because the condition duplicates a previous condition in the same sequence of \""if/else if\"" statements"",
          Collections.singletonList(new JavaFileScannerContext.Location(""Original"", condition)),
          null
        );
      }
      statement = ifStatement.elseStatement();
    }

    super.visitIfStatement(tree);
  }

  private static boolean areTriviallyEquivalent(ExpressionTree condition1, ExpressionTree condition2) {
    ExpressionTree cleanCondition1 = ExpressionUtils.skipParentheses(condition1);
    ExpressionTree cleanCondition2 = ExpressionUtils.skipParentheses(condition2);
    if (cleanCondition1.is(Tree.Kind.EQUAL_TO) && cleanCondition2.is(Tree.Kind.EQUAL_TO)) {
      BinaryExpressionTree binary1 = (BinaryExpressionTree) cleanCondition1;
      BinaryExpressionTree binary2 = (BinaryExpressionTree) cleanCondition2;
      // a == b
      return (areTriviallyEquivalent(binary1.leftOperand(), binary2.leftOperand())
        && areTriviallyEquivalent(binary1.rightOperand(), binary2.rightOperand()))
        // b == a
        || (areTriviallyEquivalent(binary1.leftOperand(), binary2.rightOperand())
        && areTriviallyEquivalent(binary1.rightOperand(), binary2.leftOperand()));
    }
    return SyntacticEquivalence.areEquivalent(cleanCondition1, cleanCondition2);
  }

}
"
S1871,CODE_SMELL,Two branches in a conditional structure should not have exactly the same implementation,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SwitchTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1871"")
public class IdenticalCasesInSwitchCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.SWITCH_STATEMENT, Tree.Kind.SWITCH_EXPRESSION, Tree.Kind.IF_STATEMENT);
  }

  @Override
  public void visitNode(Tree node) {
    if (node.is(Tree.Kind.SWITCH_STATEMENT, Tree.Kind.SWITCH_EXPRESSION)) {
      SwitchTree switchTree = (SwitchTree) node;
      Map<CaseGroupTree, Set<CaseGroupTree>> identicalBranches = checkSwitchStatement(switchTree);
      boolean allBranchesSame = allBranchesSame(identicalBranches, switchTree.cases().size());
      boolean allBranchesSameWithoutDefault = allBranchesSame && !hasDefaultClause(switchTree);
      if (!allBranchesSame || allBranchesSameWithoutDefault) {
        identicalBranches.forEach((first, others) -> {
          if (!isTrivialCase(first.body()) || allBranchesSameWithoutDefault) {
            others.forEach(other -> createIssue(other, issueMessage(""case"", first), first));
          }
        });
      }
    } else if (node.is(Tree.Kind.IF_STATEMENT) && !node.parent().is(Tree.Kind.IF_STATEMENT)) {
      IfStatementTree ifStatement = (IfStatementTree) node;
      IfElseChain ifElseChain = checkIfStatement(ifStatement);
      reportIdenticalIfChainBranches(ifElseChain.branches, ifElseChain.totalBranchCount, hasElseClause(ifStatement));
    }
  }

  protected static boolean allBranchesSame(Map<? extends Tree, ? extends Set<? extends Tree>> identicalBranches, int size) {
    return identicalBranches.keySet().size() == 1 && identicalBranchesSize(identicalBranches) == size - 1;
  }

  private static long identicalBranchesSize(Map<? extends Tree, ? extends Set<? extends Tree>> identicalBranches) {
    return identicalBranches.values().stream().flatMap(Collection::stream).count();
  }

  private static boolean isTrivialCase(List<StatementTree> body) {
    return body.size() == 1 || (body.size() == 2 && body.get(1).is(Tree.Kind.BREAK_STATEMENT));
  }

  protected Map<CaseGroupTree, Set<CaseGroupTree>> checkSwitchStatement(SwitchTree node) {
    Map<CaseGroupTree, Set<CaseGroupTree>> identicalBranches = new HashMap<>();
    int index = 0;
    List<CaseGroupTree> cases = node.cases();
    Set<CaseGroupTree> duplicates = new HashSet<>();
    for (CaseGroupTree caseGroupTree : cases) {
      index++;
      if (duplicates.contains(caseGroupTree)) {
        continue;
      }
      for (int i = index; i < cases.size(); i++) {
        CaseGroupTree caseI = cases.get(i);
        if (SyntacticEquivalence.areEquivalent(caseGroupTree.body(), caseI.body())) {
          duplicates.add(caseI);
          identicalBranches.computeIfAbsent(caseGroupTree, k -> new HashSet<>()).add(caseI);
        }
      }
    }
    return identicalBranches;
  }

  protected static class IfElseChain {
    Map<StatementTree, Set<StatementTree>> branches = new HashMap<>();
    int totalBranchCount;
  }

  protected static IfElseChain checkIfStatement(IfStatementTree node) {
    IfElseChain ifElseChain = new IfElseChain();
    ifElseChain.totalBranchCount = 1;
    List<StatementTree> allBranches = new ArrayList<>();
    allBranches.add(node.thenStatement());
    StatementTree elseStatement = node.elseStatement();
    while (elseStatement != null && elseStatement.is(Tree.Kind.IF_STATEMENT)) {
      IfStatementTree ifStatement = (IfStatementTree) elseStatement;
      allBranches.add(ifStatement.thenStatement());
      elseStatement = ifStatement.elseStatement();
    }
    if (elseStatement != null) {
      allBranches.add(elseStatement);
    }
    return collectIdenticalBranches(allBranches);
  }

  private static IfElseChain collectIdenticalBranches(List<StatementTree> allBranches) {
    IfElseChain ifElseChain = new IfElseChain();
    Set<StatementTree> duplicates = new HashSet<>();
    for (int i = 0; i < allBranches.size(); i++) {
      if (duplicates.contains(allBranches.get(i))) {
        continue;
      }
      for (int j = i + 1; j < allBranches.size(); j++) {
        StatementTree statement1 = allBranches.get(i);
        StatementTree statement2 = allBranches.get(j);
        if (SyntacticEquivalence.areEquivalent(statement1, statement2)) {
          duplicates.add(statement2);
          ifElseChain.branches.computeIfAbsent(statement1, k -> new HashSet<>()).add(statement2);
        }
      }
    }
    ifElseChain.totalBranchCount = allBranches.size();
    return ifElseChain;
  }

  private void reportIdenticalIfChainBranches(Map<StatementTree, Set<StatementTree>> identicalBranches, int totalBranchCount, boolean withElseClause) {
    boolean allBranchesSame = allBranchesSame(identicalBranches, totalBranchCount);
    boolean allBranchesSameWithoutElse = allBranchesSame && !withElseClause;
    if (!allBranchesSame || allBranchesSameWithoutElse) {
      identicalBranches.forEach((first, others) -> {
        if (!isTrivialIfStatement(first) || allBranchesSameWithoutElse) {
          others.forEach(other -> createIssue(other, issueMessage(""branch"", first), first));
        }
      });
    }
  }

  private static boolean isTrivialIfStatement(StatementTree node) {
    return !node.is(Tree.Kind.BLOCK) || ((BlockTree) node).body().size() <= 1;
  }

  protected static boolean hasDefaultClause(SwitchTree switchStatement) {
    return switchStatement.cases().stream()
      .flatMap(caseGroupTree -> caseGroupTree.labels().stream())
      .anyMatch(caseLabelTree -> ""default"".equals(caseLabelTree.caseOrDefaultKeyword().text()));
  }

  protected static boolean hasElseClause(IfStatementTree ifStatement) {
    StatementTree elseStatement = ifStatement.elseStatement();
    while (elseStatement != null && elseStatement.is(Tree.Kind.IF_STATEMENT)) {
      elseStatement = ((IfStatementTree) elseStatement).elseStatement();
    }
    return elseStatement != null;
  }

  private void createIssue(Tree node, String message, Tree secondary) {
    reportIssue(node, message, Collections.singletonList(new JavaFileScannerContext.Location(""Original"", secondary)), null);
  }

  private static String issueMessage(String type, Tree node) {
    return String.format(""This %s's code block is the same as the block for the %s on line %d."", type, type, LineUtils.startLine(node));
  }

}
"
S1872,BUG,Classes should not be compared by name,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S1872"")
public class ClassComparedByNameCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofTypes(""java.lang.String"").names(""equals"").withAnyParameters().build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (!mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      return;
    }

    ExpressionTree firstOperand = ExpressionUtils.skipParentheses(((MemberSelectExpressionTree) mit.methodSelect()).expression());
    ExpressionTree secondOperand = ExpressionUtils.skipParentheses(mit.arguments().get(0));

    // Only check comparison for string literals and use of class#getName methods to avoid FP. Ref: SONARJAVA-2603
    boolean firstOpIsClassGetNameMethod = useClassGetNameMethod(firstOperand);
    boolean secondOpIsClassGetNameMethod = useClassGetNameMethod(secondOperand);

    if (firstOpIsClassGetNameMethod && secondOpIsClassGetNameMethod) {
      reportIssue(mit, ""Use \""isAssignableFrom\"" instead."");
    } else if ((firstOpIsClassGetNameMethod && secondOperand.is(Tree.Kind.STRING_LITERAL))
      || (secondOpIsClassGetNameMethod && firstOperand.is(Tree.Kind.STRING_LITERAL))) {
      reportIssue(mit, ""Use an \""instanceof\"" comparison instead."");
    }
  }

  private static boolean useClassGetNameMethod(ExpressionTree expression) {
    ClassGetNameDetector visitor = new ClassGetNameDetector();
    expression.accept(visitor);
    return visitor.useClassGetName;
  }

  private static class ClassGetNameDetector extends BaseTreeVisitor {
    private boolean useClassGetName = false;

    private static final MethodMatchers METHOD_MATCHERS = MethodMatchers.create()
      .ofTypes(""java.lang.Class"")
      .names(""getName"", ""getSimpleName"")
      .addWithoutParametersMatcher()
      .build();

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (METHOD_MATCHERS.matches(tree)) {
        useClassGetName = true;
      }
      scan(tree.methodSelect());
    }
  }
}
"
S1874,CODE_SMELL,"""@Deprecated"" code should not be used","package org.sonar.java.checks;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""CallToDeprecatedMethod"", repositoryKey = ""squid"")
@Rule(key = ""S1874"")
public class CallToDeprecatedMethodCheck extends AbstractCallToDeprecatedCodeChecker {

  @Override
  void checkDeprecatedIdentifier(IdentifierTree identifierTree, Symbol deprecatedSymbol) {
    if (isFlaggedForRemoval(deprecatedSymbol)) {
      // do not overlap with S5738
      return;
    }
    String name = deprecatedSymbol.name();

    if (deprecatedSymbol.isMethodSymbol()) {
      Tree parent = identifierTree.parent();
      Arguments arguments = null;
      if (parent.is(Tree.Kind.METHOD_INVOCATION)) {
        arguments = ((MethodInvocationTree) parent).arguments();
      } else if (parent.is(Tree.Kind.NEW_CLASS)) {
        name = deprecatedSymbol.owner().name();
        arguments = ((NewClassTree) parent).arguments();
      }
      // If any of the arguments is of unknown type then we don't report any issue
      if (arguments != null && arguments.stream().anyMatch(arg -> arg.symbolType().isUnknown())) {
        return;
      }
    }
    reportIssue(identifierTree, String.format(""Remove this use of \""%s\""; it is deprecated."", name));
  }

  @Override
  void checkOverridingMethod(MethodTree methodTree, List<Symbol.MethodSymbol> deprecatedSymbols) {
    if (deprecatedSymbols.stream().allMatch(this::nonAbstractOrFlaggedForRemoval)) {
      reportIssue(methodTree.simpleName(), ""Don't override a deprecated method or explicitly mark it as \""@Deprecated\""."");
    }
  }

  private boolean nonAbstractOrFlaggedForRemoval(Symbol.MethodSymbol method) {
    // if the method is abstract, you are forced to implement it
    return !(method.isAbstract()
      // if the method is flagged for removal, it will be handled by S5738
      || isFlaggedForRemoval(method));
  }
}
"
S1905,CODE_SMELL,Redundant casts should not be used,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.JProblem;
import org.sonar.java.model.JWarning;
import org.sonar.java.model.JavaTree;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;

@Rule(key = ""S1905"")
public class RedundantTypeCastCheck extends IssuableSubscriptionVisitor {

  private List<JWarning> warnings;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.COMPILATION_UNIT, Tree.Kind.TYPE_CAST);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      warnings = ((JavaTree.CompilationUnitTreeImpl) tree).warnings(JProblem.Type.REDUNDANT_CAST);
      return;
    }

    TypeCastTree typeCastTree = (TypeCastTree) tree;
    Type cast = typeCastTree.type().symbolType();
    if (isUnnecessaryCast(typeCastTree)) {
      String newType = cast.erasure().name();
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onRange(typeCastTree.openParenToken(), typeCastTree.closeParenToken())
        .withMessage(""Remove this unnecessary cast to \""%s\""."", newType)
        .withQuickFix(() ->
          JavaQuickFix.newQuickFix(""Remove the cast to \""%s\"""", newType)
            .addTextEdit(JavaTextEdit.removeTextSpan(
              AnalyzerMessage.textSpanBetween(
                typeCastTree.openParenToken(), true,
                typeCastTree.expression(), false)))
            .build())
        .report();
    }
  }

  public static Tree skipParentheses(Tree tree) {
    if (tree instanceof ExpressionTree expressionTree) {
      return ExpressionUtils.skipParentheses(expressionTree);
    }
    return tree;
  }

  private boolean isUnnecessaryCast(TypeCastTree typeCastTree) {
    if (skipParentheses(typeCastTree.expression()).is(Tree.Kind.NULL_LITERAL)) {
      Tree parentTree = skipParentheses(typeCastTree.parent());
      return !parentTree.is(Tree.Kind.ARGUMENTS);
    }
    return warnings.stream().anyMatch(warning -> matchesWarning(warning, typeCastTree));
  }

  private static boolean matchesWarning(JWarning warning, TypeCastTree tree) {
    Tree warningTree = warning.syntaxTree();
    if (warningTree.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {
      // When a cast expression is nested inside one or more parenthesized expression, Eclipse raises the warning on
      // the outermost parenthesized expression rather than the cast expression, so we need to take that into account
      return tree.equals(skipParentheses(warningTree));
    }
    return tree.equals(warningTree);
  }

}
"
S1939,CODE_SMELL,Extensions and implementations should not be redundant,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol.TypeSymbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ListTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Rule(key = ""S1939"")
public class UselessExtendsCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.INTERFACE, Tree.Kind.ENUM, Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    checkExtendsObject(classTree);

    ListTree<TypeTree> superInterfaces = classTree.superInterfaces();
    if (superInterfaces.isEmpty()) {
      return;
    }

    List<Type> superInterfacesTypes = getTypes(superInterfaces);
    List<Type> superTypes = new ArrayList<>(classTree.symbol().superTypes());
    superTypes.sort(new SuperTypeComparator(superInterfacesTypes));

    Set<String> reportedNames = new HashSet<>();
    for (TypeTree superInterface : superInterfaces) {
      String superInterfaceName = extractInterfaceName(superInterface);
      if (isDuplicate(superInterfaces, superInterface) && !reportedNames.add(superInterfaceName)) {
        // add an issue on a duplicated interface the second time it is encountered
        reportIssue(superInterface, ""\"""" + superInterfaceName + ""\"" is listed multiple times."");
      }
      if (!superInterface.symbolType().isUnknown()) {
        checkRedundancy(superInterface, superInterfacesTypes, superTypes);
      }
    }
  }

  private void checkExtendsObject(ClassTree classTree) {
    TypeTree superClassTree = classTree.superClass();
    if (superClassTree != null && superClassTree.symbolType().is(""java.lang.Object"")) {
      reportIssue(superClassTree, ""\""Object\"" should not be explicitly extended."");
    }
  }

  private static boolean isDuplicate(ListTree<TypeTree> superInterfaces, TypeTree currentInterfaceTree) {
    for (TypeTree superInterfaceTree : superInterfaces) {
      if (!currentInterfaceTree.equals(superInterfaceTree) && SyntacticEquivalence.areEquivalent(currentInterfaceTree, superInterfaceTree)) {
        return true;
      }
    }
    return false;
  }

  private static List<Type> getTypes(ListTree<TypeTree> superInterfaces) {
    List<Type> types = new ArrayList<>(superInterfaces.size());
    for (TypeTree superInterface : superInterfaces) {
      types.add(superInterface.symbolType());
    }
    return types;
  }

  private void checkRedundancy(TypeTree currentInterface, List<Type> superInterfacesTypes, List<Type> superTypes) {
    Type interfaceType = currentInterface.symbolType();
    for (Type superType : superTypes) {
      TypeSymbol superTypeSymbol = superType.symbol();
      if (superTypeSymbol.interfaces().contains(interfaceType)) {
        String typeOfParentMsg = ""implemented by a super class"";
        if (superTypeSymbol.isInterface() && superInterfacesTypes.contains(superType)) {
          typeOfParentMsg = ""already extended by \"""" + superTypeSymbol.name() + ""\"""";
        }
        reportIssue(currentInterface, ""\"""" + interfaceType.name() + ""\"" is "" + typeOfParentMsg + ""; there is no need to implement it here."");
        break;
      }
    }
  }

  private static String extractInterfaceName(Tree interfaceTree) {
    if (interfaceTree.is(Tree.Kind.IDENTIFIER)) {
      return ((IdentifierTree) interfaceTree).name();
    }
    if (interfaceTree.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mset = (MemberSelectExpressionTree) interfaceTree;
      return extractInterfaceName(mset.expression()) + ""."" + mset.identifier().name();
    }
    return extractInterfaceName(((ParameterizedTypeTree) interfaceTree).type());
  }private static class SuperTypeComparator implements Comparator<Type> {

    private final List<Type> declaredSuperInterfaces;

    SuperTypeComparator(List<Type> declaredSuperInterfaces) {
      this.declaredSuperInterfaces = declaredSuperInterfaces;
    }

    @Override
    public int compare(Type t1, Type t2) {
      int indexT1 = declaredSuperInterfaces.indexOf(t1);
      int indexT2 = declaredSuperInterfaces.indexOf(t2);
      if (indexT1 != -1 && indexT2 != -1) {
        return Integer.compare(indexT1, indexT2);
      }
      if (indexT1 != -1) {
        // t1 should be placed before
        return -1;
      }
      if (indexT2 != -1) {
        // t2 should be placed before
        return +1;
      }
      // sort by name if none of t1 and t2 is present in declaration list
      return t1.name().compareTo(t2.name());
    }
  }
}
"
S1940,CODE_SMELL,Boolean checks should not be inverted,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

import java.util.Collections;
import java.util.List;
import java.util.Map;

@Rule(key = ""S1940"")
public class BooleanInversionCheck extends IssuableSubscriptionVisitor {

  private static final Map<String, String> OPERATORS = MapBuilder.<String, String>newMap()
    .put(""=="", ""!="")
    .put(""!="", ""=="")
    .put(""<"", "">="")
    .put("">"", ""<="")
    .put(""<="", "">"")
    .put("">="", ""<"")
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.LOGICAL_COMPLEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ExpressionTree expression = ExpressionUtils.skipParentheses(((UnaryExpressionTree) tree).expression());
    if (expression.is(
        Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO,
        Tree.Kind.LESS_THAN, Tree.Kind.GREATER_THAN,
        Tree.Kind.LESS_THAN_OR_EQUAL_TO, Tree.Kind.GREATER_THAN_OR_EQUAL_TO)) {
      context.reportIssue(this, tree, ""Use the opposite operator (\"""" + OPERATORS.get(((BinaryExpressionTree) expression).operatorToken().text()) + ""\"") instead."");
    }
  }

}
"
S1941,CODE_SMELL,Variables should not be declared before they are relevant,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1941"")
public class VariableDeclarationScopeCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.BLOCK);
  }

  @Override
  public void visitNode(Tree tree) {
    BlockTree block = (BlockTree) tree;
    List<StatementTree> body = block.body();
    int bodySize = body.size();
    for (int i = 0; i < bodySize; i++) {
      StatementTree statement = body.get(i);
      if (statement.is(Tree.Kind.VARIABLE)) {
        VariableTree variableTree = (VariableTree) statement;
        if (!variableTree.symbol().usages().isEmpty()) {
          check(variableTree, body, bodySize, i + 1);
        }
      }
    }
  }

  private void check(VariableTree variable, List<StatementTree> body, int bodySize, int next) {
    Symbol symbol = variable.symbol();
    ReferenceVisitor referenceVisitor = new ReferenceVisitor(symbol);
    for (int i = next; i < bodySize; i++) {
      referenceVisitor.visit(body.get(i));
      if (referenceVisitor.referenceSymbol) {
        return;
      }
      if (referenceVisitor.hasBreakingStatement) {
        reportIssue(variable.simpleName(), ""Move the declaration of \"""" + symbol.name() + ""\"" closer to the code that uses it."");
        return;
      }
    }
  }

  private static class ReferenceVisitor extends BaseTreeVisitor {
    Symbol symbol;
    boolean referenceSymbol;
    boolean hasBreakingStatement;

    ReferenceVisitor(Symbol symbol) {
      this.symbol = symbol;
    }

    void visit(StatementTree node) {
      referenceSymbol = false;
      hasBreakingStatement = false;
      node.accept(this);
    }

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      if (!hasBreakingStatement) {
        hasBreakingStatement = true;
      }
      super.visitReturnStatement(tree);
    }

    @Override
    public void visitThrowStatement(ThrowStatementTree tree) {
      if (!hasBreakingStatement) {
        hasBreakingStatement = true;
      }
      super.visitThrowStatement(tree);
    }

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      if (!referenceSymbol && symbol.equals(tree.symbol())) {
        referenceSymbol = true;
      }
      super.visitIdentifier(tree);
    }
  }
}
"
S1942,CODE_SMELL,Simple class names should be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ImportTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;

@Rule(key = ""S1942"")
public class SimpleClassNameCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Replace this fully qualified name with \""%s\"""";
  private static final Predicate<Tree> NOT_EMPTY_STATEMENT = t -> !t.is(Kind.EMPTY_STATEMENT);

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Kind.COMPILATION_UNIT);
  }

  @Override
  public void visitNode(Tree tree) {
    CompilationUnitTree cut = (CompilationUnitTree) tree;
    cut.types().stream().filter(NOT_EMPTY_STATEMENT).map(t -> ((ClassTree) t).symbol()).forEach(this::checkSymbol);
    List<ImportTree> imports = cut.imports().stream().filter(NOT_EMPTY_STATEMENT).map(ImportTree.class::cast).toList();
    boolean fileContainsStarImport = imports.stream()
      .filter(it -> it.qualifiedIdentifier().is(Kind.MEMBER_SELECT))
      .map(it -> ((MemberSelectExpressionTree) it.qualifiedIdentifier()).identifier())
      .anyMatch(i -> ""*"".equals(i.name()));
    if(!fileContainsStarImport) {
      checkImports(imports);
    }
  }

  private void checkImports(List<ImportTree> imports) {
    imports.stream()
      .map(ImportTree::symbol)
      .filter(Objects::nonNull)
      .forEach(this::checkSymbol);
  }

  private void checkSymbol(Symbol symbol) {
    for (IdentifierTree usageIdentifier : symbol.usages()) {
      Tree parent = usageIdentifier.parent();

      if (parent.is(Kind.MEMBER_SELECT) && ((MemberSelectExpressionTree) parent).expression().is(Kind.MEMBER_SELECT)) {
        reportIssue(parent, String.format(MESSAGE, symbol.name()));
      }
    }
  }

}
"
S1943,CODE_SMELL,Classes and methods that rely on the default system encoding should not be used,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;

@Rule(key = ""S1943"")
public class DefaultEncodingUsageCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final String INT = ""int"";
  private static final String BOOLEAN = ""boolean"";
  private static final String BYTE_ARRAY = ""byte[]"";
  private static final String TO_STRING = ""toString"";
  private static final String WRITE = ""write"";
  private static final String JAVA_IO_FILE = ""java.io.File"";
  private static final String JAVA_IO_FILEDESCRIPTOR = ""java.io.FileDescriptor"";
  private static final String JAVA_IO_READER = ""java.io.Reader"";
  private static final String JAVA_IO_WRITER = ""java.io.Writer"";
  private static final String JAVA_IO_FILEWRITER = ""java.io.FileWriter"";
  private static final String JAVA_IO_FILEREADER = ""java.io.FileReader"";
  private static final String JAVA_IO_PRINTWRITER = ""java.io.PrintWriter"";
  private static final String JAVA_IO_PRINTSTREAM = ""java.io.PrintStream"";
  private static final String JAVA_IO_INPUTSTREAM = ""java.io.InputStream"";
  private static final String JAVA_IO_OUTPUTSTREAM = ""java.io.OutputStream"";
  private static final String JAVA_IO_BYTEARRAYOUTPUTSTREAM = ""java.io.ByteArrayOutputStream"";
  private static final String JAVA_IO_OUTPUTSTREAMWRITER = ""java.io.OutputStreamWriter"";
  private static final String JAVA_IO_INPUTSTREAMREADER = ""java.io.InputStreamReader"";
  private static final String JAVA_NIO_FILE_PATH = ""java.nio.file.Path"";
  private static final String JAVA_NIO_CHARSET = ""java.nio.charset.Charset"";
  private static final String JAVA_LANG_CHARSEQUENCE = ""java.lang.CharSequence"";
  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String JAVA_UTIL_SCANNER = ""java.util.Scanner"";
  private static final String JAVA_UTIL_FORMATTER = ""java.util.Formatter"";

  private static final String COMMONS_IOUTILS = ""org.apache.commons.io.IOUtils"";
  private static final String COMMONS_FILEUTILS = ""org.apache.commons.io.FileUtils"";

  private static final List<MethodMatchers> COMMONS_IO = new ArrayList<>();
  private static final List<MethodMatchers> COMMONS_IO_WITH_CHARSET = new ArrayList<>();

  static {
    withAndWithoutCharset(COMMONS_IOUTILS, ""copy"", JAVA_IO_INPUTSTREAM, JAVA_IO_WRITER);
    withAndWithoutCharset(COMMONS_IOUTILS, ""copy"", JAVA_IO_READER, JAVA_IO_OUTPUTSTREAM);
    withAndWithoutCharset(COMMONS_IOUTILS, ""readLines"", JAVA_IO_INPUTSTREAM);
    withAndWithoutCharset(COMMONS_IOUTILS, ""toByteArray"", JAVA_IO_READER);
    withAndWithoutCharset(COMMONS_IOUTILS, ""toCharArray"", JAVA_IO_INPUTSTREAM);
    withAndWithoutCharset(COMMONS_IOUTILS, ""toInputStream"", JAVA_LANG_CHARSEQUENCE);
    withAndWithoutCharset(COMMONS_IOUTILS, ""toInputStream"", JAVA_LANG_STRING);
    withAndWithoutCharset(COMMONS_IOUTILS, TO_STRING, BYTE_ARRAY);
    withAndWithoutCharset(COMMONS_IOUTILS, TO_STRING, ""java.net.URI"");
    withAndWithoutCharset(COMMONS_IOUTILS, TO_STRING, ""java.net.URL"");
    withAndWithoutCharset(COMMONS_IOUTILS, WRITE, ""char[]"", JAVA_IO_OUTPUTSTREAM);
    withAndWithoutCharset(COMMONS_IOUTILS, ""writeLines"", ""java.util.Collection"", JAVA_LANG_STRING, JAVA_IO_OUTPUTSTREAM);

    withAndWithoutCharset(COMMONS_FILEUTILS, ""readFileToString"", JAVA_IO_FILE);
    withAndWithoutCharset(COMMONS_FILEUTILS, ""readLines"", JAVA_IO_FILE);
    withAndWithoutCharset(COMMONS_FILEUTILS, WRITE, JAVA_IO_FILE, JAVA_LANG_CHARSEQUENCE);
    withAndWithoutCharset(COMMONS_FILEUTILS, WRITE, JAVA_IO_FILE, JAVA_LANG_CHARSEQUENCE, BOOLEAN);
    withAndWithoutCharset(COMMONS_FILEUTILS, ""writeStringToFile"", JAVA_IO_FILE, JAVA_LANG_STRING);


    // subtypeOf is used to cover also signatures with String and StringBuffer
    MethodMatchers.ParametersBuilder parametersBuilder = MethodMatchers.create().ofTypes(COMMONS_IOUTILS).names(WRITE);

    COMMONS_IO.add(parametersBuilder.addParametersMatcher(params ->
      params.size() == 2 && params.get(0).isSubtypeOf(JAVA_LANG_CHARSEQUENCE) && params.get(1).is(JAVA_IO_OUTPUTSTREAM)
    ).build());

    COMMONS_IO_WITH_CHARSET.add(parametersBuilder.addParametersMatcher(params ->
      params.size() == 3 && params.get(0).isSubtypeOf(JAVA_LANG_CHARSEQUENCE) && params.get(1).is(JAVA_IO_OUTPUTSTREAM)
        && (params.get(2).is(JAVA_NIO_CHARSET) || params.get(2).is(JAVA_LANG_STRING))
    ).build());
  }

  private static void withAndWithoutCharset(String type, String methodName, String... parameters) {
    MethodMatchers.ParametersBuilder nameBuilder = MethodMatchers.create().ofTypes(type).names(methodName);
    COMMONS_IO.add(nameBuilder.addParametersMatcher(parameters).build());
    int originalSize = parameters.length;
    String[] copy = Arrays.copyOf(parameters, originalSize + 1);
    copy[originalSize] = JAVA_LANG_STRING;
    COMMONS_IO_WITH_CHARSET.add(nameBuilder.addParametersMatcher(copy).build());
    copy[originalSize] = JAVA_NIO_CHARSET;
    COMMONS_IO_WITH_CHARSET.add(nameBuilder.addParametersMatcher(copy).build());
  }

  private static final MethodMatchers COMMONS_IO_CHARSET_MATCHERS = MethodMatchers.or(COMMONS_IO_WITH_CHARSET);

  private static final MethodMatchers FILEUTILS_WRITE_WITH_CHARSET =
    MethodMatchers.create().ofTypes(COMMONS_FILEUTILS).names(WRITE)
      .addParametersMatcher(JAVA_IO_FILE, JAVA_LANG_CHARSEQUENCE, JAVA_LANG_STRING, BOOLEAN)
      .addParametersMatcher(JAVA_IO_FILE, JAVA_LANG_CHARSEQUENCE, JAVA_NIO_CHARSET, BOOLEAN)
      .build();

  private static final MethodMatchers FILEUTILS_WRITE_WITH_CHARSET_MATCHERS =
    MethodMatchers.or(FILEUTILS_WRITE_WITH_CHARSET);

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isSet() && version.asInt() < 18;
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS);
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    ArrayList<MethodMatchers> matchers = new ArrayList<>(Arrays.asList(
      MethodMatchers.create().ofTypes(JAVA_LANG_STRING).names(""getBytes"")
        .addWithoutParametersMatcher()
        .addParametersMatcher(INT, INT, BYTE_ARRAY, INT)
        .build(),
      MethodMatchers.create().ofTypes(JAVA_LANG_STRING).constructor()
        .addParametersMatcher(BYTE_ARRAY)
        .addParametersMatcher(BYTE_ARRAY, INT, INT)
        .build(),
      MethodMatchers.create().ofTypes(JAVA_IO_BYTEARRAYOUTPUTSTREAM).names(TO_STRING)
        .addWithoutParametersMatcher()
        .build(),
      MethodMatchers.create().ofTypes(JAVA_IO_FILEREADER).constructor()
        .addParametersMatcher(JAVA_IO_FILE)
        .addParametersMatcher(JAVA_IO_FILEDESCRIPTOR)
        .addParametersMatcher(JAVA_LANG_STRING)
        .build(),
      MethodMatchers.create().ofTypes(JAVA_IO_FILEWRITER).constructor()
        .addParametersMatcher(JAVA_IO_FILE)
        .addParametersMatcher(JAVA_IO_FILEDESCRIPTOR)
        .addParametersMatcher(JAVA_IO_FILE, BOOLEAN)
        .addParametersMatcher(JAVA_LANG_STRING)
        .addParametersMatcher(JAVA_LANG_STRING, BOOLEAN)
        .build(),
      MethodMatchers.create().ofTypes(JAVA_IO_INPUTSTREAMREADER).constructor()
        .addParametersMatcher(JAVA_IO_INPUTSTREAM)
        .build(),
      MethodMatchers.create().ofTypes(JAVA_IO_OUTPUTSTREAMWRITER).constructor()
        .addParametersMatcher(JAVA_IO_OUTPUTSTREAM)
        .build(),
      MethodMatchers.create().ofTypes(JAVA_IO_PRINTSTREAM).constructor()
        .addParametersMatcher(JAVA_IO_FILE)
        .addParametersMatcher(JAVA_IO_OUTPUTSTREAM)
        .addParametersMatcher(JAVA_IO_OUTPUTSTREAM, BOOLEAN)
        .addParametersMatcher(JAVA_LANG_STRING)
        .build(),
      MethodMatchers.create().ofTypes(JAVA_IO_PRINTWRITER).constructor()
        .addParametersMatcher(JAVA_IO_FILE)
        .addParametersMatcher(JAVA_IO_OUTPUTSTREAM)
        .addParametersMatcher(JAVA_IO_OUTPUTSTREAM, BOOLEAN)
        .addParametersMatcher(JAVA_LANG_STRING)
        .build(),
      MethodMatchers.create().ofTypes(JAVA_UTIL_FORMATTER).constructor()
        .addParametersMatcher(JAVA_LANG_STRING)
        .addParametersMatcher(JAVA_IO_FILE)
        .addParametersMatcher(JAVA_IO_OUTPUTSTREAM)
        .build(),
      MethodMatchers.create().ofTypes(JAVA_UTIL_SCANNER).constructor()
        .addParametersMatcher(JAVA_IO_FILE)
        .addParametersMatcher(JAVA_NIO_FILE_PATH)
        .addParametersMatcher(JAVA_IO_INPUTSTREAM)
        .build()
    ));
    matchers.addAll(COMMONS_IO);
    matchers.addAll(COMMONS_IO_WITH_CHARSET);
    matchers.add(FILEUTILS_WRITE_WITH_CHARSET);
    return MethodMatchers.or(matchers);
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (COMMONS_IO_CHARSET_MATCHERS.matches(mit)) {
      Arguments arguments = mit.arguments();
      ExpressionTree lastArgument = arguments.get(arguments.size() - 1);
      testNullLiteralPassedForEncoding(lastArgument);
    } else if (FILEUTILS_WRITE_WITH_CHARSET_MATCHERS.matches(mit)) {
      testNullLiteralPassedForEncoding(mit.arguments().get(2));
    } else {
      reportIssue(ExpressionUtils.methodName(mit), ""Remove this use of \"""" + mit.methodSymbol().name() + ""\""."");
    }
  }

  private void testNullLiteralPassedForEncoding(ExpressionTree argument) {
    if (isNullLiteral(argument)) {
      reportIssue(argument, ""Replace this \""null\"" with actual charset."");
    }
  }

  private static boolean isNullLiteral(ExpressionTree lastArgument) {
    ExpressionTree arg = ExpressionUtils.skipParentheses(lastArgument);
    return arg.is(Tree.Kind.NULL_LITERAL)
      || (arg.is(Tree.Kind.TYPE_CAST) && isNullLiteral(((TypeCastTree) arg).expression()));
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    Symbol.MethodSymbol symbol = newClassTree.methodSymbol();
    if (!symbol.isUnknown()) {
      String signature = symbol.owner().name() + ""("" + symbol.parameterTypes().stream().map(Type::toString).collect(Collectors.joining("","")) + "")"";
      reportIssue(newClassTree.identifier(), ""Remove this use of constructor \"""" + signature + ""\""."");
    }
  }

}
"
S1948,CODE_SMELL,"Fields in a ""Serializable"" class should either be transient or serializable","package org.sonar.java.checks.serialization;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonar.plugins.java.api.tree.WildcardTree;

@Rule(key = ""S1948"")
public class SerializableFieldInSerializableClassCheck extends IssuableSubscriptionVisitor {

  private static final String JAVAX_INJECT = ""javax.inject.Inject"";
  private static final String JAKARTA_INJECT = ""jakarta.inject.Inject"";

  private static final String[] EXCLUDED_ANNOTATIONS = new String[]{
    ""jakarta.annotation.Resource"",
    ""javax.annotation.Resource"",
    ""javax.ejb.EJB"",
    JAVAX_INJECT,
    JAKARTA_INJECT,
    ""org.apache.wicket.spring.injection.annot.SpringBean""
  };

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (isSerializable(classTree)
      && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)
      && !classTree.symbol().type().isSubtypeOf(""javax.servlet.http.HttpServlet"")) {

      Set<String> constructorInjectedParams = getConstructorOrMethodInjectedFields(classTree);

      classTree.members().stream()
        .filter(member -> member.is(Tree.Kind.VARIABLE))
        .map(VariableTree.class::cast)
        .filter(variableTree -> !(isExcluded(variableTree) ||
          constructorInjectedParams.contains(variableTree.simpleName().name())))
        .forEach(this::checkVariableMember);
    }
  }

  private static Set<String> getConstructorOrMethodInjectedFields(ClassTree classTree) {
    AssignmentsVisitor assignmentsVisitor = new AssignmentsVisitor();
    classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR, Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .filter(methodTree -> isAnnotatedWith(methodTree.symbol().metadata(), JAVAX_INJECT, JAKARTA_INJECT))
      .forEach(methodTree -> methodTree.accept(assignmentsVisitor));

    return assignmentsVisitor.getAssignedVariables();
  }

  private void checkVariableMember(VariableTree variableTree) {
    IdentifierTree simpleName = variableTree.simpleName();
    if (isCollectionOfSerializable(variableTree.type())) {
      if (!ModifiersUtils.hasModifier(variableTree.modifiers(), Modifier.PRIVATE)
        && !implementsSerializable(variableTree.type().symbolType())) {
        reportIssue(simpleName, ""Make \"""" + simpleName.name() + ""\"" private or transient."");
      } else if (isUnserializableCollection(variableTree.type().symbolType())
        || isUnserializableCollection(variableTree.initializer())) {
        reportIssue(simpleName);
      }
      checkCollectionAssignments(variableTree.symbol().usages());
    } else {
      ExpressionTree initializer = variableTree.initializer();
      Symbol.VariableSymbol variableSymbol = (Symbol.VariableSymbol) variableTree.symbol();
      if (initializer == null || !(variableSymbol.isFinal() && implementsSerializable(initializer.symbolType()))) {
        reportIssue(simpleName);
      }
    }
  }

  private static boolean isUnserializableCollection(@Nullable ExpressionTree expression) {
    return expression != null && !expression.is(Tree.Kind.NULL_LITERAL) && isUnserializableCollection(expression.symbolType());
  }

  private static boolean isUnserializableCollection(Type type) {
    return !type.symbol().isInterface() && isSubtypeOfCollectionApi(type) && !implementsSerializable(type);
  }

  private void checkCollectionAssignments(List<IdentifierTree> usages) {
    for (IdentifierTree usage : usages) {
      Tree parentTree = usage.parent();
      if (parentTree.is(Tree.Kind.ASSIGNMENT)) {
        AssignmentExpressionTree assignment = (AssignmentExpressionTree) parentTree;
        if (usage.equals(assignment.variable()) && isUnserializableCollection(assignment.expression())) {
          reportIssue(usage);
        }
      }
    }
  }

  private void reportIssue(IdentifierTree tree) {
    reportIssue(tree, ""Make \"""" + tree.name() + ""\"" transient or serializable."");
  }

  private static boolean isExcluded(VariableTree variableTree) {
    return isStatic(variableTree) || isTransientSerializableOrInjected(variableTree);
  }

  private static boolean isCollectionOfSerializable(Tree tree) {
    if (tree.is(Tree.Kind.PARAMETERIZED_TYPE)) {
      ParameterizedTypeTree typeTree = (ParameterizedTypeTree) tree;
      if (isSubtypeOfCollectionApi(typeTree.symbolType())) {
        return typeTree.typeArguments().stream().allMatch(SerializableFieldInSerializableClassCheck::isCollectionOfSerializable);
      }
    }
    return isSerializable(tree);
  }

  private static boolean isSubtypeOfCollectionApi(Type type) {
    return type.isSubtypeOf(""java.util.Collection"") || type.isSubtypeOf(""java.util.Map"");
  }

  private static boolean isStatic(VariableTree member) {
    return ModifiersUtils.hasModifier(member.modifiers(), Modifier.STATIC);
  }

  private static boolean isTransientSerializableOrInjected(VariableTree member) {
    if (ModifiersUtils.hasModifier(member.modifiers(), Modifier.TRANSIENT) || (isSerializable(member.type()) && !isSubtypeOfCollectionApi(member.type().symbolType()))) {
      return true;
    }
    SymbolMetadata metadata = member.symbol().metadata();
    return isAnnotatedWith(metadata, EXCLUDED_ANNOTATIONS);
  }

  private static boolean isAnnotatedWith(SymbolMetadata metadata, String... fullyQualifiedNames) {
    Set<String> fullyQualifiedNamesSet = new HashSet<>(Arrays.asList(fullyQualifiedNames));
    return metadata.annotations().stream()
      .map(a -> a.symbol().type())
      .anyMatch(t -> t.isUnknown() || fullyQualifiedNamesSet.contains(t.fullyQualifiedName()));
  }

  private static boolean isSerializable(Tree tree) {
    if (tree.is(Tree.Kind.ENUM, Tree.Kind.PRIMITIVE_TYPE)) {
      return true;
    } else if (tree.is(Tree.Kind.CLASS)) {
      Symbol.TypeSymbol symbol = ((ClassTree) tree).symbol();
      return implementsSerializable(symbol.type());
    } else if (tree.is(Tree.Kind.EXTENDS_WILDCARD, Tree.Kind.SUPER_WILDCARD, Tree.Kind.UNBOUNDED_WILDCARD)) {
      TypeTree bound = ((WildcardTree) tree).bound();
      return bound != null && implementsSerializable(bound.symbolType());
    }
    return implementsSerializable(((TypeTree) tree).symbolType());
  }

  private static boolean implementsSerializable(@Nullable Type type) {
    if (type == null || type.isUnknown() || type.isPrimitive()) {
      // do not raise an issue if type is unknown
      return true;
    }
    if (type.isArray()) {
      return implementsSerializable(((Type.ArrayType) type).elementType());
    }
    if (type.isClass() || type.isTypeVar()) {
      return type.isSubtypeOf(""java.io.Serializable"");
    }
    return false;
  }

  private static final class AssignmentsVisitor extends BaseTreeVisitor {
    private final Set<String> assignedVariables = new HashSet<>();

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      if (ExpressionUtils.isSelectOnThisOrSuper(tree)) {
        MemberSelectExpressionTree select = ((MemberSelectExpressionTree) tree.variable());
        assignedVariables.add(select.identifier().name());
      } else if (tree.variable().is(Tree.Kind.IDENTIFIER)) {
        IdentifierTree identifier = ((IdentifierTree) tree.variable());
        assignedVariables.add(identifier.name());
      }
    }

    public Set<String> getAssignedVariables() {
      return Collections.unmodifiableSet(assignedVariables);
    }
  }
}
"
S1989,VULNERABILITY,Exceptions should not be thrown from servlet methods,"package org.sonar.java.checks;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.List;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;

@Rule(key = ""S1989"")
public class ServletMethodsExceptionsThrownCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers IS_SERVLET_DO_METHOD = MethodMatchers.create()
    .ofSubTypes(""javax.servlet.http.HttpServlet"", ""jakarta.servlet.http.HttpServlet"")
    .name(name -> name.startsWith(""do""))
    .withAnyParameters().build();

  private final Deque<Boolean> shouldCheck = new ArrayDeque<>();
  private final Deque<List<Type>> tryCatches = new ArrayDeque<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.THROW_STATEMENT, Tree.Kind.METHOD_INVOCATION, Tree.Kind.TRY_STATEMENT, Tree.Kind.CATCH);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      shouldCheck.push(IS_SERVLET_DO_METHOD.matches((MethodTree) tree));
    } else if (shouldCheck()) {
      if (tree.is(Tree.Kind.TRY_STATEMENT)) {
        tryCatches.add(getCaughtExceptions(((TryStatementTree) tree).catches()));
      } else if (tree.is(Tree.Kind.CATCH)) {
        tryCatches.pop();
        tryCatches.add(Collections.emptyList());
      } else if (tree.is(Tree.Kind.THROW_STATEMENT)) {
        addIssueIfNotCaught(((ThrowStatementTree) tree).expression().symbolType(), tree);
      } else if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
        checkMethodInvocation((MethodInvocationTree) tree);
      }
    }
  }

  private boolean shouldCheck() {
    return !shouldCheck.isEmpty() && shouldCheck.peek();
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      shouldCheck.pop();
    } else if (shouldCheck() && tree.is(Tree.Kind.TRY_STATEMENT)) {
      tryCatches.pop();
    }
  }

  private static List<Type> getCaughtExceptions(List<CatchTree> catches) {
    List<Type> result = new ArrayList<>();
    for (CatchTree element : catches) {
      result.add(element.parameter().type().symbolType());
    }
    return result;
  }

  private void checkMethodInvocation(MethodInvocationTree node) {
    Symbol.MethodSymbol symbol = node.methodSymbol();
    if (!symbol.isUnknown()) {
      List<Type> types = symbol.thrownTypes();
      if (!types.isEmpty()) {
        addIssueIfNotCaught(types, ExpressionUtils.methodName(node), symbol.name());
      }
    }
  }

  private void addIssueIfNotCaught(Type thrown, Tree node) {
    if (isNotCaught(thrown)) {
      String message = ""Handle the "" + ""\"""" + thrown.name() + ""\"""" + "" thrown here in a \""try/catch\"" block."";
      reportIssue(node, message);
    }
  }

  private void addIssueIfNotCaught(Iterable<Type> thrown, Tree node, String methodName) {
    List<Type> uncaughtTypes = new ArrayList<>();
    for (Type type : thrown) {
      if (isNotCaught(type)) {
        uncaughtTypes.add(type);
      }
    }
    if (!uncaughtTypes.isEmpty()) {
      reportIssue(node, buildMessage(methodName, uncaughtTypes));
    }
  }

  private static String buildMessage(String methodName, List<Type> uncaughtTypes) {
    String uncaught = uncaughtTypes.stream().map(Type::name).collect(Collectors.joining("", "")) + ""."";
    return String.format(""Handle the following exception%s that could be thrown by \""%s\"": %s"",
      (uncaughtTypes.size() == 1 ? """" : ""s""),
      methodName,
      uncaught);
  }

  private boolean isNotCaught(Type type) {
    for (List<Type> tryCatch : tryCatches) {
      for (Type tryCatchType : tryCatch) {
        if (type.isSubtypeOf(tryCatchType)) {
          return false;
        }
      }
    }
    return true;
  }

}
"
S1994,CODE_SMELL,"""for"" loop increment clauses should modify the loops' counters","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ListTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Rule(key = ""S1994"")
public class ForLoopIncrementAndUpdateCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.FOR_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ForStatementTree forStatementTree = (ForStatementTree) tree;
    if (forStatementTree.update().isEmpty() || forStatementTree.condition() == null) {
      return;
    }
    Collection<Symbol> symbolsFromConditionsNotUpdated = symbolsFromConditionsNotUpdated(forStatementTree);
    if (!symbolsFromConditionsNotUpdated.isEmpty()) {
      Map<Symbol, Tree> updatesInBody = singleUpdatesInBody(forStatementTree.statement(), symbolsFromConditionsNotUpdated);
      if (!updatesInBody.isEmpty()) {
        reportIssue(forStatementTree.forKeyword(), getMessage(updatesInBody.keySet()), getSecondaries(updatesInBody), null);
      }
    }
  }

  private static String getMessage(Set<Symbol> updates) {
    return String.format(""Move the update of %s into this loop's update clause."", symbolNames(updates));
  }

  private static Collection<Symbol> symbolsFromConditionsNotUpdated(ForStatementTree forStatementTree) {
    Collection<Symbol> symbols = getConditionSymbols(forStatementTree.condition());
    symbols.removeAll(getUpdatedSymbols(forStatementTree.update()));
    return symbols;
  }

  private static Collection<Symbol> getConditionSymbols(ExpressionTree condition) {
    ConditionVisitor conditionVisitor = new ConditionVisitor();
    condition.accept(conditionVisitor);
    return conditionVisitor.symbols;
  }

  private static Collection<Symbol> getUpdatedSymbols(ListTree<StatementTree> updates) {
    UpdateVisitor updateVisitor = new UpdateVisitor();
    updates.accept(updateVisitor);
    return updateVisitor.symbols;
  }

  private static Map<Symbol, Tree> singleUpdatesInBody(StatementTree statement, Collection<Symbol> conditionsNotUpdated) {
    UpdatesInBodyVisitor updatedInBodyVisitor = new UpdatesInBodyVisitor(conditionsNotUpdated);
    statement.accept(updatedInBodyVisitor);
    // only report if there is symbols which are updated only once, as multiple update cannot easily be moved to updates
    return updatedOnlyOnceWithUnaryExpression(updatedInBodyVisitor.updates, statement);
  }

  private static String symbolNames(Set<Symbol> symbols) {
    return symbols.stream().map(s -> ""\"""" + s.name() + ""\"""").sorted().collect(Collectors.joining("",""));
  }

  private static List<JavaFileScannerContext.Location> getSecondaries(Map<Symbol, Tree> updatesInBody) {
    return updatesInBody.entrySet().stream()
      .map(entry -> new JavaFileScannerContext.Location(String.format(""Move this update of \""%s\""."", entry.getKey().name()), entry.getValue()))
      .toList();
  }

  private static Map<Symbol, Tree> updatedOnlyOnceWithUnaryExpression(Map<Symbol, List<Tree>> updatesInBody, StatementTree forStatementBody) {
    Map<Symbol, Tree> result = new HashMap<>();
    updatesInBody.forEach((updatedSymbol, updateTrees) -> {
      if (updateTrees.size() == 1) {
        Tree updateTree = updateTrees.iterator().next();
        if (updateTree.is(Tree.Kind.POSTFIX_INCREMENT, Tree.Kind.POSTFIX_DECREMENT, Tree.Kind.PREFIX_INCREMENT, Tree.Kind.PREFIX_DECREMENT)
          // only consider unary expression as single statement, and not nested
          && updateTree.parent().is(Tree.Kind.EXPRESSION_STATEMENT) && updateTree.parent().parent() == forStatementBody) {
          result.put(updatedSymbol, updateTree);
        }
      }
    });
    return result;
  }

  private static class ConditionVisitor extends BaseTreeVisitor {
    Collection<Symbol> symbols = new HashSet<>();

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      Symbol symbol = tree.symbol();
      if (symbol.isVariableSymbol()) {
        symbols.add(symbol);
      }
      super.visitIdentifier(tree);
    }
  }

  private static class UpdateVisitor extends BaseTreeVisitor {
    Collection<Symbol> symbols = new ArrayList<>();

    @Override
    public void visitUnaryExpression(UnaryExpressionTree tree) {
      checkIdentifier(tree.expression());
      super.visitUnaryExpression(tree);
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      checkIdentifier(tree.variable());
      super.visitAssignmentExpression(tree);
    }

    @Override
    public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
      checkIdentifier(tree.identifier());
      // skip expression
    }

    private void checkIdentifier(ExpressionTree expression) {
      ExpressionTree expr = ExpressionUtils.skipParentheses(expression);
      if (expr.is(Tree.Kind.IDENTIFIER)) {
        addSymbol((IdentifierTree) expr);
      } else if (expr.is(Tree.Kind.MEMBER_SELECT)) {
        addSymbol(((MemberSelectExpressionTree) expr).identifier());
      }
    }

    private void addSymbol(IdentifierTree identifierTree) {
      Symbol symbol = identifierTree.symbol();
      if (!symbol.isUnknown()) {
        symbols.add(symbol);
      }
    }
  }

  private static class UpdatesInBodyVisitor extends BaseTreeVisitor {
    private final Collection<Symbol> targets;
    private final Map<Symbol, List<Tree>> updates = new HashMap<>();

    private UpdatesInBodyVisitor(Collection<Symbol> targets) {
      this.targets = targets;
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      checkIdentifier(tree.variable(), tree);
      super.visitAssignmentExpression(tree);
    }

    @Override
    public void visitUnaryExpression(UnaryExpressionTree tree) {
      checkIdentifier(tree.expression(), tree);
      super.visitUnaryExpression(tree);
    }

    private void checkIdentifier(ExpressionTree expression, Tree root) {
      ExpressionTree expr = ExpressionUtils.skipParentheses(expression);
      if (expr.is(Tree.Kind.IDENTIFIER)) {
        addSymbol((IdentifierTree) expr, root);
      } else if (expr.is(Tree.Kind.MEMBER_SELECT)) {
        addSymbol(((MemberSelectExpressionTree) expr).identifier(), root);
      }
    }

    private void addSymbol(IdentifierTree identifierTree, Tree root) {
      Symbol symbol = identifierTree.symbol();
      if (targets.contains(symbol)) {
        updates.computeIfAbsent(symbol, k -> new ArrayList<>()).add(root);
      }
    }
  }

}
"
S1996,CODE_SMELL,Files should contain only one top-level class or interface each,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S1996"")
public class OneClassInterfacePerFileCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.COMPILATION_UNIT);
  }

  @Override
  public void visitNode(Tree tree) {
    int types = ((CompilationUnitTree) tree).types().size();
    if (types > 1) {
      context.addIssue(
        -1, OneClassInterfacePerFileCheck.this, ""There are "" + types + "" top-level types in this file; move all but one of them to other files."", types - 1);
    }
  }

}
"
S2039,CODE_SMELL,Member variable visibility should be specified,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2039"")
public class FieldModifierCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    classTree.members().stream()
      .filter(FieldModifierCheck::isConsentWithCheck)
      .forEach(member -> {
        VariableTree variableTree = (VariableTree) member;
        if (!hasModifierComment(variableTree)) {
          IdentifierTree simpleName = variableTree.simpleName();
          reportIssue(simpleName, ""Explicitly declare the visibility for \"""" + simpleName.name() + ""\""."");
        }
      });
  }

  private static boolean hasModifierComment(VariableTree variableTree) {
    for (SyntaxTrivia syntaxTrivia : variableTree.type().lastToken().trivias()) {
      if (syntaxTrivia.comment().toLowerCase(Locale.ROOT).contains(""modifier"")) {
        return true;
      }
    }
    return false;
  }

  private static boolean isConsentWithCheck(Tree member) {
    return member.is(Tree.Kind.VARIABLE)
      && hasNoVisibilityModifier((VariableTree) member)
      && !isVisibleForTesting((VariableTree) member);
  }

  private static boolean hasNoVisibilityModifier(VariableTree variableTree) {
    return ModifiersUtils.hasNoneOf(variableTree.modifiers(), Modifier.PUBLIC, Modifier.PRIVATE, Modifier.PROTECTED);
  }

  private static boolean isVisibleForTesting(VariableTree variableTree) {
    return variableTree.modifiers().annotations().stream()
      .anyMatch(annotation -> ""VisibleForTesting"".equals(annotation.annotationType().lastToken().text()));
  }

}
"
S2047,CODE_SMELL,"The names of methods with boolean return values should start with ""is"" or ""has""","package org.sonar.java.checks.naming;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type.Primitives;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2047"")
public class BooleanMethodNameCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    IdentifierTree simpleName = methodTree.simpleName();
    if (returnsBoolean(methodTree) && isBooleanGetter(simpleName) && isNotOverriding(methodTree)) {
      reportIssue(simpleName, ""Rename this method to start with \""is\"" or \""has\""."");
    }
  }

  private static boolean isBooleanGetter(IdentifierTree simpleName) {
    String text = simpleName.identifierToken().text();
    return text.startsWith(""get"") && !text.startsWith(""getBoolean"");
  }

  private static boolean isNotOverriding(MethodTree methodTree) {
    return Boolean.FALSE.equals(methodTree.isOverriding());
  }

  private static boolean returnsBoolean(MethodTree methodTree) {
    return methodTree.returnType().symbolType().isPrimitive(Primitives.BOOLEAN);
  }
}
"
S2053,VULNERABILITY,Password hashing functions should use an unpredictable salt,"package org.sonar.java.checks.security;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.Preconditions;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.ExpressionsHelper.getSingleWriteUsage;

@Rule(key = ""S2053"")
public class UnpredictableSaltCheck extends IssuableSubscriptionVisitor {

  private static final String UNPREDICTABLE_SALT = ""Make this salt unpredictable."";

  private static final String BYTE_ARRAY = ""byte[]"";
  private static final MethodMatchers NEW_PBE_KEY_SPEC = MethodMatchers.create()
    .ofSubTypes(""javax.crypto.spec.PBEKeySpec"")
    .constructor()
    .addParametersMatcher(""char[]"", BYTE_ARRAY, ""int"", ""int"")
    .addParametersMatcher(""char[]"", BYTE_ARRAY, ""int"")
    .build();

  private static final MethodMatchers NEW_PBE_PARAM_SPEC = MethodMatchers.create()
    .ofSubTypes(""javax.crypto.spec.PBEParameterSpec"")
    .constructor()
    .addParametersMatcher(BYTE_ARRAY, ""int"")
    .addParametersMatcher(BYTE_ARRAY, ""int"", ""java.security.spec.AlgorithmParameterSpec"")
    .build();

  private static final MethodMatchers GET_BYTES = MethodMatchers.create()
    .ofTypes(""java.lang.String"")
    .names(""getBytes"")
    .withAnyParameters()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    NewClassTree newClassTree = (NewClassTree) tree;
    saltExpression(((NewClassTree) tree))
    .map(ExpressionUtils::skipParentheses)
    .ifPresent(salt -> {
      List<JavaFileScannerContext.Location> locations = new ArrayList<>();
      if (isPredictable(salt, locations)) {
        reportIssue(newClassTree, UNPREDICTABLE_SALT, locations, null);
      }
    });
  }
  
  private static Optional<ExpressionTree> saltExpression(NewClassTree tree) {
    if (NEW_PBE_KEY_SPEC.matches(tree)) {
      return Optional.of(tree.arguments().get(1));
    } else if (NEW_PBE_PARAM_SPEC.matches(tree)) {
      return Optional.of(tree.arguments().get(0));
    }
    return Optional.empty();
  }

  private static boolean isPredictable(ExpressionTree saltExpression, List<JavaFileScannerContext.Location> locations) {
    return (saltExpression.is(Tree.Kind.METHOD_INVOCATION) && isInitializedWithGetBytes((MethodInvocationTree) saltExpression)) ||
      (saltExpression.is(Tree.Kind.IDENTIFIER) && isInitializedWithLiteral((IdentifierTree) saltExpression, locations));
  }

  private static boolean isInitializedWithLiteral(IdentifierTree identifier, List<JavaFileScannerContext.Location> locations) {
    Symbol symbol = identifier.symbol();
    return Optional.ofNullable(getSingleWriteUsage(symbol))
      .filter(expressionTree -> expressionTree.is(Tree.Kind.METHOD_INVOCATION))
      .map(MethodInvocationTree.class::cast)
      .map(mit -> {
        locations.add(new JavaFileScannerContext.Location(""Salt initialized with a constant."", mit));
        return isInitializedWithGetBytes(mit);
      })
      .orElse(false);
  }

  private static boolean isInitializedWithGetBytes(MethodInvocationTree mit) {
    if (!GET_BYTES.matches(mit)) {
      return false;
    }
    ExpressionTree methodSelect = (mit).methodSelect();
    Preconditions.checkState(methodSelect.is(Tree.Kind.MEMBER_SELECT),
      ""'getBytes' method invocation should have a MEMBER_SELECT kind as expression."");
    ExpressionTree expression = ((MemberSelectExpressionTree) methodSelect).expression();
    return expression.asConstant().isPresent();
  }
}
"
S2055,BUG,"The non-serializable super class of a ""Serializable"" class should have a no-argument constructor","package org.sonar.java.checks.serialization;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2055"")
public class SerializableSuperConstructorCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers WRITE_REPLACE = MethodMatchers.create()
    .ofAnyType()
    .names(""writeReplace"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (classTree.simpleName() == null) {
      // do not cover anonymous classes
      return;
    }
    Symbol.TypeSymbol classSymbol = classTree.symbol();
    Type superclass = classSymbol.superClass();
    if (isSerializable(classSymbol.type()) && isNotSerializableMissingNoArgConstructor(superclass) && !implementsSerializableMethods(classSymbol)) {
      reportIssue(classTree.superClass(), ""Add a no-arg constructor to \"""" + superclass.name() + ""\""."");
    }
  }

  private static boolean isNotSerializableMissingNoArgConstructor(@Nullable Type superclass) {
    return superclass != null
      && !superclass.isUnknown()
      && !isSerializable(superclass)
      && !hasNonPrivateNoArgConstructor(superclass);
  }

  private static boolean isSerializable(Type type) {
    return type.isSubtypeOf(""java.io.Serializable"");
  }

  private static boolean hasNonPrivateNoArgConstructor(Type type) {
    Collection<Symbol> constructors = type.symbol().lookupSymbols(""<init>"");
    for (Symbol member : constructors) {
      if (member.isMethodSymbol()) {
        Symbol.MethodSymbol method = (Symbol.MethodSymbol) member;
        if (method.parameterTypes().isEmpty() && !method.isPrivate()) {
          return true;
        }
      }
    }
    return constructors.isEmpty();
  }

  private static boolean implementsSerializableMethods(Symbol.TypeSymbol classSymbol) {
    return classSymbol.memberSymbols().stream().anyMatch(WRITE_REPLACE::matches);
  }
}
"
S2057,CODE_SMELL,"""Serializable"" classes should have a ""serialVersionUID""","package org.sonar.java.checks.serialization;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2057"")
public class SerialVersionUidCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    visitClassTree((ClassTree) tree);
  }

  private void visitClassTree(ClassTree classTree) {
    Symbol.TypeSymbol symbol = classTree.symbol();
    IdentifierTree simpleName = classTree.simpleName();
    if (simpleName != null && isSerializable(symbol.type())) {
      Symbol.VariableSymbol serialVersionUidSymbol = findSerialVersionUid(symbol);
      if (serialVersionUidSymbol == null) {
        if (!isExclusion(symbol)) {
          reportIssue(simpleName, ""Add a \""static final long serialVersionUID\"" field to this class."");
        }
      } else {
        checkModifiers(serialVersionUidSymbol);
      }
    }
  }

  private void checkModifiers(Symbol.VariableSymbol serialVersionUidSymbol) {
    List<String> missingModifiers = new ArrayList<>();
    if (!serialVersionUidSymbol.isStatic()) {
      missingModifiers.add(""static"");
    }
    if (!serialVersionUidSymbol.isFinal()) {
      missingModifiers.add(""final"");
    }
    if (!serialVersionUidSymbol.type().is(""long"")) {
      missingModifiers.add(""long"");
    }
    VariableTree variableTree = serialVersionUidSymbol.declaration();
    if (variableTree != null && !missingModifiers.isEmpty()) {
      reportIssue(variableTree.simpleName(), ""Make this \""serialVersionUID\"" field \"""" + String.join("" "", missingModifiers) + ""\""."");
    }
  }

  private static Symbol.VariableSymbol findSerialVersionUid(Symbol.TypeSymbol symbol) {
    for (Symbol member : symbol.lookupSymbols(""serialVersionUID"")) {
      if (member.isVariableSymbol()) {
        return (Symbol.VariableSymbol) member;
      }
    }
    return null;
  }

  private static boolean isSerializable(Type type) {
    return type.isSubtypeOf(""java.io.Serializable"");
  }

  private static boolean isExclusion(Symbol.TypeSymbol symbol) {
    return symbol.isAbstract()
      || symbol.type().isSubtypeOf(""java.lang.Throwable"")
      || isGuiClass(symbol);
  }

  private static boolean isGuiClass(Symbol.TypeSymbol symbol) {
    for (Type superType : symbol.superTypes()) {
      Symbol.TypeSymbol superTypeSymbol = superType.symbol();
      if (hasGuiPackage(superTypeSymbol)) {
        return true;
      }
    }
    return hasGuiPackage(symbol) || (!symbol.equals(symbol.outermostClass()) && isGuiClass(symbol.outermostClass()));
  }

  private static boolean hasGuiPackage(Symbol.TypeSymbol superTypeSymbol) {
    String fullyQualifiedName = superTypeSymbol.type().fullyQualifiedName();
    return fullyQualifiedName.startsWith(""javax.swing."") || fullyQualifiedName.startsWith(""java.awt."");
  }

}
"
S2059,CODE_SMELL,"""Serializable"" inner classes of ""Serializable"" classes should be static","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.semantic.Type;

@Rule(key = ""S2059"")
public class InnerClassOfSerializableCheck extends AbstractSerializableInnerClassRule {

  @Override
  protected boolean isMatchingOuterClass(Type outerClass) {
    return isSerializable(outerClass);
  }

}
"
S2060,BUG,"""Externalizable"" classes should have no-arguments constructors","package org.sonar.java.checks.serialization;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2060"")
public class ExternalizableClassConstructorCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (!isAnonymous(classTree) && implementsExternalizable(classTree)) {
      Collection<Symbol> constructors = classTree.symbol().lookupSymbols(""<init>"");
      var noArgConstructor = constructors.stream().filter(ExternalizableClassConstructorCheck::isNoArgConstructor).findFirst();

      if (noArgConstructor.isEmpty()) {
        reportIssue(Objects.requireNonNull(classTree.simpleName()), ""Add a no-arg constructor to this class."");
      } else if (!noArgConstructor.get().isPublic()) {
        // Implicit no-arg constructors have no declaration and same visibility as class. Can be below ""public"". Ignore them.
        var declaration = noArgConstructor.get().declaration();
        if (declaration != null) {
          reportIssue(((MethodTree) declaration).simpleName(), ""Declare this no-arg constructor public."");
        }
      }
    }
  }

  private static boolean isAnonymous(ClassTree classTree) {
    return classTree.simpleName() == null;
  }

  private static boolean implementsExternalizable(ClassTree classTree) {
    return classTree.symbol().type().isSubtypeOf(""java.io.Externalizable"");
  }

  private static boolean isNoArgConstructor(Symbol constructor) {
    return ((Symbol.MethodSymbol) constructor).parameterTypes().isEmpty();
  }
}
"
S2061,BUG,Custom serialization methods should have required signatures,"package org.sonar.java.checks.serialization;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2061"")
public class CustomSerializationMethodCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();
    if (isOwnedBySerializable(methodSymbol)) {
      if (hasSignature(methodSymbol, ""writeObject"", ""java.io.ObjectOutputStream"")
        || hasSignature(methodSymbol, ""readObject"", ""java.io.ObjectInputStream"")
        || hasSignature(methodSymbol, ""readObjectNoData"")) {
        checkPrivate(methodTree);
        checkNotStatic(methodTree);
      } else if (hasSignature(methodSymbol, ""writeReplace"")
        || hasSignature(methodSymbol, ""readResolve"")) {
        checkNotStatic(methodTree);
        checkReturnType(methodTree, ""java.lang.Object"");
      }
    }
  }

  private static boolean isOwnedBySerializable(Symbol.MethodSymbol methodSymbol) {
    Symbol.TypeSymbol owner = (Symbol.TypeSymbol) methodSymbol.owner();
    return owner.type().isSubtypeOf(""java.io.Serializable"");
  }

  private static boolean hasSignature(Symbol.MethodSymbol methodSymbol, String name, String paramType) {
    return name.equals(methodSymbol.name()) && hasSingleParam(methodSymbol, paramType);
  }

  private static boolean hasSignature(Symbol.MethodSymbol methodSymbol, String name) {
    return name.equals(methodSymbol.name()) && methodSymbol.parameterTypes().isEmpty();
  }

  private static boolean hasSingleParam(Symbol.MethodSymbol methodSymbol, String searchedParamType) {
    List<Type> parametersTypes = methodSymbol.parameterTypes();
    return parametersTypes.size() == 1 && parametersTypes.get(0).is(searchedParamType);
  }

  private void checkNotStatic(MethodTree methodTree) {
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();
    if (methodSymbol.isStatic()) {
      reportIssue(methodTree.simpleName(), ""The \""static\"" modifier should not be applied to \"""" + methodSymbol.name() + ""\""."");
    }
  }

  private void checkPrivate(MethodTree methodTree) {
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();
    if (!methodSymbol.isPrivate()) {
      reportIssue(methodTree.simpleName(), ""Make \"""" + methodSymbol.name() + ""\"" \""private\""."");
    }
  }

  private void checkReturnType(MethodTree methodTree, String requiredReturnType) {
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();
    if (!methodSymbol.returnType().type().is(requiredReturnType)) {
      reportIssue(methodTree.simpleName(), ""\"""" + methodSymbol.name() + ""\"" should return \"""" + requiredReturnType + ""\""."");
    }
  }

}
"
S2062,CODE_SMELL,"""readResolve"" methods should be inheritable","package org.sonar.java.checks.serialization;

import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2062"")
public class PrivateReadResolveCheck extends IssuableSubscriptionVisitor {
  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree method = (MethodTree) tree;
    if (isPrivateReadResolve(method) && isOwnedBySerializableExtensibleClass(method)) {
      reportIssue(method.simpleName(), ""Make this class \""private\"" or elevate the visibility of \""readResolve\""."");
    }
  }

  private static boolean isPrivateReadResolve(MethodTree method) {
    return ""readResolve"".equals(method.simpleName().name()) && method.parameters().isEmpty() && ModifiersUtils.hasModifier(method.modifiers(), Modifier.PRIVATE);
  }

  private static boolean isOwnedBySerializableExtensibleClass(MethodTree method) {
    Symbol owner = method.symbol().owner();
    return !owner.isPrivate() && !owner.isFinal() && owner.type().isSubtypeOf(""java.io.Serializable"");
  }
}
"
S2063,CODE_SMELL,"Comparators should be ""Serializable""","package org.sonar.java.checks.serialization;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2063"")
public class SerializableComparatorCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Symbol.TypeSymbol symbol = classTree.symbol();
    Type type = symbol.type();
    IdentifierTree simpleName = classTree.simpleName();
    if (simpleName != null && type.isSubtypeOf(""java.util.Comparator"") && !type.isSubtypeOf(""java.io.Serializable"") && !symbol.isAbstract()) {
      reportIssue(simpleName, ""Make this class \""Serializable\""."");
    }
  }

}
"
S2065,CODE_SMELL,"Fields in non-serializable classes should not be ""transient""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2065"")
public class TransientFieldInNonSerializableCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (isNotSerializable(classTree.symbol())) {
      for (Tree member : classTree.members()) {
        ModifierKeywordTree transientModifier = isTransient(member);
        if (transientModifier != null) {
          reportIssue(transientModifier, ""Remove the \""transient\"" modifier from this field."");
        }
      }
    }
  }

  private static boolean isNotSerializable(Symbol.TypeSymbol symbol) {
    for (Type superType : symbol.superTypes()) {
      if (superType.isUnknown()) {
        return false;
      }
    }
    return !symbol.type().isSubtypeOf(""java.io.Serializable"");
  }

  private static ModifierKeywordTree isTransient(Tree tree) {
    if (tree.is(Tree.Kind.VARIABLE)) {
      VariableTree variable = (VariableTree) tree;
      return ModifiersUtils.getModifier(variable.modifiers(), Modifier.TRANSIENT);
    }
    return null;
  }

}
"
S2066,BUG,"""Serializable"" inner classes of non-serializable outer classes should be ""static""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.semantic.Type;

@Rule(key = ""S2066"")
public class InnerClassOfNonSerializableCheck extends AbstractSerializableInnerClassRule {

  @Override
  protected boolean isMatchingOuterClass(Type outerClass) {
    return !isSerializable(outerClass);
  }

}
"
S2068,SECURITY_HOTSPOT,Hard-coded passwords are security-sensitive,"package org.sonar.java.checks;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2068"")
public class HardCodedPasswordCheck extends AbstractHardCodedCredentialChecker {

  private static final String DEFAULT_PASSWORD_WORDS = ""password,passwd,pwd,passphrase,java.naming.security.credentials"";
  private static final Pattern URL_PREFIX = Pattern.compile(""^\\w{1,8}://"");
  private static final Pattern NON_EMPTY_URL_CREDENTIAL = Pattern.compile(""(?<user>[^\\s:]*+):(?<password>\\S++)"");

  @RuleProperty(
    key = ""credentialWords"",
    description = ""Comma separated list of words identifying potential passwords"",
    defaultValue = DEFAULT_PASSWORD_WORDS)
  public String passwordWords = DEFAULT_PASSWORD_WORDS;

  @Override
  protected String getCredentialWords() {
    return passwordWords;
  }

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.STRING_LITERAL, Tree.Kind.VARIABLE, Tree.Kind.ASSIGNMENT, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.STRING_LITERAL)) {
      handleStringLiteral((LiteralTree) tree);
    } else if (tree.is(Tree.Kind.VARIABLE)) {
      handleVariable((VariableTree) tree);
    } else if (tree.is(Tree.Kind.ASSIGNMENT)) {
      handleAssignment((AssignmentExpressionTree) tree);
    } else {
      handleMethodInvocation((MethodInvocationTree) tree);
    }
  }

  @Override
  protected void handleStringLiteral(LiteralTree tree) {
    String cleanedLiteral = LiteralUtils.trimQuotes(tree.value());
    if (isURLWithCredentials(cleanedLiteral)) {
      reportIssue(tree, ""Review this hard-coded URL, which may contain a password."");
    } else {
      super.handleStringLiteral(tree);
    }
  }

  private static boolean isURLWithCredentials(String stringLiteral) {
    if (URL_PREFIX.matcher(stringLiteral).find()) {
      try {
        String userInfo = new URL(stringLiteral).getUserInfo();
        if (userInfo != null) {
          Matcher matcher = NON_EMPTY_URL_CREDENTIAL.matcher(userInfo);
          return matcher.matches() && !matcher.group(""user"").equals(matcher.group(""password""));
        }
      } catch (MalformedURLException e) {
        // ignore, stringLiteral is not a valid URL
      }
    }
    return false;
  }

  private void handleMethodInvocation(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    if (EQUALS_MATCHER.matches(mit) && methodSelect.is(Kind.MEMBER_SELECT)) {
      handleEqualsMethod(mit, (MemberSelectExpressionTree) methodSelect);
    } else {
      isSettingCredential(mit).ifPresent(settingPassword -> report(ExpressionUtils.methodName(mit), settingPassword));
    }
  }

  @Override
  protected void report(Tree tree, String match) {
    reportIssue(tree, ""'"" + match + ""' detected in this expression, review this potentially hard-coded password."");
  }

  @Override
  protected boolean isCredentialContainingPattern(ExpressionTree expression) {
    if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
      ExpressionTree methodSelect = ((MethodInvocationTree) expression).methodSelect();
      return methodSelect.is(Tree.Kind.MEMBER_SELECT) && isCredentialContainingPattern(((MemberSelectExpressionTree) methodSelect).expression());
    }
    String literal = ExpressionsHelper.getConstantValueAsString(expression).value();
    return literal == null || super.isCredentialLikeName(literal).isPresent();
  }
}
"
S2077,SECURITY_HOTSPOT,Formatting SQL queries is security-sensitive,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.ReassignmentFinder.getInitializerOrExpression;
import static org.sonar.java.checks.helpers.ReassignmentFinder.getReassignments;
import static org.sonar.plugins.java.api.semantic.MethodMatchers.CONSTRUCTOR;

@Rule(key = ""S2077"")
public class SQLInjectionCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_SQL_STATEMENT = ""java.sql.Statement"";
  private static final String JAVA_SQL_CONNECTION = ""java.sql.Connection"";
  private static final String SPRING_JDBC_OPERATIONS = ""org.springframework.jdbc.core.JdbcOperations"";

  private static final MethodMatchers SQL_INJECTION_SUSPECTS = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(""org.hibernate.Session"")
      .names(""createQuery"", ""createSQLQuery"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(JAVA_SQL_STATEMENT)
      .names(""executeQuery"", ""execute"", ""executeUpdate"", ""executeLargeUpdate"", ""addBatch"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(JAVA_SQL_CONNECTION)
      .names(""prepareStatement"", ""prepareCall"", ""nativeSQL"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofTypes(""javax.persistence.EntityManager"")
      .names(""createNativeQuery"", ""createQuery"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create().ofSubTypes(SPRING_JDBC_OPERATIONS, ""org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"")
      .names(""batchUpdate"", ""execute"", ""query"", ""queryForList"", ""queryForMap"", ""queryForObject"",
        ""queryForRowSet"", ""queryForInt"", ""queryForLong"", ""update"", ""queryForStream"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofTypes(""org.springframework.jdbc.core.PreparedStatementCreatorFactory"")
      .names(CONSTRUCTOR, ""newPreparedStatementCreator"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""javax.jdo.PersistenceManager"")
      .names(""newQuery"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""javax.jdo.Query"")
      .names(""setFilter"", ""setGrouping"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl"")
      .names(""setAuthoritiesByUsernameQuery"", ""setGroupAuthoritiesByUsernameQuery"", ""setUsersByUsernameQuery"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""org.springframework.security.provisioning.JdbcUserDetailsManager"")
      .names(""setChangePasswordSql"", ""setCreateAuthoritySql"", ""setCreateUserSql"", ""setDeleteGroupAuthoritiesSql"",
        ""setDeleteGroupAuthoritySql"", ""setDeleteGroupMemberSql"", ""setDeleteGroupMembersSql"", ""setDeleteGroupSql"",
        ""setDeleteUserAuthoritiesSql"", ""setDeleteUserSql"", ""setFindAllGroupsSql"", ""setFindGroupIdSql"", ""setFindUsersInGroupSql"",
        ""setGroupAuthoritiesSql"", ""setInsertGroupAuthoritySql"", ""setInsertGroupMemberSql"", ""setInsertGroupSql"", ""setRenameGroupSql"",
        ""setUpdateUserSql"", ""setUserExistsSql"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""org.springframework.jdbc.core.simple.JdbcClient"")
      .names(""sql"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofTypes(""org.springframework.data.r2dbc.repository.query.StringBasedR2dbcQuery"")
      .names(CONSTRUCTOR)
      .withAnyParameters()
      .build());

  private static final String MAIN_MESSAGE = ""Make sure using a dynamically formatted SQL query is safe here."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    if (anyMatch(tree)) {
      Optional<ExpressionTree> sqlStringArg = arguments(tree)
        .filter(arg -> arg.symbolType().is(""java.lang.String""))
        .findFirst();

      if (sqlStringArg.isPresent()) {
        ExpressionTree sqlArg = sqlStringArg.get();
        if (isDynamicConcatenation(sqlArg)) {
          reportIssue(sqlArg, MAIN_MESSAGE);
        } else if (sqlArg.is(Tree.Kind.IDENTIFIER)) {
          IdentifierTree identifierTree = (IdentifierTree) sqlArg;
          Symbol symbol = identifierTree.symbol();
          ExpressionTree initializerOrExpression = getInitializerOrExpression(symbol.declaration());
          List<AssignmentExpressionTree> reassignments = getReassignments(symbol.owner().declaration(), symbol.usages());

          if ((initializerOrExpression != null && isDynamicConcatenation(initializerOrExpression)) ||
            reassignments.stream().anyMatch(SQLInjectionCheck::isDynamicPlusAssignment)) {
            reportIssue(sqlArg, MAIN_MESSAGE, secondaryLocations(initializerOrExpression, reassignments, identifierTree.name()), null);
          }
        }
      }
    }
  }

  private static List<JavaFileScannerContext.Location> secondaryLocations(@Nullable ExpressionTree initializerOrExpression,
    List<AssignmentExpressionTree> reassignments,
    String identifierName) {
    List<JavaFileScannerContext.Location> secondaryLocations = reassignments.stream()
      .map(assignment -> new JavaFileScannerContext.Location(String.format(""SQL Query is assigned to '%s'"", getVariableName(assignment)),
        assignment.expression()))
      .collect(Collectors.toCollection(ArrayList::new));

    if (initializerOrExpression != null) {
      secondaryLocations.add(new JavaFileScannerContext.Location(String.format(""SQL Query is dynamically formatted and assigned to '%s'"",
        identifierName),
        initializerOrExpression));
    }
    return secondaryLocations;
  }

  private static String getVariableName(AssignmentExpressionTree assignment) {
    ExpressionTree variable = assignment.variable();
    return ((IdentifierTree) variable).name();
  }

  private static Stream<ExpressionTree> arguments(Tree methodTree) {
    if (methodTree.is(Tree.Kind.METHOD_INVOCATION)) {
      return ((MethodInvocationTree) methodTree).arguments().stream();
    }
    if (methodTree.is(Tree.Kind.NEW_CLASS)) {
      return ((NewClassTree) methodTree).arguments().stream();
    }
    return Stream.empty();
  }

  private static boolean anyMatch(Tree tree) {
    if (!hasArguments(tree)) {
      return false;
    }
    if (tree.is(Tree.Kind.NEW_CLASS)) {
      return SQL_INJECTION_SUSPECTS.matches((NewClassTree) tree);
    }
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      return SQL_INJECTION_SUSPECTS.matches((MethodInvocationTree) tree);
    }
    return false;
  }

  private static boolean hasArguments(Tree tree) {
    return arguments(tree).findAny().isPresent();
  }

  private static boolean isDynamicPlusAssignment(ExpressionTree arg) {
    return arg.is(Tree.Kind.PLUS_ASSIGNMENT) && !((AssignmentExpressionTree) arg).expression().asConstant().isPresent();
  }

  private static boolean isDynamicConcatenation(ExpressionTree arg) {
    return arg.is(Tree.Kind.PLUS) && !arg.asConstant().isPresent();
  }
}
"
S2092,SECURITY_HOTSPOT,"Creating cookies without the ""secure"" flag is security-sensitive","package org.sonar.java.checks.security;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2092"")
public class SecureCookieCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Make sure creating this cookie without the \""secure\"" flag is safe here."";

  private static final String JAX_RS_COOKIE = ""javax.ws.rs.core.Cookie"";
  private static final String JAX_RS_COOKIE_JAKARTA = ""jakarta.ws.rs.core.Cookie"";
  private static final String JAX_RS_NEW_COOKIE = ""javax.ws.rs.core.NewCookie"";
  private static final String JAX_RS_NEW_COOKIE_JAKARTA = ""jakarta.ws.rs.core.NewCookie"";
  private static final String SPRING_SAVED_COOKIE = ""org.springframework.security.web.savedrequest.SavedCookie"";
  private static final String PLAY_COOKIE = ""play.mvc.Http$Cookie"";
  private static final List<String> COOKIES = Arrays.asList(
    ""javax.servlet.http.Cookie"",
    ""jakarta.servlet.http.Cookie"",
    ""java.net.HttpCookie"",
    JAX_RS_COOKIE,
    JAX_RS_COOKIE_JAKARTA,
    JAX_RS_NEW_COOKIE,
    JAX_RS_NEW_COOKIE_JAKARTA,
    ""org.apache.shiro.web.servlet.SimpleCookie"",
    SPRING_SAVED_COOKIE,
    PLAY_COOKIE,
    ""play.mvc.Http$CookieBuilder"",
    ""org.springframework.boot.web.server.Cookie"",
    ""org.springframework.http.ResponseCookie$ResponseCookieBuilder"");

  private static final List<String> SETTER_NAMES = Arrays.asList(""setSecure"", ""withSecure"", ""secure"");private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String JAVA_UTIL_DATE = ""java.util.Date"";
  private static final String INT = ""int"";
  private static final String BOOLEAN = ""boolean"";

  private static final MethodMatchers CONSTRUCTORS_WITH_SECURE_PARAM_LAST = MethodMatchers.create()
    .ofTypes(JAX_RS_NEW_COOKIE, JAX_RS_NEW_COOKIE_JAKARTA)
    .constructor()
    .addParametersMatcher(JAX_RS_COOKIE, JAVA_LANG_STRING, INT, BOOLEAN)
    .addParametersMatcher(JAX_RS_COOKIE_JAKARTA, JAVA_LANG_STRING, INT, BOOLEAN)
    .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, INT, JAVA_LANG_STRING, INT, BOOLEAN)
    .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, INT, BOOLEAN)
    .build();

  private static final MethodMatchers CONSTRUCTORS_WITH_SECURE_PARAM_BEFORE_LAST = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(JAX_RS_NEW_COOKIE, JAX_RS_NEW_COOKIE_JAKARTA)
      .constructor()
      .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, INT, JAVA_LANG_STRING, INT, JAVA_UTIL_DATE, BOOLEAN, BOOLEAN)
      .addParametersMatcher(JAX_RS_COOKIE, JAVA_LANG_STRING, INT, JAVA_UTIL_DATE, BOOLEAN, BOOLEAN)
      .addParametersMatcher(JAX_RS_COOKIE_JAKARTA, JAVA_LANG_STRING, INT, JAVA_UTIL_DATE, BOOLEAN, BOOLEAN)
      .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, INT, BOOLEAN, BOOLEAN)
      .build(),
    MethodMatchers.create()
      .ofTypes(SPRING_SAVED_COOKIE)
      .constructor()
      .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, INT, JAVA_LANG_STRING, BOOLEAN, INT)
      .build(),
    MethodMatchers.create()
      .ofTypes(PLAY_COOKIE)
      .constructor()
      .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING, ""java.lang.Integer"", JAVA_LANG_STRING, JAVA_LANG_STRING, BOOLEAN, BOOLEAN)
      .build());

  private static final MethodMatchers CONSTRUCTORS_WITH_SECURE_PARAM_BEFORE_BEFORE_LAST = MethodMatchers.create()
    .ofTypes(PLAY_COOKIE)
    .constructor()
    .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING, ""java.lang.Integer"", JAVA_LANG_STRING, JAVA_LANG_STRING, BOOLEAN, BOOLEAN, ""play.mvc.Http$Cookie$SameSite"")
    .build();

  private final Map<Symbol.VariableSymbol, NewClassTree> unsecuredCookies = new HashMap<>();
  private final Set<NewClassTree> cookieConstructors = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.VARIABLE,
      Tree.Kind.ASSIGNMENT,
      Tree.Kind.METHOD_INVOCATION,
      Tree.Kind.NEW_CLASS);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    unsecuredCookies.clear();
    cookieConstructors.clear();
    super.setContext(context);
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    cookieConstructors.forEach(r -> reportIssue(r.identifier(), MESSAGE));
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.VARIABLE)) {
      addToUnsecuredCookies((VariableTree) tree);
    } else if (tree.is(Tree.Kind.ASSIGNMENT)) {
      addToUnsecuredCookies((AssignmentExpressionTree) tree);
    } else if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      checkSecureCall((MethodInvocationTree) tree);
    } else {
      checkConstructor((NewClassTree) tree);
    }
  }

  private void addToUnsecuredCookies(VariableTree variableTree) {
    ExpressionTree initializer = variableTree.initializer();
    Symbol variableTreeSymbol = variableTree.symbol();

    if (initializer != null && variableTreeSymbol.isVariableSymbol()) {
      boolean isInitializedWithConstructor = initializer.is(Tree.Kind.NEW_CLASS);
      boolean isMatchedType = isCookieClass(variableTreeSymbol.type()) || isCookieClass(initializer.symbolType());
      if (isInitializedWithConstructor && isMatchedType && isSecureParamFalse((NewClassTree) initializer)) {
        unsecuredCookies.put((Symbol.VariableSymbol) variableTreeSymbol, (NewClassTree) initializer);
      }
    }
  }

  private void addToUnsecuredCookies(AssignmentExpressionTree assignment) {
    if (assignment.expression().is(Tree.Kind.NEW_CLASS) && assignment.variable().is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree assignmentVariable = (IdentifierTree) assignment.variable();
      Symbol assignmentVariableSymbol = assignmentVariable.symbol();
      boolean isMatchedType = isCookieClass(assignmentVariable.symbolType()) || isCookieClass(assignment.expression().symbolType());
      if (isMatchedType && isSecureParamFalse((NewClassTree) assignment.expression()) && !assignmentVariableSymbol.isUnknown()) {
        unsecuredCookies.put((Symbol.VariableSymbol) assignmentVariableSymbol, (NewClassTree) assignment.expression());
      }
    }
  }

  private void checkSecureCall(MethodInvocationTree mit) {
    if (isSetSecureCall(mit) && mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionsHelper.ValueResolution<Boolean> valueResolution = ExpressionsHelper.getConstantValueAsBoolean(mit.arguments().get(0));
      Boolean secureArgument = valueResolution.value();
      boolean isFalse = secureArgument != null && !secureArgument;
      if (isFalse) {
        reportIssue(mit.arguments(), MESSAGE, valueResolution.valuePath(), null);
      }
      ExpressionTree methodObject = ((MemberSelectExpressionTree) mit.methodSelect()).expression();
      if (methodObject.is(Tree.Kind.IDENTIFIER)) {
        IdentifierTree identifierTree = (IdentifierTree) methodObject;
        NewClassTree newClassTree = unsecuredCookies.remove(identifierTree.symbol());
        cookieConstructors.remove(newClassTree);
      }
    }
  }

  private void checkConstructor(NewClassTree tree) {
    if (isCookieClass(tree.symbolType()) && isSecureParamFalse(tree)) {
      cookieConstructors.add(tree);
    }
  }

  private static boolean isSecureParamFalse(NewClassTree newClassTree) {
    ExpressionTree secureArgument = null;
    Arguments arguments = newClassTree.arguments();
    if (CONSTRUCTORS_WITH_SECURE_PARAM_LAST.matches(newClassTree)) {
      secureArgument = arguments.get(arguments.size() - 1);
    } else if (CONSTRUCTORS_WITH_SECURE_PARAM_BEFORE_LAST.matches(newClassTree)) {
      secureArgument = arguments.get(arguments.size() - 2);
    } else if (CONSTRUCTORS_WITH_SECURE_PARAM_BEFORE_BEFORE_LAST.matches(newClassTree)) {
      secureArgument = arguments.get(arguments.size() - 3);
    }
    if (secureArgument != null) {
      return LiteralUtils.isFalse(secureArgument);
    }
    return true;
  }

  private static boolean isSetSecureCall(MethodInvocationTree mit) {
    return mit.arguments().size() == 1
      && !mit.methodSymbol().isUnknown()
      && !mit.methodSymbol().owner().isUnknown()
      && isCookieClass(mit.methodSymbol().owner().type())
      && SETTER_NAMES.stream().anyMatch(getIdentifier(mit).name()::equals);
  }

  private static boolean isCookieClass(Type type) {
    return COOKIES.stream().anyMatch(type::isSubtypeOf);
  }

  private static IdentifierTree getIdentifier(MethodInvocationTree mit) {
    IdentifierTree id;
    if (mit.methodSelect().is(Tree.Kind.IDENTIFIER)) {
      id = (IdentifierTree) mit.methodSelect();
    } else {
      id = ((MemberSelectExpressionTree) mit.methodSelect()).identifier();
    }
    return id;
  }

}
"
S2093,CODE_SMELL,Try-with-resources should be used,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.cfg.CFG;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;

@Rule(key = ""S2093"")
public class TryWithResourcesCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  private static final MethodMatchers AUTOCLOSEABLE_BUILDER_MATCHER = MethodMatchers.or(
    MethodMatchers.create().ofTypes(""java.net.http.HttpClient$Builder"").names(""build"").addWithoutParametersMatcher().build(),
    MethodMatchers.create().ofTypes(""java.net.http.HttpClient"").names(""newHttpClient"").addWithoutParametersMatcher().build()
  );

  private final Deque<TryStatementTree> withinTry = new LinkedList<>();
  private final Deque<List<Tree>> toReport = new LinkedList<>();

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    withinTry.clear();
    toReport.clear();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.TRY_STATEMENT, Tree.Kind.NEW_CLASS, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.TRY_STATEMENT)) {
      withinTry.push((TryStatementTree) tree);
      if (withinTry.size() != toReport.size()) {
        toReport.push(new ArrayList<>());
      }
    } else if (isNewAutocloseableOrBuilder(tree, context)) {
      if (withinStandardTryWithFinally()) {
        toReport.peek().add(tree);
      } else if (isFollowedByTryWithFinally(tree)) {
        if (toReport.isEmpty() || withinTry.size() == toReport.size()) {
          // This newClass will be reported with the following tryStatement
          toReport.push(new ArrayList<>());
        }
        toReport.peek().add(tree);
      }
    }
  }

  private static boolean isNewAutocloseableOrBuilder(Tree tree, JavaFileScannerContext context) {
    return (tree instanceof NewClassTree newClass && newClass.symbolType().isSubtypeOf(""java.lang.AutoCloseable"")) ||
      (context.getJavaVersion().isJava21Compatible() && tree instanceof MethodInvocationTree mit && AUTOCLOSEABLE_BUILDER_MATCHER.matches(mit));
  }

  private static boolean isFollowedByTryWithFinally(Tree tree) {
    Tree blockParent = tree.parent();
    while (blockParent != null && !blockParent.is(Tree.Kind.BLOCK)) {
      blockParent = blockParent.parent();
    }

    if (blockParent != null) {
      CFG cfg = CFG.buildCFG(Collections.singletonList(blockParent), true);
      if (!cfg.blocks().isEmpty()) {
        return newFollowedByTryStatement(cfg.blocks().get(0));
      }
    }

    // Unreachable by construction because the CFG has been built on top of a NewClass element
    return false;
  }

  private static boolean newFollowedByTryStatement(CFG.Block cfgBlock) {
    boolean foundNewAutoCloseable = false;
    for (Tree element : cfgBlock.elements()) {
      switch (element.kind()) {
        case NEW_CLASS:
          boolean isAutoCloseable = ((NewClassTree) element).symbolType().isSubtypeOf(""java.lang.AutoCloseable"");
          if (!isAutoCloseable && foundNewAutoCloseable) {
            return false;
          }
          foundNewAutoCloseable = isAutoCloseable;
          break;
        case TRY_STATEMENT:
          if (((TryStatementTree) element).resourceList().isEmpty() && ((TryStatementTree) element).finallyBlock() != null) {
            return foundNewAutoCloseable;
          }
          return false;
        case VARIABLE:
          break;
        default:
          if (foundNewAutoCloseable) {
            return false;
          }
          break;
      }
    }
    // Unreachable: by construction at least one element of the CFG.Block is a NewClass of type ""java.lang.AutoCloseable""
    return false;
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.TRY_STATEMENT)) {
      TryStatementTree tryStatementTree = withinTry.pop();
      List<Tree> secondaryTrees = toReport.pop();
      if (!secondaryTrees.isEmpty()) {
        List<JavaFileScannerContext.Location> secondary = new ArrayList<>();
        for (Tree autoCloseable : secondaryTrees) {
          secondary.add(new JavaFileScannerContext.Location(""AutoCloseable resource"", autoCloseable));
        }
        reportIssue(tryStatementTree.tryKeyword(),
          ""Change this \""try\"" to a try-with-resources."" + context.getJavaVersion().java7CompatibilityMessage(), secondary, null);
      }
    }
  }

  private boolean withinStandardTryWithFinally() {
    return !withinTry.isEmpty() && withinTry.peek().resourceList().isEmpty() && withinTry.peek().finallyBlock() != null;
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava7Compatible();
  }
}
"
S2094,CODE_SMELL,Classes should not be empty,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S2094"")
public class EmptyClassCheck extends IssuableSubscriptionVisitor {
  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    IdentifierTree simpleName = classTree.simpleName();
    if (simpleName != null && isNotExtending(classTree) && isEmpty(classTree)) {
      reportIssue(simpleName, ""Remove this empty class, write its code or make it an \""interface\""."");
    }
  }

  private static boolean isNotExtending(ClassTree tree) {
    return tree.superClass() == null && tree.superInterfaces().isEmpty();
  }

  private static boolean isEmpty(ClassTree tree) {
    return tree.modifiers().annotations().isEmpty()
      && tree.recordComponents().isEmpty()
      && tree.members().stream().allMatch(member -> member.is(Tree.Kind.EMPTY_STATEMENT));
  }
}
"
S2096,CODE_SMELL,"""main"" should not ""throw"" anything","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2096"")
public class MainMethodThrowsExceptionCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (MethodTreeUtils.isMainMethod(methodTree) && !methodTree.throwsClauses().isEmpty()) {
      reportIssue(methodTree.throwsToken(), ""Remove this throws clause."");
    }
  }
}
"
S2097,BUG,"""equals(Object obj)"" should test the argument's type","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.InstanceOfTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S2097"")
public class EqualsArgumentTypeCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers EQUALS_MATCHER = MethodMatchers.create()
    .ofAnyType()
    .names(""equals"")
    .addParametersMatcher(ANY)
    .build();

  private static final MethodMatchers GETCLASS_MATCHER = MethodMatchers.create()
    .ofAnyType()
    .names(""getClass"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (methodTree.block() != null && ""equals"".equals(methodTree.symbol().name()) && methodTree.parameters().size() == 1) {
      Symbol parameterSymbol = methodTree.parameters().get(0).symbol();
      if (parameterSymbol.type().is(""java.lang.Object"")) {
        CastVisitor castVisitor = new CastVisitor(parameterSymbol);
        methodTree.accept(castVisitor);
        if (castVisitor.hasUncheckedCast) {
          reportIssue(methodTree.simpleName(), ""Add a type test to this method."");
        }
      }
    }
  }

  private static boolean isArgument(ExpressionTree tree, Symbol parameterSymbol) {
    ExpressionTree expressionTree = ExpressionUtils.skipParentheses(tree);
    return expressionTree.is(Tree.Kind.IDENTIFIER) && ((IdentifierTree) expressionTree).symbol().equals(parameterSymbol);
  }

  private static class CastVisitor extends BaseTreeVisitor {
    private final Symbol parameterSymbol;
    boolean typeChecked = false;
    boolean hasUncheckedCast = false;

    public CastVisitor(Symbol parameterSymbol) {
      this.parameterSymbol = parameterSymbol;
    }

    @Override
    public void visitBinaryExpression(BinaryExpressionTree tree) {
      if (tree.is(Tree.Kind.CONDITIONAL_AND)) {
        ExpressionVisitor expressionVisitor = new ExpressionVisitor(parameterSymbol);
        tree.leftOperand().accept(expressionVisitor);
        if (expressionVisitor.typeChecked) {
          typeChecked = true;
          return;
        }
        scan(tree.rightOperand());
      } else {
        super.visitBinaryExpression(tree);
      }
    }

    @Override
    public void visitConditionalExpression(ConditionalExpressionTree tree) {
      ExpressionVisitor expressionVisitor = new ExpressionVisitor(parameterSymbol);
      tree.condition().accept(expressionVisitor);
      if (expressionVisitor.typeChecked) {
        typeChecked = true;
        return;
      }
      scan(tree.trueExpression());
      scan(tree.falseExpression());
    }

    @Override
    public void visitIfStatement(IfStatementTree tree) {
      ExpressionVisitor expressionVisitor = new ExpressionVisitor(parameterSymbol);
      tree.condition().accept(expressionVisitor);
      if (expressionVisitor.typeChecked) {
        typeChecked = true;
        return;
      }
      scan(tree.thenStatement());
      scan(tree.elseStatement());
    }

    @Override
    public void visitTypeCast(TypeCastTree tree) {
      if (isArgument(tree.expression(), parameterSymbol) && !typeChecked) {
        hasUncheckedCast = true;
      } else {
        super.visitTypeCast(tree);
      }
    }
  }

  private static class ExpressionVisitor extends BaseTreeVisitor {
    private final Symbol parameterSymbol;
    private boolean typeChecked;

    ExpressionVisitor(Symbol parameterSymbol) {
      this.parameterSymbol = parameterSymbol;
    }

    @Override
    public void visitInstanceOf(InstanceOfTree tree) {
      if (isArgument(tree.expression(), parameterSymbol)) {
        typeChecked = true;
      }
    }

    @Override
    public void visitBinaryExpression(BinaryExpressionTree tree) {
      if (tree.is(Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO) && (isGetClassOnArgument(tree.leftOperand()) || isGetClassOnArgument(tree.rightOperand()))) {
        typeChecked = true;
      } else {
        super.visitBinaryExpression(tree);
      }
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (EQUALS_MATCHER.matches(tree)) {
        ExpressionTree methodSelect = tree.methodSelect();
        if ((methodSelect.is(Tree.Kind.MEMBER_SELECT) && isGetClassOnArgument(((MemberSelectExpressionTree) methodSelect).expression()))
          || isGetClassOnArgument(tree.arguments().get(0))) {
          typeChecked = true;
          return;
        }
      }
      for (ExpressionTree argument : tree.arguments()) {
        if (isArgument(argument, parameterSymbol)) {
          typeChecked = true;
          return;
        }
      }
      super.visitMethodInvocation(tree);
    }

    private boolean isGetClassOnArgument(ExpressionTree tree) {
      ExpressionTree expressionTree = ExpressionUtils.skipParentheses(tree);
      return expressionTree.is(Tree.Kind.METHOD_INVOCATION)
        && GETCLASS_MATCHER.matches((MethodInvocationTree) expressionTree)
        && isInvocationOnArgument((MethodInvocationTree) expressionTree);
    }

    private boolean isInvocationOnArgument(MethodInvocationTree tree) {
      return tree.methodSelect().is(Tree.Kind.MEMBER_SELECT) && isArgument(((MemberSelectExpressionTree) tree.methodSelect()).expression(), parameterSymbol);
    }
  }

}
"
S2109,BUG,Reflection should not be used to check non-runtime annotations,"package org.sonar.java.checks;

import java.util.List;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2109"")
public class ReflectionOnNonRuntimeAnnotationCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofSubTypes(""java.lang.reflect.AnnotatedElement"")
      .names(""isAnnotationPresent"")
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree expressionTree = mit.arguments().get(0);
    // For now ignore everything that is not a .class expression
    if (expressionTree.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) expressionTree;
      boolean isClassIdentifier = ""class"".equals(memberSelect.identifier().name());
      Type symbolType = memberSelect.expression().symbolType();
      if (isClassIdentifier && !symbolType.isUnknown() && isNotRuntimeAnnotation(symbolType)) {
        reportIssue(expressionTree, ""\""@"" + symbolType.name() + ""\"" is not available at runtime and cannot be seen with reflection."");
      }
    }
  }

  private static boolean isNotRuntimeAnnotation(Type symbolType) {
    List<SymbolMetadata.AnnotationValue> valuesFor = symbolType.symbol().metadata().valuesForAnnotation(""java.lang.annotation.Retention"");
    // default policy is CLASS
    if (valuesFor == null) {
      return true;
    }
    String retentionValue = getRetentionValue(valuesFor.get(0).value());
    return !""RUNTIME"".equals(retentionValue);
  }

  @Nullable
  private static String getRetentionValue(Object value) {
    if (value instanceof Symbol.VariableSymbol variableSymbol) {
      return variableSymbol.name();
    }
    return null;
  }
}
"
S2110,BUG,"Invalid ""Date"" values should not be used","package org.sonar.java.checks;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

@Rule(key = ""S2110"")
public class InvalidDateValuesCheck extends AbstractMethodDetection {

  public static final String JAVA_UTIL_CALENDAR = ""java.util.Calendar"";
  public static final String JAVA_UTIL_DATE = ""java.util.Date"";
  public static final String JAVA_SQL_DATE = ""java.sql.Date"";

  private static final String[] GREGORIAN_PARAMETERS = {""year"", ""month"", ""dayOfMonth"", ""hourOfDay"", ""minute"", ""second""};
  private static final String[] DATE_GET_METHODS = {""getDate"", ""getMonth"", ""getHours"", ""getMinutes"", ""getSeconds""};
  private static final String[] DATE_SET_METHODS = {""setDate"", ""setMonth"", ""setHours"", ""setMinutes"", ""setSeconds""};

  private static final MethodMatchers DATE_METHODS_COMPARISON = MethodMatchers.or(
    MethodMatchers.create().ofTypes(JAVA_UTIL_CALENDAR).names(""get"").addParametersMatcher(""int"").build(),
    // date get matchers
    MethodMatchers.create().ofTypes(JAVA_UTIL_DATE).names(DATE_GET_METHODS).addWithoutParametersMatcher().build(),
    MethodMatchers.create().ofTypes(JAVA_SQL_DATE).names(DATE_GET_METHODS).addWithoutParametersMatcher().build()
  );

  @Override
  public List<Tree.Kind> nodesToVisit() {
    ArrayList<Tree.Kind> kinds = new ArrayList<>(super.nodesToVisit());
    kinds.add(Tree.Kind.EQUAL_TO);
    kinds.add(Tree.Kind.NOT_EQUAL_TO);
    return kinds;
  }

  @Override
  public void visitNode(Tree tree) {
    super.visitNode(tree);
    if (tree.is(Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO)) {
      BinaryExpressionTree binaryExpressionTree = (BinaryExpressionTree) tree;
      String name = getThresholdToCheck(binaryExpressionTree.leftOperand());
      ExpressionTree argToCheck = null;
      if (name == null) {
        name = getThresholdToCheck(binaryExpressionTree.rightOperand());
        if (name != null) {
          argToCheck = binaryExpressionTree.leftOperand();
        }
      } else {
        argToCheck = binaryExpressionTree.rightOperand();
      }
      if (argToCheck != null) {
        checkArgument(argToCheck, name, ""\""{0}\"" is not a valid value for \""{1}\""."");
      }
    }
  }

  @CheckForNull
  private static String getThresholdToCheck(ExpressionTree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      if (DATE_METHODS_COMPARISON.matches(mit)) {
        String name = getMethodName(mit);
        return getName(mit, name);
      }
    }
    return null;
  }

  @CheckForNull
  private static String getName(MethodInvocationTree mit, String name) {
    if (""get"".equals(name)) {
      return getReferencedCalendarName(mit.arguments().get(0));
    }
    return name;
  }

  @CheckForNull
  private static String getReferencedCalendarName(ExpressionTree argument) {
    Symbol reference = null;
    if (argument.is(Tree.Kind.MEMBER_SELECT)) {
      reference = ((MemberSelectExpressionTree) argument).identifier().symbol();
    } else if (argument.is(Tree.Kind.IDENTIFIER)) {
      reference = ((IdentifierTree) argument).symbol();
    }
    if (reference != null &&
      reference.owner().type().is(JAVA_UTIL_CALENDAR) && DateField.containsField(reference.name())) {
      return reference.name();
    }
    return null;
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofTypes(JAVA_UTIL_DATE, JAVA_SQL_DATE).names(DATE_SET_METHODS).addParametersMatcher(""int"").build(),
      MethodMatchers.create().ofTypes(JAVA_UTIL_CALENDAR).names(""set"").addParametersMatcher(""int"", ""int"").build(),
      MethodMatchers.create().ofTypes(""java.util.GregorianCalendar"").constructor().withAnyParameters().build()
    );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    String name = getMethodName(mit);
    Arguments arguments = mit.arguments();
    if (""set"".equals(name)) {
      // Calendar method
      ExpressionTree arg0 = arguments.get(0);
      ExpressionTree arg1 = arguments.get(1);
      String referenceName = getReferencedCalendarName(arg0);
      if (referenceName != null) {
        checkArgument(arg1, referenceName, ""\""{0}\"" is not a valid value for setting \""{1}\""."");
      }
    } else if (""<init>"".equals(mit.methodSymbol().name())) {
      // call to this() or super()
      checkConstructorArguments(mit.arguments());
    } else {
      checkArgument(arguments.get(0), name, ""\""{0}\"" is not a valid value for \""{1}\"" method."");
    }
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    checkConstructorArguments(newClassTree.arguments());
  }

  private void checkConstructorArguments(Arguments arguments) {
    // Gregorian Calendar : simply ignore miliseconds, which could be a 7th parameter of the constructor
    int numberArgsToCheck = Math.min(arguments.size(), GREGORIAN_PARAMETERS.length);
    // Gregorian Calendar : ignore first argument: year.
    for (int i = 1; i < numberArgsToCheck; i++) {
      checkArgument(arguments.get(i), GREGORIAN_PARAMETERS[i], ""\""{0}\"" is not a valid value for setting \""{1}\""."");
    }
  }

  private void checkArgument(ExpressionTree arg, String name, String message) {
    LiteralTree literal = null;
    int sign = 1;
    if (arg.is(Tree.Kind.INT_LITERAL)) {
      literal = (LiteralTree) arg;
    } else if (arg.is(Tree.Kind.UNARY_MINUS, Tree.Kind.UNARY_PLUS) && ((UnaryExpressionTree) arg).expression().is(Tree.Kind.INT_LITERAL)) {
      if (arg.is(Tree.Kind.UNARY_MINUS)) {
        sign = -1;
      }
      literal = (LiteralTree) ((UnaryExpressionTree) arg).expression();
    }
    if (literal != null) {
      int argValue = Integer.parseInt(literal.value()) * sign;
      Range range = DateField.getFieldRange(name);
      if (argValue > range.maxValue || argValue < range.minValue) {
        reportIssue(arg, MessageFormat.format(message, argValue, name));
      }
    }
  }

  private static String getMethodName(MethodInvocationTree mit) {
    return ExpressionUtils.methodName(mit).name();
  }

  private enum DateField {
    MONTH(new Range(0, 11), ""setMonth"", ""getMonth"", ""MONTH"", ""month""),
    DATE(new Range(1, 31), ""setDate"", ""getDate"", ""DAY_OF_MONTH"", ""dayOfMonth""),
    HOURS(new Range(0, 23), ""setHours"", ""getHours"", ""HOUR_OF_DAY"", ""hourOfDay""),
    MINUTE(new Range(0, 60), ""setMinutes"", ""getMinutes"", ""MINUTE"", ""minute""),
    SECOND(new Range(0, 61), ""setSeconds"", ""getSeconds"", ""SECOND"", ""second"");

    private static final Map<String, Range> rangeByName = new HashMap<>();

    static {
      for (DateField field : DateField.values()) {
        rangeByName.put(field.javaDateSetter, field.range);
        rangeByName.put(field.javaDateGetter, field.range);
        rangeByName.put(field.calendarConstant, field.range);
        rangeByName.put(field.gregorianParam, field.range);
      }
    }

    private final Range range;
    private final String javaDateSetter;
    private final String javaDateGetter;
    private final String calendarConstant;
    private final String gregorianParam;

    DateField(Range range, String javaDateSetter, String javaDateGetter, String calendarConstant, String gregorianParam) {
      this.range = range;
      this.javaDateSetter = javaDateSetter;
      this.javaDateGetter = javaDateGetter;
      this.calendarConstant = calendarConstant;
      this.gregorianParam = gregorianParam;
    }

    public static Range getFieldRange(String name) {
      return rangeByName.get(name);
    }

    public static boolean containsField(String name) {
      return rangeByName.containsKey(name);
    }
  }

  private static class Range {
    public final int minValue;
    public final int maxValue;

    private Range(int minValue, int maxValue) {
      this.minValue = minValue;
      this.maxValue = maxValue;
    }
  }
}
"
S2111,BUG,"""BigDecimal(double)"" should not be used","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.DefaultJavaFileScannerContext;
import org.sonar.java.reporting.InternalJavaIssueBuilder;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2111"")
public class BigDecimalDoubleConstructorCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers BIG_DECIMAL_DOUBLE_FLOAT =
    MethodMatchers.create().ofTypes(""java.math.BigDecimal"")
      .constructor()
      .addParametersMatcher(""double"")
      .addParametersMatcher(""float"")
      .addParametersMatcher(""double"", MethodMatchers.ANY)
      .addParametersMatcher(""float"", MethodMatchers.ANY)
      .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    NewClassTree newClassTree = (NewClassTree) tree;
    if (BIG_DECIMAL_DOUBLE_FLOAT.matches(newClassTree)) {
      InternalJavaIssueBuilder builder = ((InternalJavaIssueBuilder) ((DefaultJavaFileScannerContext) context).newIssue())
        .forRule(this)
        .onTree(tree);

      Arguments arguments = newClassTree.arguments();
      if (arguments.size() == 1) {
        builder.withMessage(""Use \""BigDecimal.valueOf\"" instead."");
        builder.withQuickFix(() -> valueOfQuickFix(newClassTree));
      } else {
        builder.withMessage(""Use \""new BigDecimal(String, MathContext)\"" instead."");
        ExpressionTree firstArgument = arguments.get(0);
        if (firstArgument instanceof LiteralTree literalTree) {
          builder.withQuickFix(() -> stringConstructorQuickFix(literalTree));
        }
      }
      builder.report();
    }
  }

  private static JavaQuickFix valueOfQuickFix(NewClassTree newClassTree) {
    return JavaQuickFix.newQuickFix(""Replace with BigDecimal.valueOf"")
      .addTextEdit(JavaTextEdit.replaceBetweenTree(newClassTree.newKeyword(), newClassTree.identifier(), ""BigDecimal.valueOf""))
      .build();
  }

  private static JavaQuickFix stringConstructorQuickFix(LiteralTree argument) {
    String argumentValue = argument.value();
    if (argumentValue.endsWith(""f"") || argumentValue.endsWith(""d"") || argumentValue.endsWith(""F"") || argumentValue.endsWith(""D"")) {
      argumentValue = argumentValue.substring(0, argumentValue.length() - 1);
    }
    String newArgument = String.format(""\""%s\"""", argumentValue);
    return JavaQuickFix.newQuickFix(""Replace with BigDecimal(%s,"", newArgument)
      .addTextEdit(JavaTextEdit.replaceTree(argument, newArgument))
      .build();
  }
}
"
S2112,CODE_SMELL,"""URL.hashCode"" and ""URL.equals"" should be avoided","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2112"")
public class URLHashCodeAndEqualsCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_NET_URL = ""java.net.URL"";

  private static final MethodMatchers URL_MATCHERS = MethodMatchers.or(
    MethodMatchers.create().ofTypes(JAVA_NET_URL).names(""equals"").addParametersMatcher(""java.lang.Object"").build(),
    MethodMatchers.create().ofTypes(JAVA_NET_URL).names(""hashCode"").addWithoutParametersMatcher().build());

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.VARIABLE, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.VARIABLE)) {
      VariableTree variableTree = (VariableTree) tree;
      if (variableTree.initializer() != null) {
        Type variableType = variableTree.type().symbolType();
        if (isSubTypeOfSetOrMap(variableType) && usesURLAsTypeParameter(variableType)) {
          reportIssue(variableTree.type(), ""Use the URI class instead."");
        }
      }
    } else if (URL_MATCHERS.matches((MethodInvocationTree) tree)) {
      reportIssue(tree, ""Use the URI class instead."");
    }
  }

  private static boolean isSubTypeOfSetOrMap(Type type) {
    return type.isSubtypeOf(""java.util.Set"") || type.isSubtypeOf(""java.util.Map"");
  }

  private static boolean usesURLAsTypeParameter(Type type) {
    Type firstTypeParameter = getFirstTypeParameter(type);
    return firstTypeParameter != null && firstTypeParameter.is(JAVA_NET_URL);
  }

  @CheckForNull
  private static Type getFirstTypeParameter(Type type) {
    if (type.isParameterized()) {
      return type.typeArguments().get(0);
    }
    return null;
  }

}
"
S2114,BUG,Collections should not be passed as arguments to their own methods,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2114"")
public class CollectionCallingItselfCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree methodInvocationTree = (MethodInvocationTree) tree;
    Symbol symbolReference = null;
    Symbol method = null;
    String reportedName = """";
    if (methodInvocationTree.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mse = (MemberSelectExpressionTree) methodInvocationTree.methodSelect();
      IdentifierTree identifier = mse.identifier();
      reportedName = identifier.name();
      method = identifier.symbol();
      if (mse.expression().is(Tree.Kind.IDENTIFIER)) {
        symbolReference = ((IdentifierTree) mse.expression()).symbol();
      }
    }
    if (symbolReference != null && isMethodFromCollection(method)) {
      reportIssueForParameters(methodInvocationTree, symbolReference, reportedName);
    }
  }

  private void reportIssueForParameters(MethodInvocationTree methodInvocationTree, Symbol symbolReference, String reportedName) {
    for (ExpressionTree arg : methodInvocationTree.arguments()) {
      if (arg.is(Tree.Kind.IDENTIFIER)) {
        Symbol reference = ((IdentifierTree) arg).symbol();
        if (reference == symbolReference) {
          reportIssue(methodInvocationTree, ""Remove or correct this \"""" + reportedName + ""\"" call."");
        }
      }
    }
  }

  private static boolean isMethodFromCollection(Symbol methodSymbol) {
    if (!methodSymbol.isMethodSymbol()) {
      return false;
    }
    Type ownerType = methodSymbol.owner().type();
    return !ownerType.is(""java.util.Collection"") && ownerType.isSubtypeOf(""java.util.Collection"");
  }

}
"
S2115,VULNERABILITY,A secure password should be used when connecting to a database,"package org.sonar.java.checks.security;

import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2115"")
public class EmptyDatabasePasswordCheck extends AbstractMethodDetection {

  private static final String MESSAGE = ""Add password protection to this database."";
  private static final int PASSWORD_ARGUMENT = 2;
  private static final int URL_ARGUMENT = 0;
  private static final Pattern EMPTY_PASSWORD_PATTERN = Pattern.compile("".*password\\s*=\\s*([&;\\)].*|$)"");

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.sql.DriverManager"")
      .names(""getConnection"")
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    Arguments args = mit.arguments();
    if (args.size() > 2) {
      checkEmptyValue(mit, args.get(PASSWORD_ARGUMENT));
    }
    if (args.size() == 1) {
      checkUrlContainsEmptyPassword(mit);
    }

  }

  private void checkEmptyValue(MethodInvocationTree mit, ExpressionTree expression) {
    ExpressionsHelper.ValueResolution<String> valueResolution =
      ExpressionsHelper.getConstantValueAsString(expression, ""Empty password value."");
    String literal = valueResolution.value();
    if (literal != null && literal.trim().isEmpty()) {
      reportIssue(mit, MESSAGE, valueResolution.valuePath(), null);
    }
  }

  private void checkUrlContainsEmptyPassword(MethodInvocationTree mit) {
    ExpressionTree urlArgument = mit.arguments().get(URL_ARGUMENT);
    ExpressionsHelper.ValueResolution<String> valueResolution =
      ExpressionsHelper.getConstantValueAsString(urlArgument, ""URL containing the empty password."");
    String url = valueResolution.value();
    if (url != null && urlContainsEmptyPassword(url)) {
      reportIssue(mit, MESSAGE, valueResolution.valuePath(), null);
    }
  }

  private static boolean urlContainsEmptyPassword(String url) {
    return EMPTY_PASSWORD_PATTERN.matcher(url).matches();
  }

}
"
S2116,BUG,"""hashCode"" and ""toString"" should not be called on array instances","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.expression.MemberSelectExpressionTreeImpl;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

import java.util.ArrayList;
import java.util.List;

@Rule(key = ""S2116"")
public class ArrayHashCodeAndToStringCheck extends AbstractMethodDetection {

  private static final String ARRAYS = ""java.util.Arrays"";

  private QuickFixHelper.ImportSupplier importSupplier;

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofType(Type::isArray)
      .names(""toString"", ""hashCode"")
      .addWithoutParametersMatcher()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    IdentifierTree methodTree = ExpressionUtils.methodName(mit);
    String methodName = methodTree.name();
    String methodCallee = QuickFixHelper.contentForTree(((MemberSelectExpressionTreeImpl) mit.methodSelect()).expression(), context);
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(methodTree)
      .withMessage(""Use \""Arrays."" + methodName + ""(array)\"" instead."")
      .withQuickFix(() -> getQuickFix(mit, methodName, methodCallee))
      .report();
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    importSupplier = null;
  }

  private JavaQuickFix getQuickFix(MethodInvocationTree tree, String methodName, String methodCallee) {
    List<JavaTextEdit> edits = new ArrayList<>();
    getImportSupplier()
      .newImportEdit(ARRAYS)
      .ifPresent(edits::add);

    if (""toString"".equals(methodName)) {
      edits.add(JavaTextEdit.replaceTree(tree, ""Arrays.toString("" + methodCallee + "")""));
      return JavaQuickFix.newQuickFix(""Use \""Arrays.toString(array)\"" instead"")
        .addTextEdits(edits)
        .build();
    } else {
      edits.add(JavaTextEdit.replaceTree(tree, ""Arrays.hashCode("" + methodCallee + "")""));
      return JavaQuickFix.newQuickFix(""Use \""Arrays.hashCode(array)\"" instead"")
        .addTextEdits(edits)
        .build();
    }
  }

  private QuickFixHelper.ImportSupplier getImportSupplier() {
    if (importSupplier == null) {
      importSupplier = QuickFixHelper.newImportSupplier(context);
    }
    return importSupplier;
  }

}
"
S2118,BUG,"""writeObject"" argument must implement ""Serializable""","package org.sonar.java.checks.serialization;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.InstanceOfTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2118"")
public class NonSerializableWriteCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers WRITE_OBJECT_MATCHER = MethodMatchers.create()
    .ofTypes(""java.io.ObjectOutputStream"")
    .names(""writeObject"")
    .addParametersMatcher(""java.lang.Object"")
    .build();

  private final Set<Symbol> testedSymbols = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.INSTANCE_OF);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    testedSymbols.clear();
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      visitMethodInvocation((MethodInvocationTree) tree);
    } else {
      visitInstanceOf((InstanceOfTree) tree);
    }
  }

  private void visitInstanceOf(InstanceOfTree instanceOfTree) {
    ExpressionTree expression = instanceOfTree.expression();
    if (expression.is(Tree.Kind.IDENTIFIER) && instanceOfTree.type().symbolType().is(""java.io.Serializable"")) {
      testedSymbols.add(((IdentifierTree) expression).symbol());
    }
  }

  // If we met a test such as ""x instanceof Serializable"", we suppose that symbol x is Serializable
  private boolean isTestedSymbol(ExpressionTree tree) {
    if (tree.is(Tree.Kind.IDENTIFIER)) {
      Symbol symbol = ((IdentifierTree) tree).symbol();
      return testedSymbols.contains(symbol);
    }
    return false;
  }

  private void visitMethodInvocation(MethodInvocationTree methodInvocation) {
    if (WRITE_OBJECT_MATCHER.matches(methodInvocation)) {
      ExpressionTree argument = methodInvocation.arguments().get(0);
      if (!isTestedSymbol(argument) && ExpressionsHelper.isNotSerializable(argument)) {
        reportIssue(argument, ""Make the \"""" + argument.symbolType().fullyQualifiedName() + ""\"" class \""Serializable\"" or don't write it."");
      }
    }
  }

}
"
S2119,BUG,"""Random"" objects should be reused","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2119"")
public class ReuseRandomCheck extends AbstractMethodDetection {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.NEW_CLASS);
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.util.Random"").constructor().addWithoutParametersMatcher().build();
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    if (!isInConstructorOrStaticMain(newClassTree) && isUsedOnlyLocally(newClassTree)) {
      reportIssue(newClassTree.identifier(), ""Save and re-use this \""Random\""."");
    }
  }

  private static boolean isInConstructorOrStaticMain(ExpressionTree tree) {
    MethodTree enclosingMethod = ExpressionUtils.getEnclosingMethod(tree);
    if (enclosingMethod != null) {
      Symbol.MethodSymbol symbol = enclosingMethod.symbol();
      String name = symbol.name();
      return MethodMatchers.CONSTRUCTOR.equals(name) || (""main"".equals(name) && symbol.isStatic());
    }
    return false;
  }

  private static boolean isUsedOnlyLocally(Tree tree) {
    Tree parent = tree.parent();
    if (parent.is(Kind.ASSIGNMENT)) {
      return isLocalVariable(((AssignmentExpressionTree) parent).variable()) &&
        isUsedOnlyLocally(parent);
    } else if (parent.is(Kind.VARIABLE)) {
      return isLocalVariable(((VariableTree) parent).simpleName());
    } else if (parent.is(Kind.PARENTHESIZED_EXPRESSION)) {
      return isUsedOnlyLocally(parent);
    } else {
      return parent.is(Kind.EXPRESSION_STATEMENT, Kind.MEMBER_SELECT);
    }
  }

  private static boolean isLocalVariable(ExpressionTree expression) {
    if (expression.is(Kind.IDENTIFIER)) {
      return ((IdentifierTree) expression).symbol().isLocalVariable();
    }
    return false;
  }

}
"
S2121,BUG,String operations with predictable outcomes should be avoided,"package org.sonar.java.checks;

import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import static java.lang.String.format;

@Rule(key = ""S2121"")
public class SillyStringOperationsCheck extends AbstractMethodDetection {

  private static final String CHAR_SEQUENCE = ""java.lang.CharSequence"";
  private static final String STRING = ""java.lang.String"";
  private static final MethodMatchers STRING_LENGTH = MethodMatchers.create()
    .ofTypes(STRING).names(""length"").addWithoutParametersMatcher().build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofTypes(STRING)
        .names(""contains"")
        .addParametersMatcher(params -> params.size() == 1 && params.get(0).isSubtypeOf(CHAR_SEQUENCE))
        .build(),
      MethodMatchers.create().ofTypes(STRING)
        .names(""compareTo"", ""compareToIgnoreCase"", ""endsWith"", ""indexOf"", ""lastIndexOf"", ""matches"", ""split"", ""startsWith"")
        .addParametersMatcher(STRING)
        .build(),
      MethodMatchers.create().ofTypes(STRING)
        .names(""replaceFirst"")
        .addParametersMatcher(STRING, STRING)
        .build(),
      MethodMatchers.create().ofTypes(STRING)
        .names(""indexOf"", ""lastIndexOf"", ""split"", ""startsWith"")
        .addParametersMatcher(STRING, ""int"")
        .build(),
      MethodMatchers.create()
        .ofTypes(STRING)
        .names(""substring"")
        .addParametersMatcher(""int"")
        .addParametersMatcher(""int"", ""int"")
        .build());
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree tree) {
    if (tree.methodSelect().is(Kind.MEMBER_SELECT)) {
      boolean issue;
      ExpressionTree str = ((MemberSelectExpressionTree) tree.methodSelect()).expression();
      Arguments args = tree.arguments();
      String method = tree.methodSymbol().name();
      switch (method) {
        case ""contains"":
        case ""compareTo"":
        case ""compareToIgnoreCase"":
        case ""endsWith"":
        case ""indexOf"":
        case ""lastIndexOf"":
        case ""matches"":
        case ""split"":
        case ""startsWith"":
          issue = checkStartsWith(str, args);
          break;
        case ""replaceFirst"":
          issue = checkReplaceFirst(str, args);
          break;
        case ""substring"":
          issue = checkSubstring(str, args);
          break;
        default:
          issue = false;
      }
      if (issue) {
        reportIssue(tree, format(""Remove this \""%s\"" call; it has predictable results."", method));
      }
    }
  }

  private static boolean checkStartsWith(ExpressionTree str, Arguments args) {
    return isSameString(str, args.get(0));
  }

  private static boolean checkReplaceFirst(ExpressionTree str, Arguments args) {
    return isSameString(str, args.get(0)) || isSameString(args.get(0), args.get(1));
  }

  private static boolean checkSubstring(ExpressionTree str, Arguments args) {
    if (args.size() == 1) {
      return isZero(args.get(0)) || isStringLength(str, args.get(0));
    } else {
      return isStringLength(str, args.get(0)) || (isZero(args.get(0)) && isStringLength(str, args.get(1)));
    }
  }

  private static boolean isSameString(ExpressionTree str, ExpressionTree tree) {
    return isSameSymbol(str, tree) || isSameStringLiteral(str, tree);
  }

  private static boolean isSameSymbol(ExpressionTree tree, ExpressionTree other) {
    Symbol s = symbol(tree);
    return s != null && s.equals(symbol(other));
  }

  private static boolean isSameStringLiteral(ExpressionTree str, ExpressionTree tree) {
    String s = string(str);
    return s != null && s.equals(string(tree));
  }

  private static boolean isZero(ExpressionTree tree) {
    return tree.asConstant(Integer.class).filter(n -> n == 0).isPresent();
  }

  private static boolean isStringLength(ExpressionTree str, ExpressionTree tree) {
    if (tree.is(Kind.METHOD_INVOCATION)) {
      MethodInvocationTree invocation = (MethodInvocationTree) tree;
      if (STRING_LENGTH.matches(invocation) && invocation.methodSelect().is(Kind.MEMBER_SELECT)) {
        return isSameSymbol(str, ((MemberSelectExpressionTree) invocation.methodSelect()).expression());
      }
    }
    return false;
  }

  @CheckForNull
  private static Symbol symbol(ExpressionTree tree) {
    if (tree.is(Kind.IDENTIFIER)) {
      return ((IdentifierTree) tree).symbol();
    }
    return null;
  }

  @CheckForNull
  private static String string(ExpressionTree tree) {
    return tree.asConstant(String.class).orElse(null);
  }
}
"
S2122,BUG,"""ScheduledThreadPoolExecutor"" should not have 0 core threads","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;

@Rule(key = ""S2122"")
public class ScheduledThreadPoolExecutorZeroCheck extends AbstractMethodDetection {

  private static final String MESSAGE = ""Increase the \""corePoolSize\""."";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofSubTypes(""java.util.concurrent.ThreadPoolExecutor"").names(""setCorePoolSize"").addParametersMatcher(""int"").build(),
      MethodMatchers.create().ofTypes(""java.util.concurrent.ScheduledThreadPoolExecutor"").constructor().addParametersMatcher(""int"").build()
    );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree arg = mit.arguments().get(0);
    if (LiteralUtils.isZero(arg)) {
      reportIssue(arg, MESSAGE);
    }
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    ExpressionTree arg = newClassTree.arguments().get(0);
    if (LiteralUtils.isZero(arg)) {
      reportIssue(arg, MESSAGE);
    }
  }

}
"
S2123,BUG,Values should not be uselessly incremented,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S2123"")
public class UselessIncrementCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.RETURN_STATEMENT, Tree.Kind.ASSIGNMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.RETURN_STATEMENT)) {
      ExpressionTree returnExpression = ((ReturnStatementTree) tree).expression();
      if (returnExpression != null && isPostfix(returnExpression)) {
        UnaryExpressionTree unaryExpression = (UnaryExpressionTree) returnExpression;
        ExpressionTree expression = ExpressionUtils.skipParentheses(unaryExpression.expression());
        if (expression.is(Tree.Kind.IDENTIFIER) && ((IdentifierTree) expression).symbol().owner().isMethodSymbol()) {
          reportIssue(unaryExpression);
        }
      }
    } else {
      AssignmentExpressionTree aet = (AssignmentExpressionTree) tree;
      if (isPostfix(aet.expression())) {
        UnaryExpressionTree postfix = (UnaryExpressionTree) aet.expression();
        if (SyntacticEquivalence.areEquivalent(aet.variable(), postfix.expression())) {
          reportIssue(postfix);
        }
      }
    }
  }

  private void reportIssue(UnaryExpressionTree expression) {
    reportIssue(expression.operatorToken(), ""Remove this increment or correct the code not to waste it."");
  }

  private static boolean isPostfix(ExpressionTree tree) {
    return tree.is(Tree.Kind.POSTFIX_INCREMENT, Tree.Kind.POSTFIX_DECREMENT);
  }

}
"
S2127,BUG,"""Double.longBitsToDouble"" should take ""long"" as argument","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2127"")
public class LongBitsToDoubleOnIntCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.lang.Double"")
      .names(""longBitsToDouble"")
      .addParametersMatcher(""long"")
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    Type symbolType = mit.arguments().get(0).symbolType();
    if (symbolType.isUnknown()) {
      return;
    }

    if (!(symbolType.is(""long"") || symbolType.is(""java.lang.Long""))) {
      reportIssue(ExpressionUtils.methodName(mit), ""Remove this \""Double.longBitsToDouble\"" call."");
    }
  }
}
"
S2129,CODE_SMELL,"Constructors should not be used to instantiate ""String"", ""BigInteger"", ""BigDecimal"" and primitive-wrapper classes","package org.sonar.java.checks;

import java.math.BigInteger;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.LiteralUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S2129"")
public class StringPrimitiveConstructorCheck extends IssuableSubscriptionVisitor {

  private static final String QUICK_FIX_MESSAGE = ""Replace this \""%s\"" constructor with %s"";
  private static final String REPLACEMENT_MESSAGE = ""the %s literal passed as parameter"";
  private static final String ISSUE_MESSAGE = ""Remove this \""%s\"" constructor"";

  private static final String STRING = ""java.lang.String"";
  private static final BigInteger MIN_BIG_INTEGER_VALUE = BigInteger.valueOf(Long.MIN_VALUE);
  private static final BigInteger MAX_BIG_INTEGER_VALUE = BigInteger.valueOf(Long.MAX_VALUE);

  private static final MethodMatchers EMPTY_STRING_MATCHER = MethodMatchers.create().ofTypes(STRING).constructor().addWithoutParametersMatcher().build();
  private static final MethodMatchers BIG_INT_MATCHER = primitiveConstructorMatcher(""java.math.BigInteger"", STRING);

  private static final MethodMatchers matchers = MethodMatchers.or(
    EMPTY_STRING_MATCHER,
    BIG_INT_MATCHER,
    primitiveConstructorMatcher(STRING, STRING),
    primitiveConstructorMatcher(""java.lang.Byte"", ""byte""),
    primitiveConstructorMatcher(""java.lang.Character"", ""char""),
    primitiveConstructorMatcher(""java.lang.Short"", ""short""),
    primitiveConstructorMatcher(""java.lang.Integer"", ""int""),
    primitiveConstructorMatcher(""java.lang.Long"", ""long""),
    primitiveConstructorMatcher(""java.lang.Float"", ""float""),
    primitiveConstructorMatcher(""java.lang.Double"", ""double""),
    primitiveConstructorMatcher(""java.lang.Boolean"", ""boolean""));

  private static MethodMatchers primitiveConstructorMatcher(String constructor, String param) {
    return MethodMatchers.create().ofTypes(constructor).constructor().addParametersMatcher(param).build();
  }

  private static final Map<String, String> classToLiteral = Map.of(
    ""String"", ""string"",
    ""Double"", ""double"",
    ""Integer"", ""int"",
    ""Boolean"", ""boolean"",
    ""Byte"", ""byte"",
    ""Character"", ""char"",
    ""Short"", ""short"",
    ""Long"", ""long"",
    ""Float"", ""float""
    );


  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    NewClassTree newClassTree = (NewClassTree) tree;
    if (newClassTree.classBody() != null) {
      return;
    }
    if (isBigIntegerPotentiallyBiggerThanLong(newClassTree)) {
      return;
    }
    if(matchers.matches(newClassTree)) {
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(newClassTree.identifier())
        .withMessage(ISSUE_MESSAGE, newClassTree.symbolType().name())
        .withQuickFix(() -> computeQuickFix(newClassTree))
        .report();
    }
  }

  private static boolean isBigIntegerPotentiallyBiggerThanLong(NewClassTree newClassTree) {
    if (!newClassTree.symbolType().is(""java.math.BigInteger"")) {
      return false;
    }
    ExpressionTree argument = newClassTree.arguments().get(0);
    if (!argument.is(Tree.Kind.STRING_LITERAL)) {
      return true;
    }
    try {
      BigInteger value = new BigInteger(LiteralUtils.trimQuotes(((LiteralTree)argument).value()));
      return value.compareTo(MIN_BIG_INTEGER_VALUE) < 0 || value.compareTo(MAX_BIG_INTEGER_VALUE) > 0;
    } catch (NumberFormatException e) {
      return true;
    }
  }

  private JavaQuickFix computeQuickFix(NewClassTree newClassTree) {
    String message;
    JavaTextEdit textEdit;
    String className = newClassTree.symbolType().name();
    if (EMPTY_STRING_MATCHER.matches(newClassTree)) {
      message = formatQuickFixMessage(className, ""an empty string \""\"""");
      textEdit = JavaTextEdit.replaceTree(newClassTree, ""\""\"""");
    } else if (BIG_INT_MATCHER.matches(newClassTree)) {
      String arg = getFirstArgumentAsString(newClassTree).replace(""\"""", """") + ""L"";
      String replacement = String.format(""BigInteger.valueOf(%s)"", arg);
      message = formatQuickFixMessage(className, ""\""BigInteger.valueOf()\"" static method"");
      textEdit = JavaTextEdit.replaceTree(newClassTree, replacement);
    } else {
      message = formatQuickFixMessage(className, String.format(REPLACEMENT_MESSAGE, classToLiteral.get(className)));
      String replacement = getFirstArgumentAsString(newClassTree);
      textEdit = JavaTextEdit.replaceTree(newClassTree, replacement);
    }
    return JavaQuickFix.newQuickFix(message).addTextEdit(textEdit).build();
  }

  private static String formatQuickFixMessage(String constructor, String replacement) {
    return String.format(QUICK_FIX_MESSAGE, constructor, replacement);
  }

  private String getFirstArgumentAsString(NewClassTree newClassTree) {
    ExpressionTree expr = newClassTree.arguments().get(0);
    return QuickFixHelper.contentForTree(expr, context);
  }

}
"
S2130,CODE_SMELL,"Parsing should be used to convert ""Strings"" to primitives","package org.sonar.java.checks;

import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S2130"")
public class StringToPrimitiveConversionCheck extends IssuableSubscriptionVisitor {

  private final List<PrimitiveCheck> primitiveChecks = buildPrimitiveChecks();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.VARIABLE, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.VARIABLE)) {
      VariableTree variableTree = (VariableTree) tree;
      Type variableType = variableTree.type().symbolType();
      PrimitiveCheck primitiveCheck = getPrimitiveCheck(variableType);
      ExpressionTree initializer = variableTree.initializer();
      if (primitiveCheck != null && initializer != null) {
        primitiveCheck.checkInstantiation(initializer);
      }
    } else {
      MethodInvocationTree methodInvocationTree = (MethodInvocationTree) tree;
      for (PrimitiveCheck primitiveCheck : primitiveChecks) {
        primitiveCheck.checkMethodInvocation(methodInvocationTree);
      }
    }
  }

  private PrimitiveCheck getPrimitiveCheck(Type type) {
    if (!type.isPrimitive()) {
      return null;
    }
    for (PrimitiveCheck primitiveCheck : primitiveChecks) {
      if (type.isPrimitive(primitiveCheck.tag)) {
        return primitiveCheck;
      }
    }
    return null;
  }

  private List<PrimitiveCheck> buildPrimitiveChecks() {
    return Arrays.asList(
      new PrimitiveCheck(""int"", ""Integer"", Type.Primitives.INT),
      new PrimitiveCheck(""boolean"", ""Boolean"", Type.Primitives.BOOLEAN),
      new PrimitiveCheck(""byte"", ""Byte"", Type.Primitives.BYTE),
      new PrimitiveCheck(""double"", ""Double"", Type.Primitives.DOUBLE),
      new PrimitiveCheck(""float"", ""Float"", Type.Primitives.FLOAT),
      new PrimitiveCheck(""long"", ""Long"", Type.Primitives.LONG),
      new PrimitiveCheck(""short"", ""Short"", Type.Primitives.SHORT));
  }

  private class PrimitiveCheck {
    private final String primitiveName;
    private final String className;
    private final Type.Primitives tag;
    private final String message;
    private final MethodMatchers unboxingInvocationMatcher;
    private final MethodMatchers valueOfInvocationMatcher;

    private PrimitiveCheck(String primitiveName, String className, Type.Primitives tag) {
      this.primitiveName = primitiveName;
      this.className = className;
      this.tag = tag;
      this.message = ""Use \"""" + parseMethodName() + ""\"" for this string-to-"" + primitiveName + "" conversion."";
      this.unboxingInvocationMatcher = MethodMatchers.create()
        .ofTypes(""java.lang."" + className)
        .names(primitiveName + ""Value"")
        .addWithoutParametersMatcher()
        .build();
      this.valueOfInvocationMatcher = MethodMatchers.create()
        .ofTypes(""java.lang."" + className)
        .names(""valueOf"")
        .addParametersMatcher(""java.lang.String"")
        .build();
    }

    private void checkMethodInvocation(MethodInvocationTree methodInvocationTree) {
      if (unboxingInvocationMatcher.matches(methodInvocationTree)) {
        MemberSelectExpressionTree methodSelect = (MemberSelectExpressionTree) methodInvocationTree.methodSelect();
        checkInstantiation(methodSelect.expression());
      }
    }

    private void checkInstantiation(ExpressionTree expression) {
      if (isBadlyInstantiated(expression)) {
        reportIssue(expression, message);
      }
    }

    private boolean isBadlyInstantiated(ExpressionTree expression) {
      boolean result = false;
      if (expression.is(Tree.Kind.NEW_CLASS)) {
        result = isStringBasedConstructor((NewClassTree) expression);
      } else if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
        result = valueOfInvocationMatcher.matches((MethodInvocationTree) expression);
      } else if (expression.is(Tree.Kind.IDENTIFIER)) {
        IdentifierTree identifier = (IdentifierTree) expression;
        Symbol reference = identifier.symbol();
        if (reference.isVariableSymbol() && reference.usages().size() == 1) {
          Symbol.VariableSymbol variableSymbol = (Symbol.VariableSymbol) reference;
          result = isBadlyInstantiatedVariable(variableSymbol);
        }
      }
      return result;
    }

    private boolean isBadlyInstantiatedVariable(Symbol.VariableSymbol variableSymbol) {
      VariableTree variableTree = variableSymbol.declaration();
      if (variableTree != null) {
        ExpressionTree initializer = variableTree.initializer();
        if (initializer != null) {
          return isBadlyInstantiated(initializer);
        }
      }
      return false;
    }

    private boolean isStringBasedConstructor(NewClassTree newClassTree) {
      List<ExpressionTree> arguments = newClassTree.arguments();
      return arguments.get(0).symbolType().is(""java.lang.String"");
    }

    private String parseMethodName() {
      return className + "".parse"" + StringUtils.capitalize(primitiveName);
    }
  }

}
"
S2131,CODE_SMELL,"Primitives should not be boxed just for ""String"" conversion","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S2131"")
public class PrimitiveTypeBoxingWithToStringCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final MethodMatchers TO_STRING_MATCHERS = MethodMatchers.create().ofSubTypes(
    ""java.lang.Byte"",
    ""java.lang.Character"",
    ""java.lang.Short"",
    ""java.lang.Integer"",
    ""java.lang.Long"",
    ""java.lang.Float"",
    ""java.lang.Double"",
    ""java.lang.Boolean"")
    .names(""toString"")
    .addWithoutParametersMatcher()
    .build();

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitMethodInvocation(MethodInvocationTree tree) {
    if (TO_STRING_MATCHERS.matches(tree)) {
      ExpressionTree abstractTypedTree = ((MemberSelectExpressionTree) tree.methodSelect()).expression();
      if (abstractTypedTree.is(Kind.NEW_CLASS) || isValueOfInvocation(abstractTypedTree)) {
        String typeName = abstractTypedTree.symbolType().toString();
        createIssue(tree, typeName);
      }
    }
    super.visitMethodInvocation(tree);
  }


  private void createIssue(Tree reportingTree, String wrapperName) {
    context.reportIssue(this, reportingTree, ""Use \"""" + wrapperName + "".toString\"" instead."");
  }

  @Override
  public void visitAnnotation(AnnotationTree annotationTree) {
    scan(annotationTree.annotationType());
    // skip arguments of annotation as it should be compile time constant so it is not relevant here.
  }

  private static boolean isValueOfInvocation(ExpressionTree abstractTypedTree) {
    if (!abstractTypedTree.is(Kind.METHOD_INVOCATION)) {
      return false;
    }
    Type type = abstractTypedTree.symbolType();
    MethodMatchers valueOfMatcher = MethodMatchers.create()
      .ofTypes(type.fullyQualifiedName())
      .names(""valueOf"")
      .addParametersMatcher(type.primitiveType().fullyQualifiedName())
      .build();
    return valueOfMatcher.matches((MethodInvocationTree) abstractTypedTree);
  }
}
"
S2133,CODE_SMELL,"Objects should not be created only to invoke ""getClass""","package org.sonar.java.checks;

import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2133"")
public class ObjectCreatedOnlyToCallGetClassCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofAnyType().names(""getClass"").addWithoutParametersMatcher().build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (mit.methodSelect()
      .is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree expressionTree = ((MemberSelectExpressionTree) mit.methodSelect()).expression();
      if (expressionTree.is(Tree.Kind.NEW_CLASS, Tree.Kind.NEW_ARRAY)) {
        reportIssue(expressionTree);
      } else if (expressionTree.is(Tree.Kind.IDENTIFIER) && variableUsedOnlyToGetClass((IdentifierTree) expressionTree)) {
        reportIssue(getInitializer((IdentifierTree) expressionTree));
      }
    }
  }

  @CheckForNull
  private static ExpressionTree getInitializer(IdentifierTree tree) {
    Symbol symbol = tree.symbol();
    if (symbol.isVariableSymbol()) {
      VariableTree declaration = ((Symbol.VariableSymbol) symbol).declaration();
      if (declaration != null) {
        return declaration.initializer();
      }
    }
    return null;
  }

  private static boolean variableUsedOnlyToGetClass(IdentifierTree tree) {
    if (""this"".equals(tree.name()) || ""super"".equals(tree.name())) {
      return false;
    }
    Symbol symbol = tree.symbol();
    return symbol.usages().size() == 1 && hasBeenInitialized(tree);
  }

  private static boolean hasBeenInitialized(IdentifierTree tree) {
    ExpressionTree initializer = getInitializer(tree);
    return initializer != null && initializer.is(Tree.Kind.NEW_CLASS);
  }

  private void reportIssue(@Nullable ExpressionTree expressionTree) {
    if (expressionTree != null) {
      reportIssue(expressionTree, ""Remove this object instantiation and use \"""" + getTypeName(expressionTree) + "".class\"" instead."");
    }
  }

  private static String getTypeName(ExpressionTree tree) {
    Type type = tree.symbolType();
    String name = getTypeName(type);
    if (name.isEmpty()) {
      name = getAnonymousClassTypeName(type.symbol());
    }
    return name;
  }

  private static String getAnonymousClassTypeName(Symbol.TypeSymbol symbol) {
    if (symbol.interfaces().isEmpty()) {
      return getTypeName(symbol.superClass());
    }
    return getTypeName(symbol.interfaces().get(0));
  }

  private static String getTypeName(Type type) {
    return type.symbol().name();
  }

}
"
S2134,BUG,"Classes extending java.lang.Thread should provide a specific ""run"" behavior","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2134"")
public class ThreadOverridesRunCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_LANG_THREAD = ""java.lang.Thread"";
  private static final MethodMatchers RUN = MethodMatchers.create()
    .ofSubTypes(JAVA_LANG_THREAD)
    .names(""run"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Symbol.TypeSymbol classSymbol = classTree.symbol();
    if (classSymbol != null
      && isDirectSubtypeOfThread(classSymbol)
      && !overridesRunMethod(classSymbol)
      && !hasConstructorCallingSuperWithRunnable(classTree)) {
      Tree report = classTree.simpleName();
      Tree parent = classTree.parent();
      if(parent.is(Tree.Kind.NEW_CLASS)) {
        NewClassTree newClassTree = (NewClassTree) parent;
        if (hasRunnableArgument(newClassTree.arguments())) {
          // will call the super constructor setting a runnable which will be executed by the run() method
          return;
        }
        report = newClassTree.identifier();
      }
      reportIssue(report, ""Don't extend \""Thread\"", since the \""run\"" method is not overridden."");
    }
  }

  private static boolean isDirectSubtypeOfThread(Symbol.TypeSymbol classSymbol) {
    Type superClass = classSymbol.superClass();
    // Only 'java.lang.Object' has no super class
    return superClass != null && superClass.is(JAVA_LANG_THREAD);
  }

  private static boolean overridesRunMethod(Symbol.TypeSymbol classSymbol) {
    return classSymbol.lookupSymbols(""run"").stream().anyMatch(RUN::matches);
  }

  private static boolean hasConstructorCallingSuperWithRunnable(ClassTree classTree) {
    return classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR))
      .map(MethodTree.class::cast)
      .anyMatch(ThreadOverridesRunCheck::hasCallToSuperWithRunnable);
  }

  private static boolean hasRunnableArgument(Arguments args) {
    return args.stream().map(ExpressionTree::symbolType).anyMatch(ThreadOverridesRunCheck::isRunnable);
  }

  private static boolean isRunnable(Type argType) {
    return argType.isUnknown() || argType.isSubtypeOf(""java.lang.Runnable"");
  }

  private static boolean hasCallToSuperWithRunnable(MethodTree constructor) {
    SuperRunnableVisitor visitor = new SuperRunnableVisitor();
    constructor.accept(visitor);
    return visitor.callSuperWithRunnable;
  }

  private static class SuperRunnableVisitor extends BaseTreeVisitor {

    private boolean callSuperWithRunnable = false;

    private static final MethodMatchers SUPER_THREAD = MethodMatchers.create()
      .ofTypes(JAVA_LANG_THREAD)
      .constructor()
      .withAnyParameters()
      .build();

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (SUPER_THREAD.matches(tree) && ThreadOverridesRunCheck.hasRunnableArgument(tree.arguments())) {
        callSuperWithRunnable = true;
        // no need to visit further
        return;
      }
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitClass(ClassTree tree) {
      // skip inner classes
    }
  }
}
"
S2139,CODE_SMELL,Exceptions should be either logged or rethrown but not both,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.plugins.java.api.JavaFileScannerContext.Location;

@Rule(key = ""S2139"")
public class LoggedRethrownExceptionsCheck extends IssuableSubscriptionVisitor {
  private static final String JAVA_UTIL_LOGGING_LOGGER = ""java.util.logging.Logger"";
  private static final String SLF4J_LOGGER = ""org.slf4j.Logger"";
  private static final MethodMatchers LOGGING_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(JAVA_UTIL_LOGGING_LOGGER)
      .names(""config"", ""info"", ""log"", ""logp"", ""logrb"", ""throwing"", ""severe"", ""warning"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofTypes(SLF4J_LOGGER)
      .names(""debug"", ""error"", ""info"", ""trace"", ""warn"")
      .withAnyParameters()
      .build());

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CATCH);
  }

  @Override
  public void visitNode(Tree tree) {
    CatchTree catchTree = (CatchTree) tree;
    boolean isLogging = false;
    List<Location> secondaryLocations = new ArrayList<>();
    for (StatementTree statementTree : catchTree.block().body()) {
      IdentifierTree exceptionIdentifier = catchTree.parameter().simpleName();
      if (isLogging && statementTree.is(Tree.Kind.THROW_STATEMENT) &&
        isExceptionUsed(exceptionIdentifier, ((ThrowStatementTree) statementTree).expression())) {

        secondaryLocations.add(new Location(""Thrown exception."", ((ThrowStatementTree) statementTree).expression()));
        reportIssue(catchTree.parameter(), ""Either log this exception and handle it, or rethrow it with some contextual information."", secondaryLocations, 0);
        return;
      }
      if (isLoggingMethod(statementTree, exceptionIdentifier)) {
        secondaryLocations.add(new Location(""Logging statement."", statementTree));
        isLogging = true;
      }
    }
  }

  private static boolean isLoggingMethod(StatementTree statementTree, IdentifierTree exceptionIdentifier) {
    if (!statementTree.is(Tree.Kind.EXPRESSION_STATEMENT)) {
      return false;
    }
    ExpressionTree expression = ((ExpressionStatementTree) statementTree).expression();
    if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) expression;
      return LOGGING_METHODS.matches(mit) && isExceptionUsed(exceptionIdentifier, mit);
    }
    return false;
  }

  private static boolean isExceptionUsed(IdentifierTree exceptionIdentifier, MethodInvocationTree mit) {
    ExceptionUsageVisitor visitor = new ExceptionUsageVisitor(exceptionIdentifier);
    mit.arguments().forEach(param -> param.accept(visitor));
    return visitor.isExceptionIdentifierUsed;
  }

  private static boolean isExceptionUsed(IdentifierTree exceptionIdentifier, ExpressionTree expressionTree) {
    ExceptionUsageVisitor visitor = new ExceptionUsageVisitor(exceptionIdentifier);
    expressionTree.accept(visitor);
    return visitor.isExceptionIdentifierUsed;
  }


  private static class ExceptionUsageVisitor extends BaseTreeVisitor {

    IdentifierTree exceptionIdentifier;
    boolean isExceptionIdentifierUsed = false;


    ExceptionUsageVisitor(IdentifierTree exceptionIdentifier) {
      this.exceptionIdentifier = exceptionIdentifier;
    }

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      if (!isExceptionIdentifierUsed && tree.name().equals(exceptionIdentifier.name())) {
        isExceptionIdentifierUsed = true;
      }
    }
  }
}
"
S2140,CODE_SMELL,"Methods of ""Random"" that return floating point values should not be used in random integer generation","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;

@Rule(key = ""S2140"")
public class RandomFloatToIntCheck extends IssuableSubscriptionVisitor {

  private static final String NEXT_FLOAT = ""nextFloat"";
  private static final String NEXT_DOUBLE = ""nextDouble"";

  private static final MethodMatchers MATH_RANDOM_METHOD_MATCHER = MethodMatchers.create()
    .ofTypes(""java.lang.Math"").names(""random"").addWithoutParametersMatcher().build();

  private static final MethodMatchers METHOD_MATCHERS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(""java.util.concurrent.ThreadLocalRandom"")
      .names(NEXT_DOUBLE)
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofTypes(
        ""java.util.Random"",
        ""org.apache.commons.lang.math.JVMRandom"",
        ""org.apache.commons.lang.math.RandomUtils"",
        ""org.apache.commons.lang3.RandomUtils"")
      .names(NEXT_DOUBLE, NEXT_FLOAT)
      .addWithoutParametersMatcher()
      .build());

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TYPE_CAST);
  }

  @Override
  public void visitNode(Tree tree) {
    TypeCastTree castTree = (TypeCastTree) tree;
    Type castToType = castTree.type().symbolType();
    if (castToType.is(""int"")) {
      castTree.expression().accept(new RandomDoubleVisitor(""nextInt()""));
    } else if (castToType.is(""long"")) {
      castTree.expression().accept(new RandomDoubleVisitor(""nextLong()""));
    }
  }

  private class RandomDoubleVisitor extends BaseTreeVisitor {
    private final String methodToCall;

    public RandomDoubleVisitor(String methodToCall){
      this.methodToCall = methodToCall;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (MATH_RANDOM_METHOD_MATCHER.matches(tree)) {
        reportIssue(tree.methodSelect(), ""Use \""java.util.Random."" + methodToCall + ""\"" instead."");
      } else if (METHOD_MATCHERS.matches(tree)) {
        reportIssue(tree.methodSelect(), ""Use \"""" + methodToCall + ""\"" instead."");
      }
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      scan(tree.enclosingExpression());
      scan(tree.identifier());
      scan(tree.typeArguments());
      scan(tree.arguments());
      //do not scan body of anonymous classes.
    }
  }
}
"
S2141,BUG,"Classes that don't define ""hashCode()"" should not be used in hashes","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2141"")
public class ClassWithoutHashCodeInHashStructureCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers EQUALS_MATCHER = MethodMatchers.create()
    .ofAnyType()
    .names(""equals"")
    .addParametersMatcher(""java.lang.Object"")
    .build();

  private static final MethodMatchers HASHCODE_MATCHER = MethodMatchers.create()
    .ofAnyType()
    .names(""hashCode"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    Type type = ((NewClassTree) tree).symbolType();
    if (type.isParameterized() && useHashDataStructure(type)) {
      Symbol.TypeSymbol symbol = type.typeArguments().get(0).symbol();
      if (implementsEquals(symbol) && !implementsHashCode(symbol)) {
        reportIssue(tree, ""Add a \""hashCode()\"" method to \"""" + symbol.name() + ""\"" or remove it from this hash."");
      }
    }
  }

  private static boolean useHashDataStructure(Type type) {
    return type.isSubtypeOf(""java.util.HashMap"") || type.isSubtypeOf(""java.util.HashSet"") || type.isSubtypeOf(""java.util.Hashtable"");
  }

  private static boolean implementsEquals(Symbol.TypeSymbol symbol) {
    return symbol.lookupSymbols(""equals"").stream()
      .filter(s -> !s.isAbstract())
      .anyMatch(EQUALS_MATCHER::matches);
  }

  private static boolean implementsHashCode(Symbol.TypeSymbol symbol) {
    return symbol.lookupSymbols(""hashCode"").stream().anyMatch(HASHCODE_MATCHER::matches);
  }
}
"
S2142,BUG,"""InterruptedException"" and ""ThreadDeath"" should not be ignored","package org.sonar.java.checks;

import java.util.Collections;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.function.Predicate;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.matcher.MethodMatchersBuilder;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.UnionTypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.model.ExpressionUtils.extractIdentifierSymbol;

@Rule(key = ""S2142"")
public class InterruptedExceptionCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Either re-interrupt this method or rethrow the \""%s\"" that can be caught here."";

  private static final Predicate<Type> INTERRUPTING_TYPE_PREDICATE = catchType -> catchType.isSubtypeOf(""java.lang.InterruptedException"") ||
    catchType.isSubtypeOf(""java.lang.ThreadDeath"");

  private static final Predicate<Type> GENERIC_EXCEPTION_PREDICATE = catchType -> catchType.is(""java.lang.Exception"") ||
    catchType.is(""java.lang.Throwable"");

  private final Deque<Boolean> withinInterruptingFinally = new LinkedList<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRY_STATEMENT);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    super.setContext(context);
    withinInterruptingFinally.clear();
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    withinInterruptingFinally.clear();
  }

  @Override
  public void visitNode(Tree tree) {
    TryStatementTree tryStatementTree = (TryStatementTree) tree;

    withinInterruptingFinally.addFirst(isFinallyInterrupting(tryStatementTree.finallyBlock()));

    for (CatchTree catchTree : tryStatementTree.catches()) {
      VariableTree catchParameter = catchTree.parameter();
      List<Type> caughtTypes = getCaughtTypes(catchParameter);

      Optional<Type> interruptType = caughtTypes.stream().filter(INTERRUPTING_TYPE_PREDICATE).findFirst();
      if (interruptType.isPresent()) {
        if (wasNotInterrupted(catchTree)) {
          reportIssue(catchParameter, String.format(MESSAGE, interruptType.get().name()));
        }
        return;
      } else if (caughtTypes.stream().anyMatch(GENERIC_EXCEPTION_PREDICATE)) {
        reportIfThrowInterruptInBlock(tryStatementTree.block(), catchTree);
        return;
      }
    }
  }

  private void reportIfThrowInterruptInBlock(BlockTree blockTree, CatchTree catchTree) {
    InterruptingStatementCollector collector = new InterruptingStatementCollector();
    blockTree.accept(collector);
    List<Tree> invocationInterrupting = collector.getInvocationTree();

    if (!invocationInterrupting.isEmpty() && wasNotInterrupted(catchTree)) {
      reportIssue(catchTree.parameter(), String.format(MESSAGE, ""InterruptedException""),
        invocationInterrupting.stream()
          .map(t -> new JavaFileScannerContext.Location(""Statement throwing InterruptedException."", t))
          .toList(),
        null);
    }
  }

  private boolean wasNotInterrupted(CatchTree catchTree) {
    Symbol caughtSymbol = catchTree.parameter().symbol();
    BlockVisitor blockVisitor = new BlockVisitor(tree -> isRethrowingCaughtException(tree, caughtSymbol));
    catchTree.block().accept(blockVisitor);
    return !blockVisitor.threadInterrupted && !isWithinInterruptingFinally();
  }

  private static List<Type> getCaughtTypes(VariableTree parameter) {
    if (parameter.type().is(Tree.Kind.UNION_TYPE)) {
      return ((UnionTypeTree) parameter.type()).typeAlternatives().stream()
        .map(TypeTree::symbolType)
        .toList();
    }
    return Collections.singletonList(parameter.symbol().type());
  }

  private boolean isWithinInterruptingFinally() {
    return withinInterruptingFinally.stream().anyMatch(Boolean.TRUE::equals);
  }

  private static boolean isRethrowingCaughtException(ThrowStatementTree tree, Symbol catchParameter) {
    return extractIdentifierSymbol(tree.expression())
      .filter(catchParameter::equals)
      .isPresent();
  }

  @Override
  public void leaveNode(Tree tree) {
    withinInterruptingFinally.removeFirst();
  }

  private static boolean isFinallyInterrupting(@Nullable BlockTree blockTree) {
    if (blockTree == null) {
      return false;
    }
    BlockVisitor blockVisitor = new BlockVisitor();
    blockTree.accept(blockVisitor);
    return blockVisitor.threadInterrupted;
  }

  private static boolean isInterruptingExceptionExpression(ExpressionTree expressionTree) {
    return INTERRUPTING_TYPE_PREDICATE.test(expressionTree.symbolType());
  }

  private static class InterruptingStatementCollector extends MethodTreeUtils.MethodInvocationCollector {

    public InterruptingStatementCollector() {
      super(
        symbol -> symbol.thrownTypes().stream().anyMatch(INTERRUPTING_TYPE_PREDICATE));
    }

    @Override
    public void visitTryStatement(TryStatementTree tryStatementTree) {
      // If inner `try` statement catches interrupting types: cut analysis of its try block, because possible
      // interruptions thrown there are handled within the scope of the catch block.
      // Yet, all other blocks (resources, catch, finally) of inner `try`s must still be analyzed, because possible
      // interruptions thrown there must be handled within the scope of the outer try.

      boolean isCatchingAnyInterruptingTypes = tryStatementTree.catches().stream()
        .anyMatch(catchTree -> getCaughtTypes(catchTree.parameter()).stream().anyMatch(INTERRUPTING_TYPE_PREDICATE));

      scan(tryStatementTree.resourceList());
      if (!isCatchingAnyInterruptingTypes) {
        scan(tryStatementTree.block());
      }
      scan(tryStatementTree.catches());
      scan(tryStatementTree.finallyBlock());
    }

    @Override
    public void visitThrowStatement(ThrowStatementTree tree) {
      // besides to method invocation, we also need to collect throw statements
      if (isInterruptingExceptionExpression(tree.expression())) {
        invocationTree.add(tree);
      }
      super.visitThrowStatement(tree);
    }
  }

  private static class BlockVisitor extends BaseTreeVisitor {
    private final Predicate<ThrowStatementTree> rethrowCaughtExceptionCheck;
    boolean threadInterrupted = false;
    private int depth = 0;

    private static final int MAX_DEPTH = 3;

    private static final MethodMatchers INTERRUPT_MATCHERS = new MethodMatchersBuilder()
      .ofSubTypes(""java.lang.Thread"")
      .names(""interrupt"")
      .addWithoutParametersMatcher()
      .build();

    public BlockVisitor() {
      this.rethrowCaughtExceptionCheck = t -> false;
    }

    public BlockVisitor(Predicate<ThrowStatementTree> rethrowCaughtExceptionCheck) {
      this.rethrowCaughtExceptionCheck = rethrowCaughtExceptionCheck;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (threadInterrupted || INTERRUPT_MATCHERS.matches(tree)) {
        threadInterrupted = true;
        return;
      }
      depth++;
      MethodTree declaration = tree.methodSymbol().declaration();
      if (declaration != null && depth <= MAX_DEPTH) {
        BlockTree block = declaration.block();
        if (block != null) {
          block.accept(this);
        }
      }
      depth--;
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitThrowStatement(ThrowStatementTree tree) {
      if (threadInterrupted || isInterruptingExceptionExpression(tree.expression()) || rethrowCaughtExceptionCheck.test(tree)) {
        threadInterrupted = true;
      } else {
        super.visitThrowStatement(tree);
      }
    }

    @Override
    public void visitClass(ClassTree tree) {
      // Cut visit on anonymous and local classes, because we only want to analyze actual control flow.
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree tree) {
      // Cut visit on lambdas, because we only want to analyze actual control flow.
    }
  }

}
"
S2143,CODE_SMELL,"""java.time"" classes should be used for dates and times","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2143"")
public class DateAndTimesCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final MethodMatchers METHOD_MATCHERS = MethodMatchers.or(
    MethodMatchers.create().ofTypes(""java.util.Calendar"").names(""getInstance"").withAnyParameters().build(),
    MethodMatchers.create().ofTypes(""java.util.Date"").constructor().withAnyParameters().build());

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return METHOD_MATCHERS;
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    reportIssue(newClassTree);
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(mit);
  }

  private void reportIssue(Tree tree) {
    reportIssue(tree, ""Use the Java 8 Date and Time API instead."" + context.getJavaVersion().java8CompatibilityMessage());

  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava8Compatible();
  }

}
"
S2147,CODE_SMELL,Catches should be combined,"package org.sonar.java.checks;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.JavaTree.UnionTypeTreeImpl;
import org.sonar.java.model.LineUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.java.model.expression.MemberSelectExpressionTreeImpl;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.TypeTree;

@Rule(key = ""S2147"")
public class CombineCatchCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRY_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ArrayDeque<CatchTree> catches = new ArrayDeque<>();
    for (CatchTree catchTree : ((TryStatementTree) tree).catches()) {
      for (CatchTree catchTreeToBeCompared : catches) {
        if (SyntacticEquivalence.areSemanticallyEquivalent(catchTree.block().body(), catchTreeToBeCompared.block().body())) {
          reportIssueWithQuickFix(catchTree, catchTreeToBeCompared);
          break;
        }
      }
      catches.push(catchTree);
    }
  }

  private void reportIssueWithQuickFix(CatchTree catchTree, CatchTree catchTreeToBeCompared) {
    String quickFixMessage = ""Combine this catch with the one at line "" + LineUtils.startLine(catchTreeToBeCompared.catchKeyword());
    String issueMessage = quickFixMessage + "", which has the same body."" + context.getJavaVersion().java7CompatibilityMessage();
    List<JavaFileScannerContext.Location> flow = Collections.singletonList(new JavaFileScannerContext.Location(""Combine with this catch"", catchTreeToBeCompared));
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(catchTree.parameter())
      .withMessage(issueMessage)
      .withSecondaries(flow)
      .withQuickFix( () -> computeQuickFix(catchTree, catchTreeToBeCompared, quickFixMessage) )
      .report();
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava7Compatible();
  }

  private JavaQuickFix computeQuickFix(CatchTree catchTree, CatchTree catchTreeToBeCompared, String qfMessage) {
    List<TypeTree> upperCatchTypes = getExceptionTypesCaught(catchTreeToBeCompared);
    List<TypeTree> lowerCatchTypes = getExceptionTypesCaught(catchTree);

    List<TypeTree> mergedTypes = mergeCatchTypes(upperCatchTypes, lowerCatchTypes);

    var builder = JavaQuickFix.newQuickFix(qfMessage);
    builder.addTextEdit(JavaTextEdit.removeTree(catchTree));
    String replacement = computeReplacementString(mergedTypes, catchTreeToBeCompared);
    builder.addTextEdit(
      JavaTextEdit.replaceBetweenTree(
        catchTreeToBeCompared.openParenToken(), false,
        catchTreeToBeCompared.closeParenToken(), false,
        replacement)
      );
    return builder.build();
  }

  private String computeReplacementString(Collection<TypeTree> types, CatchTree toReplaceCatch) {
    StringBuilder sb = new StringBuilder();
    types.forEach(type -> sb.append(formatType(type) + "" | ""));
    sb.delete(sb.lastIndexOf(""| ""), sb.length());
    sb.append(toReplaceCatch.parameter().simpleName().name());
    return sb.toString();
  }

  private static List<TypeTree> mergeCatchTypes(List<TypeTree> upperCatchTypes, List<TypeTree> lowerCatchTypes) {
    List<TypeTree> result = new ArrayList<>();
    for (TypeTree upperType : upperCatchTypes) {
      if (isNotMaskedBySuperType(upperType, lowerCatchTypes)) {
        result.add(upperType);
      }
    }
    result.addAll(lowerCatchTypes);
    return result;
  }

  private static boolean isNotMaskedBySuperType(TypeTree type, List<TypeTree> types) {
    for (TypeTree other : types) {
      if (type.symbolType().isSubtypeOf(other.symbolType())) {
        return false;
      }
    }
    return true;
  }

  private String formatType(TypeTree type) {
    if(type instanceof MemberSelectExpressionTreeImpl mtype) {
      return QuickFixHelper.contentForTree(mtype, context);
    }
    return type.toString();
  }

  private static List<TypeTree> getExceptionTypesCaught(CatchTree catchTree){
    TypeTree catchType = catchTree.parameter().type();
    if(catchType instanceof UnionTypeTreeImpl unionTypes) {
      unionTypes.symbolType();
      return unionTypes.typeAlternatives();
    }else {
      return List.of(catchType);
    }
  }

}
"
S2148,CODE_SMELL,Underscores should be used to make large numbers readable,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Arrays;
import java.util.List;
import java.util.Locale;

@Rule(key = ""S2148"")
public class UnderscoreOnNumberCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  private enum Base {
    BINARY(""0b"", 9),
    OCTAL(""0"", 9),
    HEXADECIMAL(""0x"", 9),
    DECIMAL("""", 6);

    private final String prefix;
    private final int minimalLength;

    Base(String prefix, int minimalLength) {
      this.prefix = prefix;
      this.minimalLength = minimalLength;
    }

    private static final Base ofLiteralValue(String literalValue) {
      if (BINARY.isFromBase(literalValue)) {
        return BINARY;
      } else if (HEXADECIMAL.isFromBase(literalValue)) {
        return HEXADECIMAL;
      } else if (OCTAL.isFromBase(literalValue)) {
        return OCTAL;
      }
      return DECIMAL;
    }

    private boolean isFromBase(String value) {
      return value.toLowerCase(Locale.ENGLISH).startsWith(prefix);
    }
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava7Compatible();
  }

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.INT_LITERAL, Tree.Kind.LONG_LITERAL);
  }

  @Override
  public void visitNode(Tree tree) {
    LiteralTree literalTree = (LiteralTree) tree;
    String value = literalTree.value();
    if (!containsUnderscore(value) && !isSerialVersionUID(tree) && shouldUseUnderscore(value)) {
      reportIssue(literalTree, ""Add underscores to this numeric value for readability"");
    }
  }

  private static boolean containsUnderscore(String literalValue) {
    return literalValue.indexOf('_') >= 0;
  }

  private static boolean isSerialVersionUID(Tree tree) {
    Tree parent = tree.parent();
    while (parent != null && !parent.is(Tree.Kind.VARIABLE)) {
      parent = parent.parent();
    }
    return parent != null && ""serialVersionUID"".equals(((VariableTree) parent).simpleName().name());
  }

  private static boolean shouldUseUnderscore(String literalValue) {
    String value = LiteralUtils.trimLongSuffix(literalValue);
    Base base = Base.ofLiteralValue(value);
    return value.length() >= (base.minimalLength + base.prefix.length());
  }
}
"
S2151,BUG,"""runFinalizersOnExit"" should not be called","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2151"")
public class RunFinalizersCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.lang.Runtime"", ""java.lang.System"")
      .names(""runFinalizersOnExit"")
      .addParametersMatcher(""boolean"")
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Remove this call to \"""" + mit.methodSymbol().owner().name() + "".runFinalizersOnExit()\""."");
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isNotSet() || version.asInt() < 11;
  }

}
"
S2153,BUG,Unnecessary boxing and unboxing should be avoided,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Predicate;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2153"")
public class ImmediateReverseBoxingCheck extends IssuableSubscriptionVisitor {

  private static final Map<String, String> PRIMITIVE_TYPES_BY_WRAPPER = MapBuilder.<String, String>newMap()
    .put(""java.lang.Boolean"", ""boolean"")
    .put(""java.lang.Byte"", ""byte"")
    .put(""java.lang.Double"", ""double"")
    .put(""java.lang.Float"", ""float"")
    .put(""java.lang.Integer"", ""int"")
    .put(""java.lang.Long"", ""long"")
    .put(""java.lang.Short"", ""short"")
    .put(""java.lang.Character"", ""char"")
    .build();

  private static final MethodMatchers unboxingInvocationMatchers = unboxingInvocationMatchers();
  private static final MethodMatchers valueOfInvocationMatchers = valueOfInvocationMatchers();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.VARIABLE, Tree.Kind.ASSIGNMENT, Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      visitMethodInvocationTree((MethodInvocationTree) tree);
    } else if (tree.is(Tree.Kind.VARIABLE)) {
      VariableTree variableTree = (VariableTree) tree;
      ExpressionTree initializer = variableTree.initializer();
      if (initializer != null) {
        checkExpression(initializer, variableTree.type().symbolType());
      }
    } else if (tree.is(Tree.Kind.ASSIGNMENT)) {
      AssignmentExpressionTree assignmentTree = (AssignmentExpressionTree) tree;
      checkExpression(assignmentTree.expression(), assignmentTree.symbolType());
    } else {
      NewClassTree newClassTree = (NewClassTree) tree;
      Symbol.TypeSymbol classSymbol = wrapperClassSymbol(newClassTree);
      if (classSymbol != null) {
        ExpressionTree arg0 = newClassTree.arguments().get(0);
        checkForUnboxing(arg0);
        checkForUselessUnboxing(newClassTree.symbolType(), newClassTree.identifier(), arg0, newClassTree);
      }
    }
  }

  private void checkExpression(ExpressionTree expression, Type implicitType) {
    if (implicitType.isPrimitive()) {
      checkForBoxing(expression, expression);
    } else {
      checkForUnboxing(expression);
    }
  }

  private void visitMethodInvocationTree(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    if (isValueOfInvocation(mit)) {
      ExpressionTree arg0 = mit.arguments().get(0);
      checkForUnboxing(arg0);
      checkForUselessUnboxing(mit.symbolType(), methodSelect, arg0, mit);
    } else if (isUnboxingMethodInvocation(mit)) {
      if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
        checkForBoxing(((MemberSelectExpressionTree) methodSelect).expression(), mit);
      }
    } else {
      Symbol.MethodSymbol symbol = mit.methodSymbol();
      if (!symbol.isUnknown()) {
        checkMethodInvocationArguments(mit, symbol.parameterTypes());
      }
    }
  }

  private void checkForUselessUnboxing(Type targetType, Tree reportTree, ExpressionTree arg0, Tree originalTree) {
    Type argType = arg0.symbolType();
    if (argType.is(targetType.fullyQualifiedName())) {
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(reportTree)
        .withMessage(""Remove the boxing to \""%s\""; The argument is already of the same type."", argType.name())
        .withQuickFix(() -> JavaQuickFix.newQuickFix(""Remove the boxing"")
          .addTextEdits(removeTreeExcept(originalTree, arg0))
          .build())
        .report();
    }
  }

  private void checkMethodInvocationArguments(MethodInvocationTree methodInvocationTree, List<Type> parametersTypes) {
    List<ExpressionTree> arguments = methodInvocationTree.arguments();
    int position = 0;
    for (Type paramType : parametersTypes) {
      if (arguments.size() > position) {
        checkExpression(arguments.get(position), paramType);
      }
      position++;
    }
  }

  private void checkForBoxing(ExpressionTree expression, Tree originalTree) {
    if (expression.is(Tree.Kind.NEW_CLASS)) {
      NewClassTree newClassTree = (NewClassTree) expression;
      Symbol.TypeSymbol classSymbol = wrapperClassSymbol(newClassTree);
      if (classSymbol != null) {
        ExpressionTree boxingArg = newClassTree.arguments().get(0);
        if (boxingArg.symbolType().isPrimitive()) {
          addBoxingIssue(newClassTree, classSymbol, boxingArg, originalTree);
        }
      }
    } else if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree methodInvocationTree = (MethodInvocationTree) expression;
      if (isValueOfInvocation(methodInvocationTree)) {
        ExpressionTree boxingArg = methodInvocationTree.arguments().get(0);
        addBoxingIssue(expression, methodInvocationTree.methodSymbol().owner(), boxingArg, originalTree);
      }
    }
  }

  private static Symbol.TypeSymbol wrapperClassSymbol(NewClassTree newClassTree) {
    Symbol.TypeSymbol classSymbol = newClassTree.symbolType().symbol();
    if (PRIMITIVE_TYPES_BY_WRAPPER.containsKey(newClassTree.symbolType().fullyQualifiedName()) && !newClassTree.arguments().isEmpty()) {
      return classSymbol;
    }
    return null;
  }

  private void addBoxingIssue(Tree tree, Symbol classSymbol, Tree boxingArg, Tree originalTree) {
    String message;
    if (boxingArg.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) boxingArg;
      message = String.format(""Remove the boxing of \""%s\""."", identifier.name());
    } else {
      message = String.format(""Remove the boxing to \""%s\""."", classSymbol.name());
    }

    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(tree)
      .withMessage(message)
      .withQuickFix(() -> JavaQuickFix.newQuickFix(""Remove the boxing"")
        .addTextEdits(removeTreeExcept(originalTree, boxingArg))
        .build())
      .report();
  }

  private static List<JavaTextEdit> removeTreeExcept(Tree tree, Tree except) {
    return Arrays.asList(JavaTextEdit.removeTextSpan(AnalyzerMessage.textSpanBetween(tree, true, except, false)),
      JavaTextEdit.removeTextSpan(AnalyzerMessage.textSpanBetween(except, false, tree, true)));
  }

  private void checkForUnboxing(ExpressionTree expressionTree) {
    if (!expressionTree.is(Tree.Kind.METHOD_INVOCATION)) {
      return;
    }
    MethodInvocationTree methodInvocationTree = (MethodInvocationTree) expressionTree;
    if (isUnboxingMethodInvocation(methodInvocationTree)) {
      ExpressionTree methodSelect = methodInvocationTree.methodSelect();
      if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree memberSelectExpressionTree = (MemberSelectExpressionTree) methodSelect;
        ExpressionTree unboxedExpression = memberSelectExpressionTree.expression();
        String unboxingResultTypeName = methodInvocationTree.symbolType().fullyQualifiedName();
        if (unboxingResultTypeName.equals(PRIMITIVE_TYPES_BY_WRAPPER.get(unboxedExpression.symbolType().fullyQualifiedName()))) {
          addUnboxingIssue(expressionTree, unboxedExpression);
        }
      }
    }
  }

  private void addUnboxingIssue(ExpressionTree expressionTree, ExpressionTree unboxedExpression) {
    String message;
    if (unboxedExpression.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) unboxedExpression;
      message = String.format(""Remove the unboxing of \""%s\""."", identifier.name());
    } else {
      String name = unboxedExpression.symbolType().name();
      message = String.format(""Remove the unboxing from \""%s\""."", name);
    }

    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(expressionTree)
      .withMessage(message)
      .withQuickFix(() -> JavaQuickFix.newQuickFix(""Remove the unboxing"")
        .addTextEdit(JavaTextEdit.removeTextSpan(AnalyzerMessage.textSpanBetween(unboxedExpression, false, expressionTree, true)))
        .build())
      .report();
  }

  private static MethodMatchers unboxingInvocationMatchers() {
    List<MethodMatchers> matchers = new ArrayList<>();
    for (Entry<String, String> type : PRIMITIVE_TYPES_BY_WRAPPER.entrySet()) {
      String primitiveType = type.getValue();
      Predicate<Type> typeCriteria;
      if (""char"".equals(primitiveType) || ""boolean"".equals(primitiveType)) {
        typeCriteria = t -> t.is(type.getKey());
      } else {
        typeCriteria = t -> t.isSubtypeOf(""java.lang.Number"");
      }
      matchers.add(MethodMatchers.create().ofType(typeCriteria).names(primitiveType + ""Value"").addWithoutParametersMatcher().build());
    }
    return MethodMatchers.or(matchers);
  }

  private static MethodMatchers valueOfInvocationMatchers() {
    List<MethodMatchers> matchers = new ArrayList<>();
    for (Entry<String, String> primitiveMapping : PRIMITIVE_TYPES_BY_WRAPPER.entrySet()) {
      matchers.add(
        MethodMatchers.create()
          .ofTypes(primitiveMapping.getKey())
          .names(""valueOf"")
          .addParametersMatcher(primitiveMapping.getValue()).build());
    }
    return MethodMatchers.or(matchers);
  }

  private static boolean isUnboxingMethodInvocation(MethodInvocationTree mit) {
    return unboxingInvocationMatchers.matches(mit);
  }

  private static boolean isValueOfInvocation(MethodInvocationTree mit) {
    return valueOfInvocationMatchers.matches(mit);
  }
}
"
S2154,BUG,Dissimilar primitive wrappers should not be used with the ternary operator without explicit casting,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2154"")
public class PrimitiveWrappersInTernaryOperatorCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.CONDITIONAL_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    ConditionalExpressionTree cet = (ConditionalExpressionTree) tree;
    Type trueExpressionType = cet.trueExpression().symbolType();
    Type falseExpressionType = cet.falseExpression().symbolType();
    if (dissimilarPrimitiveTypeWrappers(trueExpressionType, falseExpressionType)) {
      reportIssue(cet.questionToken(), ""Add an explicit cast to match types of operands."");
    }
  }

  private static boolean dissimilarPrimitiveTypeWrappers(Type trueExprType, Type falseExprType) {
    return trueExprType.isPrimitiveWrapper() && falseExprType.isPrimitiveWrapper() && !trueExprType.equals(falseExprType);
  }

}
"
S2156,CODE_SMELL,"""final"" classes should not have ""protected"" members","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2156"")
public class ProtectedMemberInFinalClassCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Remove this \""protected\"" modifier."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {
      classTree.members().forEach(this::checkMember);
    }
  }

  private void checkMember(Tree member) {
    if (member.is(Tree.Kind.VARIABLE)) {
      VariableTree variableTree = (VariableTree) member;
      checkVariableCompliance(variableTree);
    } else if (member.is(Tree.Kind.METHOD)) {
      MethodTree methodTree = (MethodTree) member;
      if (Boolean.FALSE.equals(methodTree.isOverriding())) {
        checkMethodCompliance(methodTree);
      }
    }
  }

  private void checkMethodCompliance(MethodTree methodTree) {
    checkComplianceOnModifiersAndSymbol(methodTree.modifiers());
  }

  private void checkVariableCompliance(VariableTree variableTree) {
    checkComplianceOnModifiersAndSymbol(variableTree.modifiers());
  }

  private void checkComplianceOnModifiersAndSymbol(ModifiersTree modifiers) {
    ModifierKeywordTree modifier = ModifiersUtils.getModifier(modifiers, Modifier.PROTECTED);
    if (modifier != null && !isVisibleForTesting(modifiers)) {
      reportIssue(modifier.keyword(), MESSAGE);
    }
  }

  private static boolean isVisibleForTesting(ModifiersTree modifiers) {
    return modifiers.annotations().stream()
      .anyMatch(annotation -> ""VisibleForTesting"".equals(annotation.annotationType().lastToken().text()));
  }

}
"
S2157,CODE_SMELL,"""Cloneables"" should implement ""clone""","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.TypeTree;

@Rule(key = ""S2157"")
public class CloneableImplementingCloneCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers CLONE_MATCHER = MethodMatchers.create()
    .ofAnyType()
    .names(""clone"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Symbol.TypeSymbol classSymbol = classTree.symbol();
    if (isCloneable(classTree) && !classSymbol.isAbstract() && !declaresCloneMethod(classSymbol)) {
      reportIssue(classTree.simpleName(), ""Add a \""clone()\"" method to this class."");
    }
  }

  private static boolean declaresCloneMethod(Symbol.TypeSymbol classSymbol) {
    return classSymbol.lookupSymbols(""clone"").stream().anyMatch(CLONE_MATCHER::matches);
  }

  private static boolean isCloneable(ClassTree classTree) {
    return classTree.superInterfaces().stream().map(TypeTree::symbolType).anyMatch(t -> t.is(""java.lang.Cloneable""));
  }
}
"
S2159,BUG,Silly equality checks should not be made,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonarsource.analyzer.commons.collections.ListUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2159"")
public class SillyEqualsCheck extends AbstractMethodDetection {

  private static final String JAVA_LANG_OBJECT = ""java.lang.Object"";

  private static final String MESSAGE = ""Remove this call to \""equals\""; comparisons between unrelated types always return false."";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofAnyType()
      .names(""equals"")
      .addParametersMatcher(JAVA_LANG_OBJECT)
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree tree) {
    ExpressionTree firstArgument = ListUtils.getOnlyElement(tree.arguments());
    Type argumentType = firstArgument.symbolType().erasure();
    if (argumentType.isPrimitive()) {
      argumentType = argumentType.primitiveWrapperType();
    }
    Type ownerType = getMethodOwnerType(tree).erasure();

    if (ownerType.isUnknown() || argumentType.isUnknown()) {
      return;
    }

    IdentifierTree methodInvocationName = ExpressionUtils.methodName(tree);
    if (isLiteralNull(firstArgument)) {
      reportIssue(methodInvocationName, ""Remove this call to \""equals\""; comparisons against null always return false; consider using '== null' to check for nullity."");
    } else if (ownerType.isArray()) {
      checkWhenOwnerIsArray(methodInvocationName, (Type.ArrayType) ownerType, argumentType);
    } else {
      checkWhenOwnerIsNotArray(methodInvocationName, ownerType, argumentType);
    }
  }

  private void checkWhenOwnerIsArray(IdentifierTree methodInvocationName, Type.ArrayType ownerType, Type argumentType) {
    if (argumentType.isArray()) {
      if (areNotRelated(ownerType.elementType(), ((Type.ArrayType) argumentType).elementType())) {
        reportIssue(methodInvocationName, ""Remove this call to \""equals\""; comparisons between unrelated arrays always return false."");
      } else {
        reportIssue(methodInvocationName, ""Use \""Arrays.equals(array1, array2)\"" or the \""==\"" operator instead of using the \""Object.equals(Object obj)\"" method."");
      }
    } else if (!argumentType.is(JAVA_LANG_OBJECT)) {
      reportIssue(methodInvocationName, ""Remove this call to \""equals\""; comparisons between an array and a type always return false."");
    }
  }

  private void checkWhenOwnerIsNotArray(IdentifierTree methodInvocationName, Type ownerType, Type argumentType) {
    if (argumentType.isArray() && !ownerType.is(JAVA_LANG_OBJECT)) {
      reportIssue(methodInvocationName, ""Remove this call to \""equals\""; comparisons between a type and an array always return false."");
    } else if (argumentType.isClass() && areNotRelated(ownerType, argumentType)
      && (areTypesFinalClassAndInterface(ownerType, argumentType) || areNeitherInterfaces(ownerType, argumentType))) {
      reportIssue(methodInvocationName, MESSAGE);
    }
  }

  private static boolean areNeitherInterfaces(Type ownerType, Type argumentType) {
    return !ownerType.symbol().isInterface() && !argumentType.symbol().isInterface();
  }

  private static boolean areTypesFinalClassAndInterface(Type ownerType, Type argumentType) {
    return (ownerType.symbol().isInterface() && argumentType.symbol().isFinal()) || (argumentType.symbol().isInterface() && ownerType.symbol().isFinal());
  }

  private static boolean isLiteralNull(Tree tree) {
    return tree.is(Tree.Kind.NULL_LITERAL);
  }

  private static Type getMethodOwnerType(MethodInvocationTree methodSelectTree) {
    if (methodSelectTree.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      return ((MemberSelectExpressionTree) methodSelectTree.methodSelect()).expression().symbolType();
    } else {
      return methodSelectTree.methodSymbol().owner().type();
    }
  }

  private static boolean areNotRelated(Type type1, Type type2) {
    // At this point, the type should not be unknown, but to prevent FP in case of strange semantic from ECJ, we check it again.
    return !type1.isUnknown() && !type2.isUnknown() && !type1.isSubtypeOf(type2) && !type2.isSubtypeOf(type1);
  }

}
"
S2160,CODE_SMELL,"Subclasses that add fields to classes that override ""equals"" should also override ""equals""","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2160"")
public class EqualsNotOverriddenInSubclassCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers EQUALS_MATCHER = MethodMatchers.create()
    .ofAnyType().names(""equals"").addParametersMatcher(""java.lang.Object"").build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (shouldImplementEquals(classTree)) {
      reportIssue(classTree.simpleName(), ""Override the \""equals\"" method in this class."");
    }
  }

  private static boolean shouldImplementEquals(ClassTree classTree) {
    return hasAtLeastOneField(classTree) && !hasEqualsMethod(classTree.symbol()) && parentClassImplementsEquals(classTree);
  }

  private static boolean hasAtLeastOneField(ClassTree classTree) {
    return classTree.members().stream().anyMatch(EqualsNotOverriddenInSubclassCheck::isField);
  }

  private static boolean isField(Tree tree) {
    return tree.is(Tree.Kind.VARIABLE) && !ModifiersUtils.hasModifier(((VariableTree) tree).modifiers(), Modifier.STATIC);
  }

  private static boolean parentClassImplementsEquals(ClassTree tree) {
    TypeTree superClass = tree.superClass();
    if (superClass != null) {
      Type superClassType = superClass.symbolType();
      while (superClassType.symbol().isTypeSymbol() && !superClassType.is(""java.lang.Object"")) {
        Symbol.TypeSymbol superClassSymbol = superClassType.symbol();
        Optional<Symbol> equalsMethod = equalsMethod(superClassSymbol);
        if (equalsMethod.isPresent()) {
          Symbol equalsMethodSymbol = equalsMethod.get();
          return !equalsMethodSymbol.isFinal() && !equalsMethodSymbol.isAbstract();
        }
        superClassType = superClassSymbol.superClass();
      }
    }
    return false;
  }

  private static boolean hasEqualsMethod(Symbol.TypeSymbol type) {
    return equalsMethod(type).isPresent();
  }

  private static Optional<Symbol> equalsMethod(Symbol.TypeSymbol type) {
    return type.lookupSymbols(""equals"").stream().filter(EQUALS_MATCHER::matches).findFirst();
  }
}
"
S2162,BUG,"""equals"" methods should be symmetric and work for subclasses","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.ast.api.JavaKeyword;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.InstanceOfTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2162"")
public class SymmetricEqualsCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (MethodTreeUtils.isEqualsMethod(methodTree) && methodTree.block() != null) {
      methodTree.block().accept(new SymmetryBrokePatterns(methodTree.symbol()));
    }
  }

  private class SymmetryBrokePatterns extends BaseTreeVisitor {

    private final Symbol.MethodSymbol methodSymbol;
    private final Symbol owner;

    public SymmetryBrokePatterns(Symbol.MethodSymbol methodSymbol) {
      this.methodSymbol = methodSymbol;
      this.owner = methodSymbol.owner();
    }

    private boolean isOwnerFinal() {
      return owner.isFinal();
    }

    @Override
    public void visitInstanceOf(InstanceOfTree tree) {
      if (tree.type().symbolType().erasure().equals(owner.type().erasure())) {
        if (!isOwnerFinal() && !methodSymbol.isFinal()) {
          reportIssue(tree, ""Compare to \""this.getClass()\"" instead."");
        }
      } else {
        reportIssue(tree, ""Remove this comparison to an unrelated class."");
      }
      super.visitInstanceOf(tree);
    }

    @Override
    public void visitClass(ClassTree tree) {
      // inner classes will be visited by main visitor.
    }

    @Override
    public void visitBinaryExpression(BinaryExpressionTree tree) {
      if (tree.is(Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO)) {
        checkOperand(tree.leftOperand());
        checkOperand(tree.rightOperand());
      }
      super.visitBinaryExpression(tree);
    }

    private void checkOperand(ExpressionTree expressionTree) {
      if (expressionTree.is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree mset = (MemberSelectExpressionTree) expressionTree;
        if (isClassExpression(mset)) {
          if (isClassOfOwner(mset)) {
            if (!isOwnerFinal()) {
              reportIssue(expressionTree, ""Compare to \""this.getClass()\"" instead."");
            }
          } else {
            reportIssue(expressionTree, ""Remove this comparison to an unrelated class."");
          }
        }
      }
    }

    private boolean isClassExpression(MemberSelectExpressionTree mset) {
      return JavaKeyword.CLASS.getValue().equals(mset.identifier().name());
    }

    private boolean isClassOfOwner(MemberSelectExpressionTree mset) {
      return mset.expression().symbolType().equals(owner.type());
    }

  }

}
"
S2164,BUG,Math should not be performed on floats,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2164"")
public class MathOnFloatCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitBinaryExpression(BinaryExpressionTree tree) {
    if (tree.is(Tree.Kind.PLUS, Tree.Kind.MINUS, Tree.Kind.MULTIPLY, Tree.Kind.DIVIDE)) {
      if (withinStringConcatenation(tree)) {
        return;
      }
      if (tree.symbolType().is(""float"")) {
        context.reportIssue(this, tree, ""Use a \""double\"" or \""BigDecimal\"" instead."");
        // do not look for other issues in sub-tree
        return;
      }
    }
    super.visitBinaryExpression(tree);
  }

  private static boolean withinStringConcatenation(BinaryExpressionTree tree) {
    Tree parent = tree.parent();
    while (parent.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {
      parent = parent.parent();
    }
    return parent.is(Tree.Kind.PLUS) && ((BinaryExpressionTree) parent).symbolType().is(""java.lang.String"");
  }

}
"
S2165,CODE_SMELL,"""finalize"" should not set fields to ""null""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2165"")
public class FinalizeFieldsSetCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (isFinalizeDeclaration(methodTree)) {
      methodTree.accept(new AssignmentVisitor());
    }
  }

  private static boolean isFinalizeDeclaration(MethodTree tree) {
    return isMethodNamedFinalize(tree) && hasNoParameters(tree);
  }

  private static boolean isMethodNamedFinalize(MethodTree tree) {
    return ""finalize"".equals(tree.simpleName().name());
  }

  private static boolean hasNoParameters(MethodTree tree) {
    return tree.parameters().isEmpty();
  }

  private class AssignmentVisitor extends BaseTreeVisitor {
    @Override
    public void visitClass(ClassTree tree) {
      // Do not visit inner classes as their methods will be visited by main visitor
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      if (isFieldAssignment(tree) && isNullAssignment(tree)) {
        reportIssue(tree.expression(), ""Remove this nullification of \"""" + getFieldName(tree) + ""\""."");
      }
    }

    private boolean isFieldAssignment(AssignmentExpressionTree tree) {
      ExpressionTree variable = tree.variable();
      if (variable.is(Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree memberSelectExpressionTree = (MemberSelectExpressionTree) variable;
        if (!ExpressionUtils.isThis(memberSelectExpressionTree.expression())) {
          return false;
        }
        variable = memberSelectExpressionTree.identifier();
      }
      if (variable.is(Kind.IDENTIFIER)) {
        Symbol variableSymbol = ((IdentifierTree) variable).symbol();
        return variableSymbol.owner().isTypeSymbol();
      }
      return false;
    }

    private boolean isNullAssignment(AssignmentExpressionTree tree) {
      return tree.expression().is(Kind.NULL_LITERAL);
    }

    private String getFieldName(AssignmentExpressionTree tree) {
      ExpressionTree variable = tree.variable();
      if (variable.is(Kind.MEMBER_SELECT)) {
        variable = ((MemberSelectExpressionTree) variable).identifier();
      }
      return ((IdentifierTree) variable).name();
    }
  }
}
"
S2166,CODE_SMELL,"Classes named like ""Exception"" should extend ""Exception"" or a subclass","package org.sonar.java.checks.naming;

import java.util.Collections;
import java.util.List;
import java.util.Locale;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2166"")
public class ClassNamedLikeExceptionCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Symbol.TypeSymbol symbol = classTree.symbol();
    String className = symbol.name();
    if (endsWithException(className) && !isSubtypeOfException(symbol) && !hasUnknownSuperType(symbol)) {
      String suffix = className.substring(className.length() - ""exception"".length());
      reportIssue(classTree.simpleName(), ""Rename this class to remove \"""" + suffix + ""\"" or correct its inheritance."");
    }
  }

  private static boolean endsWithException(String className) {
    return className.toLowerCase(Locale.US).endsWith(""exception"");
  }

  private static boolean isSubtypeOfException(Symbol symbol) {
    return symbol.type().isSubtypeOf(""java.lang.Exception"");
  }

  private static boolean hasUnknownSuperType(Symbol.TypeSymbol symbol) {
    Type superClass = symbol.superClass();
    return superClass != null && (superClass.isUnknown() || hasUnknownSuperType(superClass.symbol()));
  }

}
"
S2167,BUG,"""compareTo"" should not return ""Integer.MIN_VALUE""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2167"")
public class CompareToReturnValueCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (isCompareToDeclaration(methodTree)) {
      methodTree.accept(new ReturnStatementVisitor());
    }
  }

  private static boolean isCompareToDeclaration(MethodTree tree) {
    return isNamedCompareTo(tree) && hasOneNonPrimitiveParameter(tree) && returnsInt(tree);
  }

  private static boolean isNamedCompareTo(MethodTree tree) {
    return ""compareTo"".equals(tree.simpleName().name());
  }

  private static boolean hasOneNonPrimitiveParameter(MethodTree methodTree) {
    List<VariableTree> parameters = methodTree.parameters();
    return parameters.size() == 1 && !parameters.get(0).type().symbolType().isPrimitive();
  }

  private static boolean returnsInt(MethodTree methodTree) {
    TypeTree typeTree = methodTree.returnType();
    return typeTree != null && typeTree.symbolType().isPrimitive(Type.Primitives.INT);
  }

  private class ReturnStatementVisitor extends BaseTreeVisitor {

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      if (returnsIntegerMinValue(tree.expression())) {
        reportIssue(tree.expression(), ""Simply return -1"");
      }
    }

    private boolean returnsIntegerMinValue(ExpressionTree expressionTree) {
      if (expressionTree.is(Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) expressionTree;
        boolean isInteger = memberSelect.expression().symbolType().is(""java.lang.Integer"");
        boolean isMinValue = ""MIN_VALUE"".equals(memberSelect.identifier().name());
        return isInteger && isMinValue;
      }
      return false;
    }

    @Override
    public void visitClass(ClassTree tree) {
      // Do not visit inner classes as methods of inner classes will be visited by main visitor
    }
  }
}
"
S2168,BUG,Double-checked locking should not be used,"package org.sonar.java.checks.synchronization;

import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;

import static org.sonar.plugins.java.api.tree.Tree.Kind.EQUAL_TO;
import static org.sonar.plugins.java.api.tree.Tree.Kind.IDENTIFIER;
import static org.sonar.plugins.java.api.tree.Tree.Kind.IF_STATEMENT;
import static org.sonar.plugins.java.api.tree.Tree.Kind.MEMBER_SELECT;
import static org.sonar.plugins.java.api.tree.Tree.Kind.METHOD;
import static org.sonar.plugins.java.api.tree.Tree.Kind.NULL_LITERAL;
import static org.sonar.plugins.java.api.tree.Tree.Kind.SYNCHRONIZED_STATEMENT;

@Rule(key = ""S2168"")
public class DoubleCheckedLockingCheck extends IssuableSubscriptionVisitor {

  private Deque<IfFieldEqNull> ifFieldStack = new LinkedList<>();
  private Deque<CriticalSection> synchronizedStmtStack = new LinkedList<>();
  private boolean methodIsSynchronized;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(IF_STATEMENT, SYNCHRONIZED_STATEMENT, METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    isIfFieldEqNull(tree).ifPresent(ifFieldEqNull -> {
      ifFieldStack.push(ifFieldEqNull);
      visitIfStatement(ifFieldEqNull.ifTree);
    });
    if (tree.is(SYNCHRONIZED_STATEMENT)) {
      CriticalSection criticalSection = new CriticalSection((SynchronizedStatementTree) tree, ifFieldStack.size());
      synchronizedStmtStack.push(criticalSection);
    }
    if (tree.is(METHOD)) {
      methodIsSynchronized = ModifiersUtils.hasModifier(((MethodTree) tree).modifiers(), Modifier.SYNCHRONIZED);
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    isIfFieldEqNull(tree).ifPresent(cl -> ifFieldStack.pop());
    if (tree.is(SYNCHRONIZED_STATEMENT)) {
      synchronizedStmtStack.pop();
    }
  }

  private static Optional<IfFieldEqNull> isIfFieldEqNull(Tree tree) {
    if (!tree.is(IF_STATEMENT)) {
      return Optional.empty();
    }
    IfStatementTree ifTree = (IfStatementTree) tree;
    if (!ifTree.condition().is(EQUAL_TO)) {
      return Optional.empty();
    }
    BinaryExpressionTree eqRelation = (BinaryExpressionTree) ifTree.condition();
    if (eqRelation.rightOperand().is(NULL_LITERAL)) {
      return isField(eqRelation.leftOperand()).map(f -> new IfFieldEqNull(ifTree, f));
    }
    if (eqRelation.leftOperand().is(NULL_LITERAL)) {
      return isField(eqRelation.rightOperand()).map(f -> new IfFieldEqNull(ifTree, f));
    }
    return Optional.empty();
  }

  private void visitIfStatement(IfStatementTree ifTree) {
    if (insideCriticalSection()) {
      Optional<IfFieldEqNull> parentIf = sameFieldAlreadyOnStack(ifFieldStack.peek());
      parentIf.ifPresent(pIf -> ifSynchronizedIfPattern(pIf, ifTree));
    }
  }

  private void ifSynchronizedIfPattern(IfFieldEqNull parentIf, IfStatementTree nestedIf) {
    if (thenStmtInitializeField(nestedIf.thenStatement(), parentIf.field)
      && !parentIf.field.isVolatile()
      && !methodIsSynchronized) {
      SyntaxToken synchronizedKeyword = synchronizedStmtStack.peek().synchronizedTree.synchronizedKeyword();
      reportIssue(synchronizedKeyword, ""Remove this dangerous instance of double-checked locking."", createFlow(parentIf.ifTree, nestedIf), null);
    }
  }

  private static List<JavaFileScannerContext.Location> createFlow(IfStatementTree parentIf, IfStatementTree nestedIf) {
    return Stream.of(parentIf.condition(), nestedIf.condition())
      .map(c -> new JavaFileScannerContext.Location(""Double-checked locking"", c))
      .toList();
  }

  private boolean insideCriticalSection() {
    return !synchronizedStmtStack.isEmpty();
  }private Optional<IfFieldEqNull> sameFieldAlreadyOnStack(IfFieldEqNull nestedIf) {
    int aboveSynchronized = ifFieldStack.size() - synchronizedStmtStack.peek().ifStackDepth;
    return ifFieldStack.stream()
      .skip(aboveSynchronized)
      .filter(parentIf -> parentIf.field == nestedIf.field)
      .findFirst();
  }

  private static Optional<Symbol> isField(ExpressionTree expressionTree) {
    return symbolFromVariable(expressionTree)
      .filter(s -> s.isVariableSymbol() && s.owner().isTypeSymbol());
  }

  private static Optional<Symbol> symbolFromVariable(ExpressionTree variable) {
    if (variable.is(IDENTIFIER)) {
      return Optional.of(((IdentifierTree) variable).symbol());
    }
    if (variable.is(MEMBER_SELECT)) {
      return Optional.of(((MemberSelectExpressionTree) variable).identifier().symbol());
    }
    return Optional.empty();
  }

  private static boolean thenStmtInitializeField(StatementTree statementTree, Symbol field) {
    AssignmentVisitor visitor = new AssignmentVisitor(field);
    statementTree.accept(visitor);
    return visitor.assignmentToField;
  }

  private static class AssignmentVisitor extends BaseTreeVisitor {

    private boolean assignmentToField;
    private Symbol field;

    AssignmentVisitor(Symbol field) {
      this.field = field;
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree assignmentTree) {
      ExpressionTree variable = assignmentTree.variable();
      symbolFromVariable(variable)
        .filter(s -> s == field)
        .ifPresent(s -> assignmentToField = true);
    }
  }

  private static class IfFieldEqNull {
    private final IfStatementTree ifTree;
    private final Symbol field;

    private IfFieldEqNull(IfStatementTree ifTree, Symbol field) {
      this.ifTree = ifTree;
      this.field = field;
    }
  }

  private static class CriticalSection {
    SynchronizedStatementTree synchronizedTree;
    int ifStackDepth;

    public CriticalSection(SynchronizedStatementTree synchronizedTree, int ifStackDepth) {
      this.synchronizedTree = synchronizedTree;
      this.ifStackDepth = ifStackDepth;
    }
  }

}
"
S2175,BUG,"Inappropriate ""Collection"" calls should not be made","package org.sonar.java.checks;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.Symbols;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S2175"")
public class CollectionInappropriateCallsCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_UTIL_COLLECTION = ""java.util.Collection"";

  private static final List<TypeChecker> TYPE_CHECKERS = new TypeCheckerListBuilder()
    .on(JAVA_UTIL_COLLECTION)
      .method(""remove"").argument(1).outOf(1).shouldMatchParametrizedType(1).add()
      .method(""removeAll"").argument(1).outOf(1).shouldMatchCollectionOfParametrizedType(1).add()
      .method(""contains"").argument(1).outOf(1).shouldMatchParametrizedType(1).add()
    .on(""java.util.List"")
      .method(""indexOf"").argument(1).outOf(1).shouldMatchParametrizedType(1).add()
      .method(""lastIndexOf"").argument(1).outOf(1).shouldMatchParametrizedType(1).add()
    .on(""java.util.Map"")
      .method(""containsKey"").argument(1).outOf(1).shouldMatchParametrizedType(1).add()
      .method(""containsValue"").argument(1).outOf(1).shouldMatchParametrizedType(2).add()
      .method(""get"").argument(1).outOf(1).shouldMatchParametrizedType(1).add()
      .method(""getOrDefault"").argument(1).outOf(2).shouldMatchParametrizedType(1).add()
      .method(""remove"")
        .argument(1).outOf(1).shouldMatchParametrizedType(1).add()
        .argument(1).outOf(2).shouldMatchParametrizedType(1).add()
        .argument(2).outOf(2).shouldMatchParametrizedType(2).add()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;
    TYPE_CHECKERS.stream()
      .filter(typeChecker -> typeChecker.methodMatcher.matches(mit))
      .forEach(typeChecker -> checkMethodInvocation(mit, typeChecker));
  }

  private void checkMethodInvocation(MethodInvocationTree tree, TypeChecker typeChecker) {
    ExpressionTree argument = tree.arguments().get(typeChecker.argumentIndex);
    Type argumentTypeToCheck = argument.symbolType();
    if (typeChecker.argumentIsACollection) {
      argumentTypeToCheck = getTypeArgumentAt(findSuperTypeMatching(argumentTypeToCheck, JAVA_UTIL_COLLECTION), 0);
    }
    if (argumentTypeToCheck.isUnknown()) {
      // could happen with type inference.
      return;
    }

    Type actualMethodType = getMethodOwnerType(tree);
    Type checkedMethodType = findSuperTypeMatching(actualMethodType, typeChecker.methodOwnerType);
    Type parameterType = getTypeArgumentAt(checkedMethodType, typeChecker.parametrizedTypeIndex);

    boolean isCallToParametrizedOrUnknownMethod = isCallToParametrizedOrUnknownMethod(argument);
    if (!isCallToParametrizedOrUnknownMethod && tree.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      isCallToParametrizedOrUnknownMethod = isCallToParametrizedOrUnknownMethod(((MemberSelectExpressionTree) tree.methodSelect()).expression());
    }
    if (!checkedMethodType.isUnknown()
      && !parameterType.isUnknown()
      && !isCallToParametrizedOrUnknownMethod
      && !isArgumentCompatible(argumentTypeToCheck, parameterType)) {
      reportIssue(ExpressionUtils.methodName(tree), message(actualMethodType, checkedMethodType, parameterType, argumentTypeToCheck));
    }
  }

  private static String message(Type actualMethodType, Type checkedMethodType, Type parameterType, Type argumentType) {
    String actualType = typeNameWithParameters(actualMethodType);
    boolean actualTypeHasTheParameterType = actualMethodType.typeArguments().stream().anyMatch(typeArg -> typeArg.equals(parameterType));
    boolean checkedTypeHasSeveralParameters = checkedMethodType.typeArguments().size() > 1;
    String typeDescription = checkedTypeHasSeveralParameters ? ("" in a \"""" + parameterType + ""\"" type"") : """";
    if (actualTypeHasTheParameterType) {
      return MessageFormat.format(""A \""{0}\"" cannot contain a \""{1}\""{2}."", actualType, argumentType.name(), typeDescription);
    }
    String checkedType = typeNameWithParameters(checkedMethodType);
    return MessageFormat.format(""\""{0}\"" is a \""{1}\"" which cannot contain a \""{2}\""{3}."",
      actualType, checkedType, argumentType.name(), typeDescription);
  }

  private static String typeNameWithParameters(Type type) {
    if (type.isParameterized()) {
      return type.name() + type.typeArguments().stream()
        .map(Type::name)
        .collect(Collectors.joining("", "", ""<"", "">""));
    }
    return type.name();
  }

  private static boolean isCallToParametrizedOrUnknownMethod(ExpressionTree expressionTree) {
    if (expressionTree.is(Tree.Kind.METHOD_INVOCATION)) {
      Symbol.MethodSymbol symbol = ((MethodInvocationTree) expressionTree).methodSymbol();
      return symbol.isUnknown() || symbol.isParametrizedMethod();
    }
    return false;
  }

  private static Type getMethodOwnerType(MethodInvocationTree mit) {
    if (mit.methodSelect().is(Kind.MEMBER_SELECT)) {
      return ((MemberSelectExpressionTree) mit.methodSelect()).expression().symbolType();
    }
    return mit.methodSymbol().owner().type();
  }

  private static Type getTypeArgumentAt(Type type, int index) {
    if (type.isParameterized()) {
      List<Type> parameters = type.typeArguments();
      if (index < parameters.size()) {
        return parameters.get(index);
      }
    }
    return Symbols.unknownType;
  }

  private static Type findSuperTypeMatching(Type type, String genericTypeName) {
    if (type.is(genericTypeName)) {
      return type;
    }
    return type.symbol().superTypes()
      .stream()
      .filter(superType -> superType.is(genericTypeName))
      .findFirst()
      .orElse(Symbols.unknownType);
  }

  private static boolean isArgumentCompatible(Type argumentType, Type collectionParameterType) {
    return isSubtypeOf(argumentType, collectionParameterType)
      || isSubtypeOf(collectionParameterType, argumentType)
      || autoboxing(argumentType, collectionParameterType);
  }

  private static boolean isSubtypeOf(Type type, Type superType) {
    return type.isSubtypeOf(superType.erasure());
  }

  private static boolean autoboxing(Type argumentType, Type collectionParameterType) {
    return argumentType.isPrimitive()
      && isSubtypeOf(argumentType.primitiveWrapperType(), collectionParameterType);
  }

  private static class TypeChecker {
    private final String methodOwnerType;
    private final MethodMatchers methodMatcher;
    private final int argumentIndex;
    private boolean argumentIsACollection;
    private final int parametrizedTypeIndex;

    private TypeChecker(String methodOwnerType, MethodMatchers methodMatcher, int argumentIndex, boolean argumentIsACollection, int parametrizedTypeIndex) {
      this.methodOwnerType = methodOwnerType;
      this.methodMatcher = methodMatcher;
      this.argumentIndex = argumentIndex;
      this.argumentIsACollection = argumentIsACollection;
      this.parametrizedTypeIndex = parametrizedTypeIndex;
    }
  }

  private static class TypeCheckerListBuilder {

    private final List<TypeChecker> typeCheckers = new ArrayList<>();

    private String methodOwnerType;
    private String methodName;
    private int argumentPosition;
    private boolean argumentIsACollection;
    private int argumentCount;
    private int parametrizedTypePosition;

    private TypeCheckerListBuilder on(String methodOwnerType) {
      this.methodOwnerType = methodOwnerType;
      return this;
    }

    private TypeCheckerListBuilder method(String methodName) {
      this.methodName = methodName;
      return this;
    }

    private TypeCheckerListBuilder argument(int argumentPosition) {
      this.argumentPosition = argumentPosition;
      return this;
    }

    private TypeCheckerListBuilder outOf(int argumentCount) {
      this.argumentCount = argumentCount;
      return this;
    }

    private TypeCheckerListBuilder shouldMatchParametrizedType(int parametrizedTypePosition) {
      this.parametrizedTypePosition = parametrizedTypePosition;
      this.argumentIsACollection = false;
      return this;
    }

    private TypeCheckerListBuilder shouldMatchCollectionOfParametrizedType(int parametrizedTypePosition) {
      this.parametrizedTypePosition = parametrizedTypePosition;
      this.argumentIsACollection = true;
      return this;
    }

    private TypeCheckerListBuilder add() {
      int argumentIndex = argumentPosition - 1;
      int parametrizedTypeIndex = parametrizedTypePosition - 1;

      List<String> methodMatcherParameters = new ArrayList<>();
      for (int i = 0; i < argumentCount; i++) {
        String parameterType = ANY;
        if (i == argumentIndex) {
          parameterType = argumentIsACollection ? JAVA_UTIL_COLLECTION : ""java.lang.Object"";
        }
        methodMatcherParameters.add(parameterType);
      }

      MethodMatchers methodMatcher = MethodMatchers.create()
        .ofSubTypes(methodOwnerType)
        .names(methodName)
        .addParametersMatcher(methodMatcherParameters.toArray(new String[0]))
        .build();

      typeCheckers.add(new TypeChecker(methodOwnerType, methodMatcher, argumentIndex, argumentIsACollection, parametrizedTypeIndex));
      return this;
    }

    private List<TypeChecker> build() {
      return typeCheckers;
    }

  }

}
"
S2176,CODE_SMELL,Class names should not shadow interfaces or superclasses,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import javax.annotation.Nullable;

import java.util.Arrays;
import java.util.List;
import java.util.Locale;

@Rule(key = ""S2176"")
public class InterfaceOrSuperclassShadowingCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.INTERFACE, Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Symbol.TypeSymbol classSymbol = classTree.symbol();
    checkSuperType(classTree, classSymbol.superClass());
    for (Type interfaceType : classSymbol.interfaces()) {
      checkSuperType(classTree, interfaceType);
    }
  }

  private void checkSuperType(ClassTree tree, @Nullable Type superType) {
    if (superType != null && hasSameName(tree, superType) && !isInnerClass(tree)) {
      reportIssue(tree.simpleName(), ""Rename this "" + tree.kind().name().toLowerCase(Locale.ROOT) + ""."");
    }
  }

  private static boolean hasSameName(ClassTree tree, Type superType) {
    return superType.symbol().name().equals(tree.symbol().name());
  }

  private static boolean isInnerClass(ClassTree tree) {
    Symbol owner = tree.symbol().owner();
    return owner != null && !owner.isUnknown() && owner.isTypeSymbol();
  }
}
"
S2177,BUG,Child class methods named for parent class methods should be overrides,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2177"")
public class ConfusingOverloadCheck extends IssuableSubscriptionVisitor {
  private static final Set<String> SERIALIZATION_METHOD_NAME = SetUtils.immutableSetOf(""writeObject"", ""readObject"", ""readObjectNoData"", ""writeReplace"", ""readResolve"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (Boolean.FALSE.equals(methodTree.isOverriding())) {
      Symbol.MethodSymbol methodSymbol = methodTree.symbol();
      Symbol.TypeSymbol owner = (Symbol.TypeSymbol) methodSymbol.owner();
      Type superClass = owner.superClass();
      if(superClass != null && !SERIALIZATION_METHOD_NAME.contains(methodSymbol.name())) {
        boolean reportStaticIssue = checkMethod(methodTree.simpleName(), methodSymbol, superClass);
        superClass = superClass.symbol().superClass();
        while (superClass != null && !reportStaticIssue) {
          reportStaticIssue = checkStaticMethod(methodTree.simpleName(), methodSymbol, superClass);
          superClass = superClass.symbol().superClass();
        }
      }
    }
  }

  private boolean checkStaticMethod(Tree reportTree, Symbol.MethodSymbol methodSymbol, Type superClass) {
    for (Symbol methodWithSameName : superClass.symbol().lookupSymbols(methodSymbol.name())) {
      if (methodWithSameName.isMethodSymbol() && hideStaticMethod(methodSymbol, (Symbol.MethodSymbol) methodWithSameName)) {
        reportIssue(reportTree, ""Rename this method or make it \""static\""."");
        return true;
      }
    }
    return false;
  }

  private boolean checkMethod(Tree reportTree, Symbol.MethodSymbol methodSymbol, Type superClass) {
    boolean reportStaticIssue = false;
    for (Symbol methodWithSameName : superClass.symbol().lookupSymbols(methodSymbol.name())) {
      if (methodWithSameName.isMethodSymbol()) {
        if (hideStaticMethod(methodSymbol, (Symbol.MethodSymbol) methodWithSameName)) {
          reportIssue(reportTree, ""Rename this method or make it \""static\""."");
          reportStaticIssue = true;
        } else if (confusingOverload(methodSymbol, (Symbol.MethodSymbol) methodWithSameName)) {
          reportIssue(reportTree, getMessage(methodWithSameName));
        }
      }
    }
    return reportStaticIssue;
  }

  private static String getMessage(Symbol methodWithSameName) {
    String message = ""Rename this method or correct the type of the argument(s) to override the parent class method."";
    if(methodWithSameName.isPrivate()) {
      message = ""Rename this method; there is a \""private\"" method in the parent class with the same name."";
    }
    return message;
  }

  private static boolean hideStaticMethod(Symbol.MethodSymbol methodSymbol, Symbol.MethodSymbol symbolWithSameName) {
    return symbolWithSameName.isStatic()
      && !methodSymbol.isStatic()
      && isPotentialOverride(methodSymbol, symbolWithSameName);
  }

  static boolean isPotentialOverride(Symbol.MethodSymbol method, Symbol.MethodSymbol overrideeCandidate) {
    List<Type> methodParameterTypes = method.parameterTypes();
    List<Type> overrideeParameterTypes = overrideeCandidate.parameterTypes();
    if (methodParameterTypes.size() != overrideeParameterTypes.size()) {
      return false;
    }
    for (int i = 0; i < methodParameterTypes.size(); i++) {
      Type methodParam = methodParameterTypes.get(i);
      Type overrideeParamType = overrideeParameterTypes.get(i);
      if (methodParam.isUnknown() || overrideeParamType.isUnknown()) {
        return false;
      }
      if (!methodParam.erasure().equals(overrideeParamType.erasure())) {
        return false;
      }
    }
    return true;
  }

  private static boolean confusingOverload(Symbol.MethodSymbol methodSymbol, Symbol.MethodSymbol methodWithSameName) {
    if (methodSymbol.isStatic()) {
      return false;
    }
    List<Type> argTypes = methodSymbol.parameterTypes();
    List<Type> parameterTypes = methodWithSameName.parameterTypes();
    if (argTypes.size() != parameterTypes.size()) {
      return false;
    }
    for (int i = 0; i < argTypes.size(); i++) {
      Type argType = argTypes.get(i);
      if (argType.isUnknown() || !argType.name().equals(parameterTypes.get(i).name())) {
        return false;
      }
    }
    return true;
  }

}
"
S2178,CODE_SMELL,Short-circuit logic should be used in boolean contexts,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S2178"")
public class NonShortCircuitLogicCheck extends IssuableSubscriptionVisitor {

  private static final Map<String, String> REPLACEMENTS = MapBuilder.<String,String>newMap()
    .put(""&"", ""&&"")
    .put(""|"", ""||"")
    .build();

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.AND, Tree.Kind.OR);
  }

  @Override
  public void visitNode(Tree tree) {
    BinaryExpressionTree binaryExpressionTree = (BinaryExpressionTree) tree;
    if (isBoolean(binaryExpressionTree.leftOperand().symbolType())) {
      String operator = binaryExpressionTree.operatorToken().text();
      String replacement = REPLACEMENTS.get(operator);
      String sideEffectWarning = """";
      if (mayHaveSideEffect(binaryExpressionTree.rightOperand())) {
        sideEffectWarning = "" and extract the right operand to a variable if it should always be evaluated"";
      }
      reportIssue(binaryExpressionTree.operatorToken(), ""Correct this \"""" + operator + ""\"" to \"""" + replacement + ""\"""" + sideEffectWarning + ""."");
    }
  }

  private static boolean isBoolean(Type type) {
    return type.is(""boolean"") || type.is(""java.lang.Boolean"");
  }

  private static boolean mayHaveSideEffect(Tree tree) {
    MethodInvocationFinder methodInvocationFinder = new MethodInvocationFinder();
    tree.accept(methodInvocationFinder);
    return methodInvocationFinder.found;
  }

  private static class MethodInvocationFinder extends BaseTreeVisitor {

    boolean found = false;

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      found = true;
    }
  }

}
"
S2183,BUG,Ints and longs should not be shifted by zero or more than their number of bits-1,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.ArrayAccessExpressionTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import javax.annotation.CheckForNull;
import javax.annotation.Nullable;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@Rule(key = ""S2183"")
public class ShiftOnIntOrLongCheck extends IssuableSubscriptionVisitor {

  private List<Tree> shiftTrees = new ArrayList<>();

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Kind.LEFT_SHIFT, Kind.LEFT_SHIFT_ASSIGNMENT, Kind.RIGHT_SHIFT, Kind.RIGHT_SHIFT_ASSIGNMENT);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    shiftTrees.clear();
    super.setContext(context);
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    for (int i = 0; i < shiftTrees.size(); i++) {
      checkShiftTree(shiftTrees.get(i), i);
    }
  }

  @Override
  public void visitNode(Tree tree) {
    shiftTrees.add(tree);
  }

  private void checkShiftTree(Tree tree, int treeIndex) {
    String identifier;
    ExpressionTree shift;
    SyntaxToken operatorToken;

    if (tree.is(Kind.LEFT_SHIFT, Kind.RIGHT_SHIFT)) {
      BinaryExpressionTree binaryExpressionTree = (BinaryExpressionTree) tree;
      if (isZeroMaskShift(binaryExpressionTree)) {
        // No issue should be reported for ""1 << 0"" or ""1 >> 0""
        return;
      }
      identifier = getIdentifierName(binaryExpressionTree.leftOperand());
      shift = binaryExpressionTree.rightOperand();
      operatorToken = binaryExpressionTree.operatorToken();
    } else {
      AssignmentExpressionTree assignmentExpressionTree = (AssignmentExpressionTree) tree;
      identifier = getIdentifierName(assignmentExpressionTree.variable());
      shift = assignmentExpressionTree.expression();
      operatorToken = assignmentExpressionTree.operatorToken();
    }

    checkShift((ExpressionTree) tree, shift, identifier, operatorToken, treeIndex);
  }

  private void checkShift(ExpressionTree tree, ExpressionTree shift, @Nullable String identifier, SyntaxToken operatorToken,
                          int treeIndex) {
    Long literalValue = LiteralUtils.longLiteralValue(shift);
    if (literalValue != null) {
      int numericalBase = getNumericalBase(tree);
      long reducedNumberBits = literalValue % numericalBase;
      if (isInvalidShift(reducedNumberBits, literalValue, numericalBase, operatorToken, treeIndex)) {
        reportIssue(operatorToken, getMessage(reducedNumberBits, numericalBase, identifier));
      }
    }
  }

  private boolean isInvalidShift(long reducedNumberBits, long numberBits, int base, SyntaxToken operatorToken, int treeIndex) {
    return (reducedNumberBits == 0L && !aligned(operatorToken, treeIndex)) || tooManyBits(numberBits, base);
  }

  private boolean aligned(SyntaxToken operatorToken, int treeIndex) {
    return (treeIndex > 0 && isAlignedWith(operatorToken, shiftTrees.get(treeIndex - 1)))
      || (treeIndex + 1 < shiftTrees.size() && isAlignedWith(operatorToken, shiftTrees.get(treeIndex + 1)));
  }

  private static boolean isAlignedWith(SyntaxToken operatorToken, Tree other) {
    SyntaxToken otherOperator = operatorToken(other);
    return otherOperator.text().equals(operatorToken.text())
      && Position.startOf(operatorToken).column() == Position.startOf(otherOperator).column()
      // less than 2 lines distance
      && Math.abs(LineUtils.startLine(operatorToken) - LineUtils.startLine(otherOperator)) < 2;
  }

  private static SyntaxToken operatorToken(Tree tree) {
    if (tree instanceof BinaryExpressionTree binaryExpressionTree) {
      return binaryExpressionTree.operatorToken();
    }
    return ((AssignmentExpressionTree) tree).operatorToken();
  }

  private static boolean isZeroMaskShift(BinaryExpressionTree binaryExpressionTree) {
    return isLiteralValue(binaryExpressionTree.leftOperand(), 1L) && isLiteralValue(binaryExpressionTree.rightOperand(), 0L);
  }

  private static boolean isLiteralValue(ExpressionTree tree, long value) {
    Long evaluatedValue = LiteralUtils.longLiteralValue(tree);
    return evaluatedValue != null && evaluatedValue == value;
  }

  private static String getMessage(long reducedNumberBits, int base, @Nullable String identifier) {
    if (reducedNumberBits == 0L) {
      return ""Remove this useless shift"";
    } else if (base == 32) {
      return MessageFormat.format(
        identifier == null ?
          ""Either use a \""long\"" or correct this shift to {0}"" :
          ""Either make \""{1}\"" a \""long\"" or correct this shift to {0}"",
        reducedNumberBits, identifier);
    } else {
      return MessageFormat.format(""Correct this shift to {0}"", reducedNumberBits);
    }
  }

  private static int getNumericalBase(ExpressionTree tree) {
    if (tree.symbolType().is(""int"")) {
      return 32;
    }
    return 64;
  }

  private static boolean tooManyBits(long numberBits, int base) {
    return Math.abs(numberBits) >= base;
  }

  @CheckForNull
  private static String getIdentifierName(ExpressionTree tree) {
    if (tree.is(Kind.ARRAY_ACCESS_EXPRESSION)) {
      return getIdentifierName(((ArrayAccessExpressionTree) tree).expression());
    } else if (tree.is(Kind.IDENTIFIER)) {
      return ((IdentifierTree) tree).name();
    }
    return null;
  }
}
"
S2184,BUG,Math operands should be cast before assignment,"package org.sonar.java.checks;

import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2184"")
public class CastArithmeticOperandCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final Map<Tree.Kind, String> OPERATION_BY_KIND = MapBuilder.<Tree.Kind, String>newMap()
    .put(Tree.Kind.PLUS, ""addition"")
    .put(Tree.Kind.MINUS, ""subtraction"")
    .put(Tree.Kind.MULTIPLY, ""multiplication"")
    .put(Tree.Kind.DIVIDE, ""division"")
    .build();
  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    if(context.getSemanticModel() != null) {
      scan(context.getTree());
    }
  }

  @Override
  public void visitAssignmentExpression(AssignmentExpressionTree aet) {
    if(aet.is(Tree.Kind.ASSIGNMENT)) {
      Type varType = aet.symbolType();
      ExpressionTree expr = aet.expression();
      checkExpression(varType, expr);
    }
    super.visitAssignmentExpression(aet);
  }

  @Override
  public void visitVariable(VariableTree tree) {
    Type varType = tree.type().symbolType();
    checkExpression(varType, tree.initializer());
    super.visitVariable(tree);
  }

  @Override
  public void visitMethodInvocation(MethodInvocationTree tree) {
    checkMethodInvocationArgument(tree.arguments(), tree.methodSymbol());
    super.visitMethodInvocation(tree);
  }

  @Override
  public void visitMethod(MethodTree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      checkMethodTree(tree);
    }
    super.visitMethod(tree);
  }

  @Override
  public void visitBinaryExpression(BinaryExpressionTree tree) {
    boolean continueVisit = true;
    if (tree.is(Tree.Kind.DIVIDE) && isIntOrLong(tree.symbolType())) {
      continueVisit = checkIntegerDivisionInsideFloatingPointExpression(tree);
    }
    if (continueVisit) {
      super.visitBinaryExpression(tree);
    }
  }

  @Override
  public void visitNewClass(NewClassTree tree) {
    checkMethodInvocationArgument(tree.arguments(), tree.methodSymbol());
    super.visitNewClass(tree);
  }

  private void checkMethodTree(MethodTree methodTree) {
    TypeTree returnTypeTree = methodTree.returnType();
    Type returnType = returnTypeTree != null ? returnTypeTree.symbolType() : null;
    if (returnType != null && isVarTypeErrorProne(returnType)) {
      methodTree.accept(new ReturnStatementVisitor(returnType));
    }
  }

  private void checkMethodInvocationArgument(Arguments arguments, Symbol.MethodSymbol symbol) {
    if (!symbol.isUnknown()) {
      List<Type> parametersTypes = symbol.parameterTypes();
      if (arguments.size() == parametersTypes.size()) {
        int i = 0;
        for (Type argType : parametersTypes) {
          checkExpression(argType, arguments.get(i));
          i++;
        }
      }
    }
  }

  private void checkExpression(Type varType, @Nullable ExpressionTree expr) {
    if (isVarTypeErrorProne(varType) && expr != null && expressionIsOperationToIntOrLong(expr)) {
      BinaryExpressionTree binaryExpressionTree = (BinaryExpressionTree) expr;
      if(binaryExpressionTree.is(Tree.Kind.DIVIDE) && varType.isPrimitive(Type.Primitives.LONG)) {
        // widening the result of an int division is harmless
        return;
      }
      if (varType.isPrimitive(Type.Primitives.LONG) && expr.symbolType().isPrimitive(Type.Primitives.LONG)) {
        return;
      }
      context.reportIssue(this,
        binaryExpressionTree.operatorToken(), ""Cast one of the operands of this "" + OPERATION_BY_KIND.get(expr.kind()) + "" operation to a \"""" + varType.name() + ""\""."");
    }
  }

  private static boolean expressionIsOperationToIntOrLong(ExpressionTree expr) {
    return expr.is(Tree.Kind.MULTIPLY, Tree.Kind.DIVIDE, Tree.Kind.PLUS, Tree.Kind.MINUS) && isIntOrLong(expr.symbolType());
  }

  private static boolean isIntOrLong(Type exprType) {
    return exprType.isPrimitive(Type.Primitives.INT) || exprType.isPrimitive(Type.Primitives.LONG);
  }

  private static boolean isVarTypeErrorProne(Type varType) {
    return varType.isPrimitive(Type.Primitives.LONG) || varType.isPrimitive(Type.Primitives.FLOAT) || varType.isPrimitive(Type.Primitives.DOUBLE);
  }

  private class ReturnStatementVisitor extends BaseTreeVisitor {
    private Type returnType;

    public ReturnStatementVisitor(Type returnType) {
      this.returnType = returnType;
    }

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      checkExpression(returnType, tree.expression());
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // skip lambdas
    }

    @Override
    public void visitClass(ClassTree tree) {
      // skip inner classes
    }
  }

  private boolean checkIntegerDivisionInsideFloatingPointExpression(BinaryExpressionTree integerDivision) {
    Tree parent = integerDivision.parent();
    while (parent instanceof ExpressionTree expressionTree) {
      if (isFloatingPoint(expressionTree.symbolType())) {
        context.reportIssue(this, integerDivision, ""Cast one of the operands of this integer division to a \""double\""."");
        return false;
      }
      parent = expressionTree.parent();
    }
    return true;
  }

  private static boolean isFloatingPoint(Type exprType) {
    return exprType.isPrimitive(Type.Primitives.DOUBLE) || exprType.isPrimitive(Type.Primitives.FLOAT);
  }
}
"
S2185,CODE_SMELL,Do not perform unnecessary mathematical operations,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;

@Rule(key = ""S2185"")
public class ConstantMathCheck extends IssuableSubscriptionVisitor {

  private static final String ABS = ""abs"";
  private static final String CEIL = ""ceil"";
  private static final String DOUBLE = ""double"";
  private static final String FLOAT = ""float"";
  private static final String FLOOR = ""floor"";
  private static final String MATH_PACKAGE_NAME = ""java.lang.Math"";
  private static final String ROUND = ""round"";

  private static final MethodMatchers CONSTANT_WITH_LITERAL_METHODS =
    MethodMatchers.create().ofTypes(MATH_PACKAGE_NAME).names(ABS)
      .addParametersMatcher(DOUBLE)
      .addParametersMatcher(FLOAT)
      .addParametersMatcher(""int"")
      .addParametersMatcher(""long"")
      .build();

  private static final MethodMatchers TRUNCATION_METHODS = MethodMatchers.or(
    MethodMatchers.create().ofTypes(MATH_PACKAGE_NAME).names(CEIL).addParametersMatcher(DOUBLE).addParametersMatcher(FLOAT).build(),
    MethodMatchers.create().ofTypes(MATH_PACKAGE_NAME).names(FLOOR).addParametersMatcher(DOUBLE).addParametersMatcher(FLOAT).build(),
    MethodMatchers.create().ofTypes(MATH_PACKAGE_NAME).names(""rint"").addParametersMatcher(DOUBLE).build(),
    MethodMatchers.create().ofTypes(MATH_PACKAGE_NAME).names(ROUND).addParametersMatcher(DOUBLE).addParametersMatcher(FLOAT).build()
  );

  private static final MethodMatchers CONSTANT_WITH_ZERO_METHODS = MethodMatchers.or(
    MethodMatchers.create().ofTypes(MATH_PACKAGE_NAME).names(""atan2"").addParametersMatcher(DOUBLE, DOUBLE).build(),
    MethodMatchers.create().ofTypes(MATH_PACKAGE_NAME).names(""cos"", ""cosh"", ""expm1"", ""sin"", ""sinh"", ""tan"", ""tanh"", ""toRadians"").addParametersMatcher(DOUBLE).build()
  );

  private static final MethodMatchers CONSTANT_WITH_ZERO_OR_ONE_METHODS =
    MethodMatchers.create().ofTypes(MATH_PACKAGE_NAME).names(""acos"", ""asin"", ""atan"", ""cbrt"", ""exp"", ""log"", ""log10"", ""sqrt"", ""toDegrees"").addParametersMatcher(DOUBLE).build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.REMAINDER, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.REMAINDER)) {
      BinaryExpressionTree remainderTree = (BinaryExpressionTree) tree;
      if (isIntegralOne(remainderTree.rightOperand()) && isIntOrLong(remainderTree.leftOperand())) {
        reportIssue(remainderTree.operatorToken(), ""Remove this computation of % 1, which always evaluates to zero."");
      }
    } else {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      if (isConstantWithLiteral(mit) || isTruncation(mit) || isConstantWithZero(mit) || isConstantWithZeroOrOne(mit)) {
        reportIssue(mit.methodSelect(), String.format(""Remove this unnecessary call to \""Math.%s\"""", mit.methodSymbol().name()));
      }
    }
  }

  private static boolean isIntOrLong(ExpressionTree expression) {
    Type type = expression.symbolType();
    return isIntegral(type) || (type.isPrimitiveWrapper() && isIntegral(type.primitiveType()));
  }

  private static boolean isTruncation(MethodInvocationTree methodTree) {
    return TRUNCATION_METHODS.matches(methodTree) && isCastFromIntegralToFloating(ExpressionUtils.skipParentheses(methodTree.arguments().get(0)));
  }

  private static boolean isConstantWithLiteral(MethodInvocationTree methodTree) {
    return CONSTANT_WITH_LITERAL_METHODS.matches(methodTree) && isConstant(methodTree.arguments().get(0));
  }

  private static boolean isConstantWithZero(MethodInvocationTree methodTree) {
    return CONSTANT_WITH_ZERO_METHODS.matches(methodTree) && isFloatingZero(methodTree.arguments().get(0));
  }

  private static boolean isConstantWithZeroOrOne(MethodInvocationTree methodTree) {
    return CONSTANT_WITH_ZERO_OR_ONE_METHODS.matches(methodTree) && isFloatingZeroOrOne(methodTree.arguments().get(0));
  }

  private static boolean isCastFromIntegralToFloating(ExpressionTree tree) {
    Type resultType = tree.symbolType();
    // explicit cast
    if (tree.is(Tree.Kind.TYPE_CAST) && isIntegral(getInnerType(((TypeCastTree) tree).expression())) && (resultType.is(DOUBLE) || resultType.is(FLOAT))) {
      return true;
    }
    // implicit cast
    return isIntegral(resultType);
  }

  private static boolean isConstant(ExpressionTree tree) {
    return getInnerExpression(tree).is(Tree.Kind.CHAR_LITERAL, Tree.Kind.DOUBLE_LITERAL, Tree.Kind.FLOAT_LITERAL, Tree.Kind.INT_LITERAL, Tree.Kind.LONG_LITERAL);
  }

  private static boolean isIntegral(Type type) {
    return type.isPrimitive() && !type.is(DOUBLE) && !type.is(FLOAT);
  }

  private static boolean isIntegralOne(ExpressionTree tree) {
    Long value = LiteralUtils.longLiteralValue(tree);
    return value != null && value == 1;
  }

  private static ExpressionTree getInnerExpression(ExpressionTree tree) {
    ExpressionTree result = ExpressionUtils.skipParentheses(tree);
    while (result.is(Tree.Kind.TYPE_CAST)) {
      result = ExpressionUtils.skipParentheses(((TypeCastTree) result).expression());
    }
    return result;
  }

  private static Type getInnerType(ExpressionTree tree) {
    return getInnerExpression(tree).symbolType();
  }

  private static boolean isFloatingZero(ExpressionTree tree) {
    Integer value = getFloatingZeroOrOne(tree);
    return value != null && value == 0;
  }

  private static boolean isFloatingZeroOrOne(ExpressionTree tree) {
    return getFloatingZeroOrOne(tree) != null;
  }

  @CheckForNull
  private static Integer getFloatingZeroOrOne(ExpressionTree tree) {
    ExpressionTree expressionTree = ExpressionUtils.skipParentheses(tree);
    if (expressionTree.is(Tree.Kind.DOUBLE_LITERAL, Tree.Kind.FLOAT_LITERAL)) {
      String value = ((LiteralTree) expressionTree).value();
      if (""0.0"".equals(value) || ""0.0d"".equalsIgnoreCase(value) || ""0.0f"".equalsIgnoreCase(value)) {
        return 0;
      } else if (""1.0"".equals(value) || ""1.0d"".equalsIgnoreCase(value) || ""1.0f"".equalsIgnoreCase(value)) {
        return 1;
      }
    }
    return null;
  }

}
"
S2186,CODE_SMELL,"JUnit assertions should not be used in ""run"" methods","package org.sonar.java.checks.tests;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.UnitTestUtils.COMMON_ASSERTION_MATCHER;

@Rule(key = ""S2186"")
public class AssertionInThreadRunCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    BlockTree block = methodTree.block();
    if (block != null && isRunMethod(methodTree)) {
      block.accept(new AssertionsVisitor());
    }
  }

  private static boolean isRunMethod(MethodTree methodTree) {
    return methodTree.symbol().owner().type().isSubtypeOf(""java.lang.Runnable"") && ""run"".equals(methodTree.simpleName().name()) && methodTree.parameters().isEmpty();
  }

  private class AssertionsVisitor extends BaseTreeVisitor {
    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (COMMON_ASSERTION_MATCHER.matches(tree)) {
        reportIssue(ExpressionUtils.methodName(tree), ""Remove this assertion."");
      }
      super.visitMethodInvocation(tree);
    }
  }
}
"
S2187,CODE_SMELL,TestCases should contain tests,"package org.sonar.java.checks.tests;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2187"")
public class NoTestInTestClassCheck extends IssuableSubscriptionVisitor {

  public static final String ARCH_UNIT_RUNNER = ""ArchUnitRunner"";
  public static final String ARCH_UNIT_ANALYZE_CLASSES = ""com.tngtech.archunit.junit.AnalyzeClasses"";
  public static final String ARCH_UNIT_TEST = ""com.tngtech.archunit.junit.ArchTest"";

  private static final List<String> PACT_UNIT_TEST = Arrays.asList(""au.com.dius.pact.provider.junit.State"", ""au.com.dius.pact.provider.junitsupport.State"");

  private final Set<String> testMethodAnnotations = new HashSet<>();
  private final Set<String> testFieldAnnotations = new HashSet<>();
  private final Set<String> seenAnnotations = new HashSet<>();

  private static final String DEFAULT_TEST_CLASS_NAME_PATTERN = "".*(Test|Tests|TestCase)"";

  @RuleProperty(key = ""TestClassNamePattern"",
    description = ""Test class name pattern (regular expression)"",
    defaultValue = """" + DEFAULT_TEST_CLASS_NAME_PATTERN)
  public String testClassNamePattern = DEFAULT_TEST_CLASS_NAME_PATTERN;
  private Pattern testClassNamePatternRegEx;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.COMPILATION_UNIT);
  }

  @Override
  public void visitNode(Tree tree) {
    resetAnnotationCache();
    CompilationUnitTree cut = (CompilationUnitTree) tree;
    cut.types().stream()
      .filter(typeTree -> typeTree.is(Tree.Kind.CLASS))
      .forEach(typeTree -> checkClass((ClassTree) typeTree));
  }

  private void resetAnnotationCache() {
    Arrays.asList(testFieldAnnotations, testMethodAnnotations, seenAnnotations).forEach(Set::clear);
    testMethodAnnotations.addAll(Arrays.asList(""org.junit.Test"", ""org.testng.annotations.Test"", ""org.junit.jupiter.api.Test""));
  }

  private void checkClass(ClassTree classTree) {
    if (!ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.ABSTRACT)) {
      Symbol.TypeSymbol classSymbol = classTree.symbol();
      Stream<Symbol> members = getAllMembers(classSymbol, checkRunWith(classSymbol, ""Enclosed""));
      IdentifierTree simpleName = classTree.simpleName();
      if (classSymbol.metadata().isAnnotatedWith(""org.testng.annotations.Test"")) {
        checkTestNGmembers(simpleName, members);
      } else {
        boolean isJunit3TestClass = classSymbol.type().isSubtypeOf(""junit.framework.TestCase"");
        List<Symbol> membersList = members.toList();
        if (isJunit3TestClass && containsJUnit3Tests(membersList)) {
          return;
        }
        if (isJunit3TestClass || isTestClassName(classSymbol.name())) {
          checkJunit4AndAboveTestClass(simpleName, classSymbol, membersList);
        }
      }
    }
  }

  private boolean isTestClassName(String className) {
    if (StringUtils.isEmpty(testClassNamePattern)) {
      return false;
    }
    if (testClassNamePatternRegEx == null) {
      testClassNamePatternRegEx = Pattern.compile(testClassNamePattern);
    }
    return testClassNamePatternRegEx.matcher(className).matches();
  }

  private static boolean isArchUnitTestClass(Symbol.TypeSymbol classSymbol) {
    return checkRunWith(classSymbol, ARCH_UNIT_RUNNER) ||
      classSymbol.metadata().isAnnotatedWith(ARCH_UNIT_ANALYZE_CLASSES);
  }

  private void checkTestNGmembers(IdentifierTree className, Stream<Symbol> members) {
    if (members.noneMatch(member -> member.isMethodSymbol() && member.isPublic() && !member.isStatic() && !""<init>"".equals(member.name()))) {
      reportClass(className);
    }
  }

  private static boolean containsJUnit3Tests(List<Symbol> members) {
    return members.stream().anyMatch(m -> m.isMethodSymbol() && m.name().startsWith(""test""));
  }

  private void checkJunit4AndAboveTestClass(IdentifierTree className, Symbol.TypeSymbol symbol, List<Symbol> members) {
    addUsedAnnotations(symbol);
    if (!runWithCucumberOrSuiteOrTheoriesRunner(symbol)
      && members.stream().noneMatch(this::isTestFieldOrMethod)) {
      reportClass(className);
    }
  }

  private void addUsedAnnotations(Symbol.TypeSymbol classSymbol) {
    if (runWithZohhak(classSymbol)) {
      testMethodAnnotations.add(""com.googlecode.zohhak.api.TestWith"");
    } else if (isArchUnitTestClass(classSymbol)) {
      testMethodAnnotations.add(ARCH_UNIT_TEST);
      testFieldAnnotations.add(ARCH_UNIT_TEST);
    } else if (runWithPact(classSymbol)) {
      testMethodAnnotations.addAll(PACT_UNIT_TEST);
    }
  }

  private static boolean runWithCucumberOrSuiteOrTheoriesRunner(Symbol.TypeSymbol symbol) {
    return checkRunWith(symbol, ""Cucumber"", ""Suite"", ""Theories"");
  }

  private static boolean runWithZohhak(Symbol.TypeSymbol symbol) {
    return checkRunWith(symbol, ""ZohhakRunner"");
  }

  private static boolean runWithPact(Symbol.TypeSymbol symbol) {
    return checkRunWith(symbol, ""PactRunner"") || checkRunWith(symbol, ""RestPactRunner"");
  }

  private static boolean checkRunWith(Symbol.TypeSymbol symbol, String... runnerClasses) {
    List<SymbolMetadata.AnnotationValue> annotationValues = symbol.metadata().valuesForAnnotation(""org.junit.runner.RunWith"");
    if (annotationValues != null && annotationValues.size() == 1) {
      Object value = annotationValues.get(0).value();
      return value instanceof Symbol.TypeSymbol typeSymbol && checkRunWithType(typeSymbol, runnerClasses);
    }
    return false;
  }

  private static boolean checkRunWithType(Symbol.TypeSymbol value, String... runnerClasses) {
    for (String runnerClass : runnerClasses) {
      if (runnerClass.equals(value.name())) {
        return true;
      }
    }
    return false;
  }

  private boolean isTestFieldOrMethod(Symbol member) {
    return member.metadata().annotations().stream().anyMatch(input -> {
      Type type = input.symbol().type();
      return type.isUnknown() ||
        (member.isMethodSymbol() && isTestMethodAnnotation(type)) ||
        (member.isVariableSymbol() && testFieldAnnotations.contains(type.fullyQualifiedName()));
    });
  }

  private boolean isTestMethodAnnotation(Type type) {
    return testMethodAnnotations.contains(type.fullyQualifiedName()) || isJUnitTestableMetaAnnotated(type);
  }

  private boolean isJUnitTestableMetaAnnotated(Type type) {
    if (seenAnnotations.contains(type.fullyQualifiedName())) {
      return false;
    }
    seenAnnotations.add(type.fullyQualifiedName());
    SymbolMetadata metadata = type.symbol().metadata();
    if (metadata.isAnnotatedWith(""org.junit.platform.commons.annotation.Testable"")) {
      testMethodAnnotations.add(type.fullyQualifiedName());
      return true;
    }
    for (SymbolMetadata.AnnotationInstance annotation : metadata.annotations()) {
      if (isJUnitTestableMetaAnnotated(annotation.symbol().type())) {
        testMethodAnnotations.add(type.fullyQualifiedName());
        return true;
      }
    }
    return false;
  }

  private static Stream<Symbol> getAllMembers(Symbol.TypeSymbol symbol, boolean isEnclosed) {
    return getAllMembers(symbol, isEnclosed, new HashSet<>());
  }

  private static Stream<Symbol> getAllMembers(Symbol.TypeSymbol symbol, boolean isEnclosed, Set<Symbol> visitedSymbols) {
    if (!visitedSymbols.add(symbol) || symbol.type().is(""java.lang.Object"")) {
      return Stream.empty();
    }
    Stream<Symbol> members = Stream.empty();
    if (!isEnclosed) {
      members = symbol.memberSymbols().stream().filter(m -> m.isMethodSymbol() || m.isVariableSymbol());
    }
    Type superClass = symbol.superClass();
    if (superClass != null) {
      members = Stream.concat(members, getAllMembers(superClass.symbol(), isEnclosed, visitedSymbols));
    }
    Stream<Symbol> defaultMethodsFromInterfaces = symbol.interfaces().stream()
      .flatMap(i -> getAllMembers(i.symbol(), false, visitedSymbols))
      .filter(m -> m.isMethodSymbol() && ((Symbol.MethodSymbol) m).isDefaultMethod());
    members = Stream.concat(members, defaultMethodsFromInterfaces);
    for (Symbol s : symbol.memberSymbols()) {
      if (isNested(s) || isPublicStaticConcrete(s)) {
        members = Stream.concat(members, getAllMembers((Symbol.TypeSymbol) s, false, visitedSymbols));
      }
    }
    return members;
  }

  private static boolean isNested(Symbol s) {
    return s.isTypeSymbol() && s.metadata().isAnnotatedWith(""org.junit.jupiter.api.Nested"");
  }

  private static boolean isPublicStaticConcrete(Symbol s) {
    return isPublicStaticClass(s) && !s.isAbstract();
  }

  private static boolean isPublicStaticClass(Symbol symbol) {
    return symbol.isTypeSymbol() && symbol.isPublic() && symbol.isStatic();
  }

  private void reportClass(IdentifierTree className) {
    reportIssue(className, ""Add some tests to this class."");
  }
}
"
S2188,CODE_SMELL,JUnit test cases should call super methods,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2188"")
public class CallSuperInTestCaseCheck extends IssuableSubscriptionVisitor {

  public static final String JUNIT_FRAMEWORK_TEST_CASE = ""junit.framework.TestCase"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();
    boolean isMethodInJunit3 = isWithinJunit3TestCase(methodSymbol) && isSetUpOrTearDown(methodSymbol);
    if (isMethodInJunit3 && requiresSuperCall(methodSymbol) && !callSuperOnOverride(methodTree.block(), methodSymbol)) {
      reportIssue(methodTree.simpleName(), String.format(""Add a \""super.%s()\"" call to this method."", methodSymbol.name()));
    }
  }

  private static boolean requiresSuperCall(Symbol.MethodSymbol methodSymbol) {
    Type superType = methodSymbol.owner().type().symbol().superClass();
    Collection<Symbol> symbols = new ArrayList<>();
    while (superType != null && !superType.is(JUNIT_FRAMEWORK_TEST_CASE) && symbols.isEmpty()) {
      symbols = superType.symbol().lookupSymbols(methodSymbol.name());
      superType = superType.symbol().superClass();
    }
    return !symbols.isEmpty() && !symbols.iterator().next().owner().type().is(JUNIT_FRAMEWORK_TEST_CASE);
  }

  private static boolean callSuperOnOverride(@Nullable BlockTree block, Symbol.MethodSymbol methodSymbol) {
    if (block == null) {
      return false;
    }
    InvocationVisitor visitor = new InvocationVisitor(methodSymbol.name());
    block.accept(visitor);
    return visitor.superCallOnOverride;
  }

  private static boolean isWithinJunit3TestCase(Symbol.MethodSymbol methodSymbol) {
    Type type = methodSymbol.owner().type();
    return type.isSubtypeOf(JUNIT_FRAMEWORK_TEST_CASE) && !type.symbol().superClass().is(JUNIT_FRAMEWORK_TEST_CASE);
  }

  private static boolean isSetUpOrTearDown(Symbol.MethodSymbol methodSymbol) {
    return (""setUp"".equals(methodSymbol.name()) || ""tearDown"".equals(methodSymbol.name()))
      && methodSymbol.parameterTypes().isEmpty();
  }

  private static class InvocationVisitor extends BaseTreeVisitor {

    private final String methodName;
    private boolean superCallOnOverride = false;

    InvocationVisitor(String methodName) {
      this.methodName = methodName;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (tree.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree mse = (MemberSelectExpressionTree) tree.methodSelect();
        if (mse.expression().is(Tree.Kind.IDENTIFIER) && ""super"".equals(((IdentifierTree) mse.expression()).name()) && mse.identifier().name().equals(methodName)) {
          superCallOnOverride |= !((IdentifierTree) mse.expression()).symbol().type().is(JUNIT_FRAMEWORK_TEST_CASE);
        }
      }
      super.visitMethodInvocation(tree);
    }

  }
}
"
S2196,CODE_SMELL,"Switches should be used for sequences of simple ""String"" tests","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

@Rule(key = ""S2196"")
public class SwitchInsteadOfIfSequenceCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.IF_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    if(tree.parent().is(Tree.Kind.IF_STATEMENT)) {
      IfStatementTree parentIf = (IfStatementTree) tree.parent();
      if(tree.equals(parentIf.elseStatement())) {
        // don't double count nested ifs
        return;
      }
    }
    IfStatementTree ifStatementTree = (IfStatementTree) tree;
    int level = 1;
    while (ifStatementTree.elseKeyword() != null && ifStatementTree.elseStatement().is(Tree.Kind.IF_STATEMENT)) {
      level++;
      if(!sameEqualCondition(ifStatementTree.condition(), ((IfStatementTree) ifStatementTree.elseStatement()).condition())) {
        level = 0;
        break;
      }
      ifStatementTree = (IfStatementTree) ifStatementTree.elseStatement();
    }
    if(level > 2) {
      reportIssue(((IfStatementTree) tree).condition(), ""Convert this \""if/else if\"" structure into a \""switch\""."" + context.getJavaVersion().java7CompatibilityMessage());
    }

  }

  private static boolean sameEqualCondition(ExpressionTree firstIfCondition, ExpressionTree secondIfCondition) {
    Optional<EqualsOperands> equalsOperandsFirst = getEqualMethodInvocationOperands(firstIfCondition);
    Optional<EqualsOperands> equalsOperandsSecond = getEqualMethodInvocationOperands(secondIfCondition);
    return equalsOperandsFirst.isPresent()
    && equalsOperandsSecond.isPresent()
    && equalsOperandsFirst.get().identifier.symbol().equals(equalsOperandsSecond.get().identifier.symbol());
  }

  private static Optional<EqualsOperands> getEqualMethodInvocationOperands(ExpressionTree expressionTree) {
    ExpressionTree arg = null;
    ExpressionTree expression = null;
    if (expressionTree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) expressionTree;
      Symbol symbol = mit.methodSymbol();
      ExpressionTree methodSelect = mit.methodSelect();
      if (mit.arguments().size() == 1) {
        arg = mit.arguments().get(0);
        if (""equals"".equals(symbol.name()) && arg.symbolType().is(""java.lang.String"") && methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
          expression = ((MemberSelectExpressionTree) methodSelect).expression();
        }
      }
    } else if (expressionTree.is(Tree.Kind.EQUAL_TO)) {
      BinaryExpressionTree equalTo = (BinaryExpressionTree) expressionTree;
      arg = equalTo.leftOperand();
      expression = equalTo.rightOperand();
    }
    if (arg != null && expression != null) {
      if (arg.is(Tree.Kind.STRING_LITERAL, Tree.Kind.TEXT_BLOCK) && expression.is(Tree.Kind.IDENTIFIER)) {
        return Optional.of(new EqualsOperands((LiteralTree) arg, (IdentifierTree) expression));
      } else if (arg.is(Tree.Kind.IDENTIFIER) && expression.is(Tree.Kind.STRING_LITERAL, Tree.Kind.TEXT_BLOCK)) {
        return Optional.of(new EqualsOperands((LiteralTree) expression, (IdentifierTree) arg));
      }
    }
    return Optional.empty();
  }

  private static class EqualsOperands {
    LiteralTree literal;
    IdentifierTree identifier;

    EqualsOperands(LiteralTree literal, IdentifierTree identifier) {
      this.literal = literal;
      this.identifier = identifier;
    }
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava7Compatible();
  }
}
"
S2197,CODE_SMELL,Modulus results should not be checked for direct equality,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2197"")
public class ModulusEqualityCheck extends IssuableSubscriptionVisitor {

  private Set<Symbol> methodParams = new HashSet<>();

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    methodParams.clear();
  }

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.EQUAL_TO, Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.EQUAL_TO)) {
      BinaryExpressionTree equality = (BinaryExpressionTree) tree;
      checkModulusAndIntLiteral(equality.leftOperand(), equality.rightOperand());
      checkModulusAndIntLiteral(equality.rightOperand(), equality.leftOperand());
    } else {
      MethodTree methodTree = (MethodTree) tree;
      for (VariableTree variableTree : methodTree.parameters()) {
        methodParams.add(variableTree.symbol());
      }
    }
  }

  private void checkModulusAndIntLiteral(ExpressionTree operand1, ExpressionTree operand2) {
    if (operand1.is(Tree.Kind.REMAINDER)) {
      BinaryExpressionTree modulusExp = (BinaryExpressionTree) operand1;
      Integer intValue = LiteralUtils.intLiteralValue(operand2);
      ExpressionTree leftOperand = modulusExp.leftOperand();
      ExpressionTree rightOperand = modulusExp.rightOperand();
      boolean usesMethodParam = isMethodParameter(leftOperand) || isMethodParameter(rightOperand);
      boolean usesSize = isSizeAccessor(leftOperand) || isSizeAccessor(rightOperand);
      if (intValue != null && intValue != 0 && usesMethodParam && !usesSize) {
        String sign = intValue > 0 ? ""positive"" : ""negative"";
        reportIssue(modulusExp.operatorToken(), ""The results of this modulus operation may not be "" + sign + ""."");
      }
    }
  }

  private boolean isMethodParameter(ExpressionTree expressionTree) {
    if (expressionTree.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) expressionTree;
      Symbol symbol = identifier.symbol();
      return methodParams.contains(symbol);
    } else if (expressionTree.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree memberSelectExpressionTree = (MemberSelectExpressionTree) expressionTree;
      return isMethodParameter(memberSelectExpressionTree.expression());
    } else if (expressionTree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree methodInvocationTree = (MethodInvocationTree) expressionTree;
      return isMethodParameter(methodInvocationTree.methodSelect());
    }
    return false;
  }

  private static boolean isSizeAccessor(ExpressionTree expressionTree) {
    if (expressionTree.is(Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree memberSelectExpressionTree = (MemberSelectExpressionTree) expressionTree;
      Type type = memberSelectExpressionTree.expression().symbolType();
      String memberName = memberSelectExpressionTree.identifier().name();
      return isCollectionSize(type, memberName) || isStringLength(type, memberName) || isArrayLength(type, memberName);
    } else if (expressionTree.is(Kind.METHOD_INVOCATION)) {
      MethodInvocationTree methodInvocationTree = (MethodInvocationTree) expressionTree;
      return isSizeAccessor(methodInvocationTree.methodSelect());
    }
    return false;
  }

  private static boolean isArrayLength(Type type, String memberName) {
    return type.isArray() && ""length"".equals(memberName);
  }

  private static boolean isStringLength(Type type, String memberName) {
    return type.is(""java.lang.String"") && ""length"".equals(memberName);
  }

  private static boolean isCollectionSize(Type type, String memberName) {
    return type.isSubtypeOf(""java.util.Collection"") && ""size"".equals(memberName);
  }
}
"
S2200,BUG,"""compareTo"" results should not be checked for specific values","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.InternalJavaIssueBuilder;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S2200"")
public class CompareToResultTestCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers COMPARE_TO = MethodMatchers.create()
    .ofSubTypes(""java.lang.Comparable"")
    .names(""compareTo"")
    .addParametersMatcher(ANY)
    .build();

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO);
  }

  @Override
  public void visitNode(Tree tree) {
    BinaryExpressionTree binaryExpression = (BinaryExpressionTree) tree;
    ExpressionTree operand1 = ExpressionUtils.skipParentheses(binaryExpression.leftOperand());
    ExpressionTree operand2 = ExpressionUtils.skipParentheses(binaryExpression.rightOperand());
    if (isCompareToResult(operand1)) {
      checkCompareToOperand(binaryExpression, operand2, true);
    } else if (isCompareToResult(operand2)) {
      checkCompareToOperand(binaryExpression, operand1, false);
    }
  }

  public void checkCompareToOperand(BinaryExpressionTree binaryExpression, ExpressionTree operand, boolean compareToIsLeft) {
    Object resolvedOperandValue = ExpressionUtils.resolveAsConstant(operand);
    if (resolvedOperandValue instanceof Number number) {
      long operandValue = number.longValue();
      if (operandValue != 0) {
        reportIssue(binaryExpression, operandValue, compareToIsLeft);
      }
    }
  }

  private void reportIssue(BinaryExpressionTree binaryExpression, long operandValue, boolean compareToIsLeft) {
    InternalJavaIssueBuilder builder = QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(binaryExpression.operatorToken())
      .withMessage(""Only the sign of the result should be examined."");
    if (binaryExpression.is(Kind.EQUAL_TO)) {
      // For !=, even if we could in theory replace by <=/>= 0, we do not suggest quick fixes and let the user figure out what was his intent
      builder.withQuickFix(() -> getQuickFix(binaryExpression, operandValue, compareToIsLeft));
    }
    builder.report();
  }

  private static JavaQuickFix getQuickFix(BinaryExpressionTree binaryExpression, long operandValue, boolean compareToIsLeft) {
    AnalyzerMessage.TextSpan textSpan;
    String newComparison;

    SyntaxToken operatorToken = binaryExpression.operatorToken();
    if (compareToIsLeft) {
      newComparison = operandValue < 0 ? ""< 0"" : ""> 0"";
      textSpan = AnalyzerMessage.textSpanBetween(operatorToken, true, binaryExpression.rightOperand(), true);
    } else {
      newComparison = operandValue < 0 ? ""0 >"" : ""0 <"";
      textSpan = AnalyzerMessage.textSpanBetween(binaryExpression.leftOperand(), true, operatorToken, true);
    }

    return JavaQuickFix.newQuickFix(""Replace with \""%s\"""", newComparison)
      .addTextEdit(JavaTextEdit.replaceTextSpan(textSpan, newComparison))
      .build();
  }

  private static boolean isCompareToResult(ExpressionTree expression) {
    if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
      return COMPARE_TO.matches((MethodInvocationTree) expression);
    }
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      return isIdentifierContainingCompareToResult((IdentifierTree) expression);
    }
    return false;
  }

  private static boolean isIdentifierContainingCompareToResult(IdentifierTree identifier) {
    Symbol variableSymbol = identifier.symbol();
    if (!variableSymbol.isVariableSymbol()) {
      return false;
    }
    VariableTree variableDefinition = ((Symbol.VariableSymbol) variableSymbol).declaration();
    if (variableDefinition != null) {
      ExpressionTree initializer = variableDefinition.initializer();
      if (initializer != null && initializer.is(Tree.Kind.METHOD_INVOCATION) && variableSymbol.owner().isMethodSymbol()) {
        MethodTree method = ((Symbol.MethodSymbol) variableSymbol.owner()).declaration();
        return method != null && COMPARE_TO.matches((MethodInvocationTree) initializer) && !isReassigned(variableSymbol, method);
      }
    }
    return false;
  }

  private static boolean isReassigned(Symbol variableSymbol, Tree method) {
    Collection<IdentifierTree> usages = variableSymbol.usages();
    ReAssignmentFinder reAssignmentFinder = new ReAssignmentFinder(usages);
    method.accept(reAssignmentFinder);
    return reAssignmentFinder.foundReAssignment;
  }

  private static class ReAssignmentFinder extends BaseTreeVisitor {

    private final Collection<IdentifierTree> usages;
    private boolean foundReAssignment = false;

    public ReAssignmentFinder(Collection<IdentifierTree> usages) {
      this.usages = usages;
    }

    @Override
    public void visitUnaryExpression(UnaryExpressionTree unaryExp) {
      if (unaryExp.is(Tree.Kind.POSTFIX_INCREMENT, Tree.Kind.POSTFIX_DECREMENT, Tree.Kind.PREFIX_INCREMENT, Tree.Kind.PREFIX_DECREMENT)) {
        checkReAssignment(unaryExp.expression());
      }
      super.visitUnaryExpression(unaryExp);
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree assignmentExpression) {
      checkReAssignment(assignmentExpression.variable());
      super.visitAssignmentExpression(assignmentExpression);
    }

    private void checkReAssignment(ExpressionTree expression) {
      expression = ExpressionUtils.skipParentheses(expression);
      if (expression.is(Tree.Kind.IDENTIFIER)) {
        IdentifierTree identifier = (IdentifierTree) expression;
        if (usages.contains(identifier)) {
          foundReAssignment = true;
        }
      }
    }
  }

}
"
S2201,BUG,Return values from functions without side effects should not be ignored,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;

@Rule(key = ""S2201"")
public class IgnoredReturnValueCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String JAVA_UTIL_FUNCTION_SUPPLIER = ""java.util.function.Supplier"";
  private static final String JAVA_UTIL_STREAM_STREAM = ""java.util.stream.Stream"";
  private static final String COLLECT = ""collect"";
  private static final List<String> CHECKED_TYPES = Arrays.asList(
    JAVA_LANG_STRING,
    ""java.lang.Boolean"",
    ""java.lang.Integer"",
    ""java.lang.Double"",
    ""java.lang.Float"",
    ""java.lang.Byte"",
    ""java.lang.Character"",
    ""java.lang.Short"",
    ""java.lang.StackTraceElement"",
    ""java.time.DayOfWeek"",
    ""java.time.Duration"",
    ""java.time.Instant"",
    ""java.time.LocalDate"",
    ""java.time.LocalDateTime"",
    ""java.time.LocalTime"",
    ""java.time.Month"",
    ""java.time.MonthDay"",
    ""java.time.OffsetDateTime"",
    ""java.time.OffsetTime"",
    ""java.time.Period"",
    ""java.time.Year"",
    ""java.time.YearMonth"",
    ""java.time.ZonedDateTime"",
    ""java.math.BigInteger"",
    ""java.math.BigDecimal"",
    ""java.util.Optional"",
    ""com.google.common.base.Optional"");

  private static final List<String> EXCLUDED_PREFIX = Arrays.asList(""parse"", ""format"", ""decode"", ""valueOf"");

  private static final MethodMatchers EXCLUDED = MethodMatchers.or(
    MethodMatchers.create().ofTypes(""java.lang.Character"").names(""toChars"").addParametersMatcher(""int"", ""char[]"", ""int"").build(),
    MethodMatchers.create().ofTypes(JAVA_LANG_STRING).names(""intern"").addWithoutParametersMatcher().build());

  private static final MethodMatchers STRING_GET_BYTES = MethodMatchers.create()
    .ofTypes(JAVA_LANG_STRING).names(""getBytes"").addParametersMatcher(""java.nio.charset.Charset"").build();

  private static final MethodMatchers COLLECTION_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(""java.util.Collection"")
      .names(""size"", ""isEmpty"", ""contains"", ""containsAll"", ""iterator"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""java.util.Collection"")
      .names(""toArray"")
      .addWithoutParametersMatcher()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""java.util.Map"")
      .names(""get"", ""getOrDefault"", ""size"", ""isEmpty"", ""containsKey"", ""containsValue"", ""keySet"", ""entrySet"", ""values"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(JAVA_UTIL_STREAM_STREAM)
      .names(COLLECT, ""toArray"", ""reduce"", ""min"", ""max"", ""count"", ""anyMatch"", ""allMatch"", ""noneMatch"", ""findFirst"", ""findAny"", ""toList"")
      .withAnyParameters()
      .build());

  private static final MethodMatchers COLLECT_WITH_COLLECTOR = MethodMatchers.create()
    .ofSubTypes(JAVA_UTIL_STREAM_STREAM)
    .names(COLLECT)
    .addParametersMatcher(""java.util.stream.Collector"")
    .build();

  private static final MethodMatchers COLLECT_WITH_FUNCTIONS = MethodMatchers.create()
    .ofSubTypes(JAVA_UTIL_STREAM_STREAM)
    .names(COLLECT)
    .addParametersMatcher(JAVA_UTIL_FUNCTION_SUPPLIER, ""java.util.function.BiConsumer"", ""java.util.function.BiConsumer"")
    .build();

  private static final MethodMatchers TO_COLLECTION = MethodMatchers.create()
    .ofSubTypes(""java.util.stream.Collectors"")
    .names(""toCollection"")
    .addParametersMatcher(JAVA_UTIL_FUNCTION_SUPPLIER)
    .build();

  private static final MethodMatchers TO_MAP_WITH_SUPPLIER = MethodMatchers.create()
    .ofSubTypes(""java.util.stream.Collectors"")
    .names(""toMap"")
    .addParametersMatcher(""java.util.function.Function"", ""java.util.function.Function"", ""java.util.function.BinaryOperator"",
      JAVA_UTIL_FUNCTION_SUPPLIER)
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.EXPRESSION_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ExpressionTree expr = ((ExpressionStatementTree) tree).expression();
    if (expr.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) expr;
      if (isExcluded(mit)) {
        return;
      }
      if (shouldUseReturnValue(mit)) {
        IdentifierTree methodName = ExpressionUtils.methodName(mit);
        reportIssue(methodName, ""The return value of \"""" + methodName.name() + ""\"" must be used."");
      }
    }
  }

  private static boolean shouldUseReturnValue(MethodInvocationTree mit) {
    Symbol symbol = mit.methodSymbol();
    return !isVoidOrUnknown(mit.symbolType())
      && !isConstructor(symbol)
      && symbol.isPublic()
      && (isCheckedType(symbol.owner().type()) || COLLECTION_METHODS.matches(symbol));
  }

  private static boolean isExcluded(MethodInvocationTree mit) {
    String methodName = mit.methodSymbol().name();
    return mit.methodSymbol().isUnknown() || EXCLUDED.matches(mit) || mayBeCollectingIntoVariable(mit) ||
      (isInTryCatch(mit) && (EXCLUDED_PREFIX.stream().anyMatch(methodName::startsWith) || STRING_GET_BYTES.matches(mit)));
  }private static boolean mayBeCollectingIntoVariable(MethodInvocationTree mit) {
    if (COLLECT_WITH_FUNCTIONS.matches(mit)) {
      return !isConstructor(mit.arguments().get(0));
    }
    if (COLLECT_WITH_COLLECTOR.matches(mit)) {
      ExpressionTree arg = mit.arguments().get(0);
      if (!arg.is(Tree.Kind.METHOD_INVOCATION)) {
        return false;
      }
      MethodInvocationTree collector = (MethodInvocationTree) arg;
      if (TO_COLLECTION.matches(collector)) {
        return !isConstructor(collector.arguments().get(0));
      }
      if (TO_MAP_WITH_SUPPLIER.matches(collector)) {
        return !isConstructor(collector.arguments().get(3));
      }
    }
    return false;
  }

  private static boolean isConstructor(ExpressionTree tree) {
    if (tree.is(Tree.Kind.METHOD_REFERENCE)) {
      return ""new"".equals(((MethodReferenceTree) tree).method().name());
    }
    return (tree.is(Tree.Kind.LAMBDA_EXPRESSION))
      && ((LambdaExpressionTree) tree).body().is(Tree.Kind.NEW_CLASS, Tree.Kind.NEW_ARRAY);
  }

  private static boolean isInTryCatch(MethodInvocationTree mit) {
    Tree parent = mit.parent();
    while (parent != null && !parent.is(Tree.Kind.TRY_STATEMENT)) {
      parent = parent.parent();
    }
    return parent != null && !((TryStatementTree) parent).catches().isEmpty();
  }

  private static boolean isCheckedType(Type ownerType) {
    return CHECKED_TYPES.stream().anyMatch(ownerType::is);
  }

  private static boolean isVoidOrUnknown(Type methodType) {
    return methodType.isVoid() || methodType.isUnknown();
  }

  private static boolean isConstructor(Symbol methodSymbol) {
    return ""<init>"".equals(methodSymbol.name());
  }
}
"
S2203,CODE_SMELL,"""collect"" should be used with ""Streams"" instead of ""list::add""","package org.sonar.java.checks;

import java.util.List;
import java.util.Optional;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2203"")
public class CollectInsteadOfForeachCheck extends AbstractMethodDetection {

  private static final MethodMatchers FOREACH = MethodMatchers.create().ofTypes(""java.util.stream.Stream"").names(""forEach"").withAnyParameters().build();
  private static final MethodMatchers ADD = MethodMatchers.create().ofSubTypes(""java.util.List"").names(""add"").withAnyParameters().build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return FOREACH;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree firstArgument = mit.arguments().get(0);
    if (firstArgument.is(Tree.Kind.METHOD_REFERENCE)) {
      handleMethodReference((MethodReferenceTree) firstArgument);
    } else if (firstArgument.is(Tree.Kind.LAMBDA_EXPRESSION)) {
      handleLambdaExpression((LambdaExpressionTree) firstArgument);
    }
  }

  private void handleMethodReference(MethodReferenceTree methodRef) {
    Tree expression = methodRef.expression();
    if (ADD.matches(methodRef.method().symbol())) {
      checkExpression(methodRef, expression);
    }
  }

  private void handleLambdaExpression(LambdaExpressionTree lambda) {
    Tree expr = lambda.body();
    if (expr.is(Tree.Kind.BLOCK)) {
      expr = expressionFromSingleStatementBlock(((BlockTree) expr).body());
    }
    if (expr != null && expr.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) expr;
      if (ADD.matches(mit)) {
        ExpressionTree methodSelect = mit.methodSelect();
        if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
          checkExpression(lambda, ((MemberSelectExpressionTree) methodSelect).expression());
        }
      }
    }
  }

  @CheckForNull
  private static ExpressionTree expressionFromSingleStatementBlock(List<StatementTree> body) {
    if (body.size() == 1) {
      StatementTree singleStatement = body.get(0);
      if (singleStatement.is(Tree.Kind.EXPRESSION_STATEMENT)) {
        return ((ExpressionStatementTree) singleStatement).expression();
      }
    }
    return null;
  }

  private void checkExpression(Tree reportTree, Tree expression) {
    Optional<String> listName = Optional.empty();
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      listName = Optional.of(((IdentifierTree) expression).name());
    } else if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      listName = Optional.of(((MemberSelectExpressionTree) expression).identifier().name());
    }
    listName.ifPresent(list -> context.reportIssue(this, reportTree, getMessage(reportTree, list)));
  }

  private static String getMessage(Tree reportTree, String listName) {
    String msg;
    if (reportTree.is(Tree.Kind.METHOD_REFERENCE)) {
      msg = ""Use \""collect(Collectors.toList())\"" instead of \""forEach(%s::add)\""."";
    } else {
      msg = ""Use \""collect(Collectors.toList())\"" instead of adding elements in \""%s\"" using \""forEach(...)\""."";
    }
    return String.format(msg, listName);
  }

}
"
S2204,BUG,""".equals()"" should not be used to test the values of ""Atomic"" classes","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2204"")
public class EqualsOnAtomicClassCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.util.concurrent.atomic.AtomicBoolean"", ""java.util.concurrent.atomic.AtomicInteger"", ""java.util.concurrent.atomic.AtomicLong"")
      .names(""equals"")
      .addParametersMatcher(""java.lang.Object"")
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Use \"".get()\"" to retrieve the value and compare it instead."");
  }

}
"
S2208,CODE_SMELL,Wildcard imports should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ImportTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2208"")
public class WildcardImportsShouldNotBeUsedCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.IMPORT);
  }

  @Override
  public void visitNode(Tree tree) {
    ImportTree importTree = (ImportTree) tree;

    // See RSPEC-2208 : exception with static imports.
    if (fullQualifiedName(importTree.qualifiedIdentifier()).endsWith("".*"") && !importTree.isStatic()) {
      reportIssue(importTree.qualifiedIdentifier(), ""Explicitly import the specific classes needed."");
    }
  }

  private static String fullQualifiedName(Tree tree) {
    if (tree.is(Tree.Kind.IDENTIFIER)) {
      return ((IdentifierTree) tree).name();
    } else if (tree.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree m = (MemberSelectExpressionTree) tree;
      return fullQualifiedName(m.expression()) + ""."" + m.identifier().name();
    }
    throw new UnsupportedOperationException(String.format(""Kind/Class '%s' not supported"", tree.getClass()));
  }
}
"
S2209,CODE_SMELL,"""static"" members should be accessed statically","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2209"")
public class StaticMembersAccessCheck extends IssuableSubscriptionVisitor {

  private QuickFixHelper.ImportSupplier importSupplier;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.MEMBER_SELECT);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    super.setContext(context);
    importSupplier = null;
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    importSupplier = null;
  }

  @Override
  public void visitNode(Tree tree) {
    MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) tree;
    IdentifierTree memberSelectIdentifier = memberSelect.identifier();
    Symbol memberSelectSymbol = memberSelectIdentifier.symbol();
    if (memberSelectSymbol.isStatic()) {
      ExpressionTree leftOperand = memberSelect.expression();
      ExpressionTree selectExpression = leftOperand.is(Tree.Kind.MEMBER_SELECT)
        ? ((MemberSelectExpressionTree) leftOperand).identifier()
        : leftOperand;
      if (!selectExpression.is(Tree.Kind.IDENTIFIER) || ((IdentifierTree) selectExpression).symbol().isVariableSymbol()) {
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(leftOperand)
          .withMessage(""Change this instance-reference to a static reference."")
          .withQuickFix(() -> createQuickFixes(leftOperand, memberSelectSymbol.owner().type()))
          .report();
      }
    }
  }

  private JavaQuickFix createQuickFixes(ExpressionTree leftOperand, Type type) {
    String leftOperandAsText = leftOperand.is(Tree.Kind.IDENTIFIER)
      ? (""\"""" + ((IdentifierTree) leftOperand).name() + ""\"""")
      : ""the expression"";
    JavaQuickFix.Builder builder = JavaQuickFix.newQuickFix(String.format(""Replace %s by \""%s\"""", leftOperandAsText, type.name()))
      .addTextEdit(JavaTextEdit.replaceTree(leftOperand, type.name()));

    if (importSupplier == null) {
      importSupplier = QuickFixHelper.newImportSupplier(context);
    }
    importSupplier.newImportEdit(type.fullyQualifiedName())
      .ifPresent(builder::addTextEdit);

    return builder.build();
  }

}
"
S2211,CODE_SMELL,Types should be used in lambdas,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.ListUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2211"")
public class LambdaTypeParameterCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.LAMBDA_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    LambdaExpressionTree lambdaExpressionTree = (LambdaExpressionTree) tree;
    List<VariableTree> parameters = lambdaExpressionTree.parameters();
    if(parameters.size() <= 2 && !lambdaExpressionTree.body().is(Tree.Kind.BLOCK)) {
      // ignore lambdas with one or two params and a non-block body
      return;
    }
    String missingTypeParameters = parameters.stream()
      .filter(variable -> variable.type().is(Tree.Kind.INFERED_TYPE))
      .map(VariableTree::simpleName)
      .map(IdentifierTree::name)
      .map(parameterName -> ""'"" + parameterName + ""'"")
      .collect(Collectors.joining("", ""));

    if (!missingTypeParameters.isEmpty()) {
      reportIssue(parameters.get(0), ListUtils.getLast(parameters), String.format(""Specify a type for: %s"", missingTypeParameters));
    }
  }
}
"
S2221,CODE_SMELL,"""Exception"" should not be caught when not required by called methods","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.UnionTypeTree;

@Rule(key = ""S2221"")
public class CatchExceptionCheck extends IssuableSubscriptionVisitor {

  private final ThrowsExceptionVisitor throwsExceptionVisitor = new ThrowsExceptionVisitor();

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.TRY_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    TryStatementTree tryStatement = (TryStatementTree) tree;
    if (!tryStatement.resourceList().isEmpty()) {
      // classes implementing AutoCloseable interface implements 'close()' methods which throws Exception
      return;
    }
    for (CatchTree catchTree : tryStatement.catches()) {
      TypeTree catchType = catchTree.parameter().type();
      if (catchesException(catchType, tryStatement.block())) {
        reportIssue(catchType, ""Catch a list of specific exception subtypes instead."");
      }
    }
  }

  private boolean catchesException(TypeTree catchType, BlockTree block) {
    if (catchType.is(Kind.UNION_TYPE)) {
      UnionTypeTree unionTypeTree = (UnionTypeTree) catchType;
      for (TypeTree typeAlternative : unionTypeTree.typeAlternatives()) {
        if (catchesExceptionCheck(block, typeAlternative)) {
          return true;
        }
      }
    } else if (catchesExceptionCheck(block, catchType)) {
      return true;
    }
    return false;
  }

  private boolean catchesExceptionCheck(BlockTree block, TypeTree catchType) {
    return isJavaLangException(catchType.symbolType()) && !throwsExceptionVisitor.containsExplicitThrowsException(block);
  }

  private static boolean isJavaLangException(Type type) {
    return type.is(""java.lang.Exception"");
  }

  private static class ThrowsExceptionVisitor extends BaseTreeVisitor {
    private boolean containsExplicitThrowsException;

    boolean containsExplicitThrowsException(Tree tree) {
      containsExplicitThrowsException = false;
      tree.accept(this);
      return containsExplicitThrowsException;
    }

    @Override
    protected void scan(@Nullable Tree tree) {
      if(containsExplicitThrowsException) {
        return;
      }
      super.scan(tree);
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (isThrowingJavaLangException(tree.methodSymbol())) {
        return;
      }
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      if (isThrowingJavaLangException(tree.methodSymbol())) {
        return;
      }
      super.visitNewClass(tree);
    }

    private boolean isThrowingJavaLangException(Symbol.MethodSymbol symbol) {
      containsExplicitThrowsException |= symbol.isUnknown() || symbol.thrownTypes().stream().anyMatch(CatchExceptionCheck::isJavaLangException);
      return containsExplicitThrowsException;
    }
  }

}
"
S2225,BUG,"""toString()"" and ""clone()"" methods should not return null","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.reporting.InternalJavaIssueBuilder;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S2225"")
public class ToStringReturningNullCheck extends IssuableSubscriptionVisitor {

  private String interestingMethodName = null;

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.RETURN_STATEMENT);
  }
  
  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      interestingMethodName = interestingMethodName((MethodTree) tree);
    } else if (interestingMethodName != null) {
      ExpressionTree rawReturnExpression = ((ReturnStatementTree) tree).expression();
      ExpressionTree returnExpression = ExpressionUtils.skipParentheses(rawReturnExpression);
      if (returnExpression.is(Kind.NULL_LITERAL)) {
        boolean isToString = ""toString"".equals(interestingMethodName);
        InternalJavaIssueBuilder builder = QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(returnExpression)
          .withMessage(isToString ? ""Return empty string instead."" : ""Return a non null object."");
        if(isToString) {
          builder.withQuickFix(() -> computeQuickFix(rawReturnExpression));
        }
        builder.report();
      }
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      interestingMethodName = null;
    }
  }

  private static String interestingMethodName(MethodTree method) {
    String methodName = method.simpleName().name();
    if (method.parameters().isEmpty() && (""toString"".equals(methodName) || ""clone"".equals(methodName))) {
      return methodName;
    }
    return null;
  }

  private static JavaQuickFix computeQuickFix(ExpressionTree rawReturnExpression) {
    return JavaQuickFix
      .newQuickFix(""Replace null with an empty string"")
      .addTextEdit(JavaTextEdit.replaceTree(rawReturnExpression, ""\""\""""))
      .build();
  }

}
"
S2226,BUG,Servlets should not have mutable instance fields,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2226"")
public class ServletInstanceFieldCheck extends IssuableSubscriptionVisitor {

  private final List<VariableTree> issuableVariables = new ArrayList<>();
  private final List<VariableTree> excludedVariables = new ArrayList<>();

  private static final MethodMatchers INIT_METHOD_WITH_PARAM_MATCHER = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(""javax.servlet.Servlet"")
      .names(""init"").addParametersMatcher(""javax.servlet.ServletConfig"").build(),
    MethodMatchers.create()
      .ofSubTypes(""jakarta.servlet.Servlet"")
      .names(""init"").addParametersMatcher(""jakarta.servlet.ServletConfig"").build());

  private static final MethodMatchers INIT_METHOD_NO_PARAMS_MATCHER = MethodMatchers.create()
    .ofSubTypes(""javax.servlet.GenericServlet"", ""jakarta.servlet.GenericServlet"")
    .names(""init"").addWithoutParametersMatcher().build();

  private static final List<String> ANNOTATIONS_EXCLUDING_FIELDS = Arrays.asList(
    ""javax.inject.Inject"",
    ""jakarta.inject.Inject"",
    ""javax.ejb.EJB"",
    ""jakarta.ejb.EJB"",
    ""javax.annotation.Resource"",
    ""jakarta.annotation.Resource"");

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.VARIABLE, Kind.METHOD);
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    reportIssuesOnVariable();
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Kind.METHOD) && isServletInit((MethodTree) tree)) {
      tree.accept(new AssignmentVisitor());
    } else if (tree.is(Kind.VARIABLE)) {
      VariableTree variable = (VariableTree) tree;
      if (isOwnedByAServlet(variable) && !isExcluded(variable)) {
        issuableVariables.add(variable);
      }
    }
  }

  private static boolean isExcluded(VariableTree variable) {
    SymbolMetadata varMetadata = variable.symbol().metadata();
    return isStaticOrFinal(variable) || ANNOTATIONS_EXCLUDING_FIELDS.stream().anyMatch(varMetadata::isAnnotatedWith);
  }

  private static boolean isServletInit(MethodTree tree) {
    return INIT_METHOD_WITH_PARAM_MATCHER.matches(tree) || INIT_METHOD_NO_PARAMS_MATCHER.matches(tree);
  }

  private void reportIssuesOnVariable() {
    issuableVariables.removeAll(excludedVariables);
    for (VariableTree variable : issuableVariables) {
      reportIssue(variable.simpleName(), ""Remove this misleading mutable servlet instance field or make it \""static\"" and/or \""final\"""");
    }
    issuableVariables.clear();
    excludedVariables.clear();
  }

  private class AssignmentVisitor extends BaseTreeVisitor {
    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      if (tree.variable().is(Kind.IDENTIFIER)) {
        Tree declaration = ((IdentifierTree) tree.variable()).symbol().declaration();
        if (declaration != null && declaration.is(Kind.VARIABLE)) {
          excludedVariables.add((VariableTree) declaration);
        }
      }
    }
  }

  private static boolean isOwnedByAServlet(VariableTree variable) {
    Symbol owner = variable.symbol().owner();

    if (!owner.isTypeSymbol() || !variable.parent().is(Tree.Kind.CLASS)) {
      return false;
    }

    var ownerType = owner.type();
    return ownerType.isSubtypeOf(""javax.servlet.http.HttpServlet"")
      || ownerType.isSubtypeOf(""jakarta.servlet.http.HttpServlet"")
      || ownerType.isSubtypeOf(""org.apache.struts.action.Action"");
  }

  private static boolean isStaticOrFinal(VariableTree variable) {
    return ModifiersUtils.hasAnyOf(variable.modifiers(), Modifier.STATIC, Modifier.FINAL);
  }

}
"
S2229,BUG,"Methods should not call same-class methods with incompatible ""@Transactional"" values","package org.sonar.java.checks.spring;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.SymbolMetadata.AnnotationValue;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2229"")
public class SpringIncompatibleTransactionalCheck extends IssuableSubscriptionVisitor {

  private static final String SPRING_TRANSACTIONAL_ANNOTATION = ""org.springframework.transaction.annotation.Transactional"";
  private static final String JAVAX_TRANSACTIONAL_ANNOTATION = ""javax.transaction.Transactional"";

  private static final String MANDATORY = ""MANDATORY"";
  private static final String NESTED = ""NESTED"";
  private static final String NEVER = ""NEVER"";
  private static final String NOT_SUPPORTED = ""NOT_SUPPORTED"";
  private static final String REQUIRED = ""REQUIRED"";
  private static final String REQUIRES_NEW = ""REQUIRES_NEW"";
  private static final String SUPPORTS = ""SUPPORTS"";
  // Made name to represent no annotation
  private static final String NOT_TRANSACTIONAL = ""SONAR_NOT_TRANSACTIONAL"";

  private static final Map<String, Set<String>> INCOMPATIBLE_PROPAGATION_MAP = buildIncompatiblePropagationMap();

  private static Map<String, Set<String>> buildIncompatiblePropagationMap() {
    Map<String, Set<String>> map = new HashMap<>();
    map.put(NOT_TRANSACTIONAL, new HashSet<>(Arrays.asList(MANDATORY, NESTED, REQUIRED, REQUIRES_NEW)));
    map.put(MANDATORY, new HashSet<>(Arrays.asList(NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW)));
    map.put(NESTED, new HashSet<>(Arrays.asList(NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW)));
    map.put(NEVER, new HashSet<>(Arrays.asList(MANDATORY, NESTED, REQUIRED, REQUIRES_NEW)));
    map.put(NOT_SUPPORTED, new HashSet<>(Arrays.asList(MANDATORY, NESTED, REQUIRED, REQUIRES_NEW)));
    map.put(REQUIRED, new HashSet<>(Arrays.asList(NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW)));
    map.put(REQUIRES_NEW, new HashSet<>(Arrays.asList(NESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW)));
    map.put(SUPPORTS, new HashSet<>(Arrays.asList(MANDATORY, NESTED, NEVER, NOT_SUPPORTED, REQUIRED, REQUIRES_NEW)));
    return map;
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Map<Symbol, String> methodsPropagationMap = collectMethodsPropagation(classTree);
    if (hasSameValues(methodsPropagationMap.values())) {
      return;
    }
    methodsPropagationMap
      .forEach((symbol, propagation) -> checkMethodInvocations((MethodTree) symbol.declaration(), propagation, methodsPropagationMap));
  }

  private void checkMethodInvocations(MethodTree method, @Nullable String callerPropagation, Map<Symbol, String> methodsPropagationMap) {
    BlockTree methodBody = method.block();
    if (methodBody == null) {
      return;
    }
    methodBody.accept(new BaseTreeVisitor() {
      @Override
      public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
        super.visitMethodInvocation(methodInvocation);
        Symbol calleeMethodSymbol = methodInvocation.methodSymbol();
        if (calleeMethodSymbol.isUnknown()) {
          return;
        }
        if (methodsPropagationMap.containsKey(calleeMethodSymbol) && methodInvocationOnThisInstance(methodInvocation)) {
          String calleePropagation = methodsPropagationMap.get(calleeMethodSymbol);
          checkIncompatiblePropagation(methodInvocation, callerPropagation, calleeMethodSymbol, calleePropagation);
        }
      }
    });
  }

  private static boolean methodInvocationOnThisInstance(MethodInvocationTree methodInvocation) {
    if (methodInvocation.methodSymbol().isStatic()) {
      return false;
    }
    ExpressionTree expression = methodInvocation.methodSelect();
    if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      return ExpressionUtils.isThis(((MemberSelectExpressionTree) expression).expression());
    }
    return expression.is(Tree.Kind.IDENTIFIER);
  }

  private void checkIncompatiblePropagation(MethodInvocationTree methodInvocation, @Nullable String callerPropagation, Symbol calleeMethodSymbol, String calleePropagation) {
    Set<String> incompatiblePropagation = INCOMPATIBLE_PROPAGATION_MAP.getOrDefault(callerPropagation, Collections.emptySet());
    if (incompatiblePropagation.contains(calleePropagation)) {
      String message = ""\"""" + calleeMethodSymbol.name() + ""'s\"" @Transactional requirement is incompatible with the one for this method."";
      List<JavaFileScannerContext.Location> secondaryLocations = Collections.singletonList(
        new JavaFileScannerContext.Location(""Incompatible method definition."", ((MethodTree) calleeMethodSymbol.declaration()).simpleName()));
      reportIssue(ExpressionUtils.methodName(methodInvocation), message, secondaryLocations, null);
    }
  }

  private static Map<Symbol, String> collectMethodsPropagation(ClassTree classTree) {
    Map<Symbol, String> methodPropagationMap = new HashMap<>();
    // When the propagation of the class itself is unknown (incomplete semantic), we do nothing to avoid FP.
    getPropagationIfKnown(classTree.symbol(), NOT_TRANSACTIONAL).ifPresent(classPropagation -> {
      for (Tree member : classTree.members()) {
        if (member.is(Tree.Kind.METHOD)) {
          MethodTree method = (MethodTree) member;
          if (method.symbol().isPublic()) {
            getPropagationIfKnown(method.symbol(), classPropagation).ifPresent(propagation ->
              methodPropagationMap.put(method.symbol(), propagation)
            );
          }
        }
      }
    });
    return methodPropagationMap;
  }

  private static boolean hasSameValues(Collection<String> methodsPropagationList) {
    return methodsPropagationList.stream().distinct().count() <= 1;
  }private static Optional<String> getPropagationIfKnown(Symbol symbol, String inheritedPropagation) {
    String defaultValue = NOT_TRANSACTIONAL.equals(inheritedPropagation) ? REQUIRED : inheritedPropagation;
    Optional<String> propagation = Optional.of(inheritedPropagation);

    for (SymbolMetadata.AnnotationInstance annotationInstance : symbol.metadata().annotations()) {
      Symbol annotationSymbol = annotationInstance.symbol();
      Type annotationType = annotationSymbol.type();
      if (annotationSymbol.isUnknown()) {
        return Optional.empty();
      } else if (annotationType.is(SPRING_TRANSACTIONAL_ANNOTATION)) {
        propagation = getAnnotationAttributeAsString(annotationInstance.values(), ""propagation"", defaultValue);
      } else if (annotationType.is(JAVAX_TRANSACTIONAL_ANNOTATION)) {
        propagation = getAnnotationAttributeAsString(annotationInstance.values(), ""value"", defaultValue);
      }
    }
    return propagation;
  }

  private static Optional<String> getAnnotationAttributeAsString(List<AnnotationValue> values, String attributeName, String defaultValue) {
    for (AnnotationValue annotationValue : values) {
      if (attributeName.equals(annotationValue.name())) {
        Object value = annotationValue.value();
        if (value instanceof Symbol.VariableSymbol variableSymbol) {
          // expected values are constant from a Enum, translated into variable symbol
          return Optional.of(variableSymbol.name());
        } else {
          return Optional.empty();
        }
      }
    }
    return Optional.of(defaultValue);
  }

}
"
S2230,BUG,Methods with Spring proxying annotations should be public,"package org.sonar.java.checks.spring;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2230"")
public class TransactionalMethodVisibilityCheck extends IssuableSubscriptionVisitor {

  private static final List<String> proxyAnnotations = List.of(
    ""org.springframework.transaction.annotation.Transactional"",
    ""org.springframework.scheduling.annotation.Async"");

  private static final Map<String, String> annShortName = Map.of(
    ""org.springframework.transaction.annotation.Transactional"", ""@Transactional"",
    ""org.springframework.scheduling.annotation.Async"", ""@Async"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree method = (MethodTree) tree;
    if (!method.symbol().isPublic()) {
      proxyAnnotations.stream()
        .filter(annSymbol -> hasAnnotation(method, annSymbol))
        .forEach(annSymbol -> reportIssue(
          method.simpleName(),
          ""Make this method \""public\"" or remove the \"""" + annShortName.get(annSymbol) + ""\"" annotation.""));
    }
  }

  private static boolean hasAnnotation(MethodTree method, String annotationSymbol) {
    for (AnnotationTree annotation : method.modifiers().annotations()) {
      if (annotation.symbolType().is(annotationSymbol)) {
        return true;
      }
    }
    return false;
  }

}
"
S2232,CODE_SMELL,"""ResultSet.isLast()"" should not be used","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2232"")
public class ResultSetIsLastCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.sql.ResultSet"").names(""isLast"").addWithoutParametersMatcher().build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Remove this call to \""isLast()\""."");
  }
}
"
S2234,CODE_SMELL,Parameters should be passed in the correct order,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2234"")
public class MethodParametersOrderCheck extends IssuableSubscriptionVisitor {

  private Map<Symbol, ParametersList> parametersByMethod = new HashMap<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    parametersByMethod.clear();
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree methodInvTree = (MethodInvocationTree) tree;
    MethodTree methodDeclaration = methodInvTree.methodSymbol().declaration();
    if (methodDeclaration == null) {
      return;
    }
    ParametersList formalParameterList = parametersByMethod.computeIfAbsent(methodInvTree.methodSymbol(), m -> new ParametersList(methodDeclaration));
    List<IdentifierTree> argumentsList = methodInvTree.arguments().stream().map(this::argumentToIdentifier).toList();
    if (matchingNames(formalParameterList, argumentsList)) {
      List<VariableTree> matchingTypesWrongOrder = matchingTypesWrongOrder(formalParameterList, argumentsList);
      if (!matchingTypesWrongOrder.isEmpty()) {
        List<JavaFileScannerContext.Location> flow = matchingTypesWrongOrder.stream()
          .map(param -> new JavaFileScannerContext.Location(""Misplaced Parameter"", param))
          .toList();
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(methodInvTree.arguments())
          .withMessage(""Parameters to %s have the same names but not the same order as the method arguments."", methodInvTree.methodSymbol().name() )
          .withSecondaries(flow)
          .report();
      }
    }
  }

  private static boolean matchingNames(ParametersList formalParameters, List<IdentifierTree> argumentsList) {
    List<String> argListNames = argumentsList.stream().filter(Objects::nonNull).map(arg -> arg.name().toLowerCase(Locale.ENGLISH)).toList();
    return allUnique(argListNames)
      && argListNames.stream().allMatch(formalParameters::hasArgumentWithName);
  }

  public IdentifierTree argumentToIdentifier(ExpressionTree expr) {
    if (expr.is(Tree.Kind.IDENTIFIER)) {
      return (IdentifierTree) ExpressionUtils.skipParentheses(expr);
    } else if (expr.is(Tree.Kind.MEMBER_SELECT)) {
      return (IdentifierTree) ExpressionUtils.skipParentheses(((MemberSelectExpressionTree) expr).identifier());
    } else {
      return null;
    }
  }

  public static boolean allUnique(List<String> argListNames) {
    return argListNames.size() == new HashSet<>(argListNames).size();
  }

  private static List<VariableTree> matchingTypesWrongOrder(ParametersList formalParameterList, List<IdentifierTree> argumentList) {
    Iterator<IdentifierTree> argumentsIterator = argumentList.stream().filter(Objects::nonNull).iterator();
    List<VariableTree> misplacedParameters = new ArrayList<>();
    while (argumentsIterator.hasNext()) {
      IdentifierTree argument = argumentsIterator.next();
      int index = formalParameterList.indexOf(argument.name().toLowerCase(Locale.ENGLISH));
      Type formalType = formalParameterList.typeOfIndex(index);
      Type argType = argument.symbolType();
      if (!formalType.is(argType.fullyQualifiedName()) || formalType.isUnknown() || argType.isUnknown()) {
        return Collections.emptyList();
      }
      if (argumentList.indexOf(argument) != index) {
        misplacedParameters.add(formalParameterList.parameterAt(index));
      }
    }
    if (misplacedParameters.size() >= 2) {
      return misplacedParameters;
    }
    return Collections.emptyList();
  }

  private static class ParametersList {

    private List<String> parameterNames;
    private List<Type> parameterTypes;
    private List<VariableTree> parameters;

    public ParametersList(MethodTree methodTree) {
      parameterNames = new ArrayList<>();
      parameterTypes = new ArrayList<>();
      methodTree.parameters().stream().map(VariableTree::symbol).forEach(symbol -> {
        parameterNames.add(symbol.name().toLowerCase(Locale.ENGLISH));
        parameterTypes.add(symbol.type());
      });
      parameters = methodTree.parameters();
    }

    public boolean hasArgumentWithName(String argument) {
      return parameterNames.contains(argument);
    }

    public int indexOf(String argName) {
      return parameterNames.indexOf(argName);
    }

    public Type typeOfIndex(int index) {
      return parameterTypes.get(index);
    }

    public VariableTree parameterAt(int index) {
      return parameters.get(index);
    }
  }
}
"
S2235,CODE_SMELL,"""IllegalMonitorStateException"" should not be caught","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.UnionTypeTree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2235"")
public class CatchIllegalMonitorStateExceptionCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CATCH);
  }

  @Override
  public void visitNode(Tree tree) {
    CatchTree catchTree = (CatchTree) tree;
    TypeTree parameterTypeTree = catchTree.parameter().type();
    if (parameterTypeTree.is(Kind.UNION_TYPE)) {
      UnionTypeTree unionTypeTree = (UnionTypeTree) parameterTypeTree;
      for (TypeTree exceptionTypeTree : unionTypeTree.typeAlternatives()) {
        checkExceptionType(exceptionTypeTree);
      }
    } else {
      checkExceptionType(parameterTypeTree);
    }
  }

  private void checkExceptionType(TypeTree exceptionTypeTree) {
    if (exceptionTypeTree.symbolType().is(""java.lang.IllegalMonitorStateException"")) {
      reportIssue(exceptionTypeTree, ""Refactor this piece of code to not catch IllegalMonitorStateException"");
    }
  }

}
"
S2236,BUG,"Methods ""wait(...)"", ""notify()"" and ""notifyAll()"" should not be called on Thread instances","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2236"")
public class ThreadWaitCallCheck extends AbstractMethodDetection {

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Refactor the synchronisation mechanism to not use a Thread instance as a monitor"");
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofSubTypes(""java.lang.Thread"")
        .names(""wait"")
        .addParametersMatcher(""long"")
        .addParametersMatcher(""long"", ""int"")
        .build(),
      MethodMatchers.create()
        .ofSubTypes(""java.lang.Thread"")
        .names(""wait"", ""notify"", ""notifyAll"")
        .addWithoutParametersMatcher().build());
  }
}
"
S2245,SECURITY_HOTSPOT,Using pseudorandom number generators (PRNGs) is security-sensitive,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2245"")
public class PseudoRandomCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Make sure that using this pseudorandom number generator is safe here."";

  private static final MethodMatchers STATIC_RANDOM_METHODS = MethodMatchers.or(
    MethodMatchers.create().ofTypes(""java.lang.Math"").names(""random"").addWithoutParametersMatcher().build(),
    MethodMatchers.create()
      .ofSubTypes(""java.util.concurrent.ThreadLocalRandom"",
        ""org.apache.commons.lang.math.RandomUtils"",
        ""org.apache.commons.lang3.RandomUtils"",
        ""org.apache.commons.lang.RandomStringUtils"",
        ""org.apache.commons.lang3.RandomStringUtils"")
      .anyName()
      .withAnyParameters()
      .build()
  );

  private static final MethodMatchers RANDOM_STRING_UTILS_RANDOM_WITH_RANDOM_SOURCE = MethodMatchers.create()
    .ofSubTypes(""org.apache.commons.lang.RandomStringUtils"", ""org.apache.commons.lang3.RandomStringUtils"")
    .names(""random"")
    .addParametersMatcher(""int"", ""int"", ""int"", ""boolean"", ""boolean"", ""char[]"", ""java.util.Random"")
    .build();

  private static final Set<String> RANDOM_CONSTRUCTOR_TYPES = SetUtils.immutableSetOf(
    ""java.util.Random"",
    ""org.apache.commons.lang.math.JVMRandom""
  );

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.NEW_CLASS, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      IdentifierTree reportLocation = ExpressionUtils.methodName(mit);

      if (isStaticCallToInsecureRandomMethod(mit)) {
        reportIssue(reportLocation, MESSAGE);
      }
    } else {
      NewClassTree newClass = (NewClassTree) tree;
      if (RANDOM_CONSTRUCTOR_TYPES.contains(newClass.symbolType().fullyQualifiedName())) {
        reportIssue(newClass.identifier(), MESSAGE);
      }
    }
  }

  private static boolean isStaticCallToInsecureRandomMethod(MethodInvocationTree mit) {
    return STATIC_RANDOM_METHODS.matches(mit)
      && !RANDOM_STRING_UTILS_RANDOM_WITH_RANDOM_SOURCE.matches(mit)
      && mit.methodSymbol().isStatic();
  }

}
"
S2250,CODE_SMELL,Collection methods with O(n) performance should be used carefully,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S2250"")
public class CollectionMethodsWithLinearComplexityCheck extends IssuableSubscriptionVisitor {

  private static final String ARRAY_LIST = ""java.util.ArrayList"";
  private static final String LINKED_LIST = ""java.util.LinkedList"";
  private static final String COPY_ON_WRITE_ARRAY_LIST = ""java.util.concurrent.CopyOnWriteArrayList"";
  private static final String COPY_ON_WRITE_ARRAY_SET = ""java.util.concurrent.CopyOnWriteArraySet"";
  private static final String CONCURRENT_LINKED_QUEUE = ""java.util.concurrent.ConcurrentLinkedQueue"";
  private static final String CONCURRENT_LINKED_DEQUE = ""java.util.concurrent.ConcurrentLinkedDeque"";

  private static final MethodMatchers.NameBuilder COLLECTION_METHOD_MATCHER = MethodMatchers.create().ofSubTypes(""java.util.Collection"");

  private static final Map<MethodMatchers, Set<String>> matcherActualTypeMap;
  static {
    MapBuilder<MethodMatchers, Set<String>> builder = MapBuilder.newMap();

    MethodMatchers collectionContains = COLLECTION_METHOD_MATCHER.names(""contains"").addParametersMatcher(""java.lang.Object"").build();
    builder.put(collectionContains, SetUtils.immutableSetOf(
      ARRAY_LIST, LINKED_LIST, COPY_ON_WRITE_ARRAY_LIST, COPY_ON_WRITE_ARRAY_SET, CONCURRENT_LINKED_QUEUE, CONCURRENT_LINKED_DEQUE));

    MethodMatchers collectionSize = COLLECTION_METHOD_MATCHER.names(""size"").addWithoutParametersMatcher().build();
    builder.put(collectionSize, SetUtils.immutableSetOf(CONCURRENT_LINKED_QUEUE, CONCURRENT_LINKED_DEQUE));

    MethodMatchers collectionAdd = COLLECTION_METHOD_MATCHER.names(""add"").addParametersMatcher(ANY).build();
    builder.put(collectionAdd, SetUtils.immutableSetOf(COPY_ON_WRITE_ARRAY_SET, COPY_ON_WRITE_ARRAY_LIST));

    MethodMatchers collectionRemove = COLLECTION_METHOD_MATCHER.names(""remove"").addParametersMatcher(""java.lang.Object"").build();
    builder.put(collectionRemove, SetUtils.immutableSetOf(ARRAY_LIST, COPY_ON_WRITE_ARRAY_SET, COPY_ON_WRITE_ARRAY_LIST));

    MethodMatchers listGet = MethodMatchers.create().ofSubTypes(""java.util.List"").names(""get"").addParametersMatcher(""int"").build();
    builder.put(listGet, Collections.singleton(LINKED_LIST));
    matcherActualTypeMap = builder.build();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;
    matcherActualTypeMap.forEach((methodMatcher, actualTypes) -> {
      if (methodMatcher.matches(mit) && invocationInMethod(mit)) {
        Symbol target = invocationTarget(mit);
        if (target != null && isField(target) && matchesActualType(target, actualTypes)) {
          IdentifierTree methodName = ExpressionUtils.methodName(mit);
          reportIssue(methodName, ""This call to \"""" + methodName.name() + ""()\"" may be a performance hot spot if the collection is large."");
        }
      }
    });
  }

  private static boolean invocationInMethod(MethodInvocationTree mit) {
    Tree parent = mit.parent();
    while (parent != null && !parent.is(Tree.Kind.METHOD)) {
      parent = parent.parent();
    }
    return parent != null;
  }

  private static boolean isField(Symbol symbol) {
    return symbol.isVariableSymbol() && symbol.owner().isTypeSymbol() && !""this"".equals(symbol.name()) && !""super"".equals(symbol.name());
  }

  private static boolean matchesActualType(Symbol invocationTarget, Set<String> actualTypes) {
    Type declaredType = invocationTarget.type();
    if (actualTypes.contains(declaredType.fullyQualifiedName())) {
      return true;
    }
    // actual type is looked up only on private or final fields, otherwise it can't be guaranteed
    if (invocationTarget.isPrivate() || invocationTarget.isFinal()) {
      Set<String> assignedTypes = findAssignedTypes(invocationTarget);
      return !assignedTypes.isEmpty() && actualTypes.containsAll(assignedTypes);
    }
    return false;
  }

  @CheckForNull
  private static Symbol invocationTarget(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree methodSelectExpression = ((MemberSelectExpressionTree) methodSelect).expression();
      if (methodSelectExpression.is(Tree.Kind.IDENTIFIER)) {
        return ((IdentifierTree) methodSelectExpression).symbol();
      }
    }
    return null;
  }

  private static Set<String> findAssignedTypes(Symbol symbol) {
    Set<String> types = new HashSet<>();
    Tree declaration = symbol.declaration();
    if (declaration != null && declaration.is(Tree.Kind.VARIABLE)) {
      ExpressionTree initializer = ((VariableTree) declaration).initializer();
      if (initializer != null) {
        types.add(initializer.symbolType().fullyQualifiedName());
      }
    }
    symbol.usages().stream()
      .flatMap(CollectionMethodsWithLinearComplexityCheck::usageInAssignment)
      .map(assignment -> assignment.expression().symbolType().fullyQualifiedName())
      .forEach(types::add);
    return types;
  }

  private static Stream<AssignmentExpressionTree> usageInAssignment(IdentifierTree usage) {
    Tree prevParent = usage;
    Tree parent = usage.parent();
    while (parent != null && !parent.is(Tree.Kind.ASSIGNMENT) && parent.is(Tree.Kind.MEMBER_SELECT, Tree.Kind.IDENTIFIER)) {
      prevParent = parent;
      parent = parent.parent();
    }
    if (parent != null && parent.is(Tree.Kind.ASSIGNMENT)) {
      AssignmentExpressionTree assignment = (AssignmentExpressionTree) parent;
      if (assignment.variable().equals(prevParent)) {
        return Stream.of(assignment);
      }
    }
    return Stream.empty();
  }
}
"
S2251,BUG,"A ""for"" loop update clause should move the counter in the right direction","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2251"")
public class ForLoopIncrementSignCheck extends AbstractForLoopRule {

  @Override
  public void visitForStatement(ForStatementTree forStatement) {
    ExpressionTree condition = forStatement.condition();
    ForLoopIncrement loopIncrement = ForLoopIncrement.findInUpdates(forStatement);
    if (condition == null || loopIncrement == null || !loopIncrement.hasValue()) {
      return;
    }
    checkIncrementSign(condition, loopIncrement);
  }

  private void checkIncrementSign(ExpressionTree condition, ForLoopIncrement loopIncrement) {
    if (condition.is(Tree.Kind.GREATER_THAN, Tree.Kind.GREATER_THAN_OR_EQUAL_TO)) {
      BinaryExpressionTree binaryExp = (BinaryExpressionTree) condition;
      if (loopIncrement.hasSameIdentifier(binaryExp.leftOperand())) {
        checkNegativeIncrement(condition, loopIncrement);
      } else if (loopIncrement.hasSameIdentifier(binaryExp.rightOperand())) {
        checkPositiveIncrement(condition, loopIncrement);
      }
    } else if (condition.is(Tree.Kind.LESS_THAN, Tree.Kind.LESS_THAN_OR_EQUAL_TO)) {
      BinaryExpressionTree binaryExp = (BinaryExpressionTree) condition;
      if (loopIncrement.hasSameIdentifier(binaryExp.leftOperand())) {
        checkPositiveIncrement(condition, loopIncrement);
      } else if (loopIncrement.hasSameIdentifier(binaryExp.rightOperand())) {
        checkNegativeIncrement(condition, loopIncrement);
      }
    }
  }

  private void checkPositiveIncrement(Tree tree, ForLoopIncrement loopIncrement) {
    if (loopIncrement.value() < 0) {
      reportIssue(tree, String.format(""\""%s\"" is decremented and will never reach \""stop condition\""."", loopIncrement.identifier().name()));
    }
  }

  private void checkNegativeIncrement(Tree tree, ForLoopIncrement loopIncrement) {
    if (loopIncrement.value() > 0) {
      reportIssue(tree, String.format(""\""%s\"" is incremented and will never reach \""stop condition\""."", loopIncrement.identifier().name()));
    }
  }


}
"
S2252,BUG,Loop conditions should be true at least once,"package org.sonar.java.checks;

import javax.annotation.CheckForNull;
import org.apache.commons.lang3.BooleanUtils;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

@Rule(key = ""S2252"")
public class ForLoopFalseConditionCheck extends AbstractForLoopRule {

  @Override
  public void visitForStatement(ForStatementTree forStatement) {
    ExpressionTree condition = forStatement.condition();
    if (condition != null && (isAlwaysFalseCondition(condition) || isConditionFalseAtInitialization(forStatement))) {
      reportIssue(condition, ""This loop will never execute."");
    }
  }

  private static boolean isAlwaysFalseCondition(ExpressionTree expression) {
    if (expression.is(Tree.Kind.BOOLEAN_LITERAL)) {
      return BooleanUtils.isFalse(booleanLiteralValue(expression));
    }
    if (expression.is(Tree.Kind.LOGICAL_COMPLEMENT)) {
      ExpressionTree subExpression = ((UnaryExpressionTree) expression).expression();
      return BooleanUtils.isTrue(booleanLiteralValue(subExpression));
    }
    return false;
  }

  @CheckForNull
  private static Boolean booleanLiteralValue(ExpressionTree expression) {
    if (expression.is(Tree.Kind.BOOLEAN_LITERAL)) {
      return Boolean.valueOf(((LiteralTree) expression).value());
    }
    return null;
  }

  private static boolean isConditionFalseAtInitialization(ForStatementTree forStatement) {
    Iterable<ForLoopInitializer> initializers = ForLoopInitializer.list(forStatement);
    ExpressionTree condition = forStatement.condition();
    if (!condition.is(Tree.Kind.GREATER_THAN, Tree.Kind.GREATER_THAN_OR_EQUAL_TO, Tree.Kind.LESS_THAN, Tree.Kind.LESS_THAN_OR_EQUAL_TO)) {
      return false;
    }
    BinaryExpressionTree binaryCondition = (BinaryExpressionTree) condition;
    Integer leftOperand = eval(binaryCondition.leftOperand(), initializers);
    Integer rightOperand = eval(binaryCondition.rightOperand(), initializers);
    if (leftOperand != null && rightOperand != null) {
      return !evaluateCondition(condition, leftOperand, rightOperand);
    }
    return false;
  }

  private static boolean evaluateCondition(ExpressionTree condition, int leftOperand, int rightOperand) {
    boolean conditionValue;
    switch (condition.kind()) {
      case GREATER_THAN:
        conditionValue = leftOperand > rightOperand;
        break;
      case GREATER_THAN_OR_EQUAL_TO:
        conditionValue = leftOperand >= rightOperand;
        break;
      case LESS_THAN:
        conditionValue = leftOperand < rightOperand;
        break;
      case LESS_THAN_OR_EQUAL_TO:
        conditionValue = leftOperand <= rightOperand;
        break;
      default:
        conditionValue = true;
    }
    return conditionValue;
  }

  private static Integer eval(ExpressionTree expression, Iterable<ForLoopInitializer> initializers) {
    Object resolvedConstant = ExpressionUtils.resolveAsConstant(expression);
    Integer intLiteralValue = resolvedConstant instanceof Integer integer ? integer : null;
    if (intLiteralValue == null) {
      for (ForLoopInitializer initializer : initializers) {
        if (initializer.hasSameIdentifier(expression)) {
          intLiteralValue = initializer.value();
        }
      }
    }
    return intLiteralValue;
  }

}
"
S2253,CODE_SMELL,Track uses of disallowed methods,"package org.sonar.java.checks;

import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2253"")
public class DisallowedMethodCheck extends AbstractMethodDetection {

  @RuleProperty(key = ""className"", description = ""Name of the class whose method is forbidden"")
  private String className = """";

  @RuleProperty(key = ""methodName"", description = ""Name of the forbidden method"")
  private String methodName = """";

  @RuleProperty(key = ""argumentTypes"", description = ""Comma-delimited list of argument types, E.G. java.lang.String, int[], int"")
  private String argumentTypes = """";

  @RuleProperty(key = ""allOverloads"", description = ""Set to true to flag all overloads regardless of parameter type"", defaultValue = ""false"")
  private boolean allOverloads = false;

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    if (StringUtils.isEmpty(methodName)) {
      return MethodMatchers.none();
    }
    MethodMatchers.TypeBuilder typeBuilder = MethodMatchers.create();
    MethodMatchers.NameBuilder nameBuilder;
    if (StringUtils.isNotEmpty(className)) {
      nameBuilder = typeBuilder.ofTypes(className);
    } else {
      nameBuilder = typeBuilder.ofAnyType();
    }
    MethodMatchers.ParametersBuilder parametersBuilder = nameBuilder.names(methodName);

    if (allOverloads) {
      return parametersBuilder.withAnyParameters().build();
    } else {
      String[] args = StringUtils.split(argumentTypes, "","");
      if (args.length == 0) {
        return parametersBuilder.addWithoutParametersMatcher().build();
      } else {
        String[] trimmedArgs = new String[args.length];
        for (int i = 0; i < trimmedArgs.length; i++) {
          trimmedArgs[i] = StringUtils.trim(args[i]);
        }
        return parametersBuilder.addParametersMatcher(trimmedArgs).build();
      }
    }
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Remove this forbidden call"");
  }

  public void setClassName(String className) {
    this.className = className;
  }

  public void setMethodName(String methodName) {
    this.methodName = methodName;
  }

  public void setArgumentTypes(String argumentTypes) {
    this.argumentTypes = argumentTypes;
  }

  public void setAllOverloads(boolean allOverloads) {
    this.allOverloads = allOverloads;
  }
}
"
S2254,VULNERABILITY,"""HttpServletRequest.getRequestedSessionId()"" should not be used","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2254"")
public class GetRequestedSessionIdCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""javax.servlet.http.HttpServletRequest"", ""jakarta.servlet.http.HttpServletRequest"")
      .names(""getRequestedSessionId"")
      .addWithoutParametersMatcher()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Remove use of this unsecured \""getRequestedSessionId()\"" method"");
  }
}
"
S2257,SECURITY_HOTSPOT,Using non-standard cryptographic algorithms is security-sensitive,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S2257"")
public class CustomCryptographicAlgorithmCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE_DIGEST_QUALIFIED_NAME = ""java.security.MessageDigest"";
  private static final String MESSAGE = ""Make sure using a non-standard cryptographic algorithm is safe here."";

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (isJavaSecurityMessageDigestSubClass(classTree)) {
      reportIssue(ExpressionsHelper.reportOnClassTree(classTree), MESSAGE);
    }
  }

  private static boolean isJavaSecurityMessageDigestSubClass(ClassTree tree) {
    Symbol.TypeSymbol classSymbol = tree.symbol();
    // Corner case: A type is a subtype of itself
    return classSymbol != null && !classSymbol.type().is(MESSAGE_DIGEST_QUALIFIED_NAME) &&
      classSymbol.type().isSubtypeOf(MESSAGE_DIGEST_QUALIFIED_NAME);
  }
}
"
S2260,CODE_SMELL,Java parser failure,"package org.sonar.java.checks;

import com.sonar.sslr.api.RecognitionException;
import java.io.PrintWriter;
import java.io.StringWriter;
import org.sonar.check.Rule;
import org.sonar.java.ExceptionHandler;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""ParsingError"", repositoryKey = ""squid"")
@Rule(key = ""S2260"")
public class ParsingErrorCheck implements ExceptionHandler, JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
  }

  @Override
  public void processException(Exception e) {
    StringWriter exception = new StringWriter();
    e.printStackTrace(new PrintWriter(exception));
    context.addIssueOnFile(this, exception.toString());
  }

  @Override
  public void processRecognitionException(RecognitionException e) {
    context.addIssue(e.getLine(), this, ""Parse error"");
  }

}
"
S2272,BUG,"""Iterator.next()"" methods should throw ""NoSuchElementException""","package org.sonar.java.checks;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S2272"")
public class IteratorNextExceptionCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers NEXT_INVOCATION_MATCHER = MethodMatchers.create()
      .ofSubTypes(""java.util.Iterator"")
      .name(name -> name.startsWith(""next"") || name.startsWith(""previous""))
      .addWithoutParametersMatcher()
      .build();

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (isIteratorNextMethod(methodTree.symbol()) && methodTree.block() != null) {
      NextMethodBodyVisitor visitor = new NextMethodBodyVisitor();
      visitor.methodsVisited.add(methodTree);
      tree.accept(visitor);
      if (!visitor.expectedExceptionIsThrown) {
        reportIssue(methodTree.simpleName(), ""Add a \""NoSuchElementException\"" for iteration beyond the end of the collection."");
      }
    }
  }

  private static boolean isIteratorNextMethod(Symbol.MethodSymbol symbol) {
    return ""next"".equals(symbol.name()) && symbol.parameterTypes().isEmpty() && isIterator(symbol.enclosingClass());
  }

  private static boolean isIterator(Symbol.TypeSymbol typeSymbol) {
    return typeSymbol.type().isSubtypeOf(""java.util.Iterator"");
  }

  private static class NextMethodBodyVisitor extends BaseTreeVisitor {
    private boolean expectedExceptionIsThrown = false;
    private final Set<MethodTree> methodsVisited = new HashSet<>();

    @Override
    public void visitThrowStatement(ThrowStatementTree throwStatementTree) {
      ExpressionTree expression = throwStatementTree.expression();
      if (expression.is(Tree.Kind.NEW_CLASS)) {
        NewClassTree newClassTree = (NewClassTree) expression;
        Type symbolType = newClassTree.symbolType();
        if (symbolType.isSubtypeOf(""java.util.NoSuchElementException"") || symbolType.isUnknown()) {
          // Consider any unknown Exception as NoSuchElementException to avoid FP.
          expectedExceptionIsThrown = true;
        }
      }
      super.visitThrowStatement(throwStatementTree);
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
      if (NEXT_INVOCATION_MATCHER.matches(methodInvocation) || throwsNoSuchElementException(methodInvocation)) {
        expectedExceptionIsThrown = true;
      } else {
        Symbol.MethodSymbol methodSymbol = methodInvocation.methodSymbol();
        MethodTree methodTree = methodSymbol.declaration();
        boolean canVisit = methodTree != null && methodsVisited.add(methodTree);
        if (canVisit) {
          scan(methodTree);
        }
      }
      super.visitMethodInvocation(methodInvocation);
    }

    private static boolean throwsNoSuchElementException(MethodInvocationTree methodInvocationTree) {
      Symbol.MethodSymbol symbol = methodInvocationTree.methodSymbol();
      if (symbol.isUnknown()) {
        // Consider that it could throw an Exception to avoid FP.
        return true;
      }
      return throwsNoSuchElementException(symbol.thrownTypes());
    }

    private static boolean throwsNoSuchElementException(List<? extends Type> thrownTypes) {
      return thrownTypes.stream().anyMatch(t -> t.isSubtypeOf(""java.util.NoSuchElementException"") || t.isUnknown());
    }

  }

}
"
S2273,BUG,"""Object.wait()"", ""Object.notify()"" and ""Object.notifyAll()"" should only be called from synchronized code","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2273"")
public class WaitInSynchronizeCheck extends AbstractInSynchronizeChecker {

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (!isInSyncBlock()) {
      IdentifierTree methodName = ExpressionUtils.methodName(mit);
      ExpressionTree methodSelect = mit.methodSelect();
      String lockName;
      if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
        lockName = ((MemberSelectExpressionTree) methodSelect).expression().symbolType().name();
      } else {
        lockName = ""this"";
      }
      reportIssue(methodName, ""Move this call to \"""" + methodName + ""()\"" into a synchronized block to be sure the monitor on \"""" + lockName + ""\"" is held."");
    }
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofAnyType().names(""wait"")
        .addWithoutParametersMatcher()
        .addParametersMatcher(""long"")
        .addParametersMatcher(""long"", ""int"")
        .build(),
      MethodMatchers.create()
        .ofAnyType()
        .names(""notify"", ""notifyAll"")
        .addWithoutParametersMatcher()
        .build());
  }
}
"
S2274,CODE_SMELL,"""Object.wait(...)"" and ""Condition.await(...)"" should be called inside a ""while"" loop","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2274"")
public class WaitInWhileLoopCheck extends AbstractMethodDetection {

  private Deque<Boolean> inWhileLoop = new LinkedList<>();

  @Override
  public void setContext(JavaFileScannerContext context) {
    inWhileLoop.push(false);
    super.setContext(context);
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    inWhileLoop.clear();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.WHILE_STATEMENT, Tree.Kind.DO_STATEMENT, Tree.Kind.FOR_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      super.visitNode(tree);
    } else if (tree.is(Tree.Kind.FOR_STATEMENT)) {
      ForStatementTree fst = (ForStatementTree) tree;
      inWhileLoop.push(fst.initializer().isEmpty() && fst.condition() == null && fst.update().isEmpty());
    } else {
      inWhileLoop.push(true);
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.WHILE_STATEMENT, Tree.Kind.DO_STATEMENT, Tree.Kind.FOR_STATEMENT)) {
      inWhileLoop.pop();
    }
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (!Boolean.TRUE.equals(inWhileLoop.peek())) {
      IdentifierTree identifierTree = ExpressionUtils.methodName(mit);
      reportIssue(identifierTree, ""Remove this call to \"""" + identifierTree.name() + ""\"" or move it into a \""while\"" loop."");
    }
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofAnyType().names(""wait"")
        .addWithoutParametersMatcher()
        .addParametersMatcher(""long"")
        .addParametersMatcher(""long"", ""int"")
        .build(),
      MethodMatchers.create().ofTypes(""java.util.concurrent.locks.Condition"").name(name -> name.startsWith(""await"")).withAnyParameters().build()
    );
  }
}
"
S2275,BUG,Printf-style format strings should not lead to unexpected behavior at runtime,"package org.sonar.java.checks;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2275"")
public class PrintfFailCheck extends AbstractPrintfChecker {

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    boolean isMessageFormat = MESSAGE_FORMAT.matches(mit);
    if (isMessageFormat && !mit.methodSymbol().isStatic()) {
      // only consider the static method
      return;
    }
    super.checkFormatting(mit, isMessageFormat);
  }

  @Override
  protected void handlePrintfFormat(MethodInvocationTree mit, String formatString, List<ExpressionTree> args) {
    List<String> params = getParameters(formatString, mit);
    cleanupLineSeparator(params);
    if (!params.isEmpty()) {
      if (checkArgumentNumber(mit, argIndexes(params).size(), args.size())) {
        return;
      }
      verifyParametersForErrors(mit, args, params);
    }
  }

  @Override
  protected void handleMessageFormat(MethodInvocationTree mit, String formatString, List<ExpressionTree> args) {
    String newFormatString = cleanupDoubleQuote(formatString);
    checkUnbalancedBraces(mit, newFormatString);
  }

  private void checkUnbalancedBraces(MethodInvocationTree mit, String formatString) {
    String withoutParam = MESSAGE_FORMAT_PATTERN.matcher(formatString).replaceAll("""");
    int numberOpenBrace = 0;
    for (int i = 0; i < withoutParam.length(); ++i) {
      char ch = withoutParam.charAt(i);
      switch (ch) {
        case '{':
          numberOpenBrace++;
          break;
        case '}':
          numberOpenBrace--;
          break;
        default:
          break;
      }
    }
    if (numberOpenBrace > 0) {
      reportIssue(mit.arguments().get(0), ""Single left curly braces \""{\"" must be escaped."");
    }
  }

  @Override
  protected void handlePrintfFormatCatchingErrors(MethodInvocationTree mit, String formatString, List<ExpressionTree> args) {
    // Do nothing, since the method invocation will catch the error.
  }

  @Override
  protected void handleOtherFormatTree(MethodInvocationTree mit, ExpressionTree formatTree, List<ExpressionTree> args) {
    // do nothing
  }

  @Override
  protected void reportMissingPrevious(MethodInvocationTree mit) {
    reportIssue(mit, ""The argument index '<' refers to the previous format specifier but there isn't one."");
  }

}
"
S2276,BUG,"""wait(...)"" should be used instead of ""Thread.sleep(...)"" when a lock is held","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2276"")
public class ThreadSleepCheck extends AbstractInSynchronizeChecker {

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (isInSyncBlock()) {
      reportIssue(ExpressionUtils.methodName(mit), ""Replace the call to \""Thread.sleep(...)\"" with a call to \""wait(...)\""."");
    }
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofTypes(""java.lang.Thread"").names(""sleep"").withAnyParameters().build();
  }
}
"
S2293,CODE_SMELL,"The diamond operator (""<>"") should be used","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.apache.commons.lang3.ArrayUtils;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.ast.visitors.SubscriptionVisitor;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.JavaTree;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ArrayAccessExpressionTree;
import org.sonar.plugins.java.api.tree.ArrayTypeTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.ParenthesizedTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeArguments;
import org.sonar.plugins.java.api.tree.TypeCastTree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2293"")
public class DiamondOperatorCheck extends SubscriptionVisitor implements JavaVersionAwareVisitor {

  private static final Tree.Kind[] JAVA_7_KINDS = new Tree.Kind[] {
    Tree.Kind.VARIABLE,
    Tree.Kind.TYPE_CAST,
    Tree.Kind.RETURN_STATEMENT,
    Tree.Kind.ASSIGNMENT
  };
  private static final Tree.Kind[] JAVA_8_KINDS = ArrayUtils.add(JAVA_7_KINDS, Tree.Kind.CONDITIONAL_EXPRESSION);
  private Tree.Kind[] expressionKindsToCheck = JAVA_7_KINDS;

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    if (version.isJava8Compatible()) {
      expressionKindsToCheck = JAVA_8_KINDS;
    }
    return version.isJava7Compatible();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    NewClassTree newClassTree = (NewClassTree) tree;
    TypeTree newTypeTree = newClassTree.identifier();
    if (!isParameterizedType(newTypeTree) || newClassTree.classBody() != null) {
      return;
    }
    TypeTree type = getTypeFromExpression(tree.parent(), expressionKindsToCheck);
    if ((type != null && isParameterizedType(type))
      || usedAsArgumentWithoutDiamond(newClassTree)) {
      TypeArguments typeArguments = ((ParameterizedTypeTree) newTypeTree).typeArguments();
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(typeArguments)
        .withMessage(""Replace the type specification in this constructor call with the diamond operator (\""<>\"").%s"", context.getJavaVersion().java7CompatibilityMessage())
        .withQuickFix(() -> JavaQuickFix.newQuickFix(""Replace with <>"")
          .addTextEdit(JavaTextEdit.replaceTree(typeArguments, ""<>""))
          .build())
        .report();
    }
  }

  private static boolean usedAsArgumentWithoutDiamond(NewClassTree newClassTree) {
    Tree parent = newClassTree.parent();
    if (!parent.is(Tree.Kind.ARGUMENTS)) {
      // not part of an invocation
      return false;
    }

    Tree invocation = parent.parent();
    Symbol.MethodSymbol symbol = null;
    // arguments are only used in METHOD_INVOCATION, NEW_CLASS_TREE and ANNOTATION
    // however annotations values can not store parameterized types
    if (invocation.is(Tree.Kind.METHOD_INVOCATION)) {
      symbol = ((MethodInvocationTree) invocation).methodSymbol();
    } else {
      symbol = ((NewClassTree) invocation).methodSymbol();
    }

    if (symbol.isUnknown()) {
      // unresolved invocation
      return false;
    }

    Symbol.MethodSymbol methodSymbol = symbol;
    int index = getArgIndex(newClassTree, (Arguments) parent);
    if (index >= methodSymbol.parameterTypes().size()) {
      // killing the noise - varargs
      return false;
    }

    if (methodSymbol.isParametrizedMethod()) {
      // killing the noise - might be required for inference on nested method calls
      return false;
    }

    Type parameterType = methodSymbol.parameterTypes().get(index);
    return parameterType.isParameterized();
  }

  private static int getArgIndex(Tree tree, Arguments arguments) {
    int i = 0;
    while (!tree.equals(arguments.get(i))) {
      i++;
    }
    return i;
  }

  @CheckForNull
  private static TypeTree getTypeFromExpression(Tree expression, Tree.Kind[] kinds) {
    if (expression.is(kinds)) {
      TypeTreeLocator visitor = new TypeTreeLocator(kinds);
      expression.accept(visitor);
      return visitor.type;
    }
    return null;
  }

  private static boolean isParameterizedType(TypeTree type) {
    if (type.is(Tree.Kind.ARRAY_TYPE)) {
      return isParameterizedType(((ArrayTypeTree) type).type());
    }
    return type.is(Tree.Kind.PARAMETERIZED_TYPE) && !((ParameterizedTypeTree) type).typeArguments().isEmpty();
  }

  private static class TypeTreeLocator extends BaseTreeVisitor {

    private final Tree.Kind[] kinds;

    @Nullable
    private TypeTree type = null;

    public TypeTreeLocator(Tree.Kind[] kinds) {
      this.kinds = kinds;
    }

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      type = getMethodReturnType(tree);
    }

    @Override
    public void visitTypeCast(TypeCastTree tree) {
      type = tree.type();
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      Tree assignedVariable = getAssignedVariable(tree.variable());
      if (assignedVariable != null) {
        type = getTypeFromExpression(assignedVariable, kinds);
      }
    }

    @Override
    public void visitVariable(VariableTree tree) {
      type = tree.type();
    }

    @Override
    public void visitConditionalExpression(ConditionalExpressionTree tree) {
      type = getTypeFromExpression(tree.parent(), kinds);
    }

    @CheckForNull
    private static TypeTree getMethodReturnType(ReturnStatementTree returnStatementTree) {
      MethodTree methodTree = getParentMethod(returnStatementTree);
      if (methodTree != null) {
        return methodTree.returnType();
      }
      return null;
    }

    @CheckForNull
    private static MethodTree getParentMethod(Tree tree) {
      Tree result = tree;
      while (result != null && !result.is(Tree.Kind.METHOD)) {
        result = result.parent();
      }
      return (MethodTree) result;
    }

    @CheckForNull
    private static Tree getAssignedVariable(ExpressionTree expression) {
      IdentifierTree identifier;
      switch (expression.kind()) {
        case ARRAY_ACCESS_EXPRESSION:
          return getAssignedVariable(((ArrayAccessExpressionTree) expression).expression());
        case TYPE_CAST:
          return getAssignedVariable(((TypeCastTree) expression).expression());
        case PARENTHESIZED_EXPRESSION:
          return getAssignedVariable(((ParenthesizedTree) expression).expression());
        case IDENTIFIER:
          identifier = (IdentifierTree) expression;
          break;
        case MEMBER_SELECT:
          identifier = ((MemberSelectExpressionTree) expression).identifier();
          break;
        case METHOD_INVOCATION:
          return getAssignedVariable(((MethodInvocationTree) expression).methodSelect());
        default:
          throw new IllegalStateException(""Unexpected expression "" + expression.kind().name() + "" at: "" + ((JavaTree) expression).getLine());
      }
      return identifier.symbol().declaration();
    }
  }
}
"
S2301,CODE_SMELL,Public methods should not contain selector arguments,"package org.sonar.java.checks;

import java.text.MessageFormat;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2301"")
public class SelectorMethodArgumentCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (!Boolean.FALSE.equals(methodTree.isOverriding())) {
      // In case it cannot be determined (isOverriding returns null), consider as overriding to avoid FP.
      return;
    }
    List<Symbol> booleanParameterSymbols = getBooleanParametersAsSymbol(methodTree.parameters());
    BlockTree blockTree = methodTree.block();

    if (isPublic(methodTree) && blockTree != null && !booleanParameterSymbols.isEmpty()) {
      for (Symbol variable : booleanParameterSymbols) {
        List<IdentifierTree> usages = variable.usages();
        if (usages.size() == 1) {
          blockTree.accept(new ConditionalStatementVisitor(variable.name(), usages.get(0), methodTree));
        }
      }
    }
  }

  private static boolean isPublic(MethodTree methodTree) {
    return ModifiersUtils.hasModifier(methodTree.modifiers(), Modifier.PUBLIC);
  }

  private static List<Symbol> getBooleanParametersAsSymbol(List<VariableTree> parameters) {
    List<Symbol> booleanParameters = new LinkedList<>();
    for (VariableTree variableTree : parameters) {
      if (isBooleanVariable(variableTree)) {
        booleanParameters.add(variableTree.symbol());
      }
    }
    return booleanParameters;
  }

  private static boolean isBooleanVariable(VariableTree variableTree) {
    return variableTree.type().symbolType().isPrimitive(Type.Primitives.BOOLEAN);
  }

  private class ConditionalStatementVisitor extends BaseTreeVisitor {

    private final String variableName;
    private final MethodTree method;
    private final IdentifierTree usage;

    public ConditionalStatementVisitor(String variableName, IdentifierTree usage, MethodTree method) {
      this.variableName = variableName;
      this.usage = usage;
      this.method = method;
    }

    @Override
    public void visitIfStatement(IfStatementTree tree) {
      checkParameterUsage(tree.condition());
    }

    @Override
    public void visitConditionalExpression(ConditionalExpressionTree tree) {
      checkParameterUsage(tree.condition());
    }

    private void checkParameterUsage(ExpressionTree condition) {
      if (usage.equals(condition)) {
        reportIssue(method.simpleName(), MessageFormat.format(""Provide multiple methods instead of using \""{0}\"" to determine which action to take."", variableName));
      }
    }
  }
}
"
S2308,CODE_SMELL,"""deleteOnExit"" should not be used","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""CallToFileDeleteOnExitMethod"", repositoryKey = ""squid"")
@Rule(key = ""S2308"")
public class CallToFileDeleteOnExitMethodCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofTypes(""java.io.File"").names(""deleteOnExit"").addWithoutParametersMatcher().build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Remove this call to \""deleteOnExit\""."");
  }
}
"
S2309,CODE_SMELL,Files should not be empty,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonarsource.analyzer.commons.annotations.DeprecatedRuleKey;

@DeprecatedRuleKey(ruleKey = ""EmptyFile"", repositoryKey = ""squid"")
@Rule(key = ""S2309"")
public final class EmptyFileCheck implements JavaFileScanner {

  @Override
  public void scanFile(JavaFileScannerContext context) {
    if (context.fileParsed()) {
      CompilationUnitTree cut = context.getTree();
      if (cut.moduleDeclaration() == null && cut.packageDeclaration() == null && cut.types().isEmpty()) {
        context.addIssueOnFile(this, ""This file has 0 lines of code."");
      }
    }
  }

}
"
S2325,CODE_SMELL,"""private"" and ""final"" methods that don't access instance data should be ""static""","package org.sonar.java.checks;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Objects;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2325"")
public class StaticMethodCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String JAVA_IO_SERIALIZABLE = ""java.io.Serializable"";
  private static final MethodMatchers EXCLUDED_SERIALIZABLE_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(JAVA_IO_SERIALIZABLE)
      .names(""readObject"")
      .addParametersMatcher(params -> params.size() == 1 && params.get(0).isSubtypeOf(""java.io.ObjectInputStream""))
      .build(),
    MethodMatchers.create()
      .ofSubTypes(JAVA_IO_SERIALIZABLE)
      .names(""writeObject"")
      .addParametersMatcher(params -> params.size() == 1 && params.get(0).isSubtypeOf(""java.io.ObjectOutputStream""))
      .build(),
    MethodMatchers.create()
      .ofSubTypes(JAVA_IO_SERIALIZABLE)
      .names(""readObjectNoData"", ""writeReplace"", ""readResolve"")
      .addWithoutParametersMatcher()
      .build());

  private JavaFileScannerContext context;
  private Deque<MethodReference> methodReferences = new LinkedList<>();

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    if (context.getSemanticModel() != null) {
      scan(context.getTree());
    }
  }

  @Override
  public void visitMethod(MethodTree tree) {
    if (isExcluded(tree)) {
      return;
    }
    Symbol.MethodSymbol symbol = tree.symbol();
    methodReferences.push(new MethodReference(symbol));
    scan(tree.parameters());
    scan(tree.block());
    MethodReference reference = methodReferences.pop();
    ClassTree classTree = (ClassTree) tree.parent();
    if (!Boolean.FALSE.equals(tree.isOverriding()) || classTree.is(Tree.Kind.ENUM)) {
      // In case it cannot be determined (isOverriding returns null), consider as overriding to avoid FP.
      return;
    }
    if ((symbol.isPrivate() || symbol.isFinal() || classTree.symbol().isFinal()) && !symbol.isStatic() && !reference.hasNonStaticReference()) {
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(tree.simpleName())
        .withMessage(""Make \""%s\"" a \""static\"" method."", symbol.name())
        .withQuickFix(() -> getQuickFix(tree))
        .report();
    }
  }

  private static JavaQuickFix getQuickFix(MethodTree tree) {
    Tree insertPosition = QuickFixHelper.nextToken(tree.modifiers());

    for (ModifierKeywordTree modifier: tree.modifiers().modifiers()) {
      if (shouldBePlacedAfterStatic(modifier.modifier())) {
        insertPosition = modifier;
        break;
      }
    }

    return JavaQuickFix.newQuickFix(""Make static"")
      .addTextEdit(JavaTextEdit.insertBeforeTree(insertPosition, ""static ""))
      .build();
  }

  private static boolean shouldBePlacedAfterStatic(Modifier modifier) {
    return modifier.ordinal() > Modifier.STATIC.ordinal();
  }

  private static boolean isExcluded(MethodTree tree) {
    return tree.is(Tree.Kind.CONSTRUCTOR) || EXCLUDED_SERIALIZABLE_METHODS.matches(tree) || hasEmptyBody(tree);
  }

  private static boolean hasEmptyBody(MethodTree tree) {
    return tree.block() != null && tree.block().body().isEmpty();
  }

  @Override
  public void visitIdentifier(IdentifierTree tree) {
    super.visitIdentifier(tree);
    if (""class"".equals(tree.name()) || methodReferences.isEmpty()) {
      return;
    }
    if (parentIs(tree, Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree parent = (MemberSelectExpressionTree) tree.parent();
      // Exclude identifiers used in member select, except for instance creation
      // New class may use member select to denote an inner class
      if (tree.equals(parent.identifier()) && !parentIs(parent, Tree.Kind.NEW_CLASS) && !refToEnclosingClass(tree)) {
        return;
      }
    }
    visitTerminalIdentifier(tree);
  }

  private static boolean refToEnclosingClass(IdentifierTree tree) {
    String identifier = tree.name();
    return ""this"".equals(identifier) || ""super"".equals(identifier);
  }

  private void visitTerminalIdentifier(IdentifierTree tree) {
    Symbol symbol = tree.symbol();
    MethodReference currentMethod = methodReferences.peek();
    if (symbol.isUnknown()) {
      currentMethod.setNonStaticReference();
      return;
    }
    for (MethodReference methodReference : methodReferences) {
      methodReference.checkSymbol(symbol);
    }
  }

  private static boolean parentIs(Tree tree, Tree.Kind kind) {
    return tree.parent() != null && tree.parent().is(kind);
  }

  @Override
  public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
    if (tree.expression().is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) tree.expression();
      Symbol owner = identifier.symbol().owner();
      if (owner != null && owner.isMethodSymbol()) {
        // No need to investigate selection on local symbols
        return;
      }
    }
    super.visitMemberSelectExpression(tree);
  }

  private static class MethodReference {

    private final Symbol.MethodSymbol methodSymbol;
    private final Symbol methodScopeOwner;
    private boolean nonStaticReference = false;

    MethodReference(Symbol.MethodSymbol symbol) {
      methodSymbol = symbol;
      methodScopeOwner = methodSymbol.owner();
      if (methodScopeOwner != null && methodScopeOwner.isTypeSymbol()) {
        nonStaticReference = !methodScopeOwner.isStatic() && !methodScopeOwner.owner().isPackageSymbol();
      }
    }

    @CheckForNull
    private static Symbol getPackage(Symbol symbol) {
      Symbol owner = symbol.owner();
      while (owner != null) {
        if (owner.isPackageSymbol()) {
          break;
        }
        owner = owner.owner();
      }
      return owner;
    }

    void setNonStaticReference() {
      nonStaticReference = true;
    }

    boolean hasNonStaticReference() {
      return nonStaticReference;
    }

    void checkSymbol(Symbol symbol) {
      if (nonStaticReference || methodSymbol.equals(symbol) || symbol.isStatic()) {
        return;
      }
      Symbol scopeOwner = symbol.owner();
      if (isConstructor(symbol)) {
        checkConstructor(scopeOwner);
      } else if (scopeOwner != null) {
        checkNonConstructor(scopeOwner);
      }
    }

    private void checkConstructor(Symbol constructorClass) {
      if (!constructorClass.isStatic()) {
        Symbol methodPackage = getPackage(methodScopeOwner);
        Symbol constructorPackage = getPackage(constructorClass);
        if (Objects.equals(methodPackage, constructorPackage) && !constructorClass.owner().isPackageSymbol()) {
          setNonStaticReference();
        }
      }
    }

    private void checkNonConstructor(Symbol scopeOwner) {
      if (scopeOwner.isMethodSymbol()) {
        return;
      }
      if (hasLocalAccess(methodScopeOwner, scopeOwner)) {
        setNonStaticReference();
      }
    }

    private static boolean isConstructor(Symbol symbol) {
      return ""<init>"".equals(symbol.name());
    }

    private static boolean hasLocalAccess(Symbol scope, Symbol symbol) {
      if (scope.equals(symbol)) {
        return true;
      }
      if (scope.isTypeSymbol() && symbol.isTypeSymbol()) {
        Type scopeType = scope.type().erasure();
        Type symbolType = symbol.type().erasure();
        if (scopeType.isSubtypeOf(symbolType)) {
          return true;
        }
      }
      return false;
    }
  }
}
"
S2326,CODE_SMELL,Unused type parameters should be removed,"package org.sonar.java.checks.unused;

import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeParameterTree;
import org.sonar.plugins.java.api.tree.TypeParameters;

@Rule(key = ""S2326"")
public class UnusedTypeParameterCheck extends IssuableSubscriptionVisitor {

  private static final String ISSUE_MESSAGE = ""%s is not used in the %s."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.INTERFACE, Tree.Kind.RECORD, Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    TypeParameters typeParameters = tree.is(Tree.Kind.METHOD) ? ((MethodTree) tree).typeParameters() : ((ClassTree) tree).typeParameters();
    for (TypeParameterTree typeParameter : typeParameters) {
      Symbol symbol = typeParameter.symbol();
      if (!symbol.isUnknown() && symbol.usages().isEmpty()) {
        String message = String.format(ISSUE_MESSAGE, symbol.name(), tree.kind().name().toLowerCase(Locale.ROOT));
        reportIssue(typeParameter.identifier(), message);
      }
    }
  }
}
"
S2333,CODE_SMELL,Redundant modifiers should not be used,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2333"")
public class RedundantModifierCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE, Tree.Kind.CLASS, Tree.Kind.ENUM, Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (classTree.is(Tree.Kind.RECORD)) {
      checkRedundantModifiers(classTree.modifiers(), Modifier.FINAL);
    }
    for (Tree member : classTree.members()) {
      switch (member.kind()) {
        case METHOD:
          checkMethod((MethodTree) member, classTree);
          break;
        case VARIABLE:
          checkVariable((VariableTree) member, classTree);
          break;
        case CONSTRUCTOR:
          if (tree.is(Tree.Kind.ENUM)) {
            checkRedundantModifiers(((MethodTree) member).modifiers(), Modifier.PRIVATE);
          }
          break;
        case INTERFACE:
          ClassTree nestedClass = (ClassTree) member;
          checkNestedInterface(nestedClass, classTree);
          checkNestedType(nestedClass, classTree);
          break;
        case CLASS:
          checkNestedType((ClassTree) member, classTree);
          break;
        default:
          // Do nothing for others members
      }
    }
  }

  private void checkMethod(MethodTree methodTree, ClassTree classTree) {
    ModifiersTree modifiers = methodTree.modifiers();
    if (isInterfaceOrAnnotation(classTree)) {
      checkRedundantModifiers(modifiers, Modifier.ABSTRACT, Modifier.PUBLIC);
    } else if (classTree.is(Tree.Kind.RECORD) || ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {
      checkRedundantModifiers(modifiers, Modifier.FINAL);
    }
  }

  private void checkVariable(VariableTree variableTree, ClassTree classTree) {
    if (isInterfaceOrAnnotation(classTree)) {
      ModifiersTree modifiers = variableTree.modifiers();
      checkRedundantModifiers(modifiers, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);
    }
  }

  private void checkNestedType(ClassTree nested, ClassTree classTree) {
    if (isInterfaceOrAnnotation(classTree)) {
      ModifiersTree modifiers = nested.modifiers();
      checkRedundantModifiers(modifiers, Modifier.PUBLIC, Modifier.STATIC);
    }
  }

  private void checkNestedInterface(ClassTree nested, ClassTree classTree) {
    if (classTree.is(Tree.Kind.CLASS, Tree.Kind.ENUM)) {
      checkRedundantModifiers(nested.modifiers(), Modifier.STATIC);
    }
  }

  private static boolean isInterfaceOrAnnotation(Tree tree) {
    return tree.is(Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE);
  }

  private void checkRedundantModifiers(ModifiersTree modifiersTree, Modifier... modifiers) {
    for (Modifier modifier : modifiers) {
      ModifierKeywordTree foundModifier = ModifiersUtils.getModifier(modifiersTree, modifier);
      if (foundModifier != null) {
        reportIssue(foundModifier, String.format(""\""%s\"" is redundant in this context."", foundModifier.keyword().text()));
      }
    }
  }

}
"
S2384,CODE_SMELL,Private mutable members should not be stored or returned directly,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2384"")
public class MutableMembersUsageCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final List<String> MUTABLE_TYPES = Arrays.asList(
    ""java.util.Collection"",
    ""java.util.Date"",
    ""java.util.Map"");
  private static final List<String> IMMUTABLE_TYPES = Arrays.asList(
    ""java.util.Collections.UnmodifiableCollection"",
    ""java.util.Collections.UnmodifiableMap"",
    ""com.google.common.collect.ImmutableCollection"",
    ""com.google.common.collect.ImmutableMap"");

  private static final MethodMatchers UNMODIFIABLE_COLLECTION_CALL = MethodMatchers.or(
    MethodMatchers.create().ofType(type -> MutableMembersUsageCheck.containsImmutableLikeTerm(type.name())).anyName().withAnyParameters().build(),
    MethodMatchers.create().ofAnyType().name(MutableMembersUsageCheck::containsImmutableLikeTerm).withAnyParameters().build(),
    MethodMatchers.create().ofTypes(""java.util.Collections"")
      .name(name -> name.startsWith(""singleton"") || name.startsWith(""empty""))
      .withAnyParameters().build(),
    MethodMatchers.create().ofTypes(""java.util.Set"", ""java.util.List"").names(""of"", ""copyOf"").withAnyParameters().build(),
    MethodMatchers.create().ofTypes(""com.google.common.collect.Sets"").names(""union"", ""intersection"", ""difference"", ""symmetricDifference"").withAnyParameters().build(),
    MethodMatchers.create().ofTypes(""com.google.common.collect.Lists"").names(""asList"").withAnyParameters().build()
  );

  private static final MethodMatchers STREAM_COLLECT_CALL = MethodMatchers.create().
    ofTypes(""java.util.stream.Stream"")
    .names(""collect"")
    .addParametersMatcher(""java.util.stream.Collector"")
    .build();

  private static final MethodMatchers UNMODIFIABLE_COLLECTOR_CALL = MethodMatchers.create().
    ofTypes(""java.util.stream.Collectors"")
    .names(""toUnmodifiableSet"", ""toUnmodifiableList"", ""toUnmodifiableMap"")
    .withAnyParameters()
    .build();

  private JavaFileScannerContext context;
  private Deque<Set<Symbol>> parametersStack = new LinkedList<>();

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitMethod(MethodTree tree) {
    if (tree.is(Tree.Kind.CONSTRUCTOR)) {
      Symbol.TypeSymbol enclosingClass = tree.symbol().enclosingClass();
      if (enclosingClass.isEnum()) {
        return;
      }
    }
    parametersStack.push(tree.parameters().stream()
      .map(VariableTree::symbol)
      .collect(Collectors.toSet()));
    super.visitMethod(tree);
    parametersStack.pop();
  }

  @Override
  public void visitAssignmentExpression(AssignmentExpressionTree tree) {
    super.visitAssignmentExpression(tree);
    if (!isMutableType(tree.expression())) {
      return;
    }
    ExpressionTree variable = tree.variable();
    Symbol leftSymbol = null;
    if (variable.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifierTree = (IdentifierTree) variable;
      leftSymbol = identifierTree.symbol();
    } else if (variable.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mit = (MemberSelectExpressionTree) variable;
      leftSymbol = mit.identifier().symbol();
    }
    if (leftSymbol != null && leftSymbol.isPrivate()) {
      checkStore(tree.expression());
    }
  }

  private void checkStore(ExpressionTree expression) {
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifierTree = (IdentifierTree) expression;
      if (!parametersStack.isEmpty() && parametersStack.peek().contains(identifierTree.symbol())) {
        context.reportIssue(this, identifierTree, ""Store a copy of \"""" + identifierTree.name() + ""\""."");
      }
    }
  }

  @Override
  public void visitReturnStatement(ReturnStatementTree tree) {
    super.visitReturnStatement(tree);
    ExpressionTree expressionTree = tree.expression();
    if (expressionTree == null || !isMutableType(expressionTree)) {
      return;
    }
    checkReturnedExpression(expressionTree);
  }

  private void checkReturnedExpression(ExpressionTree expression) {
    if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mse = (MemberSelectExpressionTree) expression;
      if (ExpressionUtils.isThis(mse.expression())) {
        checkReturnedExpression(mse.identifier());
      }
    }
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifierTree = (IdentifierTree) expression;
      if (identifierTree.symbol().isPrivate() && !isOnlyAssignedImmutableVariable((Symbol.VariableSymbol) identifierTree.symbol())) {
        context.reportIssue(this, identifierTree, ""Return a copy of \"""" + identifierTree.name() + ""\""."");
      }
    }
  }

  private static boolean isOnlyAssignedImmutableVariable(Symbol.VariableSymbol symbol) {
    VariableTree declaration = symbol.declaration();
    if (declaration != null) {
      ExpressionTree initializer = declaration.initializer();
      if (initializer != null) {
        boolean isInitializerImmutable = !isMutableType(initializer) || isEmptyArray(initializer);
        if (symbol.isFinal() || !isInitializerImmutable) {
          // If the symbol is final or it is assigned something mutable, no need to look at re-assignment:
          // we already know if it is immutable or not.
          return isInitializerImmutable;
        }
      }
    }

    return !assignementsOfMutableType(symbol.usages());
  }

  private static boolean isEmptyArray(ExpressionTree initializer) {
    return initializer.is(Tree.Kind.NEW_ARRAY) &&
      !((NewArrayTree) initializer).dimensions().isEmpty() &&
      ((NewArrayTree) initializer).dimensions().stream().allMatch(adt -> isZeroLiteralValue(adt.expression()));
  }

  private static boolean isZeroLiteralValue(@Nullable ExpressionTree expressionTree) {
    if (expressionTree == null) {
      return false;
    }
    Integer integer = LiteralUtils.intLiteralValue(expressionTree);
    return integer != null && integer == 0;
  }

  private static boolean assignementsOfMutableType(List<IdentifierTree> usages) {
    for (IdentifierTree usage : usages) {
      Tree current = usage;
      Tree parent = usage.parent();
      do {
        if (parent.is(Tree.Kind.ASSIGNMENT)) {
          break;
        }
        current = parent;
        parent = current.parent();
      } while (parent != null);
      if (parent != null) {
        AssignmentExpressionTree assignment = (AssignmentExpressionTree) parent;
        if (assignment.variable().equals(current) && isMutableType(assignment.expression())) {
          return true;
        }
      }
    }
    return false;
  }

  private static boolean isMutableType(ExpressionTree expressionTree) {
    if (expressionTree.is(Tree.Kind.NULL_LITERAL)) {
      // In case of incomplete semantic, working with ""nulltype"" returns strange results, we can return early as the null will never be mutable anyway.
      return false;
    }
    if (expressionTree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree methodInvocationTree = (MethodInvocationTree) expressionTree;
      if (UNMODIFIABLE_COLLECTION_CALL.matches(methodInvocationTree) || (isUnmodifiableCollector(methodInvocationTree))) {
        return false;
      }
    }
    return isMutableType(expressionTree.symbolType());
  }

  private static boolean isUnmodifiableCollector(MethodInvocationTree methodInvocationTree) {
    if (STREAM_COLLECT_CALL.matches(methodInvocationTree) && methodInvocationTree.arguments().get(0).is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree collector = (MethodInvocationTree) methodInvocationTree.arguments().get(0);
      return UNMODIFIABLE_COLLECTOR_CALL.matches(collector);
    }
    return false;
  }

  private static boolean isMutableType(Type type) {
    if (type.isArray()) {
      return true;
    }
    for (String mutableType : MUTABLE_TYPES) {
      if (type.isSubtypeOf(mutableType) && isNotImmutable(type)) {
        return true;
      }
    }
    return false;
  }

  private static boolean isNotImmutable(Type type) {
    for (String immutableType : IMMUTABLE_TYPES) {
      if (type.isSubtypeOf(immutableType)) {
        return false;
      }
    }
    return true;
  }

  public static boolean containsImmutableLikeTerm(String methodName) {
    String lowerCaseName = methodName.toLowerCase(Locale.ROOT);
    return lowerCaseName.contains(""unmodifiable"") || lowerCaseName.contains(""immutable"");
  }

}
"
S2386,CODE_SMELL,"Mutable fields should not be ""public static""","package org.sonar.java.checks;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ArrayDimensionTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2386"")
public class PublicStaticMutableMembersCheck extends IssuableSubscriptionVisitor {

  private static final List<String> ALWAYS_MUTABLE_TYPES = Arrays.asList(
    ""java.awt.Point"",
    ""java.util.Date""
  );

  private static final List<String> MUTABLE_TYPES = Arrays.asList(
    ""java.awt.Point"",
    ""java.util.Date"",
    ""java.util.Collection"",
    ""java.util.Map"");

  private static final String DECORATE = ""decorate"";
  // java.util and apache commons
  private static final MethodMatchers UNMODIFIABLE_METHOD_CALLS = MethodMatchers.or(
    MethodMatchers.create().ofTypes(""java.util.Collections"").name(name -> name.startsWith(""singleton"") || name.startsWith(""empty"")).withAnyParameters().build(),
    MethodMatchers.create().ofType(type -> MutableMembersUsageCheck.containsImmutableLikeTerm(type.name())).anyName().withAnyParameters().build(),
    MethodMatchers.create().ofAnyType().name(MutableMembersUsageCheck::containsImmutableLikeTerm).withAnyParameters().build(),
    // Java 9s
    MethodMatchers.create().ofTypes(""java.util.Set"", ""java.util.List"", ""java.util.Map"").names(""of"", ""ofEntries"", ""copyOf"").withAnyParameters().build(),
    // apache...
    MethodMatchers.create()
      // commons 3.X
      .ofSubTypes(
        ""org.apache.commons.collections.map.UnmodifiableMap"",
        ""org.apache.commons.collections.list.UnmodifiableList"",
        ""org.apache.commons.collections.set.UnmodifiableSet"",
        // commons 4.X
        ""org.apache.commons.collections4.map.UnmodifiableMap"",
        ""org.apache.commons.collections4.set.UnmodifiableSet"",
        ""org.apache.commons.collections4.list.UnmodifiableList"")
      .names(DECORATE)
      .withAnyParameters()
      .build(),
    MethodMatchers.create().ofTypes(""com.google.common.collect.Sets"").names(""union"", ""intersection"", ""difference"", ""symmetricDifference"").withAnyParameters().build(),
    MethodMatchers.create().ofTypes(""com.google.common.collect.Lists"").names(""asList"").withAnyParameters().build()
  );

  private static final MethodMatchers STREAM_COLLECT_CALL = MethodMatchers.create().
    ofTypes(""java.util.stream.Stream"")
    .names(""collect"")
    .addParametersMatcher(""java.util.stream.Collector"")
    .build();

  private static final MethodMatchers UNMODIFIABLE_COLLECTOR_CALL = MethodMatchers.create().
    ofTypes(""java.util.stream.Collectors"")
    .names(""toUnmodifiableSet"", ""toUnmodifiableList"", ""toUnmodifiableMap"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers ARRAYS_AS_LIST = MethodMatchers.create()
    .ofTypes(""java.util.Arrays"").names(""asList"").withAnyParameters().build();

  private static final List<String> ACCEPTED_TYPES = Arrays.asList(
    ""com.google.common.collect.ImmutableMap"",
    ""com.google.common.collect.ImmutableCollection""
  );

  private static final List<String> ACCEPTED_NEW_TYPES = Collections.singletonList(
    ""org.apache.commons.collections4.list.UnmodifiableList""
  );

  private static final Set<Symbol> IMMUTABLE_CANDIDATES = new HashSet<>();
  private static final Map<Tree, List<Symbol>> CLASS_IMMUTABLE_CANDIDATES = new HashMap<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.INTERFACE, Tree.Kind.CLASS, Tree.Kind.ENUM, Tree.Kind.ASSIGNMENT);
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    CLASS_IMMUTABLE_CANDIDATES.clear();
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.ASSIGNMENT)) {
      checkAssignment((AssignmentExpressionTree) tree);
    } else {
      List<Tree> members = ((ClassTree) tree).members();
      for (Tree member : members) {
        if (member.is(Tree.Kind.VARIABLE)) {
          preCheckVariable(tree, (VariableTree) member);
        }
      }
    }
  }

  private void preCheckVariable(Tree owner, VariableTree variableTree) {
    Symbol symbol = variableTree.symbol();
    if (symbol != null && isPublicStatic(symbol) && isForbiddenType(symbol.type())) {
      if (isMutable(variableTree.initializer(), symbol)) {
        String message = ""Make this member \""protected\""."";
        if (owner.is(Tree.Kind.INTERFACE)) {
          message = MessageFormat.format(""Move \""{0}\"" to a class and lower its visibility"", variableTree.simpleName().name());
        }
        reportIssue(variableTree.simpleName(), message);
      } else {
        IMMUTABLE_CANDIDATES.add(symbol);
        CLASS_IMMUTABLE_CANDIDATES.computeIfAbsent(owner, key -> new ArrayList<>()).add(symbol);
      }
    }
  }

  private void checkAssignment(AssignmentExpressionTree node) {
    ExpressionTree variable = ExpressionUtils.skipParentheses(node.variable());
    if (variable.is(Tree.Kind.MEMBER_SELECT)) {
      variable = ((MemberSelectExpressionTree) variable).identifier();
    }
    if (variable.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifierTree = (IdentifierTree) variable;
      Symbol symbol = identifierTree.symbol();
      if (IMMUTABLE_CANDIDATES.contains(symbol) && isMutable(node.expression(), symbol)) {
        reportIssue(identifierTree, ""Make member \"""" + symbol.name() + ""\"" \""protected\""."");
        IMMUTABLE_CANDIDATES.remove(symbol);
      }
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    // cleanup
    if (tree.is(Tree.Kind.CLASS, Tree.Kind.ENUM)) {
      IMMUTABLE_CANDIDATES.removeAll(CLASS_IMMUTABLE_CANDIDATES.getOrDefault(tree, Collections.emptyList()));
    }
  }

  static boolean isMutable(@Nullable ExpressionTree initializer, Symbol symbol) {
    Type type = symbol.type();
    if (initializer == null) {
      return ALWAYS_MUTABLE_TYPES.stream().anyMatch(type::isSubtypeOf);
    }
    if (symbol.isFinal() && isEmptyArray(initializer)) {
      return false;
    }
    ExpressionTree expression = ExpressionUtils.skipParentheses(initializer);
    if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
      return returnValueIsMutable((MethodInvocationTree) expression);
    } else if (expression.is(Tree.Kind.NEW_CLASS)) {
      return !isUnknownOrAcceptedType(expression.symbolType(), ACCEPTED_NEW_TYPES);
    } else if (expression.is(Tree.Kind.IDENTIFIER)) {
      Symbol assigned = ((IdentifierTree) expression).symbol();
      return !IMMUTABLE_CANDIDATES.contains(assigned);
    }
    return true;
  }

  private static boolean isEmptyArray(ExpressionTree expression) {
    if (!expression.is(Tree.Kind.NEW_ARRAY)) {
      return false;
    }
    NewArrayTree nat = (NewArrayTree) expression;
    return hasEmptyInitializer(nat) || hasOnlyZeroDimensions(nat.dimensions());
  }

  private static boolean hasEmptyInitializer(NewArrayTree newArrayTree) {
    return newArrayTree.openBraceToken() != null && newArrayTree.initializers().isEmpty();
  }

  private static boolean hasOnlyZeroDimensions(List<ArrayDimensionTree> dimensions) {
    return !dimensions.isEmpty() && dimensions.stream().allMatch(PublicStaticMutableMembersCheck::isZeroDimension);
  }

  private static boolean isZeroDimension(ArrayDimensionTree dim) {
    ExpressionTree expression = dim.expression();
    return expression != null && LiteralUtils.isZero(expression);
  }

  private static boolean returnValueIsMutable(MethodInvocationTree mit) {
    if (isAcceptedTypeOrUnmodifiableMethodCall(mit)) {
      return false;
    } else if (ARRAYS_AS_LIST.matches(mit)) {
      return !mit.arguments().isEmpty();
    }
    return true;
  }

  private static boolean isAcceptedTypeOrUnmodifiableMethodCall(MethodInvocationTree mit) {
    Type type = mit.symbolType();
    return isUnknownOrAcceptedType(type, ACCEPTED_TYPES) || UNMODIFIABLE_METHOD_CALLS.matches(mit) || isUnmodifiableCollector(mit);
  }

  private static boolean isUnmodifiableCollector(MethodInvocationTree methodInvocationTree) {
    if (STREAM_COLLECT_CALL.matches(methodInvocationTree) && methodInvocationTree.arguments().get(0).is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree collector = (MethodInvocationTree) methodInvocationTree.arguments().get(0);
      return UNMODIFIABLE_COLLECTOR_CALL.matches(collector);
    }
    return false;
  }

  private static boolean isUnknownOrAcceptedType(Type type, List<String> accepted) {
    // In case of broken semantics, the type is unknown and can therefore not be matched against an accepted one.
    // To avoid raising FPs, we consider that an unknown type is most likely an accepted one.
    if (type.isUnknown()) {
      return true;
    }
    for (String acceptedType : accepted) {
      if (type.isSubtypeOf(acceptedType)) {
        return true;
      }
    }
    return false;
  }

  static boolean isPublicStatic(Symbol symbol) {
    return symbol.isStatic() && symbol.isPublic();
  }

  static boolean isForbiddenType(final Type type) {
    return type.isArray() || MUTABLE_TYPES.stream().anyMatch(type::isSubtypeOf);
  }
}
"
S2387,CODE_SMELL,Child class fields should not shadow parent class fields,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

import javax.annotation.CheckForNull;

import java.util.Collections;
import java.util.List;
import java.util.Set;

@Rule(key = ""S2387"")
public class ChildClassShadowFieldCheck extends IssuableSubscriptionVisitor {

  private static final Set<String> IGNORED_FIELDS = Collections.singleton(""serialVersionUID"");

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    TypeTree superClass = ((ClassTree) tree).superClass();
    if (superClass != null) {
      Symbol.TypeSymbol superclassSymbol = superClass.symbolType().symbol();
      ((ClassTree) tree).members().stream()
        .filter(m -> m.is(Kind.VARIABLE))
        .map(VariableTree.class::cast)
        .map(VariableTree::simpleName)
        .forEach(fieldSimpleName -> {
          if (!IGNORED_FIELDS.contains(fieldSimpleName.name())) {
            checkForIssue(superclassSymbol, fieldSimpleName);
          }
        });
    }
  }

  private void checkForIssue(Symbol.TypeSymbol classSymbol, IdentifierTree fieldSimpleName) {
    for (Symbol.TypeSymbol symbol = classSymbol; symbol != null; symbol = getSuperclass(symbol)) {
      if (checkMembers(fieldSimpleName, symbol)) {
        return;
      }
    }
  }

  private boolean checkMembers(IdentifierTree fieldSimpleName, Symbol.TypeSymbol symbol) {
    for (Symbol member : symbol.memberSymbols()) {
      if (member.isVariableSymbol()
        && !member.isPrivate()
        && !member.isStatic()
        && member.name().equals(fieldSimpleName.name())) {
        reportIssue(fieldSimpleName, String.format(""\""%s\"" is the name of a field in \""%s\""."", fieldSimpleName.name(), symbol.name()));
        return true;
      }
    }
    return false;
  }

  @CheckForNull
  private static Symbol.TypeSymbol getSuperclass(Symbol.TypeSymbol symbol) {
    Type superType = symbol.superClass();
    if (superType != null) {
      return superType.symbol();
    }
    return null;
  }

}
"
S2388,CODE_SMELL,Inner class calls to super class methods should be unambiguous,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2388"")
public class CallSuperMethodFromInnerClassCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.INTERFACE);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Symbol.TypeSymbol classSymbol = classTree.symbol();
    if (classSymbol != null && isInnerClass(classSymbol) && !extendsOuterClass(classSymbol)) {
      classTree.accept(new MethodInvocationVisitor(classSymbol));
    }
  }

  private static boolean isInnerClass(Symbol symbol) {
    return symbol.owner().isTypeSymbol();
  }

  private static boolean extendsOuterClass(Symbol.TypeSymbol classSymbol) {
    Type superType = classSymbol.superClass();
    return superType != null && superType.erasure().equals(classSymbol.owner().type().erasure());
  }


  private class MethodInvocationVisitor extends BaseTreeVisitor {
    private final Symbol.TypeSymbol classSymbol;

    public MethodInvocationVisitor(Symbol.TypeSymbol classSymbol) {
      this.classSymbol = classSymbol;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      Symbol symbol = tree.methodSymbol();
      if (tree.methodSelect().is(Tree.Kind.IDENTIFIER) && isCallToSuperclassMethod(symbol)) {
        String methodName = ((IdentifierTree) tree.methodSelect()).name();
        reportIssue(ExpressionUtils.methodName(tree), ""Prefix this call to \"""" + methodName + ""\"" with \""super.\""."");
      }
      super.visitMethodInvocation(tree);
    }

    private boolean isCallToSuperclassMethod(Symbol symbol) {
      return symbol.isMethodSymbol() && !isConstructor(symbol) && isInherited(symbol) && outerClassHasMethodWithSameName(symbol);
    }

    private boolean isConstructor(Symbol symbol) {
      return ""<init>"".equals(symbol.name());
    }

    private boolean isInherited(Symbol symbol) {
      Type methodOwnerType = symbol.owner().type().erasure();
      Type innerType = classSymbol.type().erasure();
      return !symbol.isStatic() && innerType.isSubtypeOf(methodOwnerType)
        && !classSymbol.owner().type().equals(methodOwnerType) && !innerType.equals(methodOwnerType);
    }

    private boolean outerClassHasMethodWithSameName(Symbol symbol) {
      return !((Symbol.TypeSymbol) classSymbol.owner()).lookupSymbols(symbol.name()).isEmpty();
    }

  }
}
"
S2390,BUG,Classes should not access their own subclasses during class initialization,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import org.sonar.check.Rule;
import org.sonar.java.ast.api.JavaKeyword;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2390"")
public class SubClassStaticReferenceCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Type classType = classTree.symbol().type();
    List<Tree> members = classTree.members();

    // JLS 12.4. Initialization of Classes and Interfaces:
    // Initialization of a class consists of executing its static initializers and the initializers for static fields (class variables)
    // declared in the class.
    checkStaticVariables(members, classType);
    checkStaticInitializers(members, classType);
  }

  private void checkStaticVariables(List<Tree> members, Type classType) {
    members.stream()
      .filter(member -> member.is(Tree.Kind.VARIABLE))
      .map(VariableTree.class::cast)
      .filter(SubClassStaticReferenceCheck::isStaticVariable)
      .map(VariableTree::initializer)
      .filter(Objects::nonNull)
      .forEach(initializer -> initializer.accept(new StaticAccessVisitor(classType)));
  }

  private static boolean isStaticVariable(VariableTree tree) {
    return tree.symbol().isStatic();
  }

  private void checkStaticInitializers(List<Tree> members, Type classType) {
    members.stream()
      .filter(member -> member.is(Tree.Kind.STATIC_INITIALIZER))
      .forEach(tree -> tree.accept(new StaticAccessVisitor(classType)));
  }


  private class StaticAccessVisitor extends BaseTreeVisitor {
    private final Type classTypeErasure;

    public StaticAccessVisitor(Type classType) {
      this.classTypeErasure = classType.erasure();
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      // skip the variable
      scan(tree.expression());
    }

    @Override
    public void visitClass(ClassTree tree) {
      // skip anonymous classes
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // skip lambdas
    }

    @Override
    public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
      if (JavaKeyword.CLASS.getValue().equals(tree.identifier().name())) {
        // skip visit of class literal (MyType.class)
        return;
      }
      super.visitMemberSelectExpression(tree);
    }

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      Type type = tree.symbolType();
      if (!sameErasure(type) && type.isSubtypeOf(classTypeErasure) && !isNestedSubtype(type)) {
        reportIssue(tree, String.format(""Remove this reference to \""%s\""."", type.symbol().name()));
      }
    }

    private boolean sameErasure(Type type) {
      return classTypeErasure.equals(type.erasure());
    }

    private boolean isNestedSubtype(Type type) {
      // The owner cannot be null in this context thanks to the checks in visitIdentifier.
      Type ownerType = Objects.requireNonNull(type.symbol().owner()).type();
      return ownerType != null && ownerType.erasure().isSubtypeOf(classTypeErasure);
    }

  }

}
"
S2437,CODE_SMELL,Unnecessary bit operations should not be performed,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S2437"")
public class UnnecessaryBitOperationCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(
      Kind.XOR,
      Kind.XOR_ASSIGNMENT,
      Kind.AND,
      Kind.AND_ASSIGNMENT,
      Kind.OR,
      Kind.OR_ASSIGNMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ExpressionTree expression;
    SyntaxToken operatorToken;
    if (tree.is(Kind.OR, Kind.XOR, Kind.AND)) {
      BinaryExpressionTree binary = (BinaryExpressionTree) tree;
      expression = binary.rightOperand();
      operatorToken = binary.operatorToken();
    } else {
      AssignmentExpressionTree assignment = (AssignmentExpressionTree) tree;
      expression = assignment.expression();
      operatorToken = assignment.operatorToken();
    }
    Long evaluatedExpression = LiteralUtils.longLiteralValue(expression);
    if (evaluatedExpression != null && getBitwiseOperationIdentityElement(tree).equals(evaluatedExpression)) {
      reportIssue(operatorToken, ""Remove this unnecessary bit operation."");
    }
  }

  private static Long getBitwiseOperationIdentityElement(Tree tree) {
    if (tree.is(Kind.AND, Kind.AND_ASSIGNMENT)) {
      return  -1L;
    }
    return 0L;
  }

}
"
S2438,CODE_SMELL,"""Thread"" should not be used where a ""Runnable"" argument is expected","package org.sonar.java.checks;

import java.text.MessageFormat;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonar.plugins.java.api.tree.YieldStatementTree;

@Rule(key = ""S2438"")
public class ThreadAsRunnableArgumentCheck extends IssuableSubscriptionVisitor {

  private static final String RUNNABLE_TYPE = ""java.lang.Runnable"";
  private static final String THREAD_TYPE = ""java.lang.Thread"";
  private static final String RUNNABLE_ARRAY_TYPE = RUNNABLE_TYPE + ""[]"";
  private static final String THREAD_ARRAY_TYPE = THREAD_TYPE + ""[]"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.VARIABLE, Tree.Kind.RETURN_STATEMENT, Tree.Kind.YIELD_STATEMENT, Tree.Kind.ASSIGNMENT,
      Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS, Tree.Kind.NEW_ARRAY);
  }

  @Override
  public void visitNode(Tree tree) {
    switch(tree.kind()) {
      case VARIABLE -> visitVariable((VariableTree) tree);
      case RETURN_STATEMENT -> visitReturnStatement((ReturnStatementTree) tree);
      case YIELD_STATEMENT -> visitYieldStatement((YieldStatementTree) tree);
      case NEW_ARRAY -> visitNewArray((NewArrayTree) tree);
      case ASSIGNMENT -> {
        var assignment = (AssignmentExpressionTree) tree;
        checkTypeCoercion(assignment.variable().symbolType(), assignment.expression());
      }
      case METHOD_INVOCATION -> {
        var invocation = (MethodInvocationTree) tree;
        visitInvocation(invocation.methodSymbol(), invocation.arguments());
      }
      case NEW_CLASS -> {
        var invocation = (NewClassTree) tree;
        visitInvocation(invocation.methodSymbol(), invocation.arguments());
      }
    }
  }

  private void visitVariable(VariableTree tree) {
    var initializer = tree.initializer();
    if (initializer != null) {
      checkTypeCoercion(tree.symbol().type(), initializer);
    }
  }

  private void visitInvocation(Symbol.MethodSymbol methodSymbol, Arguments rhsValues) {
    List<Type> lhsTypes = methodSymbol.parameterTypes();

    var nonVarargCount = lhsTypes.size() - (methodSymbol.isVarArgsMethod() ? 1 : 0);
    for (int i = 0; i < nonVarargCount; i++) {
      checkTypeCoercion(lhsTypes.get(i), rhsValues.get(i));
    }
    var argumentCount = rhsValues.size();
    if (!methodSymbol.isVarArgsMethod() || argumentCount == nonVarargCount) {
      return;
    }

    var arrayType = (Type.ArrayType) lhsTypes.get(nonVarargCount);
    var elementType = arrayType.elementType();
    checkTypeCoercion(arrayType, rhsValues.get(nonVarargCount));
    for (int i = nonVarargCount; i < argumentCount; i++) {
      checkTypeCoercion(elementType, rhsValues.get(i));
    }
  }

  private void visitNewArray(NewArrayTree tree) {
    var lhsType = tree.type();
    if (lhsType != null && lhsType.symbolType().is(RUNNABLE_TYPE)) {
      tree.initializers().forEach(rhsValue -> checkTypeCoercion(lhsType.symbolType(), rhsValue));
    }
  }

  private void visitReturnStatement(ReturnStatementTree tree) {
    var expression = tree.expression();
    if (expression == null) {
      return;
    }

    Tree enclosing = ExpressionUtils.getEnclosingTree(tree, Tree.Kind.METHOD, Tree.Kind.LAMBDA_EXPRESSION);
    if (enclosing != null) {
      var lhsType = enclosing instanceof LambdaExpressionTree lambda ?
        lambda.symbol().returnType().type() : ((MethodTree) enclosing).returnType().symbolType();
      checkTypeCoercion(lhsType, expression);
    }
  }

  private void visitYieldStatement(YieldStatementTree tree) {
    Tree enclosing = ExpressionUtils.getEnclosingTree(tree, Tree.Kind.SWITCH_EXPRESSION, Tree.Kind.SWITCH_STATEMENT);
    if (enclosing == null || enclosing.is(Tree.Kind.SWITCH_STATEMENT)) {
      // Iside of a SwitchStatementTree, the `yield` is implicit and does not return a value.
      // Unlike SwitchExpressionTree, SwitchStatementTree is not an ExpressionTree.
      return;
    }
    var lhsType = ((ExpressionTree) enclosing).symbolType();
    checkTypeCoercion(lhsType, tree.expression());
  }

  private void checkTypeCoercion(Type lhsType, ExpressionTree rhsValue) {
    var rhsType = rhsValue.symbolType();
    if ((lhsType.is(RUNNABLE_TYPE) && isNonNullSubtypeOf(rhsType, THREAD_TYPE)) ||
      (lhsType.is(RUNNABLE_ARRAY_TYPE) && isNonNullSubtypeOf(rhsType, THREAD_ARRAY_TYPE))) {
      var message = MessageFormat.format(""Replace this {0} instance with an instance of {1}."", rhsType.name(), lhsType.name());
      context.reportIssue(this, rhsValue, message);
    }
  }

  private static boolean isNonNullSubtypeOf(Type type, String superTypeName) {
    return !type.isNullType() && type.isSubtypeOf(superTypeName);
  }
}
"
S2440,CODE_SMELL,"Classes with only ""static"" methods should not be instantiated","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.JUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.TypeTree;

import javax.annotation.Nullable;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

@Rule(key = ""S2440"")
public class ClassWithOnlyStaticMethodsInstantiationCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    TypeTree identifier = ((NewClassTree) tree).identifier();
    Symbol.TypeSymbol newClassTypeSymbol = identifier.symbolType().symbol();
    if (!newClassTypeSymbol.isEnum() && hasOnlyStaticMethodsAndFields(newClassTypeSymbol) && !instantiateOwnClass(identifier, newClassTypeSymbol)) {
      String message = ""Remove this instantiation."";
      String name = getNewClassName(identifier);
      if (name != null) {
        message = ""Remove this instantiation of \""{0}\""."";
      }
      reportIssue(identifier, MessageFormat.format(message, name));
    }
  }

  private static boolean instantiateOwnClass(Tree identifier, Symbol.TypeSymbol newClassTypeSymbol) {
    Type enclosingClassType = JUtils.enclosingClass(identifier).type();
    return enclosingClassType.equals(newClassTypeSymbol.type());
  }

  private static boolean hasOnlyStaticMethodsAndFields(Symbol.TypeSymbol newClassTypeSymbol) {
    Collection<Symbol> symbols = filterMethodsAndFields(newClassTypeSymbol.memberSymbols());
    if (symbols.isEmpty()) {
      return false;
    }
    for (Symbol symbol : symbols) {
      if (!symbol.isStatic()) {
        return false;
      }
    }
    return superTypesHaveOnlyStaticMethods(newClassTypeSymbol);
  }

  private static boolean superTypesHaveOnlyStaticMethods(Symbol.TypeSymbol newClassTypeSymbol) {
    Type superClass = newClassTypeSymbol.superClass();
    if (superClass != null && !superClass.is(""java.lang.Object"") && !hasOnlyStaticMethodsAndFields(superClass.symbol())) {
      return false;
    }
    for (Type superInterface : newClassTypeSymbol.interfaces()) {
      if (!hasOnlyStaticMethodsAndFields(superInterface.symbol())) {
        return false;
      }
    }
    return true;
  }

  private static Collection<Symbol> filterMethodsAndFields(Collection<Symbol> symbols) {
    List<Symbol> filtered = new ArrayList<>();
    for (Symbol symbol : symbols) {
      if ((symbol.isVariableSymbol() && !isThisOrSuper(symbol)) || (symbol.isMethodSymbol() && !isConstructor(symbol))) {
        filtered.add(symbol);
      }
    }
    return filtered;
  }

  private static boolean isThisOrSuper(Symbol symbol) {
    String name = symbol.name();
    return ""this"".equals(name) || ""super"".equals(name);
  }

  private static boolean isConstructor(Symbol symbol) {
    return ""<init>"".equals(symbol.name());
  }

  @Nullable
  private static String getNewClassName(Tree tree) {
    if (tree.is(Kind.IDENTIFIER)) {
      return ((IdentifierTree) tree).name();
    } else if (tree.is(Kind.MEMBER_SELECT)) {
      return ((MemberSelectExpressionTree) tree).identifier().name();
    } else if (tree.is(Kind.PARAMETERIZED_TYPE)) {
      return getNewClassName(((ParameterizedTypeTree) tree).type());
    }
    return null;
  }
}
"
S2441,BUG,"Non-serializable objects should not be stored in ""javax.servlet.http.HttpSession"" instances","package org.sonar.java.checks.serialization;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S2441"")
public class SerializableObjectInSessionCheck extends AbstractMethodDetection {

  private static final String SESSION_POSTFIX = ""servlet.http.HttpSession"";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""javax."" + SESSION_POSTFIX, ""jakarta."" + SESSION_POSTFIX)
      .names(""setAttribute"")
      .addParametersMatcher(""java.lang.String"", ANY)
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree argument = mit.arguments().get(1);
    Type type = argument.symbolType();
    if (ExpressionsHelper.isNotSerializable(argument)) {
      String andParameters = type.isParameterized() ? "" and its parameters"" : """";
      reportIssue(argument, ""Make \"""" + type.name() + ""\"""" + andParameters + "" serializable or don't store it in the session."");
    }
  }

}
"
S2442,CODE_SMELL,"Synchronizing on a ""Lock"" object should be avoided","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2442"")
public class SynchronizedLockCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.SYNCHRONIZED_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ExpressionTree expression = ((SynchronizedStatementTree) tree).expression();
    if (expression.symbolType().isSubtypeOf(""java.util.concurrent.locks.Lock"")) {
      reportIssue(expression, ""Synchronize on this \""Lock\"" object using \""acquire/release\""."");
    }
  }

}
"
S2444,CODE_SMELL,"Lazy initialization of ""static"" fields should be ""synchronized""","package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2444"")
public class StaticFieldInitializationCheck extends AbstractInSynchronizeChecker {

  private Deque<Boolean> classWithSynchronizedMethod = new LinkedList<>();
  private Deque<Boolean> withinStaticInitializer = new LinkedList<>();
  private Deque<Boolean> methodUsesLocks = new LinkedList<>();
  private MethodMatchers locks = MethodMatchers.create()
    .ofTypes(""java.util.concurrent.locks.Lock"")
    .names(""lock"", ""tryLock"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    List<Tree.Kind> nodesToVisit = new ArrayList<>(super.nodesToVisit());
    nodesToVisit.add(Tree.Kind.CLASS);
    nodesToVisit.add(Tree.Kind.ASSIGNMENT);
    nodesToVisit.add(Tree.Kind.STATIC_INITIALIZER);
    return nodesToVisit;
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    classWithSynchronizedMethod.push(false);
    withinStaticInitializer.push(false);
    methodUsesLocks.push(false);
    super.setContext(context);
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    withinStaticInitializer.clear();
    methodUsesLocks.clear();
    classWithSynchronizedMethod.clear();
  }

  @Override
  public void visitNode(Tree tree) {
    switch (tree.kind()) {
      case CLASS:
        classWithSynchronizedMethod.push(hasSynchronizedMethod((ClassTree) tree));
        break;
      case STATIC_INITIALIZER:
        withinStaticInitializer.push(true);
        break;
      case METHOD:
        methodUsesLocks.push(false);
        break;
      case METHOD_INVOCATION:
        if (locks.matches((MethodInvocationTree) tree) && methodUsesLocks.size() != 1) {
          methodUsesLocks.pop();
          methodUsesLocks.push(true);
        }
        break;
      case ASSIGNMENT:
        AssignmentExpressionTree aet = (AssignmentExpressionTree) tree;
        if (aet.variable().is(Tree.Kind.IDENTIFIER)
          && !isInSyncBlock()
          && !isInStaticInitializer()
          && !isUsingLock()
          && isInClassWithSynchronizedMethod()) {
          IdentifierTree variable = (IdentifierTree) aet.variable();
          if (isStaticNotVolatileObject(variable)) {
            reportIssue(variable, ""Synchronize this lazy initialization of '"" + variable.name() + ""'"");
          }
        }
        break;
      default:
        // Do nothing
    }
    super.visitNode(tree);
  }

  private boolean isInStaticInitializer() {
    return withinStaticInitializer.peek();
  }

  private static Boolean hasSynchronizedMethod(ClassTree tree) {
    return tree.members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .map(MethodTree::modifiers)
      .anyMatch(modifiers -> ModifiersUtils.hasModifier(modifiers, Modifier.SYNCHRONIZED));
  }

  private boolean isInClassWithSynchronizedMethod() {
    return classWithSynchronizedMethod.peek();
  }

  private boolean isUsingLock() {
    return methodUsesLocks.peek();
  }

  @Override
  public void leaveNode(Tree tree) {
    switch (tree.kind()) {
      case CLASS:
        classWithSynchronizedMethod.pop();
        break;
      case STATIC_INITIALIZER:
        withinStaticInitializer.pop();
        break;
      case METHOD:
        methodUsesLocks.pop();
        break;
      default:
        // do nothing
    }
    super.leaveNode(tree);
  }

  private static boolean isStaticNotVolatileObject(IdentifierTree variable) {
    Symbol symbol = variable.symbol();
    if (symbol.isUnknown()) {
      return false;
    }
    return isStaticNotFinalNotVolatile(symbol) && !symbol.type().isPrimitive();
  }

  private static boolean isStaticNotFinalNotVolatile(Symbol symbol) {
    return symbol.isStatic() && !symbol.isVolatile() && !symbol.isFinal();
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.none();
  }

}
"
S2445,BUG,"Blocks should be synchronized on ""private final"" fields","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2445"")
public class SynchronizedFieldAssignmentCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.SYNCHRONIZED_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    SynchronizedStatementTree sst = (SynchronizedStatementTree) tree;
    if(sst.expression().is(Tree.Kind.NEW_CLASS)) {
      reportIssue(tree, ""Synchronizing on a new instance is a no-op."");
      return;
    }
    Symbol field = getField(sst.expression());
    if (field != null) {
      sst.block().accept(new AssignmentVisitor(field, sst.expression()));
    } else {
      Symbol parameter = getParam(sst.expression());
      if(parameter != null) {
        reportIssue(tree, String.format(""\""%s\"" is a method parameter, and should not be used for synchronization."", parameter.name()));
      }
    }
  }

  @CheckForNull
  private static Symbol getParam(ExpressionTree tree) {
    if (tree.is(Tree.Kind.IDENTIFIER)) {
      Symbol reference = ((IdentifierTree) tree).symbol();
      if (reference.isParameter()) {
        return reference;
      }
    }
    return null;
  }

  @CheckForNull
  private static Symbol getField(ExpressionTree tree) {
    if (tree.is(Tree.Kind.IDENTIFIER)) {
      Symbol reference = ((IdentifierTree) tree).symbol();
      if (!reference.isUnknown() && reference.owner().isTypeSymbol()) {
        return reference;
      }
    } else if (tree.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mse = (MemberSelectExpressionTree) tree;
      if (isField(mse)) {
        return getField(mse.identifier());
      }
    }
    return null;
  }

  private static boolean isField(ExpressionTree tree) {
    if (tree.is(Tree.Kind.IDENTIFIER)) {
      Symbol reference = ((IdentifierTree) tree).symbol();
      return !reference.isUnknown() && reference.owner().isTypeSymbol();
    }
    if (tree.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mse = (MemberSelectExpressionTree) tree;
      ExpressionTree mseExpression = mse.expression();
      if (ExpressionUtils.isThis(mseExpression)) {
        return isField(mse.identifier());
      } else {
        return isField(mseExpression);
      }
    }
    return false;
  }

  private class AssignmentVisitor extends BaseTreeVisitor {

    private final Symbol field;
    private final Tree synchronizedStatement;

    AssignmentVisitor(Symbol field, Tree tree) {
      this.field = field;
      this.synchronizedStatement = tree;
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      checkSymbolAssignment(tree.variable());
    }

    private void checkSymbolAssignment(Tree variable) {
      if (variable.is(Tree.Kind.IDENTIFIER)) {
        if (field.equals(((IdentifierTree) variable).symbol())) {
          reportIssue(
            synchronizedStatement,
            String.format(""\""%s\"" is not \""private final\"", and should not be used for synchronization. "", field.name()));
        }
      } else if (variable.is(Tree.Kind.MEMBER_SELECT)) {
        checkSymbolAssignment(((MemberSelectExpressionTree) variable).identifier());
      }
    }

  }
}
"
S2446,BUG,"""notifyAll()"" should be preferred over ""notify()""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2446"")
public class NotifyCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofAnyType().names(""notify"").addWithoutParametersMatcher().build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    IdentifierTree methodName = ExpressionUtils.methodName(mit);
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(methodName)
      .withMessage(""\""notify\"" may not wake up the appropriate thread."")
      .withQuickFix(() -> JavaQuickFix.newQuickFix(""Replace with \""notifyAll()\"""")
        .addTextEdit(JavaTextEdit.replaceTree(methodName, ""notifyAll""))
        .build())
      .report();
  }
}
"
S2447,CODE_SMELL,"""null"" should not be returned from a ""Boolean"" method","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.SymbolMetadata.NullabilityLevel;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S2447"")
public class BooleanMethodReturnCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    SymbolMetadata metadata = methodTree.symbol().metadata();
    if (returnsBoolean(methodTree) && !metadata.nullabilityData().isNullable(NullabilityLevel.PACKAGE, false, true)) {
      methodTree.accept(new ReturnStatementVisitor());
    }
  }

  private static boolean returnsBoolean(MethodTree methodTree) {
    return methodTree.returnType().symbolType().is(""java.lang.Boolean"");
  }

  private class ReturnStatementVisitor extends BaseTreeVisitor {

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // skip lambdas
    }

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      if (tree.expression().is(Kind.NULL_LITERAL)) {
        reportIssue(tree.expression(), ""Null is returned but a \""Boolean\"" is expected."");
      }
    }

    @Override
    public void visitClass(ClassTree tree) {
      // Do not visit inner classes as methods of inner classes will be visited by main visitor
    }
  }

}
"
S2479,CODE_SMELL,Whitespace and control characters in literals should be explicit,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2479"")
public class ControlCharacterInLiteralCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE_FORMAT = ""Remove the non-escaped \\u%04X character from this literal."";

  private static final String CONTROL_CHARACTERS =
    // ASCII control character, C0 control characters
    ""\u0000-\u0008"" +
    // skip U+000A line feed and U+000B line tabulation tab
    ""\u000C"" +
    // skip U+000D carriage return
    ""\u000E-\u001F"" +
    // stop before U+0020 space and include U+007F(delete) U+0085(next line) U+00A0(no-break space)
    ""\u007F\u0085\u00A0"" +
    // Unicode Whitespace > U+007F
    ""\u1680\u180E\u2000-\u200D\u2028\u2029\u202F\u205F\u2060\u3000\uFEFF"";

  // line tab, vertical tab, character tabulation set, character tabulation with justification, line tabulation set
  private static final String TAB_CHARACTERS = ""\u0009\u000B\u0088\u0089\u008A"";

  private static final Pattern CONTROL_CHARACTERS_PATTERN = Pattern.compile(""["" + CONTROL_CHARACTERS + TAB_CHARACTERS + ""]"");
  private static final Pattern CONTROL_CHARACTERS_WITHOUT_TABS_PATTERN = Pattern.compile(""["" + CONTROL_CHARACTERS + ""]"");

  @RuleProperty(
    key = ""allowTabsInTextBlocks"",
    description = ""Allow tabs in text blocks"",
    defaultValue = ""false"")
  public boolean allowTabsInTextBlocks;

  public ControlCharacterInLiteralCheck() {
    this.allowTabsInTextBlocks = false;
  }


  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.STRING_LITERAL, Tree.Kind.CHAR_LITERAL, Tree.Kind.TEXT_BLOCK);
  }

  @Override
  public void visitNode(Tree tree) {
    LiteralTree literal = (LiteralTree) tree;
    String literalValue = LiteralUtils.getAsStringValue(literal);
    Matcher matcher = null;
    if (allowTabsInTextBlocks && tree.is(Tree.Kind.TEXT_BLOCK)) {
      matcher = CONTROL_CHARACTERS_WITHOUT_TABS_PATTERN.matcher(literalValue);
    } else {
      matcher = CONTROL_CHARACTERS_PATTERN.matcher(literalValue);
    }
    if (matcher.find()) {
      reportIssue(literal,  String.format(MESSAGE_FORMAT, literalValue.codePointAt(matcher.start())));
    }
  }

}
"
S2612,SECURITY_HOTSPOT,Setting loose POSIX file permissions is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2612"")
public class FilePermissionsCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String ISSUE_MESSAGE = ""Make sure this permission is safe."";
  private static final Set<String> POSIX_OTHER_PERMISSIONS = new HashSet<>(Arrays.asList(""OTHERS_READ"", ""OTHERS_WRITE"", ""OTHERS_EXECUTE""));
  private static final MethodMatchers POSIX_FILE_PERMISSIONS_FROM_STRING = MethodMatchers.create()
    .ofTypes(""java.nio.file.attribute.PosixFilePermissions"")
    .names(""fromString"")
    .addParametersMatcher(JAVA_LANG_STRING)
    .build();

  private static final MethodMatchers RUNTIME_EXEC = MethodMatchers.create()
    .ofTypes(""java.lang.Runtime"")
    .names(""exec"")
    .withAnyParameters()
    .build();

  // 'other' group not being 0
  private static final Pattern CHMOD_OCTAL_PATTERN = Pattern.compile(""(^|\\s)[0-7]{2,3}[1-7](\\s|$)"");

  private static final String WHO = ""([ug]*+[ao][ugao]*+)?"";
  // ignoring '-' as it should be safe to explicitly REMOVE permission
  private static final String WHAT = ""[+=]"";
  private static final String WHICH = ""[sStT]*+[rwxX][rwxXsStT]*+"";
  // simplification of all the possible combinations of adding perms to 'other'
  private static final Pattern SIMPLIFIED_CHMOD_OTHER_PATTERN = Pattern.compile(""(^|\\s|,)"" + WHO + WHAT + WHICH + ""(\\s|,|$)"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.IDENTIFIER, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.IDENTIFIER)) {
      checkIdentifier((IdentifierTree) tree);
    } else {
      checkMethodInvocation((MethodInvocationTree) tree);
    }
  }

  private void checkIdentifier(IdentifierTree identifier) {
    if (isPosixPermission(identifier) && isBeingAdded(identifier)) {
      reportIssue(identifier, ISSUE_MESSAGE);
    }
  }

  private static boolean isPosixPermission(IdentifierTree identifier) {
    return POSIX_OTHER_PERMISSIONS.contains(identifier.name())
      && identifier.symbolType().isSubtypeOf(""java.nio.file.attribute.PosixFilePermission"");
  }

  private static boolean isBeingAdded(IdentifierTree identifier) {
    Tree parent = identifier.parent();
    while (parent != null) {
      // Whatever the owner of ""add"" (or ""addAll"") we assume the property is added to be included
      // (""add"" and ""addAll"" are implemented by all classes extending ""java.util.Collection"")
      if (parent.is(Tree.Kind.METHOD_INVOCATION)) {
        String methodName = ((MethodInvocationTree) parent).methodSymbol().name();
        if (methodName.contains(""add"")) {
          return true;
        }
      }
      parent = parent.parent();
    }
    return false;
  }

  private void checkMethodInvocation(MethodInvocationTree mit) {
    if (POSIX_FILE_PERMISSIONS_FROM_STRING.matches(mit)) {
      ExpressionTree arg0 = mit.arguments().get(0);
      if (sensitivePermissionsAsString(arg0)) {
        reportIssue(arg0, ISSUE_MESSAGE);
      }
    } else if (RUNTIME_EXEC.matches(mit)) {
      ExpressionTree arg0 = mit.arguments().get(0);
      Type arg0Type = arg0.symbolType();
      if (arg0Type.is(JAVA_LANG_STRING)) {
        checkExecSingleStringArgument(arg0);
      } else if (arg0Type.is(JAVA_LANG_STRING + ""[]"") && arg0.is(Tree.Kind.NEW_ARRAY)) {
        // only consider explicit array declaration
        checkExecStringArrayArgument((NewArrayTree) arg0);
      }
    }
  }

  private static boolean sensitivePermissionsAsString(ExpressionTree arg0) {
    return arg0.asConstant(String.class)
      .filter(chmod -> chmod.length() == 9)
      .filter(chmod -> !chmod.endsWith(""---""))
      .isPresent();
  }

  private void checkExecSingleStringArgument(ExpressionTree arg0) {
    if (chmodCommand(arg0).filter(FilePermissionsCheck::isSensitiveChmodMode).isPresent()) {
      reportIssue(arg0, ISSUE_MESSAGE);
    }
  }

  private void checkExecStringArrayArgument(NewArrayTree newArrayTree) {
    List<ExpressionTree> initializers = newArrayTree.initializers();
    if (initializers.size() < 3 || !chmodCommand(initializers.get(0)).isPresent()) {
      // malformed or not chmod
      return;
    }
    // check all other arguments against sensitive configuration
    for (int i = 1; i < initializers.size(); i++) {
      ExpressionTree arg = initializers.get(i);
      if (arg.asConstant(String.class).filter(FilePermissionsCheck::isSensitiveChmodMode).isPresent()) {
        reportIssue(arg, ISSUE_MESSAGE);
      }
    }
  }

  private static Optional<String> chmodCommand(ExpressionTree expr) {
    return expr.asConstant(String.class).filter(cmd -> cmd.contains(""chmod""));
  }

  private static boolean isSensitiveChmodMode(String mode) {
    return CHMOD_OCTAL_PATTERN.matcher(mode).find() || SIMPLIFIED_CHMOD_OTHER_PATTERN.matcher(mode).find();
  }
}
"
S2629,CODE_SMELL,"""Preconditions"" and logging arguments should not require evaluation","package org.sonar.java.checks;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S2629"")
public class LazyArgEvaluationCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String STRING = ""java.lang.String"";
  private static final String OBJECT_ARR = ""java.lang.Object[]"";

  private static class SLF4J {

    private static final String[] METHOD_NAMES = {
      ""trace"",
      ""debug"",
      ""info"",
      ""warn"",
      ""error""
    };

    private static final String LOGGER = ""org.slf4j.Logger"";
    private static final String MARKER = ""org.slf4j.Marker"";

    private static final MethodMatchers LOG = MethodMatchers.create()
      .ofSubTypes(LOGGER)
      .names(METHOD_NAMES)
      .addParametersMatcher(STRING)
      .addParametersMatcher(STRING, ANY)
      .addParametersMatcher(STRING, ANY, ANY)
      .addParametersMatcher(STRING, OBJECT_ARR)
      .addParametersMatcher(MARKER, STRING)
      .addParametersMatcher(MARKER, STRING, ANY)
      .addParametersMatcher(MARKER, STRING, ANY, ANY)
      .addParametersMatcher(MARKER, STRING, OBJECT_ARR)
      .build();

    private static final MethodMatchers TEST = MethodMatchers.create()
      .ofSubTypes(LOGGER)
      .names(testMethodNames(METHOD_NAMES))
      .addWithoutParametersMatcher()
      .build();
  }

  private static class JUL {

    private static final String[] METHOD_NAMES = {
      ""severe"",
      ""warning"",
      ""info"",
      ""config"",
      ""fine"",
      ""finer"",
      ""finest""
    };

    private static final String LOGGER = ""java.util.logging.Logger"";

    private static final MethodMatchers LOG = MethodMatchers.or(
      MethodMatchers.create()
        .ofTypes(LOGGER)
        .names(METHOD_NAMES)
        .addParametersMatcher(STRING)
        .build(),
      MethodMatchers.create()
        .ofTypes(LOGGER)
        .names(""log"")
        .addParametersMatcher(""java.util.logging.Level"", STRING)
        .build());

    private static final MethodMatchers TEST = MethodMatchers.create()
      .ofTypes(LOGGER)
      .names(""isLoggable"")
      .addParametersMatcher(""java.util.logging.Level"")
      .build();
  }

  private static class LOG4J {

    private static final String[] METHOD_NAMES = {
      ""debug"",
      ""error"",
      ""fatal"",
      ""info"",
      ""trace"",
      ""warn""
    };

    private static final String LEVEL = ""org.apache.logging.log4j.Level"";
    private static final String LOGGER = ""org.apache.logging.log4j.Logger"";
    private static final String MARKER = ""org.apache.logging.log4j.Marker"";
    private static final Predicate<Type> SUPPLIER = type -> type.isSubtypeOf(""org.apache.logging.log4j.util.Supplier"") ||
      type.isSubtypeOf(""org.apache.logging.log4j.util.MessageSupplier"");

    private static final MethodMatchers LOG = MethodMatchers.or(
      MethodMatchers.create()
        .ofSubTypes(LOGGER)
        .names(METHOD_NAMES)
        .withAnyParameters()
        .build(),
      MethodMatchers.create()
        .ofSubTypes(LOGGER)
        .names(""log"")
        .withAnyParameters()
        .build());

    private static final MethodMatchers TEST = MethodMatchers.or(
      MethodMatchers.create()
        .ofSubTypes(LOGGER)
        .names(testMethodNames(METHOD_NAMES))
        .withAnyParameters()
        .build(),
      MethodMatchers.create()
        .ofSubTypes(LOGGER)
        .names(""isEnabled"")
        .addParametersMatcher(LEVEL)
        .addParametersMatcher(LEVEL, MARKER)
        .build());
  }

  private static final MethodMatchers PRECONDITIONS = MethodMatchers.create()
    .ofTypes(""com.google.common.base.Preconditions"")
    .names(""checkState"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers LAZY_ARG_METHODS = MethodMatchers.or(
    PRECONDITIONS,
    SLF4J.LOG,
    JUL.LOG,
    LOG4J.LOG);

  private static final MethodMatchers LOG_LEVEL_TESTS = MethodMatchers.or(
    SLF4J.TEST,
    JUL.TEST,
    LOG4J.TEST);

  private static String[] testMethodNames(String[] lowerCaseNames) {
    return Stream.of(lowerCaseNames)
      .map(name -> ""is"" + Character.toUpperCase(name.charAt(0)) + name.substring(1) + ""Enabled"")
      .toArray(String[]::new);
  }

  private JavaFileScannerContext context;
  private Deque<Tree> treeStack = new ArrayDeque<>();

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    if (context.getSemanticModel() == null) {
      return;
    }
    scan(context.getTree());
  }

  @Override
  public void visitMethodInvocation(MethodInvocationTree tree) {
    if (LAZY_ARG_METHODS.matches(tree) && !insideCatchStatement() && !insideLevelTest() && !argsUsingSuppliers(tree)) {
      onMethodInvocationFound(tree);
    }
  }

  private static boolean argsUsingSuppliers(MethodInvocationTree tree) {
    return tree.arguments().stream().map(ExpressionTree::symbolType).anyMatch(LOG4J.SUPPLIER);
  }

  @Override
  public void visitIfStatement(IfStatementTree ifTree) {
    LevelTestVisitor levelTestVisitor = new LevelTestVisitor();
    ifTree.condition().accept(levelTestVisitor);
    if (levelTestVisitor.match) {
      stackAndContinue(ifTree, super::visitIfStatement);
    } else {
      super.visitIfStatement(ifTree);
    }
  }

  @Override
  public void visitCatch(CatchTree tree) {
    stackAndContinue(tree, super::visitCatch);
  }

  @Override
  public void visitMethod(MethodTree tree) {
    // we put method trees on stack to be able to detect log statements in anonymous classes
    stackAndContinue(tree, super::visitMethod);
  }

  private boolean insideLevelTest() {
    return treeStack.stream().anyMatch(t -> t.is(Tree.Kind.IF_STATEMENT));
  }

  private boolean insideCatchStatement() {
    return treeStack.peek() != null && treeStack.peek().is(Tree.Kind.CATCH);
  }

  private <T extends Tree> void stackAndContinue(T tree, Consumer<T> visit) {
    treeStack.push(tree);
    visit.accept(tree);
    treeStack.pop();
  }

  private void onMethodInvocationFound(MethodInvocationTree mit) {
    List<JavaFileScannerContext.Location> flow = findStringArg(mit)
      .flatMap(LazyArgEvaluationCheck::checkArgument)
      .toList();
    if (!flow.isEmpty()) {
      context.reportIssue(this, flow.get(0).syntaxNode, flow.get(0).msg, flow.subList(1, flow.size()), null);
    }
  }

  private static Stream<JavaFileScannerContext.Location> checkArgument(ExpressionTree stringArgument) {
    StringExpressionVisitor visitor = new StringExpressionVisitor();
    stringArgument.accept(visitor);
    if (visitor.shouldReport) {
      return Stream.of(locationFromArg(stringArgument, visitor));
    } else {
      return Stream.empty();
    }
  }

  private static JavaFileScannerContext.Location locationFromArg(ExpressionTree stringArgument, StringExpressionVisitor visitor) {
    StringBuilder msg = new StringBuilder();
    if (visitor.hasMethodInvocation) {
      msg.append(""Invoke method(s) only conditionally. "");
    }
    if (visitor.hasBinaryExpression) {
      msg.append(""Use the built-in formatting to construct this argument."");
    }
    return new JavaFileScannerContext.Location(msg.toString(), stringArgument);
  }

  private static Stream<ExpressionTree> findStringArg(MethodInvocationTree mit) {
    return mit.arguments().stream()
      .filter(arg -> arg.symbolType().is(STRING));
  }

  private static class StringExpressionVisitor extends BaseTreeVisitor {

    private boolean hasBinaryExpression;
    private boolean shouldReport;
    private boolean hasMethodInvocation;

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (!isGetter(tree)) {
        shouldReport = true;
        hasMethodInvocation = true;
      }
    }

    private static boolean isGetter(MethodInvocationTree tree) {
      if (isAnnotationMethod(tree)) {
        return true;
      }

      String methodName = tree.methodSymbol().name();
      return tree.methodSymbol().parameterTypes().isEmpty()
        && (methodName.startsWith(""get"") || methodName.startsWith(""is"") || isGetterMatchingFieldNameAndType(tree.methodSymbol()));
    }

    private static boolean isGetterMatchingFieldNameAndType(Symbol.MethodSymbol methodSymbol) {
      Symbol owner = methodSymbol.owner();
      Type getterReturnType = methodSymbol.returnType().type();
      // methodSymbol's owner is always not null and TypeSymbol
      return ((Symbol.TypeSymbol) owner).memberSymbols()
        .stream()
        .filter(symbol -> symbol.isVariableSymbol() && symbol.type().equals(getterReturnType))
        .anyMatch(symbol -> symbol.name().equals(methodSymbol.name()));
    }

    private static boolean isAnnotationMethod(MethodInvocationTree tree) {
      Symbol owner = tree.methodSymbol().owner();
      return owner.isTypeSymbol() && ((Symbol.TypeSymbol) owner).isAnnotation();
    }

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      if (hasBinaryExpression) {
        shouldReport = true;
      }
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      hasMethodInvocation = true;
      shouldReport = true;
    }

    @Override
    public void visitBinaryExpression(BinaryExpressionTree tree) {
      hasBinaryExpression = true;
      if (!isConstant(tree.rightOperand())) {
        tree.rightOperand().accept(this);
      }
      if (!isConstant(tree.leftOperand())) {
        tree.leftOperand().accept(this);
      }
    }

    private static boolean isConstant(ExpressionTree operand) {
      switch (operand.kind()) {
        case BOOLEAN_LITERAL:
        case CHAR_LITERAL:
        case DOUBLE_LITERAL:
        case FLOAT_LITERAL:
        case INT_LITERAL:
        case LONG_LITERAL:
        case STRING_LITERAL:
        case NULL_LITERAL:
          return true;
        case IDENTIFIER:
          return isConstant(((IdentifierTree) operand).symbol());
        case MEMBER_SELECT:
          MemberSelectExpressionTree mset = (MemberSelectExpressionTree) operand;
          return isConstant(mset.identifier().symbol());
        default:
          return false;
      }
    }

    private static boolean isConstant(Symbol symbol) {
      return symbol.isStatic() && symbol.isFinal();
    }
  }

  private static class LevelTestVisitor extends BaseTreeVisitor {
    boolean match = false;

    @Override
    public void visitMethodInvocation(MethodInvocationTree mit) {
      if (LOG_LEVEL_TESTS.matches(mit)) {
        match = true;
      }
    }
  }

}
"
S2638,CODE_SMELL,Method overrides should not change contracts,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.model.JUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.SymbolMetadata.NullabilityData;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.checks.helpers.NullabilityDataUtils.nullabilityAsString;
import static org.sonar.plugins.java.api.semantic.SymbolMetadata.NullabilityLevel.PACKAGE;

@Rule(key = ""S2638"")
public class ChangeMethodContractCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();
    List<Symbol.MethodSymbol> overriddenSymbols = methodSymbol.overriddenSymbols();
    if (overriddenSymbols.isEmpty()) {
      return;
    }
    Symbol.MethodSymbol overridee = overriddenSymbols.get(0);
    if (overridee.isMethodSymbol()) {
      checkContractChange(methodTree, overridee);
    }
  }

  private void checkContractChange(MethodTree methodTree, Symbol.MethodSymbol overridee) {
    if (MethodTreeUtils.isEqualsMethod(methodTree)) {
      // Handled by S4454.
      return;
    }
    for (int i = 0; i < methodTree.parameters().size(); i++) {
      VariableTree parameter = methodTree.parameters().get(i);
      checkParameter(parameter, JUtils.parameterAnnotations(overridee, i));
    }

    // If the method from the parent claims to never return null, the method from the child
    // that can actually be executed at runtime should not return null.
    NullabilityData overrideeNullability = overridee.metadata().nullabilityData();
    if (overrideeNullability.isNonNull(PACKAGE, false, false)) {
      NullabilityData methodNullability = methodTree.symbol().metadata().nullabilityData();
      if (methodNullability.isNullable(PACKAGE, false, false)) {
        // returnType() returns null in case of constructor: the rule does not support them.
        reportIssue(methodTree.returnType(), overrideeNullability, methodNullability);
      }
    }
  }

  private void checkParameter(VariableTree parameter, SymbolMetadata overrideeParamMetadata) {
    // Annotations on parameters is the opposite of return value: if arguments of the parent can be null, the child method has to accept null value.
    NullabilityData overrideeParamNullability = overrideeParamMetadata.nullabilityData();
    if (overrideeParamNullability.isNullable(PACKAGE, false, false)) {
      NullabilityData paramNullability = parameter.symbol().metadata().nullabilityData();
      if (paramNullability.isNonNull(PACKAGE, false, false)) {
        reportIssue(parameter.simpleName(), overrideeParamNullability, paramNullability);
      }
    }
  }

  private void reportIssue(Tree reportLocation, NullabilityData overrideeNullability, NullabilityData otherNullability) {
    Optional<String> overrideeAsString = nullabilityAsString(otherNullability);
    Optional<String> otherAsString = nullabilityAsString(overrideeNullability);
    if (overrideeAsString.isPresent() && otherAsString.isPresent()) {
      reportIssue(reportLocation,
        String.format(""Fix the incompatibility of the annotation %s to honor %s of the overridden method."",
          overrideeAsString.get(),
          otherAsString.get()),
        getSecondariesForAnnotations(otherNullability, overrideeNullability),
        null);
    }
  }

  private static List<JavaFileScannerContext.Location> getSecondariesForAnnotations(NullabilityData childData, NullabilityData parentData) {
    List<JavaFileScannerContext.Location> secondaries = new ArrayList<>();
    Tree childDeclaration = childData.declaration();
    if (childDeclaration != null) {
      secondaries.add(new JavaFileScannerContext.Location(""Child annotation"", childDeclaration));
    }
    Tree parentDeclaration = parentData.declaration();
    if (parentDeclaration != null) {
      secondaries.add(new JavaFileScannerContext.Location(""Overridden annotation"", parentDeclaration));
    }
    return secondaries;
  }

}
"
S2639,BUG,Inappropriate regular expressions should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2639"")
public class InappropriateRegexpCheck extends AbstractMethodDetection {

  private static final String INAPPROPRIATE_REGEXPS = ""[.|]"";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.lang.String"")
      .names(""replaceAll"", ""replaceFirst"")
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree firstArg = mit.arguments().get(0);
    if (isInappropriateRegexpStringLiteral(firstArg) || isFileSeparator(firstArg)) {
      reportIssue(firstArg, ""Correct this regular expression."");
    }
  }

  private static boolean isInappropriateRegexpStringLiteral(ExpressionTree firstArg) {
    return firstArg.asConstant(String.class)
      .filter(regexp -> regexp.matches(INAPPROPRIATE_REGEXPS))
      .isPresent();
  }

  private static boolean isFileSeparator(ExpressionTree firstArg) {
    if (firstArg.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mse = (MemberSelectExpressionTree) firstArg;
      return ""separator"".equals(mse.identifier().name()) && mse.expression().symbolType().is(""java.io.File"");
    }
    return false;
  }

}
"
S2647,VULNERABILITY,Basic authentication should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2647"")
public class BasicAuthCheck extends AbstractMethodDetection {

  private static final String LANG_STRING = ""java.lang.String"";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofSubTypes(""org.apache.http.message.AbstractHttpMessage"").names(""setHeader"").withAnyParameters().build(),
      MethodMatchers.create()
        .ofSubTypes(""org.apache.http.message.AbstractHttpMessage"").names(""addHeader"").addParametersMatcher(LANG_STRING, LANG_STRING).build(),
      MethodMatchers.create()
        .ofSubTypes(""org.apache.http.message.BasicHeader"").constructor().addParametersMatcher(LANG_STRING, LANG_STRING).build(),
      MethodMatchers.create()
        .ofSubTypes(""java.net.URLConnection"").names(""setRequestProperty"").withAnyParameters().build(),
      MethodMatchers.create()
        .ofSubTypes(""java.net.URLConnection"").names(""addRequestProperty"").withAnyParameters().build()
      );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    checkArguments(mit.arguments());
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    checkArguments(newClassTree.arguments());
  }

  private void checkArguments(Arguments arguments) {
    if (""Authorization"".equals(ExpressionsHelper.getConstantValueAsString(arguments.get(0)).value())) {
      ExpressionTree arg = mostLeft(arguments.get(1));
      String authentication = ExpressionsHelper.getConstantValueAsString(arg).value();
      if (authentication != null && authentication.startsWith(""Basic"")) {
        reportIssue(arg, ""Use a more secure method than basic authentication."");
      }
    }
  }

  private static ExpressionTree mostLeft(ExpressionTree arg) {
    ExpressionTree res = ExpressionUtils.skipParentheses(arg);
    while (res.is(Tree.Kind.PLUS)) {
      res = ExpressionUtils.skipParentheses(((BinaryExpressionTree) res).leftOperand());
    }
    return res;
  }
}
"
S2658,VULNERABILITY,Classes should not be loaded dynamically,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2658"")
public class DynamicClassLoadCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofSubTypes(""java.lang.Class"").names(""forName"").withAnyParameters().build(),
      MethodMatchers.create().ofSubTypes(""java.lang.ClassLoader"").names(""loadClass"").withAnyParameters().build());
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    String stringConstant = ExpressionsHelper.getConstantValueAsString(mit.arguments().get(0)).value();
    if (stringConstant == null) {
      reportIssue(ExpressionUtils.methodName(mit), ""Remove this use of dynamic class loading."");
    }
  }

}
"
S2674,BUG,The value returned from a stream read should be checked,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2674"")
public class IgnoredStreamReturnValueCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers MATCHERS = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(""java.io.InputStream"")
      .names(""skip"")
      .addParametersMatcher(""long"")
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""java.io.InputStream"")
      .names(""read"")
      .addParametersMatcher(""byte[]"")
      .build());

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.EXPRESSION_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ExpressionTree statement = ((ExpressionStatementTree) tree).expression();
    if (statement.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) statement;
      if (MATCHERS.matches(mit)) {
        reportIssue(ExpressionUtils.methodName(mit), ""Check the return value of the \"""" + mit.methodSymbol().name() + ""\"" call to see how many bytes were read."");
      }
    }
  }

}
"
S2675,CODE_SMELL,"""readObject"" should not be ""synchronized""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2675"")
public class ReadObjectSynchronizedCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (implementsSerializable(classTree)) {
      for (Tree member : classTree.members()) {
        if (member.is(Tree.Kind.METHOD)) {
          checkMember((MethodTree) member);
        }
      }
    }
  }

  private void checkMember(MethodTree member) {
    if (isReadObject(member)) {
      ModifierKeywordTree modifier = ModifiersUtils.getModifier(member.modifiers(), Modifier.SYNCHRONIZED);
      if (modifier != null) {
        reportIssue(modifier.keyword(), ""Remove the \""synchronized\"" keyword from this method."");
      }
    }
  }

  private static boolean implementsSerializable(ClassTree classTree) {
    return classTree.symbol().type().isSubtypeOf(""java.io.Serializable"");
  }

  private static boolean isReadObject(MethodTree methodTree) {
    return ""readObject"".equals(methodTree.simpleName().name())
      && methodTree.parameters().size() == 1
      && methodTree.parameters().get(0).type().symbolType().is(""java.io.ObjectInputStream"");
  }

}
"
S2676,BUG,"""Math.abs"" and negation should not be used on numbers that could be ""MIN_VALUE""","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.ParenthesizedTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

@Rule(key = ""S2676"")
public class AbsOnNegativeCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers MATH_ABS_METHODS =
    MethodMatchers.create()
      .ofTypes(""java.lang.Math"")
      .names(""abs"")
      .addParametersMatcher(""int"")
      .addParametersMatcher(""long"")
      .build();

  private static final MethodMatchers NEGATIVE_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofAnyType()
      .names(""hashCode"")
      .addWithoutParametersMatcher()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""java.util.Random"")
      .names(""nextInt"", ""nextLong"")
      .addWithoutParametersMatcher()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""java.lang.Comparable"")
      .names(""compareTo"")
      .addParametersMatcher(MethodMatchers.ANY)
      .build()
  );

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.UNARY_MINUS);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree methodTree = (MethodInvocationTree) tree;
      if (MATH_ABS_METHODS.matches(methodTree)) {
        ExpressionTree firstArgument = methodTree.arguments().get(0);
        checkForIssue(firstArgument);
      }
    } else {
      ExpressionTree operand = ((UnaryExpressionTree) tree).expression();
      checkForIssue(operand);
    }
  }

  private void checkForIssue(ExpressionTree tree) {
    if (tree.is(Tree.Kind.MEMBER_SELECT)) {
      Symbol identifierSymbol = ((MemberSelectExpressionTree) tree).identifier().symbol();
      Type ownerType = identifierSymbol.owner().type();
      if (""MIN_VALUE"".equals(identifierSymbol.name()) && (ownerType.is(""java.lang.Integer"") || ownerType.is(""java.lang.Long""))) {
        reportIssue(tree, ""Use the original value instead."");
      }
    } else {
      MethodInvocationTree nestedTree = extractMethodInvocation(tree);
      if (nestedTree != null && NEGATIVE_METHODS.matches(nestedTree)) {
        reportIssue(nestedTree, ""Use the original value instead."");
      }
    }
  }

  @CheckForNull
  private static MethodInvocationTree extractMethodInvocation(ExpressionTree tree) {
    ExpressionTree result = tree;
    while (true) {
      if (result.is(Tree.Kind.TYPE_CAST)) {
        result = ((TypeCastTree) result).expression();
      } else if (result.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {
        result = ((ParenthesizedTree) result).expression();
      } else if (result.is(Tree.Kind.METHOD_INVOCATION)) {
        return (MethodInvocationTree) result;
      } else {
        return null;
      }
    }
  }

}
"
S2677,BUG,"""read"" and ""readLine"" return values should be used","package org.sonar.java.checks.unused;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2677"")
public class UnusedReturnedDataCheck extends IssuableSubscriptionVisitor {

  private static final List<MethodMatchers> CHECKED_METHODS = Arrays.asList(
    MethodMatchers.create()
      .ofSubTypes(""java.io.BufferedReader"")
      .names(""readLine"")
      .addWithoutParametersMatcher()
    .build(),
    MethodMatchers.create()
      .ofSubTypes(""java.io.Reader"")
      .names(""read"")
      .addWithoutParametersMatcher()
      .build());

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.EXPRESSION_STATEMENT, Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.EXPRESSION_STATEMENT)) {
      CHECKED_METHODS.stream()
        .map(matcher -> isTreeMethodInvocation(((ExpressionStatementTree) tree).expression(), matcher))
        .filter(Objects::nonNull)
        .forEach(mit -> raiseIssue(ExpressionUtils.methodName(mit)));
    } else {
      BinaryExpressionTree expressionTree = (BinaryExpressionTree) tree;
      ExpressionTree leftOperand = expressionTree.leftOperand();
      ExpressionTree rightOperand = expressionTree.rightOperand();
      for (MethodMatchers matcher : CHECKED_METHODS) {
        MethodInvocationTree leftMit = isTreeMethodInvocation(leftOperand, matcher);
        if (leftMit != null && isTreeLiteralNull(rightOperand)) {
          raiseIssue(ExpressionUtils.methodName(leftMit));
        }
        MethodInvocationTree rightMit = isTreeMethodInvocation(rightOperand, matcher);
        if (rightMit != null && isTreeLiteralNull(leftOperand)) {
          raiseIssue(ExpressionUtils.methodName(rightMit));
        }
      }
    }
  }

  @CheckForNull
  private static MethodInvocationTree isTreeMethodInvocation(ExpressionTree tree, MethodMatchers matcher) {
    Tree expression = ExpressionUtils.skipParentheses(tree);
    if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree methodInvocation = (MethodInvocationTree) expression;
      if (matcher.matches(methodInvocation)) {
        return methodInvocation;
      }
    }
    return null;
  }

  private static boolean isTreeLiteralNull(ExpressionTree tree) {
    return ExpressionUtils.skipParentheses(tree).is(Tree.Kind.NULL_LITERAL);
  }

  private void raiseIssue(IdentifierTree identifierTree) {
    reportIssue(identifierTree, String.format(""Use or store the value returned from \""%s\"" instead of throwing it away."", identifierTree.identifierToken().text()));
  }

}
"
S2681,CODE_SMELL,Multiline blocks should be enclosed in curly braces,"package org.sonar.java.checks;

import java.util.Locale;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

@Rule(key = ""S2681"")
public class MultilineBlocksCurlyBracesCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String LOOP_MESSAGE = ""This line will not be executed in a loop; only the first line of this %d-line block will be. The rest will execute only once."";
  private static final String LOOP_MESSAGE_ONE_LINER = ""This statement will not be executed in a loop; only the first statement will be. The rest will execute only once."";
  private static final String IF_MESSAGE = ""This line will not be executed conditionally; "" +
    ""only the first line of this %d-line block will be. The rest will execute unconditionally."";
  private static final String IF_MESSAGE_ONE_LINER = ""This statement will not be executed conditionally; only the first statement will be. The rest will execute unconditionally."";
  private JavaFileScannerContext context;

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitBlock(BlockTree tree) {
    super.visitBlock(tree);
    StatementTree previous = null;
    for (StatementTree current : tree.body()) {
      if (previous != null) {
        check(current, previous);
      }
      previous = current;
    }
  }

  private void check(StatementTree current, StatementTree previous) {
    StatementTree block = null;
    boolean condition = false;
    if (previous.is(Tree.Kind.FOR_EACH_STATEMENT)) {
      block = ((ForEachStatement) previous).statement();
    } else if (previous.is(Tree.Kind.FOR_STATEMENT)) {
      block = ((ForStatementTree) previous).statement();
    } else if (previous.is(Tree.Kind.WHILE_STATEMENT)) {
      block = ((WhileStatementTree) previous).statement();
    } else if (previous.is(Tree.Kind.IF_STATEMENT)) {
      block = getIfStatementLastBlock(previous);
      condition = true;
    }
    if (block != null && !block.is(Tree.Kind.BLOCK)) {
      Position previousTokenStart = Position.startOf(block);
      int previousColumn = previousTokenStart.column();
      int previousLine = previousTokenStart.line();
      Position currentTokenStart = Position.startOf(current);
      int currentColumn = currentTokenStart.column();
      int currentLine = currentTokenStart.line();
      if ((previousColumn == currentColumn && previousLine + 1 == currentLine)
        || (previousLine == Position.startOf(previous).line() && Position.startOf(previous).column() < currentColumn)) {
        int lines = 1 + currentLine - previousLine;
        context.reportIssue(this, current, getMessage(condition, lines));
      }
    }
  }

  private static String getMessage(boolean ifStatementMessage, int lines) {
    if (lines == 1) {
      return ifStatementMessage ? IF_MESSAGE_ONE_LINER : LOOP_MESSAGE_ONE_LINER;
    }
    return String.format(Locale.US, ifStatementMessage ? IF_MESSAGE : LOOP_MESSAGE, lines);
  }

  private static StatementTree getIfStatementLastBlock(StatementTree statementTree) {
    StatementTree block = statementTree;
    while (block.is(Tree.Kind.IF_STATEMENT)) {
      IfStatementTree ifStatementTree = (IfStatementTree) block;
      StatementTree elseStatement = ifStatementTree.elseStatement();
      block = elseStatement == null ? ifStatementTree.thenStatement() : elseStatement;
    }
    return block;
  }
}
"
S2692,CODE_SMELL,"""indexOf"" checks should not be for positive numbers","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ReassignmentFinder;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2692"")
public class IndexOfWithPositiveNumberCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String INDEX_OF = ""indexOf"";

  private static final MethodMatchers CHECKED_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(JAVA_LANG_STRING)
      .names(INDEX_OF)
      .addParametersMatcher(""int"")
      .addParametersMatcher(JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""java.util.List"")
      .names(INDEX_OF)
      .addParametersMatcher(""java.lang.Object"")
      .build());

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.GREATER_THAN, Tree.Kind.LESS_THAN);
  }

  @Override
  public void visitNode(Tree tree) {
    BinaryExpressionTree binaryTree = (BinaryExpressionTree) tree;
    if (tree.is(Tree.Kind.GREATER_THAN)) {
      checkForIssue(tree, binaryTree.leftOperand(),
        LiteralUtils.longLiteralValue(retrieveClosestAssignmentIfAny(binaryTree.rightOperand())));
    } else {
      checkForIssue(tree, binaryTree.rightOperand(),
        LiteralUtils.longLiteralValue(retrieveClosestAssignmentIfAny(binaryTree.leftOperand())));
    }
  }

  private static ExpressionTree retrieveClosestAssignmentIfAny(ExpressionTree expression) {
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) expression;
      ExpressionTree reassignmentOrDeclaration = ReassignmentFinder.getClosestReassignmentOrDeclarationExpression(expression,
        identifier.symbol());
      if (reassignmentOrDeclaration != null) {
        return reassignmentOrDeclaration;
      }
    }
    return expression;
  }

  private void checkForIssue(Tree tree, ExpressionTree operand, @Nullable Long constant) {
    if (constant != null && constant == 0 && isIndexOfOnArrayOrString(operand)) {
      reportIssue(tree, ""0 is a valid index, but is ignored by this check."");
    }
  }

  private static boolean isIndexOfOnArrayOrString(Tree tree) {
    return tree.is(Tree.Kind.METHOD_INVOCATION) && CHECKED_METHODS.matches((MethodInvocationTree) tree);
  }

}
"
S2693,CODE_SMELL,Threads should not be started in constructors,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import org.apache.commons.lang3.BooleanUtils;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2693"")
public class ThreadStartedInConstructorCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers THREAD_START = MethodMatchers.create()
    .ofSubTypes(""java.lang.Thread"")
    .names(""start"")
    .addWithoutParametersMatcher()
    .build();

  private final Deque<Boolean> inMethodOrStaticInitializerOrFinalClass = new LinkedList<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.RECORD, Tree.Kind.METHOD, Tree.Kind.METHOD_INVOCATION, Tree.Kind.STATIC_INITIALIZER);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.CLASS, Tree.Kind.RECORD)) {
      inMethodOrStaticInitializerOrFinalClass.push(((ClassTree) tree).symbol().isFinal());
    } else if (tree.is(Tree.Kind.METHOD, Tree.Kind.STATIC_INITIALIZER)) {
      inMethodOrStaticInitializerOrFinalClass.push(Boolean.TRUE);
    } else if (BooleanUtils.isFalse(inMethodOrStaticInitializerOrFinalClass.peek()) && THREAD_START.matches((MethodInvocationTree) tree)) {
      reportIssue(ExpressionUtils.methodName((MethodInvocationTree) tree), ""Move this \""start\"" call to another method."");
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.CLASS, Tree.Kind.METHOD, Tree.Kind.STATIC_INITIALIZER)) {
      inMethodOrStaticInitializerOrFinalClass.pop();
    }
  }

}
"
S2694,CODE_SMELL,"Inner classes which do not reference their owning classes should be ""static""","package org.sonar.java.checks;

import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2694"")
public class InnerStaticClassesCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;
  private Deque<Symbol> outerClasses = new LinkedList<>();
  private Deque<Boolean> atLeastOneReference = new LinkedList<>();

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    Symbol.TypeSymbol symbol = tree.symbol();
    outerClasses.push(symbol);
    atLeastOneReference.push(Boolean.FALSE);
    scan(tree.members());
    Boolean oneReference = atLeastOneReference.pop();
    outerClasses.pop();
    if (!symbol.isStatic()
      && !Boolean.TRUE.equals(oneReference)
      && !isParameterizedWithTypeVarFromParent(tree)
      && couldBeDeclaredStatic(symbol)) {
      Tree reportTree = tree.simpleName();
      if(reportTree == null) {
        // Ignore issues on anonymous classes
        return;
      }
      String message = ""Make this a \""static\"" inner class."";
      if(symbol.owner().isMethodSymbol()) {
        message = ""Extract this local class into a \""static\"" inner class."";
      }
      context.reportIssue(this, reportTree, message);
    }
  }

  private boolean couldBeDeclaredStatic(Symbol.TypeSymbol symbol) {
    Type superClass = symbol.superClass();
    if (superClass != null) {
      Symbol superClassSymbol = superClass.symbol();
      if (!superClassSymbol.owner().isPackageSymbol() && !superClassSymbol.isStatic()) {
        return false;
      }
    }
    if (outerClasses.size() == 1) {
      return true;
    }
    for (Symbol outerClass : outerClasses) {
      if (outerClass.isStatic()) {
        return true;
      }
    }
    return false;
  }

  private static boolean isParameterizedWithTypeVarFromParent(ClassTree tree) {
    if (!tree.typeParameters().isEmpty()) {
      return false;
    }
    List<ParameterizedTypeTree> parameterizedSuperTypes = new LinkedList<>();
    TypeTree superClass = tree.superClass();
    if (superClass != null && superClass.is(Tree.Kind.PARAMETERIZED_TYPE)) {
      parameterizedSuperTypes.add((ParameterizedTypeTree) superClass);
    }
    for (TypeTree typeTree : tree.superInterfaces()) {
      if (typeTree.is(Tree.Kind.PARAMETERIZED_TYPE)) {
        parameterizedSuperTypes.add((ParameterizedTypeTree) typeTree);
      }
    }

    return parameterizedSuperTypes.stream()
      .flatMap(parameterizedTypeTree -> parameterizedTypeTree.typeArguments().stream())
      .map(TypeTree::symbolType)
      .anyMatch(Type::isTypeVar);
  }

  @Override
  public void visitIdentifier(IdentifierTree tree) {
    super.visitIdentifier(tree);
    checkSymbol(tree.symbol());
  }

  @Override
  public void visitNewClass(NewClassTree tree) {
    super.visitNewClass(tree);
    checkSymbol(tree.symbolType().symbol());
  }

  private void checkSymbol(Symbol symbol) {
    if (!atLeastOneReference.isEmpty()) {
      int level = referenceInstance(symbol);
      if (level >= 0) {
        for (int i = 0; i < level; i++) {
          atLeastOneReference.pop();
        }
        while (atLeastOneReference.size() != outerClasses.size()) {
          atLeastOneReference.push(Boolean.TRUE);
        }
      }
    }
  }

  private int referenceInstance(Symbol symbol) {
    Symbol owner = symbol.owner();
    if(owner != null && owner.isMethodSymbol()) {
      //local variable, use owner of the method
      owner = owner.owner();
    }
    int result = -1;
    if (owner != null && !outerClasses.peek().equals(owner)) {
      if (symbol.isUnknown()) {
        result = atLeastOneReference.size() - 1;
      } else if (!symbol.isStatic()) {
        result = fromInstance(symbol, owner);
      }
    }
    return result;
  }

  private int fromInstance(Symbol symbol, Symbol owner) {
    int i = -1;
    Type ownerType = owner.type();
    for (Symbol outerClass : outerClasses) {
      i++;
      if (symbol.equals(outerClass) || (ownerType != null && owner.isTypeSymbol() && outerClass.type().isSubtypeOf(ownerType))) {
        return i;
      }
    }
    return -1;
  }

  @Override
  public void visitVariable(VariableTree tree) {
    Symbol symbol = tree.symbol();
    if (symbol != null && !symbol.isStatic()) {
      scan(tree.modifiers());
      scan(tree.type());
      // skip the simple name
      scan(tree.initializer());
    }
  }

  @Override
  public void visitMethod(MethodTree tree) {
    scan(tree.modifiers());
    scan(tree.typeParameters());
    scan(tree.returnType());
    // skip the simple name
    scan(tree.parameters());
    scan(tree.defaultValue());
    scan(tree.throwsClauses());
    scan(tree.block());
  }
}
"
S2695,BUG,"""PreparedStatement"" and ""ResultSet"" methods should be called with valid indices","package org.sonar.java.checks;

import java.util.Optional;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ReassignmentFinder;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S2695"")
public class PreparedStatementAndResultSetCheck extends AbstractMethodDetection {

  private static final String INT = ""int"";
  private static final String JAVA_SQL_RESULTSET = ""java.sql.ResultSet"";
  private static final MethodMatchers PREPARE_STATEMENT = MethodMatchers.create()
    .ofTypes(""java.sql.Connection"").name(name -> name.startsWith(""prepareStatement"")).withAnyParameters().build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofTypes(""java.sql.PreparedStatement"").name(name -> name.startsWith(""set"")).addParametersMatcher(INT, ANY).build(),
      MethodMatchers.create().ofTypes(JAVA_SQL_RESULTSET).name(name -> name.startsWith(""get"")).addParametersMatcher(INT).addParametersMatcher(INT, ANY).build()
    );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree firstArgument = mit.arguments().get(0);
    Optional<Integer> firstArgumentAsConstant = firstArgument.asConstant(Integer.class);
    if (!firstArgumentAsConstant.isPresent()) {
      // nothing to say if first argument can not be evaluated
      return;
    }

    boolean isMethodFromJavaSqlResultSet = mit.methodSymbol().owner().type().is(JAVA_SQL_RESULTSET);
    int methodFirstArgumentValue = firstArgumentAsConstant.get();

    if (isMethodFromJavaSqlResultSet && methodFirstArgumentValue == 0) {
      reportIssue(firstArgument, ""ResultSet indices start at 1."");
    } else if (!isMethodFromJavaSqlResultSet) {
      if (methodFirstArgumentValue == 0) {
        reportIssue(firstArgument, ""PreparedStatement indices start at 1."");
      } else {
        ExpressionTree preparedStatementReference = getPreparedStatementReference(mit);
        Integer numberParameters = getPreparedStatementNumberOfParameters(preparedStatementReference);
        if (numberParameters != null && methodFirstArgumentValue > numberParameters) {
          reportIssue(firstArgument, ""This \""PreparedStatement\"" "" + (numberParameters == 0 ? ""has no"" : (""only has "" + numberParameters)) + "" parameters."");
        }
      }
    }
  }

  @CheckForNull
  private static ExpressionTree getPreparedStatementReference(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree expression = ((MemberSelectExpressionTree) methodSelect).expression();
      if (expression.is(Tree.Kind.IDENTIFIER)) {
        Symbol referenceSymbol = ((IdentifierTree) expression).symbol();
        return ReassignmentFinder.getClosestReassignmentOrDeclarationExpression(mit, referenceSymbol);
      }
    }
    return null;
  }

  @CheckForNull
  private static Integer getPreparedStatementNumberOfParameters(@Nullable ExpressionTree tree) {
    if (tree != null && tree.is(Tree.Kind.METHOD_INVOCATION)) {
      Arguments arguments = ((MethodInvocationTree) tree).arguments();
      if (!arguments.isEmpty() && PREPARE_STATEMENT.matches((MethodInvocationTree) tree)) {
        ExpressionTree firstArgument = arguments.get(0);
        return getNumberQuery(firstArgument, firstArgument);
      }
    }
    return null;
  }@CheckForNull
  private static Integer getNumberQuery(ExpressionTree expression, Tree startingPointForReassignment) {
    ExpressionTree expr = ExpressionUtils.skipParentheses(expression);
    if (expr.is(Tree.Kind.IDENTIFIER)) {
      return handleVariableUsedAsQuery((IdentifierTree) expr, startingPointForReassignment);
    } else if (expr.is(Tree.Kind.PLUS)) {
      return handleStringConcatenation((BinaryExpressionTree) expr, startingPointForReassignment);
    }
    return countQuery(expr);
  }

  private static Integer handleVariableUsedAsQuery(IdentifierTree identifier, Tree startingPointForReassignment) {
    ExpressionTree lastAssignmentExpr = ReassignmentFinder.getClosestReassignmentOrDeclarationExpression(startingPointForReassignment, identifier.symbol());
    if (lastAssignmentExpr != null) {
      Tree lastAssignment = lastAssignmentExpr.parent();
      if (lastAssignment.is(Tree.Kind.PLUS_ASSIGNMENT)) {
        return zeroIfNull(getNumberQuery(lastAssignmentExpr, lastAssignment))
          + zeroIfNull(getNumberQuery(((AssignmentExpressionTree) lastAssignment).variable(), lastAssignment));
      }
      // If the current assignment contains the identifier, we have to update the starting point for reassignment to avoid infinite recursion.
      return getNumberQuery(lastAssignmentExpr, lastAssignment);
    }
    return null;
  }

  private static Integer handleStringConcatenation(BinaryExpressionTree expr, Tree startingPointForReassignment) {
    Integer left = getNumberQuery(expr.leftOperand(), startingPointForReassignment);
    Integer right = getNumberQuery(expr.rightOperand(), startingPointForReassignment);
    return (left == null && right == null) ? null : (zeroIfNull(left) + zeroIfNull(right));
  }

  private static int zeroIfNull(@Nullable Integer intValue) {
    return intValue == null ? 0 : intValue;
  }

  @CheckForNull
  private static Integer countQuery(ExpressionTree expression) {
    return expression.is(Tree.Kind.STRING_LITERAL) ? StringUtils.countMatches(((LiteralTree) expression).value(), ""?"") : null;
  }
}
"
S2696,CODE_SMELL,"Instance methods should not write to ""static"" fields","package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ArrayAccessExpressionTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

@Rule(key = ""S2696"")
public class StaticFieldUpateCheck extends AbstractInSynchronizeChecker {

  private static final Kind[] ASSIGNMENT_EXPRESSIONS = new Kind[]{
    Kind.AND_ASSIGNMENT,
    Kind.ASSIGNMENT,
    Kind.DIVIDE_ASSIGNMENT,
    Kind.LEFT_SHIFT_ASSIGNMENT,
    Kind.MINUS_ASSIGNMENT,
    Kind.MULTIPLY_ASSIGNMENT,
    Kind.OR_ASSIGNMENT,
    Kind.PLUS_ASSIGNMENT,
    Kind.REMAINDER_ASSIGNMENT,
    Kind.UNSIGNED_RIGHT_SHIFT_ASSIGNMENT,
    Kind.XOR_ASSIGNMENT};

  private static final Kind[] UNARY_EXPRESSIONS = new Kind[]{
    Kind.POSTFIX_DECREMENT,
    Kind.POSTFIX_INCREMENT,
    Kind.PREFIX_DECREMENT,
    Kind.PREFIX_INCREMENT};

  private Deque<Boolean> withinStaticMethod = new LinkedList<>();

  @Override
  public List<Kind> nodesToVisit() {
    ArrayList<Kind> nodesToVisit = new ArrayList<>(super.nodesToVisit());
    nodesToVisit.add(Kind.STATIC_INITIALIZER);
    nodesToVisit.addAll(Arrays.asList(ASSIGNMENT_EXPRESSIONS));
    nodesToVisit.addAll(Arrays.asList(UNARY_EXPRESSIONS));
    return nodesToVisit;
  }

  @Override
  public void visitNode(Tree tree) {
    // use AbstractInSynchronizeChecker logic to check synchronized blocks
    super.visitNode(tree);

    if (tree.is(Kind.METHOD)) {
      withinStaticMethod.push(isMethodStatic((MethodTree) tree));
    } else if (tree.is(Kind.STATIC_INITIALIZER)) {
      withinStaticMethod.push(true);
    } else if (isInInstanceMethod() && !hasAnyParentStatic() && !hasAnyParentSync()) {
      if (tree.is(ASSIGNMENT_EXPRESSIONS)) {
        checkVariableModification(((AssignmentExpressionTree) tree).variable());
      } else if (tree.is(UNARY_EXPRESSIONS)) {
        checkVariableModification(((UnaryExpressionTree) tree).expression());
      }
    }
  }

  private boolean hasAnyParentStatic() {
    return withinStaticMethod.contains(true);
  }

  private boolean isInInstanceMethod() {
    return !withinStaticMethod.isEmpty() && !withinStaticMethod.peek();
  }

  private static boolean isMethodStatic(MethodTree tree) {
    return ModifiersUtils.hasModifier(tree.modifiers(), Modifier.STATIC);
  }

  @Override
  public void leaveNode(Tree tree) {
    // use AbstractInSynchronizeChecker logic to keep updated synchronized blocks tracking
    super.leaveNode(tree);

    if (tree.is(Tree.Kind.METHOD, Kind.STATIC_INITIALIZER)) {
      withinStaticMethod.pop();
    }
  }

  private void checkVariableModification(ExpressionTree expression) {
    if (expression.is(Kind.IDENTIFIER)) {
      checkFieldModification((IdentifierTree) expression);
    } else if (expression.is(Kind.MEMBER_SELECT)) {
      checkFieldModification(((MemberSelectExpressionTree) expression).identifier());
    } else if (expression.is(Kind.ARRAY_ACCESS_EXPRESSION)) {
      checkVariableModification(((ArrayAccessExpressionTree) expression).expression());
    }
  }

  private void checkFieldModification(IdentifierTree identifier) {
    Symbol variable = identifier.symbol();
    if (isStaticField(variable)) {
      reportIssue(identifier, ""Make the enclosing method \""static\"" or remove this set."");
    }
  }

  private static boolean isStaticField(Symbol symbol) {
    return symbol.isVariableSymbol()
      && symbol.owner().isTypeSymbol()
      && symbol.isStatic();
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.none();
  }
}
"
S2698,CODE_SMELL,Test assertions should include messages,"package org.sonar.java.checks.tests;

import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.plugins.java.api.semantic.Type.Primitives.DOUBLE;
import static org.sonar.plugins.java.api.semantic.Type.Primitives.FLOAT;

@Rule(key = ""S2698"")
public class AssertionsWithoutMessageCheck extends AbstractMethodDetection {

  private static final String MESSAGE = ""Add a message to this assertion."";
  private static final String MESSAGE_FEST_LIKE = ""Add a message to this assertion chain before the predicate method."";
  private static final String ASSERT = ""assert"";

  private static final String JAVA_LANG_STRING = ""java.lang.String"";

  private static final String FEST_GENERIC_ASSERT = ""org.fest.assertions.GenericAssert"";
  private static final String ASSERTJ_ABSTRACT_ASSERT = ""org.assertj.core.api.AbstractAssert"";
  private static final MethodMatchers FEST_LIKE_MESSAGE_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(FEST_GENERIC_ASSERT).names(""as"", ""describedAs"", ""overridingErrorMessage"")
      .addParametersMatcher(types -> matchFirstParameterWithAnyOf(types, JAVA_LANG_STRING, ""org.fest.assertions.Description"")).build(),
    MethodMatchers.create()
      .ofSubTypes(ASSERTJ_ABSTRACT_ASSERT).names(""as"", ""describedAs"", ""withFailMessage"", ""overridingErrorMessage"")
      .addParametersMatcher(types -> matchFirstParameterWithAnyOf(types, JAVA_LANG_STRING, ""org.assertj.core.description.Description""))
      .build()
  );

  private static final Set<String> ASSERT_METHODS_WITH_ONE_PARAM = SetUtils.immutableSetOf(""assertNull"", ""assertNotNull"");
  private static final Set<String> ASSERT_METHODS_WITH_TWO_PARAMS = SetUtils.immutableSetOf(""assertEquals"", ""assertSame"", ""assertNotSame"", ""assertThat"");
  private static final Set<String> JUNIT5_ASSERT_METHODS_IGNORED = SetUtils.immutableSetOf(""assertAll"", ""assertLinesMatch"");
  private static final Set<String> JUNIT5_ASSERT_METHODS_WITH_ONE_PARAM = SetUtils.immutableSetOf(""assertTrue"", ""assertFalse"", ""assertNull"", ""assertNotNull"", ""assertDoesNotThrow"");
  private static final Set<String> JUNIT5_ASSERT_METHODS_WITH_DELTA = SetUtils.immutableSetOf(""assertArrayEquals"", ""assertEquals"");

  private static final MethodMatchers FEST_LIKE_ABSTRACT_ASSERT = MethodMatchers.create()
    .ofSubTypes(FEST_GENERIC_ASSERT, ASSERTJ_ABSTRACT_ASSERT).anyName().withAnyParameters().build();

  private static final MethodMatchers ASSERT_THAT_MATCHER = MethodMatchers.create()
    .ofSubTypes(""org.assertj.core.api.Assertions"",
      ""org.assertj.core.api.AssertionsForInterfaceTypes"",
      ""org.assertj.core.api.AssertionsForClassTypes"",
      ""org.fest.assertions.Assertions"")
    .names(""assertThat"", ""assertThatObject"").withAnyParameters().build();

  private static final MethodMatchers ASSERT_SETTING_CONTEXT = MethodMatchers.create()
    .ofSubTypes(ASSERTJ_ABSTRACT_ASSERT)
      .name(name -> name.startsWith(""extracting"") || name.startsWith(""using"") || name.startsWith(""filtered""))
      .withAnyParameters()
      .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofTypes(""org.junit.jupiter.api.Assertions"", ""org.junit.Assert"", ""junit.framework.Assert"", ""org.fest.assertions.Fail"",
          ""org.assertj.core.api.Fail"")
        .name(name -> name.startsWith(ASSERT) || ""fail"".equals(name)).withAnyParameters().build(),
      FEST_LIKE_ABSTRACT_ASSERT
      );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    Symbol symbol = mit.methodSymbol();
    Type type = symbol.owner().type();

    if (FEST_LIKE_MESSAGE_METHODS.matches(mit) || ASSERT_SETTING_CONTEXT.matches(mit)) {
      // If we can establish that the currently tested method is the one adding a message or not an assertion predicate,
      // we have very easily shown that this rule does not apply.
      return;
    }

    IdentifierTree reportLocation = ExpressionUtils.methodName(mit);

    if (type.isSubtypeOf(FEST_GENERIC_ASSERT) || type.isSubtypeOf(ASSERTJ_ABSTRACT_ASSERT)) {
      checkFestLikeAssertion(mit, symbol, reportLocation);
    } else if (type.is(""org.junit.jupiter.api.Assertions"")) {
      checkJUnit5(mit, reportLocation);
    } else if (mit.arguments().isEmpty() || !isString(mit.arguments().get(0)) || isAssertingOnStringWithNoMessage(mit)) {
      reportIssue(reportLocation, MESSAGE);
    }
  }

  private void checkFestLikeAssertion(MethodInvocationTree mit, Symbol symbol, IdentifierTree reportLocation) {
    if (isConstructor(symbol)) {
      return;
    }
    if (isFirstAssertingPredicateAfterAssertThat(mit)) {
      // If we have anything between the current assertion predicate and the assertion subject, it's either
      // - another assertion predicate: the issue will be raised on this one (if problematic)
      // - a message: compliant solution
      reportIssue(reportLocation, MESSAGE_FEST_LIKE);
    }
  }

  private static boolean isFirstAssertingPredicateAfterAssertThat(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree expression = ((MemberSelectExpressionTree) methodSelect).expression();
      if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree childMit = (MethodInvocationTree) expression;
        if (ASSERT_THAT_MATCHER.matches(childMit)) {
          return true;
        } else if (ASSERT_SETTING_CONTEXT.matches(childMit)) {
          return isFirstAssertingPredicateAfterAssertThat(childMit);
        }
      }
    }
    return false;
  }

  private void checkJUnit5(MethodInvocationTree mit, IdentifierTree reportLocation) {
    String methodName = mit.methodSymbol().name();
    if (JUNIT5_ASSERT_METHODS_IGNORED.contains(methodName)) {
      return;
    }

    if (mit.arguments().isEmpty()) {
      reportIssue(reportLocation, MESSAGE);
    } else if (""fail"".equals(methodName)) {
      if (mit.arguments().size() == 1 && mit.arguments().get(0).symbolType().isSubtypeOf(""java.lang.Throwable"")) {
        reportIssue(reportLocation, MESSAGE);
      }
    } else {
      checkJUnit5Assertions(mit, reportLocation);
    }
  }

  private void checkJUnit5Assertions(MethodInvocationTree mit, IdentifierTree reportLocation) {
    String methodName = mit.methodSymbol().name();
    if (JUNIT5_ASSERT_METHODS_WITH_ONE_PARAM.contains(methodName)) {
      if (mit.arguments().size() == 1) {
        reportIssue(reportLocation, MESSAGE);
      }
    } else if (mit.arguments().size() == 2) {
      reportIssue(reportLocation, MESSAGE);
    } else if (JUNIT5_ASSERT_METHODS_WITH_DELTA.contains(methodName) && mit.arguments().size() == 3) {
      Type thirdArgumentType = mit.arguments().get(2).symbolType();
      if (thirdArgumentType.isPrimitive(DOUBLE) || thirdArgumentType.isPrimitive(FLOAT)) {
        reportIssue(reportLocation, MESSAGE);
      }
    }
  }

  private static Boolean matchFirstParameterWithAnyOf(List<Type> parameterTypes, String... acceptableTypes) {
    if (!parameterTypes.isEmpty()) {
      Type firstParamType = parameterTypes.get(0);
      for (String acceptableType : acceptableTypes) {
        if (firstParamType.is(acceptableType)) {
          return true;
        }
      }
    }
    return false;
  }

  private static boolean isConstructor(Symbol symbol) {
    return ""<init>"".equals(symbol.name());
  }

  private static boolean isAssertingOnStringWithNoMessage(MethodInvocationTree mit) {
    return isAssertWithTwoParams(mit) || isAssertWithOneParam(mit);
  }

  private static boolean isAssertWithOneParam(MethodInvocationTree mit) {
    return ASSERT_METHODS_WITH_ONE_PARAM.contains(mit.methodSymbol().name()) && mit.arguments().size() == 1;
  }

  private static boolean isAssertWithTwoParams(MethodInvocationTree mit) {
    return ASSERT_METHODS_WITH_TWO_PARAMS.contains(mit.methodSymbol().name()) && mit.arguments().size() == 2;
  }

  private static boolean isString(ExpressionTree expressionTree) {
    return expressionTree.symbolType().is(JAVA_LANG_STRING);
  }

}
"
S2699,CODE_SMELL,Tests should include assertions,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.AbstractAssertionVisitor;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;

import static org.apache.commons.lang3.StringUtils.isEmpty;
import static org.sonar.java.checks.helpers.UnitTestUtils.isUnitTest;

@Rule(key = ""S2699"")
public class AssertionsInTestsCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final Logger LOG = LoggerFactory.getLogger(AssertionsInTestsCheck.class);

  @RuleProperty(
    key = ""customAssertionMethods"",
    description = ""Comma-separated list of fully qualified method symbols that should be considered as assertion methods. "" +
      ""The wildcard character can be used at the end of the method name."",
    defaultValue = """")
  public String customAssertionMethods = """";
  private MethodMatchers customAssertionMethodsMatcher = null;

  private final Map<Symbol, Boolean> assertionInMethod = new HashMap<>();
  private JavaFileScannerContext context;

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    if (context.getSemanticModel() == null) {
      // requires semantic
      return;
    }
    this.context = context;
    assertionInMethod.clear();
    scan(context.getTree());
    assertionInMethod.clear();
  }

  @Override
  public void visitMethod(MethodTree methodTree) {
    if (ModifiersUtils.hasModifier(methodTree.modifiers(), Modifier.ABSTRACT)) {
      return;
    }

    if (isUnitTest(methodTree) && !isSpringBootSanityTest(methodTree) && !expectAssertion(methodTree) && !isLocalMethodWithAssertion(methodTree.symbol())) {
      context.reportIssue(this, methodTree.simpleName(), ""Add at least one assertion to this test case."");
    }
  }

  private static boolean isSpringBootSanityTest(MethodTree methodTree){
    if(""contextLoads"".equals(methodTree.simpleName().name())){
      ClassTree classTree = (ClassTree) methodTree.parent();
      return classTree.symbol().metadata().isAnnotatedWith(""org.springframework.boot.test.context.SpringBootTest"");
    }
    return false;
  }

  private boolean isLocalMethodWithAssertion(Symbol symbol) {
    if (!assertionInMethod.containsKey(symbol)) {
      assertionInMethod.put(symbol, false);
      Tree declaration = symbol.declaration();
      if (declaration != null) {
        AssertionVisitor assertionVisitor = new AssertionVisitor(getCustomAssertionMethodsMatcher());
        declaration.accept(assertionVisitor);
        assertionInMethod.put(symbol, assertionVisitor.hasAssertion());
      }
    }

    return assertionInMethod.get(symbol);
  }

  private MethodMatchers getCustomAssertionMethodsMatcher() {
    if (customAssertionMethodsMatcher == null) {
      String[] fullyQualifiedMethodSymbols = customAssertionMethods.isEmpty() ? new String[0] : customAssertionMethods.split("","");
      List<MethodMatchers> customMethodMatchers = new ArrayList<>(fullyQualifiedMethodSymbols.length);
      for (String fullyQualifiedMethodSymbol : fullyQualifiedMethodSymbols) {
        String[] methodMatcherParts = fullyQualifiedMethodSymbol.split(""#"");
        if (methodMatcherParts.length == 2 && !isEmpty(methodMatcherParts[0].trim()) && !isEmpty(methodMatcherParts[1].trim())) {
          String methodName = methodMatcherParts[1].trim();
          Predicate<String> namePredicate;
          if (methodName.endsWith(""*"")) {
            namePredicate = name -> name.startsWith(methodName.substring(0, methodName.length() - 1));
          } else {
            namePredicate = name -> name.equals(methodName);
          }
          customMethodMatchers.add(MethodMatchers.create().ofSubTypes(methodMatcherParts[0].trim()).name(namePredicate).withAnyParameters().build());
        } else {
          LOG.warn(""Unable to create a corresponding matcher for custom assertion method, please check the format of the following symbol: '{}'"", fullyQualifiedMethodSymbol);
        }
      }

      customAssertionMethodsMatcher = MethodMatchers.or(customMethodMatchers);
    }

    return customAssertionMethodsMatcher;
  }

  private static boolean expectAssertion(MethodTree methodTree) {
    List<SymbolMetadata.AnnotationValue> annotationValues = methodTree.symbol().metadata().valuesForAnnotation(""org.junit.Test"");
    if (annotationValues != null) {
      for (SymbolMetadata.AnnotationValue annotationValue : annotationValues) {
        if (""expected"".equals(annotationValue.name())) {
          return true;
        }
      }
    }
    return false;
  }

  private class AssertionVisitor extends AbstractAssertionVisitor {
    private MethodMatchers customMethodsMatcher;

    private AssertionVisitor(MethodMatchers customMethodsMatcher) {
      this.customMethodsMatcher = customMethodsMatcher;
    }

    @Override
    protected boolean isAssertion(Symbol methodSymbol) {
      return customMethodsMatcher.matches(methodSymbol) || isLocalMethodWithAssertion(methodSymbol);
    }
  }

}
"
S2701,CODE_SMELL,Literal boolean values and nulls should not be used in assertions,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;

import java.util.List;
import java.util.Optional;

@Rule(key = ""S2701"")
public class BooleanOrNullLiteralInAssertionsCheck extends AbstractMethodDetection {
  private static final String DEFAULT_MESSAGE = ""Remove or correct this assertion."";
  private static final String MESSAGE_WITH_ALTERNATIVE = ""Use %s instead."";
  private static final String ASSERT = ""assert"";
  private static final String IS = ""is"";

  private static final MethodMatchers FEST_ASSERT_THAT = MethodMatchers.create()
    .ofTypes(""org.fest.assertions.Assertions"")
    .names(""assertThat"")
    .addParametersMatcher(MethodMatchers.ANY)
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofTypes(
          ""org.junit.Assert"",
          ""org.junit.jupiter.api.Assertions"",
          ""junit.framework.Assert"",
          ""junit.framework.TestCase"")
        .name(name -> name.startsWith(ASSERT))
        .withAnyParameters()
        .build(),
      MethodMatchers.create()
        .ofSubTypes(""org.fest.assertions.GenericAssert"")
        .name(name -> name.startsWith(IS))
        .withAnyParameters()
        .build()
      );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    switch (mit.methodSymbol().name()) {
      case ""assertEquals"":
      case ""assertSame"":
        checkEqualityAsserts(mit, false);
        break;

      case ""assertNotEquals"":
      case ""assertNotSame"":
        checkEqualityAsserts(mit, true);
        break;

      case ""isEqualTo"":
      case ""isSameAs"":
        checkFestEqualityAsserts(mit, false);
        break;

      case ""isNotEqualTo"":
      case ""isNotSameAs"":
        checkFestEqualityAsserts(mit, true);
        break;

      default:
        checkOtherAsserts(mit);
        break;
    }
  }

  private void checkEqualityAsserts(MethodInvocationTree mit, boolean flipped) {
    List<LiteralTree> literals = findLiterals(mit.arguments());
    IdentifierTree methodName = ExpressionUtils.methodName(mit);
    if (literals.size() > 1) {
      reportDefaultMessage(methodName, literals);
    } else if (literals.size() == 1) {
      checkEqualityAssertWithOneLiteral(methodName, literals.get(0), flipped, ASSERT);
    }
  }

  private void checkFestEqualityAsserts(MethodInvocationTree mit, boolean flipped) {
    if (mit.arguments().isEmpty()) {
      return;
    }
    Optional<LiteralTree> expectedLiteral = getBoolOrNullLiteral(mit.arguments().get(0));
    Optional<LiteralTree> actualLiteral = findActualLiteralForFest(mit);
    IdentifierTree methodName = ExpressionUtils.methodName(mit);
    if (expectedLiteral.isPresent() && actualLiteral.isPresent()) {
      reportDefaultMessage(methodName, Arrays.asList(expectedLiteral.get(), actualLiteral.get()));
    } else {
      expectedLiteral.ifPresent(literal -> checkEqualityAssertWithOneLiteral(methodName, literal, flipped, IS));
      actualLiteral.ifPresent(literal -> checkEqualityAssertWithOneLiteral(methodName, literal, flipped, IS));
    }
  }

  private void checkEqualityAssertWithOneLiteral(IdentifierTree methodName, LiteralTree literal, boolean flipped, String assertOrIs) {
    String predicate;
    if (literal.is(Tree.Kind.NULL_LITERAL)) {
      predicate = flipped ? ""NotNull"" : ""Null"";
    } else {
      Optional<Boolean> value = literal.asConstant(Boolean.class);
      if (!value.isPresent()) {
        return;
      }
      if (Boolean.TRUE.equals(value.get())) {
        predicate = flipped ? ""False"" : ""True"";
      } else {
        predicate = flipped ? ""True"" : ""False"";
      }
    }
    String recommendedAssertMethod = assertOrIs + predicate;
    List<JavaFileScannerContext.Location> secondaryLocation = Collections.singletonList(
      new JavaFileScannerContext.Location(""This literal can be avoided by using a different assertion method."", literal)
    );
    String mainMessage = String.format(MESSAGE_WITH_ALTERNATIVE, recommendedAssertMethod);
    reportIssue(methodName, mainMessage, secondaryLocation, null);
  }

  private void checkOtherAsserts(MethodInvocationTree mit) {
    List<LiteralTree> literals = findLiterals(mit.arguments());
    Optional<LiteralTree> festActualLiteral = findActualLiteralForFest(mit);
    festActualLiteral.ifPresent(literals::add);
    if (!literals.isEmpty()) {
      reportDefaultMessage(ExpressionUtils.methodName(mit), literals);
    }
  }

  private static List<LiteralTree> findLiterals(List<ExpressionTree> expressions) {
    List<LiteralTree> result = new ArrayList<>();
    for (ExpressionTree expression : expressions) {
      getBoolOrNullLiteral(expression).ifPresent(result::add);
    }
    return result;
  }

  private static Optional<LiteralTree> findActualLiteralForFest(MethodInvocationTree mit) {
    if (FEST_ASSERT_THAT.matches(mit)) {
      return getBoolOrNullLiteral(mit.arguments().get(0));
    }
    if (mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree member = (MemberSelectExpressionTree) mit.methodSelect();
      if (member.expression().is(Tree.Kind.METHOD_INVOCATION)) {
        return findActualLiteralForFest((MethodInvocationTree) member.expression());
      }
    }
    return Optional.empty();
  }private static Optional<LiteralTree> getBoolOrNullLiteral(ExpressionTree expr) {
    if (expr.is(Tree.Kind.TYPE_CAST)) {
      return getBoolOrNullLiteral(((TypeCastTree) expr).expression());
    } else if (expr.is(Tree.Kind.NULL_LITERAL) || expr.is(Tree.Kind.BOOLEAN_LITERAL)) {
      return Optional.of((LiteralTree) expr);
    } else {
      return Optional.empty();
    }
  }

  private void reportDefaultMessage(IdentifierTree methodName, List<LiteralTree> literals) {
    List<JavaFileScannerContext.Location> literalLocations = literals.stream()
      .map(literal -> new JavaFileScannerContext.Location(""There does not seem to be a reason to use a literal here."", literal))
      .toList();
    reportIssue(methodName, DEFAULT_MESSAGE, literalLocations, null);
  }
}
"
S2718,CODE_SMELL,"""DateUtils.truncate"" from Apache Commons Lang library should not be used","package org.sonar.java.checks;

import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2718"")
public class DateUtilsTruncateCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final Set<String> FIRST_PARAMETER_TYPES = SetUtils.immutableSetOf(
    ""java.util.Date"", ""java.util.Calendar"", ""java.lang.Object"");

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava8Compatible();
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""org.apache.commons.lang.time.DateUtils"")
      .names(""truncate"")
      .addParametersMatcher(
        params -> params.size() == 2 &&
          FIRST_PARAMETER_TYPES.contains(params.get(0).fullyQualifiedName()) &&
          params.get(1).is(""int""))
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Use \""ZonedDateTime.truncatedTo\"" instead."" + context.getJavaVersion().java8CompatibilityMessage());
  }

}
"
S2737,CODE_SMELL,"""catch"" clauses should do more than rethrow","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2737"")
public class CatchRethrowingCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRY_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    TryStatementTree tst = (TryStatementTree) tree;
    if (tst.catches().size() == 1) {
      CatchTree catchTree = tst.catches().get(0);
      if (onlyRethrows(catchTree)) {
        reportIssue(catchTree.block().body().get(0), ""Add logic to this catch clause or eliminate it and rethrow the exception automatically."");
      }
    }
  }

  private static boolean onlyRethrows(CatchTree catchTree) {
    List<StatementTree> catchBody = catchTree.block().body();
    if (catchBody.size() == 1) {
      return catchBody.get(0).is(Tree.Kind.THROW_STATEMENT) && catchTree.parameter().symbol().usages().contains(((ThrowStatementTree) catchBody.get(0)).expression());
    }
    return false;
  }
}
"
S2757,BUG,"Non-existent operators like ""=+"" should not be used","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S2757"")
public class WrongAssignmentOperatorCheck extends IssuableSubscriptionVisitor {

  private static final Set<String> SUSPICIOUS_TOKEN_VALUES = SetUtils.immutableSetOf(""!"", ""+"", ""-"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.ASSIGNMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    AssignmentExpressionTree aeTree = (AssignmentExpressionTree) tree;
    SyntaxToken operatorToken = aeTree.operatorToken();
    SyntaxToken expressionFirstToken = aeTree.expression().firstToken();
    SyntaxToken variableLastToken = aeTree.variable().lastToken();
    if (isSuspiciousToken(expressionFirstToken)
      && noSpacingBetween(operatorToken, expressionFirstToken)
      && !noSpacingBetween(variableLastToken, operatorToken)) {
      reportIssue(operatorToken, expressionFirstToken, getMessage(expressionFirstToken, aeTree));
    }
  }

  private static String getMessage(SyntaxToken expressionFirstToken, AssignmentExpressionTree aeTree) {
    if (isSingleNegationAssignment(expressionFirstToken, aeTree)) {
      return ""Add a space between \""=\"" and \""!\"" to avoid confusion."";
    }
    return ""Was \"""" + expressionFirstToken.text() + ""=\"" meant instead?"";
  }

  private static boolean isSingleNegationAssignment(SyntaxToken firstToken, AssignmentExpressionTree aeTree) {
    return ""!"".equals(firstToken.text()) && (aeTree.parent() == null || !aeTree.parent().is(Tree.Kind.ASSIGNMENT));
  }

  private static boolean noSpacingBetween(SyntaxToken firstToken, SyntaxToken secondToken) {
    return Position.endOf(firstToken).equals(Position.startOf(secondToken));
  }

  private static boolean isSuspiciousToken(SyntaxToken firstToken) {
    return SUSPICIOUS_TOKEN_VALUES.contains(firstToken.text());
  }
}
"
S2761,BUG,Unary prefix operators should not be repeated,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

@Rule(key = ""S2761"")
public class DoublePrefixOperatorCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.LOGICAL_COMPLEMENT, Tree.Kind.BITWISE_COMPLEMENT, Tree.Kind.UNARY_PLUS, Tree.Kind.UNARY_MINUS);
  }

  private Set<ExpressionTree> prefixSet = new HashSet<>();

  @Override
  public void setContext(JavaFileScannerContext context) {
    prefixSet.clear();
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    UnaryExpressionTree exprTree = (UnaryExpressionTree) tree;
    if (alreadyReported(exprTree)) {
      return;
    }
    ExpressionTree expr = ExpressionUtils.skipParentheses(exprTree.expression());
    if (exprTree.is(expr.kind())) {
      UnaryExpressionTree child = (UnaryExpressionTree) expr;
      if (child.is(Tree.Kind.BITWISE_COMPLEMENT) && !ExpressionUtils.skipParentheses(child.expression()).is(Tree.Kind.BITWISE_COMPLEMENT)) {
        return;
      }
      prefixSet.add(child);
      reportIssue(exprTree.operatorToken(), child.operatorToken(), ""Remove multiple operator prefixes."");
    }
  }

  private boolean alreadyReported(UnaryExpressionTree tree) {
    if (prefixSet.contains(tree)) {
      return true;
    }
    Tree parent = tree;
    while (parent.is(Tree.Kind.PARENTHESIZED_EXPRESSION, Tree.Kind.BITWISE_COMPLEMENT, Tree.Kind.LOGICAL_COMPLEMENT, Tree.Kind.UNARY_PLUS, Tree.Kind.UNARY_MINUS)) {
      parent = parent.parent();
      if (prefixSet.contains(parent)) {
        return true;
      }
    }
    return false;
  }

}
"
S2786,CODE_SMELL,"Nested ""enum""s should not be declared static","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2786"")
public class NestedEnumStaticCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    ModifierKeywordTree staticKeyword = ModifiersUtils.getModifier(classTree.modifiers(), Modifier.STATIC);
    if (staticKeyword != null) {
      List<JavaFileScannerContext.Location> secondary = Collections.singletonList(new JavaFileScannerContext.Location("""", classTree.declarationKeyword()));
      reportIssue(staticKeyword, ""Remove this redundant \""static\"" qualifier; nested enum types are implicitly static."", secondary, null);
    }
  }
}
"
S2789,BUG,"""null"" should not be used with ""Optional""","package org.sonar.java.checks;

import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonarsource.analyzer.commons.collections.SetUtils;

import static org.sonar.java.checks.helpers.NullabilityDataUtils.nullabilityAsString;


@Rule(key = ""S2789"")
public class NullShouldNotBeUsedWithOptionalCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final Set<String> OPTIONAL_CLASSES = SetUtils.immutableSetOf(""java.util.Optional"", ""com.google.common.base.Optional"");

  private JavaFileScannerContext context;

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitMethod(MethodTree method) {
    if (!method.is(Tree.Kind.CONSTRUCTOR) && returnsOptional(method)) {

      // check that the method is not annotated with @Nullable
      checkNullability(method.symbol(), ""Methods with an \""Optional\"" return type should not be \""%s\""."");

      // check that the method does not return ""null""
      method.accept(new ReturnNullVisitor());
    }

    super.visitMethod(method);
  }

  @Override
  public void visitBinaryExpression(BinaryExpressionTree binaryExpression) {
    // check that an @Optional is not compared to ""null""
    if (binaryExpression.is(Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO)) {
      ExpressionTree left = binaryExpression.leftOperand();
      ExpressionTree right = binaryExpression.rightOperand();
      if ((isOptional(left) && isNull(right)) || (isNull(left) && isOptional(right))) {
        context.reportIssue(this, binaryExpression, ""Ensure this \""Optional\"" could never be null and remove this null-check."");
      }
    }

    super.visitBinaryExpression(binaryExpression);
  }

  @Override
  public void visitAssignmentExpression(AssignmentExpressionTree assignment) {
    if (isOptional(assignment.variable()) && isNull(assignment.expression())) {
      context.reportIssue(this, assignment.expression(), ""Replace this null literal by an \""Optional\"" object."");
    }
    super.visitAssignmentExpression(assignment);
  }

  @Override
  public void visitVariable(VariableTree variable) {
    if (isOptionalType(variable.type())) {
      checkNullability(variable.symbol(), ""\""Optional\"" variables should not be \""%s\""."");
      ExpressionTree initializer = variable.initializer();
      if (initializer != null && isNull(initializer)) {
        context.reportIssue(this, initializer, ""Replace this null literal by an \""Optional\"" object."");
      }
    }

    super.visitVariable(variable);
  }

  private class ReturnNullVisitor extends BaseTreeVisitor {

    @Override
    public void visitReturnStatement(ReturnStatementTree returnStatement) {
      checkNull(returnStatement.expression());

      super.visitReturnStatement(returnStatement);
    }

    @Override
    public void visitConditionalExpression(ConditionalExpressionTree conditionalExpression) {
      if (isOptionalType(conditionalExpression)) {
        checkNull(conditionalExpression.trueExpression());
        checkNull(conditionalExpression.falseExpression());
      }

      super.visitConditionalExpression(conditionalExpression);
    }

    private void checkNull(ExpressionTree expression) {
      if (isNull(expression)) {
        context.reportIssue(NullShouldNotBeUsedWithOptionalCheck.this, expression, ""Methods with an \""Optional\"" return type should never return null."");
      }
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // don't visit lambdas, as they are allowed to return null
    }

    @Override
    public void visitClass(ClassTree tree) {
      // don't visit inner class tree, as methods in there will be visited by outer class
    }


  }

  private static boolean returnsOptional(MethodTree method) {
    return isOptionalType(method.returnType());
  }

  private static boolean isOptional(ExpressionTree expression) {
    return isOptionalType(expression) && !isNull(expression);
  }

  private static boolean isOptionalType(TypeTree type) {
    return isOptionalType(type.symbolType());
  }

  private static boolean isOptionalType(ExpressionTree expression) {
    return isOptionalType(expression.symbolType());
  }

  private static boolean isOptionalType(Type type) {
    return OPTIONAL_CLASSES.contains(type.fullyQualifiedName());
  }

  private static boolean isNull(ExpressionTree expression) {
    return expression.is(Tree.Kind.NULL_LITERAL);
  }

  private void checkNullability(Symbol symbol, String messageFormat) {
    SymbolMetadata.NullabilityLevel level;
    if (symbol.isVariableSymbol()) {
      level = SymbolMetadata.NullabilityLevel.VARIABLE;
    } else {
      level = SymbolMetadata.NullabilityLevel.METHOD;
    }
    SymbolMetadata.NullabilityData nullabilityData = symbol.metadata().nullabilityData();
    if (nullabilityData.isNullable(level, true, false)) {
      Tree annotationTree = nullabilityData.declaration();
      if (annotationTree != null) {
        nullabilityAsString(nullabilityData).ifPresent(annotationText ->
          context.reportIssue(
            this,
            annotationTree,
            String.format(messageFormat, annotationText)
          )
        );
      }
    }
  }

}
"
S2864,CODE_SMELL,"""entrySet()"" should be iterated when both the key and value are needed","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.ListUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S2864"")
public class KeySetInsteadOfEntrySetCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers MAP_GET_METHOD = MethodMatchers.create()
    .ofSubTypes(""java.util.Map"")
    .names(""get"")
    .addParametersMatcher(""java.lang.Object"")
    .build();

  private static final MethodMatchers MAP_KEYSET_METHOD = MethodMatchers.create()
    .ofSubTypes(""java.util.Map"")
    .names(""keySet"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.FOR_EACH_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ForEachStatement forEachTree = (ForEachStatement) tree;
    ExpressionTree expressionTree = forEachTree.expression();
    if (expressionTree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree methodTree = (MethodInvocationTree) expressionTree;
      Symbol ownerSymbol = getOwnerSymbol(methodTree);
      if (ownerSymbol != null && MAP_KEYSET_METHOD.matches(methodTree)) {
        new GetUsageVisitor().isCallingGetWithSymbol(forEachTree, forEachTree.variable().symbol(), ownerSymbol);
      }
    }
  }

  @CheckForNull
  private static Symbol getOwnerSymbol(MethodInvocationTree tree) {
    ExpressionTree expressionTree = tree.methodSelect();
    // direct invocation: symbol is implicitly this
    if (expressionTree.is(Tree.Kind.IDENTIFIER)) {
      return tree.methodSymbol().owner();
    }
    expressionTree = ((MemberSelectExpressionTree) expressionTree).expression();
    if (expressionTree.is(Tree.Kind.IDENTIFIER)) {
      return ((IdentifierTree) expressionTree).symbol();
    } else {
      return getFieldAccessedUsingSuperOrThis(expressionTree);
    }
  }

  @CheckForNull
  private static Symbol getFieldAccessedUsingSuperOrThis(ExpressionTree expressionTree) {
    if (expressionTree.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree memberSelectTree = (MemberSelectExpressionTree) expressionTree;
      if (memberSelectTree.expression().is(Tree.Kind.IDENTIFIER)) {
        String identifierText = ((IdentifierTree) memberSelectTree.expression()).identifierToken().text();
        if (""super"".equals(identifierText) || ""this"".equals(identifierText)) {
          return memberSelectTree.identifier().symbol();
        }
      }
    }
    return null;
  }

  private class GetUsageVisitor extends BaseTreeVisitor {
    private Symbol variable;
    private boolean result;
    private Symbol mapSymbol;

    public void isCallingGetWithSymbol(ForEachStatement forEachTree, Symbol variable, Symbol mapSymbol) {
      this.variable = variable;
      result = false;
      this.mapSymbol = mapSymbol;
      scan(forEachTree.statement());
      if (result) {
        reportIssue(forEachTree.forKeyword(), ""Iterate over the \""entrySet\"" instead of the \""keySet\""."");
      }
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (MAP_GET_METHOD.matches(tree)) {
        Tree firstArgument = ListUtils.getOnlyElement(tree.arguments());
        if (mapSymbol.equals(getOwnerSymbol(tree)) && firstArgument.is(Tree.Kind.IDENTIFIER) && ((IdentifierTree) firstArgument).symbol().equals(variable)) {
          result = true;
          return;
        }
      }
      super.visitMethodInvocation(tree);
    }
  }

}
"
S2885,BUG,Non-thread-safe fields should not be static,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import javax.annotation.CheckForNull;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2885"")
public class StaticMultithreadedUnsafeFieldsCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_TEXT_SIMPLE_DATE_FORMAT = ""java.text.SimpleDateFormat"";
  private static final String[] FORBIDDEN_TYPES = {JAVA_TEXT_SIMPLE_DATE_FORMAT, ""java.util.Calendar"", ""javax.xml.xpath.XPath"", ""javax.xml.validation.SchemaFactory""};
  private static final MethodMatchers GET_DATE_INSTANCE = MethodMatchers.create()
    .ofTypes(""java.text.DateFormat"")
    .names(""getDateInstance"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.VARIABLE);
  }

  @Override
  public void visitNode(Tree tree) {
    VariableTree variableTree = (VariableTree) tree;
    Type type = variableTree.type().symbolType();
    if (ModifiersUtils.hasModifier(variableTree.modifiers(), Modifier.STATIC) && isForbidden(variableTree)) {
      if (type.isSubtypeOf(JAVA_TEXT_SIMPLE_DATE_FORMAT) && onlySynchronizedUsages((Symbol.VariableSymbol) variableTree.symbol())) {
        return;
      }
      IdentifierTree identifierTree = variableTree.simpleName();
      reportIssue(identifierTree, String.format(""Make \""%s\"" an instance variable."", identifierTree.name()));
    }
  }

  private static boolean isForbidden(VariableTree variableTree) {
    if (isForbiddenType(variableTree.type().symbolType())) {
      return true;
    }
    ExpressionTree initializer = variableTree.initializer();
    if (initializer == null || initializer.is(Tree.Kind.NULL_LITERAL)) {
      return false;
    }
    return isForbiddenType(initializer.symbolType())
      || (initializer.is(Tree.Kind.METHOD_INVOCATION) && GET_DATE_INSTANCE.matches((MethodInvocationTree) initializer));
  }

  private static boolean isForbiddenType(Type type) {
    for (String name : FORBIDDEN_TYPES) {
      if (type.isSubtypeOf(name)) {
        return true;
      }
    }
    return false;
  }

  private static boolean onlySynchronizedUsages(Symbol.VariableSymbol variable) {
    List<IdentifierTree> usages = variable.usages();
    if (usages.isEmpty()) {
      return false;
    }
    for (IdentifierTree usage : usages) {
      SynchronizedStatementTree synchronizedStatementTree = getParentSynchronizedStatement(usage);
      if (synchronizedStatementTree == null) {
        // used outside a synchronized statement
        return false;
      } else {
        ExpressionTree expression = synchronizedStatementTree.expression();
        if (!expression.is(Tree.Kind.IDENTIFIER) || !variable.equals(((IdentifierTree) expression).symbol())) {
          // variable is not the expression synchronized
          return false;
        }
        // check other usages
      }
    }
    return true;
  }

  @CheckForNull
  private static SynchronizedStatementTree getParentSynchronizedStatement(IdentifierTree usage) {
    Tree parent = usage.parent();
    while (parent != null && !parent.is(Tree.Kind.SYNCHRONIZED_STATEMENT)) {
      parent = parent.parent();
    }
    if (parent == null) {
      return null;
    }
    return (SynchronizedStatementTree) parent;
  }

}
"
S2886,BUG,Getters and setters should be synchronized in pairs,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collection;
import java.util.Collections;
import java.util.List;

@Rule(key = ""S2886"")
public class SyncGetterAndSetterCheck extends IssuableSubscriptionVisitor {

  private static final GetSetPredicate SETTER = new GetSetPredicate() {
    @Override
    public String getStartName() {
      return ""set"";
    }

    @Override
    public boolean apply(MethodTree methodTree) {
      return methodTree.simpleName().name().startsWith(getStartName()) && methodTree.parameters().size() == 1 && methodTree.returnType().symbolType().is(""void"");
    }
  };
  private static final GetSetPredicate GETTER = new GetSetPredicate() {
    @Override
    public String getStartName() {
      return ""get"";
    }

    @Override
    public boolean apply(MethodTree methodTree) {
      return methodTree.simpleName().name().startsWith(getStartName()) && methodTree.parameters().isEmpty() && !methodTree.returnType().symbolType().is(""void"");
    }
  };
  private static final GetSetPredicate GETTER_BOOLEAN = new GetSetPredicate() {
    @Override
    public String getStartName() {
      return ""is"";
    }

    @Override
    public boolean apply(MethodTree methodTree) {
      return methodTree.simpleName().name().startsWith(getStartName()) && methodTree.parameters().isEmpty() && !methodTree.returnType().symbolType().is(""void"");
    }
  };

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    checkMethodTree(methodTree, GETTER, SETTER);
    checkMethodTree(methodTree, GETTER_BOOLEAN, SETTER);
    checkMethodTree(methodTree, SETTER, GETTER);
    checkMethodTree(methodTree, SETTER, GETTER_BOOLEAN);
  }

  private void checkMethodTree(MethodTree methodTree, GetSetPredicate ownPredicate, GetSetPredicate pairPredicate) {
    if (isSynchronized(methodTree) && ownPredicate.apply(methodTree)) {
      // Synchronized getter, lookup the setter.
      Symbol.TypeSymbol owner = (Symbol.TypeSymbol) methodTree.symbol().owner();
      Collection<Symbol> pairedMethods = owner.lookupSymbols(pairPredicate.getStartName() + methodTree.symbol().name().substring(ownPredicate.getStartName().length()));
      pairedMethods.stream()
        .filter(Symbol::isMethodSymbol)
        .map(symbol -> (MethodTree) symbol.declaration())
        .filter(pairMethod -> pairPredicate.apply(pairMethod) && !isSynchronized(pairMethod))
        .forEach(pairMethod -> {
          String otherMethodName = methodTree.simpleName().name();
          reportIssue(pairMethod.simpleName(), String.format(""Synchronize this method to match the synchronization on \""%s\""."", otherMethodName),
            Collections.singletonList(new JavaFileScannerContext.Location(String.format(""%s method."", otherMethodName), methodTree.simpleName())), null);
        });
    }
  }

  private static boolean isSynchronized(MethodTree methodTree) {
    return ModifiersUtils.hasModifier(methodTree.modifiers(), Modifier.SYNCHRONIZED) || hasSingleSyncStatement(methodTree);
  }

  private static boolean hasSingleSyncStatement(MethodTree methodTree) {
    BlockTree blockTree = methodTree.block();
    if (blockTree != null && blockTree.body().size() == 1 && blockTree.body().get(0).is(Tree.Kind.SYNCHRONIZED_STATEMENT)) {
      SynchronizedStatementTree sync = (SynchronizedStatementTree) blockTree.body().get(0);
      return ExpressionUtils.isThis(sync.expression());
    }
    return false;
  }

  private interface GetSetPredicate {
    String getStartName();

    boolean apply(MethodTree methodTree);
  }

}
"
S2924,CODE_SMELL,JUnit rules should be used,"package org.sonar.java.checks.unused;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S2924"")
public class UnusedTestRuleCheck extends IssuableSubscriptionVisitor {

  private static final Set<String> CHECKED_RULE = SetUtils.immutableSetOf(
    ""org.junit.rules.TemporaryFolder"",
    ""org.junit.rules.TestName""
  );

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    for (Tree member : classTree.members()) {
      if (member.is(Tree.Kind.VARIABLE)) {
        VariableTree variableTree = (VariableTree) member;
        Symbol symbol = variableTree.symbol();
        if ((isTestNameOrTemporaryFolderRule(symbol) || hasTempDirAnnotation(symbol)) && symbol.usages().isEmpty()) {
          reportIssue(variableTree.simpleName(), ""Remove this unused \"""" + getSymbolType(symbol) + ""\""."");
        }
      } else if (member.is(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR)) {
        checkJUnit5((MethodTree) member);
      }
    }
  }

  private void checkJUnit5(MethodTree member) {
    for (VariableTree param : member.parameters()) {
      Symbol symbol = param.symbol();
      if ((hasTempDirAnnotation(symbol) || symbol.type().is(""org.junit.jupiter.api.TestInfo"")) && symbol.usages().isEmpty()) {
        reportIssue(param.simpleName(), ""Remove this unused \"""" + getSymbolType(symbol) + ""\""."");
      }
    }
  }

  private static boolean isTestNameOrTemporaryFolderRule(Symbol symbol) {
    return symbol.metadata().isAnnotatedWith(""org.junit.Rule"") && CHECKED_RULE.contains(symbol.type().fullyQualifiedName());
  }

  private static boolean hasTempDirAnnotation(Symbol symbol) {
    return symbol.metadata().isAnnotatedWith(""org.junit.jupiter.api.io.TempDir"");
  }

  private static String getSymbolType(Symbol symbol) {
    return hasTempDirAnnotation(symbol) ? ""TempDir"" : symbol.type().toString();
  }

}
"
S2925,CODE_SMELL,"""Thread.sleep"" should not be used in tests","package org.sonar.java.checks.tests;

import java.util.Objects;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S2925"")
public class ThreadSleepInTestsCheck extends AbstractMethodDetection {
  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    String name = Objects.requireNonNull(mit.methodSymbol().owner()).type().name();
    reportIssue(ExpressionUtils.methodName(mit), String.format(""Remove this use of \""%s.sleep()\""."", name));
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(MethodMatchers.create().ofTypes(""java.lang.Thread"").names(""sleep"").withAnyParameters().build(),
      MethodMatchers.create().ofTypes(""java.util.concurrent.TimeUnit"").names(""sleep"").withAnyParameters().build());
  }
}
"
S2959,CODE_SMELL,Unnecessary semicolons should be omitted,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.ListUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ListTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2959"")
public class UnnecessarySemicolonCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRY_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ListTree<Tree> resources = ((TryStatementTree) tree).resourceList();
    // need only (resources.size - 1) separators
    if (!resources.isEmpty() && resources.separators().size() == resources.size()) {
      reportIssue(ListUtils.getLast(resources.separators()), ""Remove this extraneous semicolon."");
    }
  }

}
"
S2970,CODE_SMELL,Assertions should be complete,"package org.sonar.java.checks.tests;

import java.util.List;
import java.util.Objects;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.java.annotations.VisibleForTesting;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaFileScannerContext.Location;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static java.util.Collections.emptyList;
import static org.sonar.java.checks.helpers.UnitTestUtils.hasTestAnnotation;
import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S2970"")
public class AssertionsCompletenessCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String FEST_ASSERT_SUPERTYPE = ""org.fest.assertions.Assert"";
  private static final String ASSERTJ_SUPERTYPE = ""org.assertj.core.api.AbstractAssert"";
  private static final String ASSERTJ_THROWABLE_SUPERTYPE = ""org.assertj.core.api.ThrowableTypeAssert"";
  private static final String TRUTH_SUPERTYPE = ""com.google.common.truth.TestVerb"";
  private static final String JAVA6_ABSTRACT_SOFT_ASSERT = ""org.assertj.core.api.Java6AbstractStandardSoftAssertions"";
  private static final MethodMatchers MOCKITO_VERIFY = MethodMatchers.create()
    .ofSubTypes(""org.mockito.Mockito"").names(""verify"").withAnyParameters().build();
  private static final MethodMatchers ASSERTJ_ASSERT_ALL =
    MethodMatchers.create()
      .ofSubTypes(""org.assertj.core.api.SoftAssertions"", ""org.assertj.core.api.Java6SoftAssertions"")
      .names(""assertAll"")
      .withAnyParameters()
      .build();
  private static final MethodMatchers ASSERTJ_ASSERT_THAT = MethodMatchers.create()
    .ofSubTypes(""org.assertj.core.api.AbstractSoftAssertions"").name(name -> name.startsWith(""assertThat""))
    .withAnyParameters()
    .build();
  private static final MethodMatchers ASSERTJ_ASSERT_SOFTLY = MethodMatchers.create()
    .ofSubTypes(""org.assertj.core.api.SoftAssertions"").names(""assertSoftly"").withAnyParameters().build();

  private static final MethodMatchers FEST_LIKE_ASSERT_THAT = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(
        // Fest 1.X
        ""org.fest.assertions.Assertions"",
        // Fest 2.X
        ""org.fest.assertions.api.Assertions"",
        // AssertJ 1.X
        ""org.assertj.core.api.AbstractSoftAssertions"",
        // AssertJ 2.X
        ""org.assertj.core.api.Assertions"",
        ""org.assertj.core.api.Java6Assertions"",
        ""org.assertj.core.api.AbstractStandardSoftAssertions"",
        JAVA6_ABSTRACT_SOFT_ASSERT,
        // AssertJ 3.X
        ""org.assertj.core.api.StrictAssertions"")
      .names(""assertThat"")
      .addParametersMatcher(ANY)
      .build(),

    MethodMatchers.create()
      .ofTypes(
        // AssertJ 3.X having specific method names
        ""org.assertj.core.api.Assertions"")
      .names(
        ""assertThatObject"",
        ""assertThatCode"",
        ""assertThatExceptionOfType"",
        ""assertThatNullPointerException"",
        ""assertThatIllegalArgumentException"",
        ""assertThatIOException"",
        ""assertThatIllegalStateException"")
      .withAnyParameters()
      .build(),

    MethodMatchers.create()
      .ofSubTypes(
        // Truth 0.29
        ""com.google.common.truth.Truth"",
        // Truth8 0.39
        ""com.google.common.truth.Truth8"").name(name -> name.startsWith(""assert""))
      .addParametersMatcher(ANY)
      .build());

  private static final MethodMatchers ASSERTJ_BDD_EXCEPTION_ASSERTIONS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(
        ""org.assertj.core.api.BDDAssertions"")
      .names(
        ""thenNullPointerException"",
        ""thenIllegalArgumentException"",
        ""thenIOException"",
        ""thenIllegalStateException"",
        ""thenException"",
        ""thenIndexOutOfBoundsException"",
        ""thenReflectiveOperationException"",
        ""thenRuntimeException"")
      .withAnyParameters()
      .build());

  private static final Pattern FEST_LIKE_EXCLUSION_NAMES = Pattern.compile(""as.*+|using.*+|with.*+|describedAs|overridingErrorMessage|extracting"");

  private static final MethodMatchers FEST_LIKE_EXCLUSIONS = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(FEST_ASSERT_SUPERTYPE, ASSERTJ_SUPERTYPE, ASSERTJ_THROWABLE_SUPERTYPE)
      .name(name -> FEST_LIKE_EXCLUSION_NAMES.matcher(name).matches())
      .withAnyParameters()
      .build(),

    // Truth has assertWithMessage, Truth8 does not
    MethodMatchers.create().ofSubTypes(TRUTH_SUPERTYPE).names(""that"").withAnyParameters().build()
  );

  private Boolean chainedToAnyMethodButFestExclusions = null;
  private JavaFileScannerContext context;

  private static boolean isMethodCalledOnJava6AbstractStandardSoftAssertions(MethodInvocationTree mit) {
    // Java6AbstractStandardSoftAssertions does not contain 'assertAll()' method so this class should not be used
    ExpressionTree methodSelect = mit.methodSelect();
    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      Type type = ((MemberSelectExpressionTree) methodSelect).expression().symbolType();
      if (type.is(JAVA6_ABSTRACT_SOFT_ASSERT)) {
        return true;
      }
    }
    return false;
  }

  @Override
  public void scanFile(final JavaFileScannerContext context) {
    if (context.getSemanticModel() == null) {
      // requires semantic
      return;
    }
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitVariable(VariableTree tree) {
    // skip variable assignments
  }

  @Override
  public void visitReturnStatement(ReturnStatementTree tree) {
    // skip return statements
  }

  @Override
  public void visitMethod(MethodTree methodTree) {
    if (ModifiersUtils.hasModifier(methodTree.modifiers(), Modifier.ABSTRACT)) {
      return;
    }
    super.visitMethod(methodTree);

    // soft assertions are allowed to be incomplete outside unit tests
    if (hasTestAnnotation(methodTree)) {
      SoftAssertionsVisitor softAssertionsVisitor = new SoftAssertionsVisitor();
      methodTree.accept(softAssertionsVisitor);
      if (softAssertionsVisitor.assertThatCalled && !isInClassUsingSoftAssertionsExtension(methodTree.symbol())) {
        context.reportIssue(this, methodTree.block().closeBraceToken(), ""Add a call to 'assertAll' after all 'assertThat'."");
      }
    }
  }

  private static boolean isInClassUsingSoftAssertionsExtension(Symbol symbol) {
    Symbol owner = symbol.owner();
    if (owner != null && owner.isTypeSymbol()) {
      List<SymbolMetadata.AnnotationValue> annotationValues = owner.metadata().valuesForAnnotation(""org.junit.jupiter.api.extension.ExtendWith"");
      return (annotationValues != null && annotationValues.stream().anyMatch(av -> isSoftAssertionsExtensionClass(av.value())))
        // Check if nesting class uses SoftAssertionsExtension since it is a valid use case.
        || isInClassUsingSoftAssertionsExtension(owner);
    }
    return false;
  }

  @VisibleForTesting
  static boolean isSoftAssertionsExtensionClass(Object value) {
    if (value instanceof Object[] values) {
      for (Object v : values) {
        if (v instanceof Symbol vSymbol && vSymbol.type().is(""org.assertj.core.api.junit.jupiter.SoftAssertionsExtension"")) {
          return true;
        }
      }
    }
    return false;
  }

  @Override
  public void visitMethodInvocation(MethodInvocationTree mit) {
    if (incompleteAssertion(mit)) {
      return;
    }
    Boolean previous = chainedToAnyMethodButFestExclusions;
    chainedToAnyMethodButFestExclusions = ((chainedToAnyMethodButFestExclusions != null) && chainedToAnyMethodButFestExclusions) || !FEST_LIKE_EXCLUSIONS.matches(mit);
    scan(mit.methodSelect());
    // skip arguments
    chainedToAnyMethodButFestExclusions = previous;
  }

  private boolean incompleteAssertion(MethodInvocationTree mit) {
    if (isMethodCalledOnJava6AbstractStandardSoftAssertions(mit)) {
      return false;
    }

    if ((FEST_LIKE_ASSERT_THAT.matches(mit) || MOCKITO_VERIFY.matches(mit) || ASSERTJ_BDD_EXCEPTION_ASSERTIONS.matches(mit)) &&
      !Boolean.TRUE.equals(chainedToAnyMethodButFestExclusions)) {
      context.reportIssue(this, mit.methodSelect(), ""Complete the assertion."");
      return true;
    }
    return false;
  }

  class SoftAssertionsVisitor extends BaseTreeVisitor {
    private boolean assertThatCalled;
    private final List<MethodInvocationTree> intermediateMethodInvocations;

    public SoftAssertionsVisitor() {
      this(false, emptyList());
    }

    public SoftAssertionsVisitor(boolean assertThatCalled, List<MethodInvocationTree> intermediateMethodInvocations) {
      this.assertThatCalled = assertThatCalled;
      this.intermediateMethodInvocations = intermediateMethodInvocations;
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      if (tree.symbolType().is(JAVA6_ABSTRACT_SOFT_ASSERT)) {
        context.reportIssue(AssertionsCompletenessCheck.this, tree, ""Use 'Java6SoftAssertions' instead of 'Java6AbstractStandardSoftAssertions'."");
        return;
      }
      super.visitNewClass(tree);
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree mit) {
      if (isMethodCalledOnJava6AbstractStandardSoftAssertions(mit)) {
        return;
      }

      boolean assertThatStateBeforeInvocation = assertThatCalled;
      super.visitMethodInvocation(mit);

      if (ASSERTJ_ASSERT_SOFTLY.matches(mit)) {
        assertThatCalled = assertThatStateBeforeInvocation;
      }

      if (ASSERTJ_ASSERT_ALL.matches(mit)) {
        if (assertThatCalled) {
          assertThatCalled = false;
        } else {
          List<MethodInvocationTree> allLocations = Stream.concat(intermediateMethodInvocations.stream(), Stream.of(mit)).toList();
          MethodInvocationTree mainLocation = allLocations.get(0);
          List<Location> secondaries = allLocations.stream()
            .skip(1L)
            .map(methodInvocation -> new Location("""", methodInvocation.methodSelect()))
            .toList();
          context.reportIssue(AssertionsCompletenessCheck.this, mainLocation, ""Add one or more 'assertThat' before 'assertAll'."", secondaries, null);
        }
      } else if (ASSERTJ_ASSERT_THAT.matches(mit) && !isJUnitSoftAssertions(mit)) {
        assertThatCalled = true;
      } else if (mit.methodSymbol().declaration() != null && intermediateMethodInvocations.stream().noneMatch(invocation -> invocation.methodSymbol().equals(mit.methodSymbol()))) {
        List<MethodInvocationTree> allLocations = Stream.concat(intermediateMethodInvocations.stream(), Stream.of(mit)).toList();
        SoftAssertionsVisitor softAssertionsVisitor = new SoftAssertionsVisitor(assertThatCalled, allLocations);
        mit.methodSymbol().declaration().accept(softAssertionsVisitor);
        assertThatCalled = softAssertionsVisitor.assertThatCalled;
      }
    }

    @Override
    public void visitTryStatement(TryStatementTree tree) {
      boolean hasAutoCloseableSoftAssertion = tree.resourceList().stream()
        .map(this::resourceSymbol)
        .map(Symbol::type)
        .filter(Objects::nonNull)
        .anyMatch(type -> type.isSubtypeOf(""org.assertj.core.api.AutoCloseableSoftAssertions""));
      super.visitTryStatement(tree);
      if (hasAutoCloseableSoftAssertion) {
        if (assertThatCalled) {
          assertThatCalled = false;
        } else {
          List<Location> secondaries = intermediateMethodInvocations.stream()
            .map(methodInvocation -> new Location("""", methodInvocation.methodSelect()))
            .toList();
          context.reportIssue(AssertionsCompletenessCheck.this,
            tree.block().closeBraceToken(),
            ""Add one or more 'assertThat' before the end of this try block."",
            secondaries,
            null);
        }
      }
    }

    private Symbol resourceSymbol(Tree tree) {
      switch (tree.kind()) {
        case VARIABLE:
          return ((VariableTree) tree).symbol();
        case IDENTIFIER:
          return ((IdentifierTree) tree).symbol();
        case MEMBER_SELECT:
          return ((MemberSelectExpressionTree) tree).identifier().symbol();
        default:
          throw new IllegalArgumentException(""Tree is not try-with-resources resource"");
      }
    }

    private boolean isJUnitSoftAssertions(MethodInvocationTree mit) {
      ExpressionTree expressionTree = mit.methodSelect();
      if (expressionTree.is(Tree.Kind.MEMBER_SELECT)) {
        Type type = ((MemberSelectExpressionTree) expressionTree).expression().symbolType();
        return type.isSubtypeOf(""org.assertj.core.api.JUnitSoftAssertions"") ||
          type.isSubtypeOf(""org.assertj.core.api.Java6JUnitSoftAssertions"");
      }
      return false;
    }

  }
}
"
S2972,CODE_SMELL,Inner classes should not have too many lines of code,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.metrics.MetricsScannerContext;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S2972"")
public class InnerClassTooManyLinesCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_MAX = 25;

  @RuleProperty(key = ""Max"",
    description = ""The maximum number of lines allowed"",
    defaultValue = """" + DEFAULT_MAX)
  public int max = DEFAULT_MAX;

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Kind.CLASS, Kind.ENUM, Kind.INTERFACE, Kind.ANNOTATION_TYPE);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree node = (ClassTree) tree;
    Symbol.TypeSymbol symbol = node.symbol();
    Symbol owner = symbol.owner();
    Type ownerType = owner.type();
    if (ownerType != null && ownerType.isClass() && owner.owner().isPackageSymbol()) {
      // raise only one issue for the first level of nesting when multiple nesting
      var metricsComputer = ((MetricsScannerContext)context).getMetricsComputer();
      int lines = metricsComputer.getLinesOfCode(node);
      if (lines > max) {
        reportIssue(ExpressionsHelper.reportOnClassTree(node), ""Reduce this class from "" + lines +
          "" lines to the maximum allowed "" + max + "" or externalize it in a public class."");
      }
    }
  }

}
"
S2973,CODE_SMELL,Escaped Unicode characters should not be used,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S2973"")
public class EscapedUnicodeCharactersCheck extends IssuableSubscriptionVisitor {

  private static final Set<String> UNICODE_WHITESPACES = SetUtils.immutableSetOf(
    ""1680"", ""2000"", ""2001"", ""2002"", ""2003"", ""2004"", ""2005"", ""2006"", ""2007"", ""2008"", ""2009"", ""200A"",
    ""2028"", ""2029"", ""202F"", ""205F"", ""3000"", ""180E"", ""200B"", ""200C"", ""200D"", ""2060"", ""FEFF"");

  private static final Pattern UNICODE_ESCAPED_CHAR = Pattern.compile(""\\\\u+[a-fA-F0-9]{4}"");

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Kind.STRING_LITERAL, Kind.TEXT_BLOCK);
  }

  @Override
  public void visitNode(Tree node) {
    if (LiteralUtils.isEmptyString(node)) {
      return;
    }
    String value = LiteralUtils.trimQuotes(((LiteralTree) node).value());
    if (node.is(Kind.TEXT_BLOCK)) {
      value = value.replaceAll(""(\r?\n|\r)\\s*"", """");
    }
    // replace \\ with nothing just to differentiate \u0000 and \\u0000
    Matcher matcher = UNICODE_ESCAPED_CHAR.matcher(value.replace(""\\\\"", """"));
    List<String> matches = getAllMatches(matcher);
    if (!matches.isEmpty()) {
      boolean notOnlyUnicodeEscaped = !matcher.replaceAll("""").isEmpty();
      if (notOnlyUnicodeEscaped && matches.stream().anyMatch(EscapedUnicodeCharactersCheck::isPrintableEscapedUnicode)) {
        reportIssue(node, ""Remove this Unicode escape sequence and use the character instead."");
      }
    }
  }

  private static List<String> getAllMatches(Matcher matcher) {
    List<String> matches = new ArrayList<>();
    while (matcher.find()) {
      matches.add(matcher.group());
    }
    return matches;
  }

  private static boolean isPrintableEscapedUnicode(String input) {
    String hexValue = input.substring(input.length() - 4).toUpperCase(Locale.ROOT);
    if (UNICODE_WHITESPACES.contains(hexValue)) {
      return false;
    }
    int unicodePointDecimal = Integer.parseInt(hexValue, 16);
    return (31 < unicodePointDecimal && unicodePointDecimal < 127) || 160 < unicodePointDecimal ;
  }

}
"
S2974,CODE_SMELL,"Classes without ""public"" constructors should be ""final""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.TypeTree;

import javax.annotation.Nullable;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2974"")
public class FinalClassCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (hasOnlyPrivateConstructors(classTree) && !isExtended(classTree) && !ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {
      reportIssue(classTree.simpleName(), ""Make this class \""final\"" or add a public constructor."");
    }
  }

  private static boolean isExtended(ClassTree classTree) {
    IsExtendedVisitor isExtendedVisitor = new IsExtendedVisitor(classTree.symbol().type().erasure());
    classTree.accept(isExtendedVisitor);
    return isExtendedVisitor.isExtended;
  }

  private static boolean hasOnlyPrivateConstructors(ClassTree classTree) {
    boolean hasConstructor = false;
    for (Tree member : classTree.members()) {
      if (member.is(Kind.CONSTRUCTOR)) {
        hasConstructor = true;
        if (!ModifiersUtils.hasModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE)) {
          // has a constructor not private.
          return false;
        }
      }
    }
    return hasConstructor;
  }

  private static class IsExtendedVisitor extends BaseTreeVisitor {
    private final Type type;
    boolean isExtended;

    IsExtendedVisitor(Type type) {
      this.type = type;
    }

    @Override
    protected void scan(@Nullable Tree tree) {
      if (!isExtended) {
        super.scan(tree);
      }
    }

    @Override
    public void visitClass(ClassTree tree) {
      TypeTree superClass = tree.superClass();
      if (superClass != null && superClass.symbolType().erasure() == type) {
        isExtended = true;
      }
      super.visitClass(tree);
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      if (tree.classBody() != null && tree.symbolType().isSubtypeOf(type)) {
        isExtended = true;
      }
      super.visitNewClass(tree);
    }
  }
}
"
S2975,CODE_SMELL,"""clone"" should not be overridden","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S2975"")
public class CloneOverrideCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    IdentifierTree identifierTree = methodTree.simpleName();
    if (methodTree.parameters().isEmpty() && ""clone"".equals(identifierTree.name()) && !isUnsupportedCloneOverride(methodTree)) {
      reportIssue(identifierTree, ""Remove this \""clone\"" implementation; use a copy constructor or copy factory instead."");
    }
  }

  private static boolean isUnsupportedCloneOverride(MethodTree methodTree) {
    if (isOneStatementMethod(methodTree)) {
      StatementTree statementTree = methodTree.block().body().get(0);
      return statementTree.is(Tree.Kind.THROW_STATEMENT) && ((ThrowStatementTree) statementTree).expression().symbolType().is(""java.lang.CloneNotSupportedException"");
    }
    return false;
  }

  private static boolean isOneStatementMethod(MethodTree methodTree) {
    BlockTree block = methodTree.block();
    return block != null && block.body().size() == 1;
  }




}
"
S3008,CODE_SMELL,Static non-final field names should comply with a naming convention,"package org.sonar.java.checks.naming;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.AbstractBadFieldNameChecker;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifiersTree;

@Rule(key = ""S3008"")
public class BadFieldNameStaticNonFinalCheck extends AbstractBadFieldNameChecker {

  @RuleProperty(
    key = DEFAULT_FORMAT_KEY,
    description = DEFAULT_FORMAT_DESCRIPTION,
    defaultValue = DEFAULT_FORMAT_VALUE)
  public String format = DEFAULT_FORMAT_VALUE;

  @Override
  protected String getFormat() {
    return format;
  }

  @Override
  protected boolean isFieldModifierConcernedByRule(ModifiersTree modifier) {
    return ModifiersUtils.hasModifier(modifier, Modifier.STATIC) && !ModifiersUtils.hasModifier(modifier, Modifier.FINAL);
  }

}
"
S3010,CODE_SMELL,Static fields should not be updated in constructors,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ArrayAccessExpressionTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import javax.annotation.CheckForNull;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Rule(key = ""S3010"")
public class StaticFieldUpdateInConstructorCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree constructor = (MethodTree) tree;

    Symbol.TypeSymbol owner = constructor.symbol().enclosingClass();
    Set<Symbol> staticFields = owner.memberSymbols().stream()
      .filter(Symbol::isVariableSymbol)
      .filter(Symbol::isStatic)
      .collect(Collectors.toSet());

    StaticFieldUpdateVisitor visitor = new StaticFieldUpdateVisitor(staticFields);
    constructor.block().accept(visitor);
    visitor.assignedStaticFields().forEach(identifierTree -> {
      Symbol staticField = identifierTree.symbol();
      reportIssue(identifierTree,
        ""Remove this assignment of \"""" + staticField.name() + ""\""."",
        Collections.singletonList(new JavaFileScannerContext.Location(""Static field declaration."", staticField.declaration())),
        null);
    });

  }

  private static class StaticFieldUpdateVisitor extends BaseTreeVisitor {

    private final Set<Symbol> staticFields;
    private final List<IdentifierTree> assignedStaticFields;

    StaticFieldUpdateVisitor(Set<Symbol> staticFields) {
      this.staticFields = staticFields;
      this.assignedStaticFields = new ArrayList<>();
    }

    Stream<IdentifierTree> assignedStaticFields() {
      return assignedStaticFields.stream();
    }

    @Override
    public void visitSynchronizedStatement(SynchronizedStatementTree tree) {
      // skip synchronized blocks
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      checkExpression(tree.variable());
      super.visitAssignmentExpression(tree);
    }

    private void checkExpression(ExpressionTree expressionTree) {
      IdentifierTree variable = getVariable(expressionTree);
      if (variable != null && staticFields.contains(variable.symbol())) {
        assignedStaticFields.add(variable);
      }
    }

    @CheckForNull
    private static IdentifierTree getVariable(ExpressionTree expressionTree) {
      Tree variable = ExpressionUtils.skipParentheses(expressionTree);
      if (variable.is(Tree.Kind.ARRAY_ACCESS_EXPRESSION)) {
        return getVariable(((ArrayAccessExpressionTree) variable).expression());
      }
      if (variable.is(Tree.Kind.MEMBER_SELECT)) {
        return getVariable(((MemberSelectExpressionTree) variable).identifier());
      }
      if (variable.is(Tree.Kind.IDENTIFIER)) {
        return (IdentifierTree) variable;
      }
      return null;
    }
  }

}
"
S3011,CODE_SMELL,"Reflection should not be used to increase accessibility of classes, methods, or fields","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S3011"")
public class AccessibilityChangeCheck extends AbstractAccessibilityChangeChecker {
  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (isModifyingFieldFromRecord(mit)) {
      return;
    }
    if (SET_ACCESSIBLE_MATCHER.matches(mit)) {
      if (setsToPubliclyAccessible(mit)) {
        reportIssue(mit, ""This accessibility update should be removed."");
      }
    } else {
      reportIssue(mit, ""This accessibility bypass should be removed."");
    }
  }
}
"
S3012,CODE_SMELL,Arrays and lists should not be copied using loops,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type.Primitives;
import org.sonar.plugins.java.api.tree.ArrayAccessExpressionTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.DoWhileStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ListTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S3012"")
public class ArrayCopyLoopCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers COLLECTION_ADD = MethodMatchers.create().ofSubTypes(""java.util.Collection"").names(""add"").addParametersMatcher(ANY).build();

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Kind.FOR_STATEMENT, Kind.FOR_EACH_STATEMENT, Kind.WHILE_STATEMENT, Kind.DO_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    StatementTree statement;
    if (tree.is(Kind.FOR_STATEMENT)) {
      statement = checkFor((ForStatementTree) tree);
    } else if (tree.is(Kind.WHILE_STATEMENT)) {
      statement = checkDoOrWhile((WhileStatementTree) tree);
    } else if (tree.is(Kind.DO_STATEMENT)) {
      statement = checkDoOrWhile((DoWhileStatementTree) tree);
    } else {
      statement = checkForEach((ForEachStatement) tree);
    }
    if (statement != null) {
      reportIssue(statement, ""Use \""Arrays.copyOf\"", \""Arrays.asList\"", \""Collections.addAll\"" or \""System.arraycopy\"" instead."");
    }
  }

  @CheckForNull
  private static StatementTree checkFor(ForStatementTree tree) {
    ListTree<StatementTree> updates = tree.update();
    if (updates.size() == 1) {
      StatementTree update = updates.get(0);
      Symbol counter = checkUpdate(update);
      if (counter != null) {
        ExpressionTree condition = tree.condition();
        if (condition != null && checkCondition(condition, counter)) {
          StatementTree statement = getStatement(tree);
          if (statement != null && checkStatement(statement, counter)) {
            return statement;
          }
        }
      }
    }
    return null;
  }

  @CheckForNull
  private static StatementTree checkDoOrWhile(StatementTree tree) {
    StatementTree doOrWhile = statement(tree);
    if (doOrWhile.is(Kind.BLOCK)) {
      BlockTree block = (BlockTree) doOrWhile;
      List<StatementTree> body = block.body();
      if (body.size() == 2) {
        StatementTree update = body.get(1);
        Symbol counter = checkUpdate(update);
        if (counter != null) {
          ExpressionTree condition = condition(tree);
          if (checkCondition(condition, counter)) {
            StatementTree statement = body.get(0);
            if (checkStatement(statement, counter)) {
              return statement;
            }
          }
        }
      }
    }
    return null;
  }

  private static ExpressionTree condition(StatementTree tree) {
    return tree.is(Kind.WHILE_STATEMENT) ? ((WhileStatementTree) tree).condition() : ((DoWhileStatementTree) tree).condition();
  }

  private static StatementTree statement(StatementTree tree) {
    return tree.is(Kind.WHILE_STATEMENT) ? ((WhileStatementTree) tree).statement() : ((DoWhileStatementTree) tree).statement();
  }

  @CheckForNull
  private static StatementTree checkForEach(ForEachStatement tree) {
    ExpressionTree expression = tree.expression();
    if (expression.symbolType().isArray()) {
      StatementTree statement = getStatement(tree);
      if (statement != null && statement.is(Kind.EXPRESSION_STATEMENT)) {
        expression = ((ExpressionStatementTree) statement).expression();
        if (isArrayToListCopy(expression, tree.variable())) {
          return statement;
        }
      }
    }
    return null;
  }

  private static boolean checkCondition(ExpressionTree tree, Symbol counter) {
    if (tree.is(Kind.LESS_THAN, Kind.LESS_THAN_OR_EQUAL_TO, Kind.GREATER_THAN, Kind.GREATER_THAN_OR_EQUAL_TO, Kind.NOT_EQUAL_TO)) {
      BinaryExpressionTree comparison = (BinaryExpressionTree) tree;
      ExpressionTree lhs = comparison.leftOperand();
      ExpressionTree rhs = comparison.rightOperand();
      // the XOR makes sure we don't allow `i < i` as the loop termination condition
      return isCounter(lhs, counter) ^ isCounter(rhs, counter);
    }
    return false;
  }

  @CheckForNull
  private static Symbol checkUpdate(StatementTree tree) {
    Symbol counter = null;
    if (tree.is(Kind.EXPRESSION_STATEMENT)) {
      ExpressionStatementTree update = (ExpressionStatementTree) tree;
      counter = isIncrement(update);
      if (counter == null) {
        counter = isPlusAssignment(update);
        if (counter == null) {
          counter = isAssignment(update);
        }
      }
    }
    return counter;
  }

  private static boolean checkStatement(StatementTree tree, Symbol counter) {
    if (tree.is(Kind.EXPRESSION_STATEMENT)) {
      ExpressionTree expression = ((ExpressionStatementTree) tree).expression();
      return isArrayToArrayCopy(expression, counter) || isArrayToListCopy(expression, counter);
    }
    return false;
  }

  @CheckForNull
  private static Symbol isIncrement(ExpressionStatementTree update) {
    if (update.expression().is(Kind.POSTFIX_INCREMENT, Kind.PREFIX_INCREMENT)) {
      UnaryExpressionTree increment = (UnaryExpressionTree) update.expression();
      if (increment.expression().is(Kind.IDENTIFIER)) {
        IdentifierTree identifier = (IdentifierTree) increment.expression();
        return identifier.symbol();
      }
    }
    return null;
  }

  @CheckForNull
  private static Symbol isPlusAssignment(ExpressionStatementTree update) {
    if (update.expression().is(Kind.PLUS_ASSIGNMENT)) {
      AssignmentExpressionTree assignment = (AssignmentExpressionTree) update.expression();
      ExpressionTree lhs = assignment.variable();
      ExpressionTree rhs = assignment.expression();
      if (lhs.is(Kind.IDENTIFIER)) {
        IdentifierTree identifier = (IdentifierTree) lhs;
        if (isOne(rhs)) {
          return identifier.symbol();
        }
      }
    }
    return null;
  }

  @CheckForNull
  private static Symbol isAssignment(ExpressionStatementTree update) {
    if (update.expression().is(Kind.ASSIGNMENT)) {
      AssignmentExpressionTree assignment = (AssignmentExpressionTree) update.expression();
      ExpressionTree lhs = assignment.variable();
      ExpressionTree rhs = assignment.expression();
      if (lhs.is(Kind.IDENTIFIER) && isIntegerType(lhs)) {
        Symbol counter = ((IdentifierTree) lhs).symbol();
        if (rhs.is(Kind.PLUS)) {
          BinaryExpressionTree addition = (BinaryExpressionTree) rhs;
          lhs = addition.leftOperand();
          rhs = addition.rightOperand();
          if ((isCounter(lhs, counter) && isOne(rhs)) || (isOne(lhs) && isCounter(rhs, counter))) {
            return counter;
          }
        }
      }
    }
    return null;
  }

  private static boolean isArrayToArrayCopy(ExpressionTree expression, Symbol counter) {
    if (expression.is(Kind.ASSIGNMENT)) {
      AssignmentExpressionTree assignment = (AssignmentExpressionTree) expression;
      ExpressionTree lhs = assignment.variable();
      ExpressionTree rhs = assignment.expression();
      if (lhs.is(Kind.ARRAY_ACCESS_EXPRESSION) && rhs.is(Kind.ARRAY_ACCESS_EXPRESSION)) {
        ArrayAccessExpressionTree src = (ArrayAccessExpressionTree) rhs;
        ArrayAccessExpressionTree dst = (ArrayAccessExpressionTree) lhs;
        return isCounter(src.dimension().expression(), counter) && isCounter(dst.dimension().expression(), counter);
      }
    }
    return false;
  }

  private static boolean isArrayToListCopy(ExpressionTree expression, Symbol counter) {
    if (expression.is(Kind.METHOD_INVOCATION)) {
      MethodInvocationTree invocation = (MethodInvocationTree) expression;
      if (COLLECTION_ADD.matches(invocation) && invocation.methodSelect().is(Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree select = (MemberSelectExpressionTree) invocation.methodSelect();
        if (select.expression().is(Kind.IDENTIFIER)) {
          ExpressionTree argument = invocation.arguments().get(0);
          if (argument.is(Kind.ARRAY_ACCESS_EXPRESSION) && !argument.symbolType().isPrimitive()) {
            ArrayAccessExpressionTree access = (ArrayAccessExpressionTree) argument;
            return access.expression().is(Kind.IDENTIFIER) && isCounter(access.dimension().expression(), counter);
          }
        }
      }
    }
    return false;
  }

  private static boolean isArrayToListCopy(ExpressionTree expression, VariableTree iterated) {
    if (expression.is(Kind.METHOD_INVOCATION)) {
      MethodInvocationTree invocation = (MethodInvocationTree) expression;
      if (COLLECTION_ADD.matches(invocation)) {
        expression = invocation.methodSelect();
        if (expression.is(Kind.MEMBER_SELECT)) {
          MemberSelectExpressionTree select = (MemberSelectExpressionTree) expression;
          if (select.expression().is(Kind.IDENTIFIER)) {
            ExpressionTree argument = invocation.arguments().get(0);
            Symbol identifier = getIdentifier(argument);
            return identifier != null && identifier.equals(iterated.symbol()) && !argument.symbolType().isPrimitive();
          }
        }
      }
    }
    return false;
  }

  @CheckForNull
  private static Symbol getIdentifier(ExpressionTree tree) {
    if (tree.is(Kind.IDENTIFIER)) {
      return ((IdentifierTree) tree).symbol();
    }
    return null;
  }

  private static boolean isCounter(ExpressionTree tree, Symbol counter) {
    Symbol identifier = getIdentifier(tree);
    return identifier != null && identifier.equals(counter);
  }

  private static boolean isIntegerType(ExpressionTree tree) {
    return tree.symbolType().isPrimitive(Primitives.INT) || tree.symbolType().isPrimitive(Primitives.LONG);
  }

  private static boolean isOne(ExpressionTree tree) {
    return Long.valueOf(1L).equals(LiteralUtils.longLiteralValue(tree));
  }

  @CheckForNull
  private static StatementTree getStatement(Tree tree) {
    if (tree.is(Kind.FOR_STATEMENT)) {
      ForStatementTree loop = (ForStatementTree) tree;
      return getBody(loop.statement(), 1);
    }
    ForEachStatement loop = (ForEachStatement) tree;
    return getBody(loop.statement(), 1);
  }

  @CheckForNull
  private static StatementTree getBody(StatementTree tree, int expectedSize) {
    if (tree.is(Kind.BLOCK)) {
      BlockTree block = (BlockTree) tree;
      List<StatementTree> body = block.body();
      tree = body.size() == expectedSize ? body.get(0) : null;
    }
    return tree;
  }
}
"
S3014,CODE_SMELL,"""ThreadGroup"" should not be used","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S3014"")
public class DisallowedThreadGroupCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String JAVA_LANG_THREADGROUP = ""java.lang.ThreadGroup"";
  private static final String MESSAGE = ""Remove this use of \""ThreadGroup\"". Prefer the use of \""ThreadPoolExecutor\""."";

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    if (context.getSemanticModel() == null) {
      return;
    }
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    TypeTree superClass = tree.superClass();
    if (superClass != null && superClass.symbolType().is(JAVA_LANG_THREADGROUP)) {
      context.reportIssue(this, superClass, MESSAGE);
    }
    super.visitClass(tree);
  }

  @Override
  public void visitMethod(MethodTree tree) {
    boolean notOverriding = Boolean.FALSE.equals(tree.isOverriding());
    boolean reported = false;
    boolean declaresThreadGroup = false;

    TypeTree returnType = tree.returnType();
    if (returnType != null && returnType.symbolType().is(JAVA_LANG_THREADGROUP)) {
      if (notOverriding) {
        context.reportIssue(this, returnType, MESSAGE);
        reported = true;
      }
      declaresThreadGroup = true;
    }
    for (VariableTree variableTree : tree.parameters()) {
      TypeTree type = variableTree.type();
      if (type.symbolType().is(JAVA_LANG_THREADGROUP)) {
        if (notOverriding) {
          context.reportIssue(this, type, MESSAGE);
          reported = true;
        }
        declaresThreadGroup = true;
      }
    }

    if (declaresThreadGroup && !reported) {
      // skip body of overrides to avoid FPs
      return;
    }
    super.scan(tree.block());
  }

  @Override
  public void visitVariable(VariableTree tree) {
    TypeTree type = tree.type();
    if (type.symbolType().is(JAVA_LANG_THREADGROUP)) {
      context.reportIssue(this, type, MESSAGE);
    }
    super.visitVariable(tree);
  }
}
"
S3020,BUG,"""Collection.toArray()"" should be passed an array of the proper type","package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;

@Rule(key = ""S3020"")
public class ToArrayCheck extends AbstractMethodDetection {

  private static final MethodMatchers COLLECTION_TO_ARRAY = MethodMatchers.create().ofSubTypes(""java.util.Collection"")
    .names(""toArray"").addWithoutParametersMatcher().build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return COLLECTION_TO_ARRAY;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    Tree parent = mit.parent();
    if (parent.is(Tree.Kind.TYPE_CAST)) {
      checkCast(((TypeCastTree) parent), mit);
    }
  }

  private void checkCast(TypeCastTree castTree, MethodInvocationTree mit) {
    Type type = castTree.symbolType();
    if (type.isArray() && !type.is(""java.lang.Object[]"")) {
      Type elementType = ((Type.ArrayType) type).elementType();
      ExpressionTree methodSelect = mit.methodSelect();
      // Do not report an issue for type variables and call to toArray from the Collection itself
      if (!elementType.isTypeVar() && methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
        String typeName = String.format(""new %s[0]"", elementType.name());
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(mit)
          .withMessage(""Pass \""%s\"" as argument to \""toArray\""."", typeName)
          .withQuickFix(() -> getQuickFix(castTree, mit, (MemberSelectExpressionTree) methodSelect, typeName))
          .report();
      }
    }
  }

  private static JavaQuickFix getQuickFix(TypeCastTree castTree, MethodInvocationTree mit, MemberSelectExpressionTree methodSelect, String typeName) {
    List<JavaTextEdit> textEdits = new ArrayList<>();
    textEdits.add(JavaTextEdit.insertAfterTree(mit.arguments().firstToken(), typeName));
    if (!methodSelect.expression().symbolType().isRawType()) {
      textEdits.add(JavaTextEdit.removeTextSpan(AnalyzerMessage.textSpanBetween(castTree, true, mit, false)));
    }
    return JavaQuickFix.newQuickFix(""Pass \""%s\"" as argument"", typeName)
      .addTextEdits(textEdits)
      .build();
  }
}
"
S3030,CODE_SMELL,"Classes should not have too many ""static"" imports","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonar.plugins.java.api.tree.ImportClauseTree;
import org.sonar.plugins.java.api.tree.ImportTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3030"")
public class StaticImportCountCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_THRESHOLD = 4;

  @RuleProperty(key = ""threshold"", description = ""The maximum number of static imports allowed"", defaultValue = """" + DEFAULT_THRESHOLD)
  private int threshold = DEFAULT_THRESHOLD;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.COMPILATION_UNIT);
  }

  @Override
  public void visitNode(Tree tree) {
    CompilationUnitTree cut = (CompilationUnitTree) tree;
    List<ImportClauseTree> staticImports = cut.imports().stream()
      .filter(importClauseTree -> importClauseTree.is(Tree.Kind.IMPORT) && ((ImportTree) importClauseTree).isStatic())
      .toList();
    int staticImportsCount = staticImports.size();

    if (staticImportsCount > threshold) {
      List<JavaFileScannerContext.Location> flow = staticImports.stream()
        .map(importStatement -> new JavaFileScannerContext.Location(""+1"", importStatement))
        .toList();
      String message = String.format(""Reduce the number of \""static\"" imports in this class from %d to the maximum allowed %d."", staticImportsCount, threshold);
      reportIssue(staticImports.get(0), message, flow, null);
    }
  }


  public void setThreshold(int threshold) {
    this.threshold = threshold;
  }
}
"
S3032,BUG,"JEE applications should not ""getClassLoader""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S3032"")
public class GetClassLoaderCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofTypes(""java.lang.Class"").names(""getClassLoader"").addWithoutParametersMatcher().build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Use \""Thread.currentThread().getContextClassLoader()\"" instead."");
  }

}
"
S3034,BUG,Raw byte values should not be used in bitwise operations in combination with shifts,"package org.sonar.java.checks;

import java.util.HashSet;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.semantic.Type.Primitives;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3034"")
public class RawByteBitwiseOperationsCheck extends BaseTreeVisitor implements JavaFileScanner {

  JavaFileScannerContext context;
  Set<ExpressionTree> shifts = new HashSet<>();
  Set<ExpressionTree> byteContainments = new HashSet<>();

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
    shifts.clear();
    byteContainments.clear();
  }

  @Override
  public void visitBinaryExpression(BinaryExpressionTree tree) {
    super.visitBinaryExpression(tree);
    if (isShifting(tree)) {
      shifts.add(tree);
      return;
    }
    if (ExpressionUtils.isSecuringByte(tree)) {
      byteContainments.add(tree);
      return;
    }
    if (isIntegerOrLongExpected(tree.symbolType())) {
      ExpressionTree leftOperand = ExpressionUtils.skipParentheses(tree.leftOperand());
      ExpressionTree rightOperand = ExpressionUtils.skipParentheses(tree.rightOperand());
      checkShiftWithoutByteSecuring(leftOperand, rightOperand);
      checkShiftWithoutByteSecuring(rightOperand, leftOperand);
    }
  }

  private static boolean isShifting(BinaryExpressionTree tree) {
    return tree.is(Tree.Kind.LEFT_SHIFT, Tree.Kind.RIGHT_SHIFT, Tree.Kind.UNSIGNED_RIGHT_SHIFT);
  }

  private static boolean isIntegerOrLongExpected(Type type) {
    return type.isPrimitive(Primitives.INT) || type.isPrimitive(Primitives.LONG);
  }

  private void checkShiftWithoutByteSecuring(ExpressionTree shiftExpr, ExpressionTree byteExpr) {
    if (shifts.contains(shiftExpr) && !byteContainments.contains(byteExpr) && byteExpr.symbolType().isPrimitive(Primitives.BYTE)) {
      context.reportIssue(this, byteExpr, ""Prevent \""int\"" promotion by adding \""& 0xff\"" to this expression."");
    }
  }

}
"
S3038,CODE_SMELL,Abstract methods should not be redundant,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.JUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.SymbolMetadata.AnnotationInstance;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3038"")
public class RedundantAbstractMethodCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    Symbol.MethodSymbol method = ((MethodTree) tree).symbol();
    if (method.isAbstract() && method.owner().isAbstract()) {
      checkMethod(method);
    }
  }

  private void checkMethod(Symbol.MethodSymbol method) {
    List<Symbol.MethodSymbol> overridees = method.overriddenSymbols();
    if (overridees.isEmpty()) {
      return;
    }
    Symbol.MethodSymbol overridee = overridees.get(0);
    if (!overridees.isEmpty() && overridee.owner().isInterface() && !differentContract(method, overridee)) {
      reportIssue(method.declaration(), ""\"""" + method.name() + ""\"" is defined in the \"""" + overridee.owner().name() + ""\"" interface and can be removed from this class."");
    }
  }

  private static boolean differentContract(Symbol.MethodSymbol method, Symbol.MethodSymbol overridee) {
    return removingParametrizedAspect(method, overridee)
      || differentThrows(method, overridee)
      || differentReturnType(method, overridee)
      || differentParameters(method, overridee)
      || differentAnnotations(method.metadata(), overridee.metadata());
  }

  private static boolean removingParametrizedAspect(Symbol.MethodSymbol method, Symbol.MethodSymbol overridee) {
    return !method.isParametrizedMethod() && overridee.isParametrizedMethod();
  }

  private static boolean differentThrows(Symbol.MethodSymbol method, Symbol.MethodSymbol overridee) {
    return !(new HashSet<>(method.thrownTypes()).equals(new HashSet<>(overridee.thrownTypes())));
  }

  private static boolean differentReturnType(Symbol.MethodSymbol method, Symbol.MethodSymbol overridee) {
    Type methodResultType = resultType(method);
    Type overrideeResultType = resultType(overridee);
    return specializationOfReturnType(methodResultType.erasure(), overrideeResultType.erasure()) || useRawTypeOfParametrizedType(methodResultType, overrideeResultType);
  }

  private static Type resultType(Symbol.MethodSymbol method) {
    return method.returnType().type();
  }

  private static boolean specializationOfReturnType(Type methodResultType, Type overrideeResultType) {
    return !methodResultType.isVoid()
      && (methodResultType.isSubtypeOf(overrideeResultType) && !overrideeResultType.isSubtypeOf(methodResultType));
  }

  private static boolean differentParameters(Symbol.MethodSymbol method, Symbol.MethodSymbol overridee) {
    return useRawTypeOfParametrizedType(method.parameterTypes(), overridee.parameterTypes())
      || differentAnnotationsOnParameters(method, overridee);
  }

  private static boolean useRawTypeOfParametrizedType(List<Type> methodParamTypes, List<Type> overrideeParamType) {
    for (int i = 0; i < methodParamTypes.size(); i++) {
      if (useRawTypeOfParametrizedType(methodParamTypes.get(i), overrideeParamType.get(i))) {
        return true;
      }
    }
    return false;
  }

  private static boolean useRawTypeOfParametrizedType(Type methodParam, Type overrideeParam) {
    return !methodParam.isParameterized()
      && overrideeParam.isParameterized()
      && methodParam.erasure().equals(overrideeParam.erasure());
  }

  private static boolean differentAnnotationsOnParameters(Symbol.MethodSymbol method, Symbol.MethodSymbol overridee) {
    for (int i = 0; i < method.parameterTypes().size(); i++) {
      if (differentAnnotations(
        JUtils.parameterAnnotations(method, i),
        JUtils.parameterAnnotations(overridee, i))) {
        return true;
      }
    }
    return false;
  }

  private static boolean differentAnnotations(SymbolMetadata methodMetadata, SymbolMetadata overrideeMetadata) {
    for (AnnotationInstance annotation : methodMetadata.annotations()) {
      Type type = annotation.symbol().type();
      if (!type.is(""java.lang.Override"") && !overrideeMetadata.isAnnotatedWith(type.fullyQualifiedName())) {
        return true;
      }
    }
    return false;
  }
}
"
S3039,BUG,"Indexes to passed to ""String"" operations should be within the string's bounds","package org.sonar.java.checks;

import java.util.function.BiPredicate;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S3039"")
public class StringCallsBeyondBoundsCheck extends AbstractMethodDetection {

  private static final String STRING = ""java.lang.String"";
  private static final MethodMatchers STRING_LENGTH = MethodMatchers.create()
    .ofTypes(STRING).names(""length"").addWithoutParametersMatcher().build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofTypes(STRING)
        .names(""charAt"", ""codePointAt"", ""codePointBefore"")
        .addParametersMatcher(""int"")
        .build(),
      MethodMatchers.create()
        .ofTypes(STRING)
        .names(""codePointCount"", ""offsetByCodePoints"", ""subSequence"")
        .addParametersMatcher(""int"", ""int"")
        .build(),
      MethodMatchers.create()
        .ofTypes(STRING)
        .names(""substring"")
        .addParametersMatcher(""int"")
        .addParametersMatcher(""int"", ""int"")
        .build(),
      MethodMatchers.create()
        .ofTypes(STRING)
        .names(""getChars"")
        .addParametersMatcher(""int"", ""int"", ""char[]"", ""int"")
        .build());
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree invocation) {
    boolean issue;
    String method = invocation.methodSymbol().name();
    switch (method) {
      case ""charAt"":
      case ""codePointAt"":
        issue = checkCodePointAt(invocation);
        break;
      case ""codePointBefore"":
        issue = checkCodePointBefore(invocation);
        break;
      case ""getChars"":
        issue = checkGetChars(invocation);
        break;
      case ""offsetByCodePoints"":
        issue = checkOffsetByCodePoints(invocation);
        break;
      case ""codePointCount"":
      case ""subSequence"":
        issue = checkSubsequence(invocation);
        break;
      case ""substring"":
        issue = checkSubstring(invocation);
        break;
      default:
        issue = false;
    }
    if (issue) {
      reportIssue(invocation, String.format(""Refactor this \""%s\"" call; it will result in an \""StringIndexOutOfBounds\"" exception at runtime."", invocation.methodSymbol().name()));
    }
  }

  private static boolean check(MethodInvocationTree invocation, BiPredicate<ExpressionTree, Arguments> condition) {
    if (invocation.methodSelect().is(Kind.MEMBER_SELECT)) {
      ExpressionTree string = ((MemberSelectExpressionTree) invocation.methodSelect()).expression();
      Arguments arguments = invocation.arguments();
      return condition.test(string, arguments);
    }
    return false;
  }

  private static boolean checkCodePointAt(MethodInvocationTree tree) {
    return check(tree, (str, args) -> {
      Integer index = constant(args.get(0));
      if (index != null && index < 0) {
        return true;
      }
      Integer strlen = length(str);
      if (index != null && strlen != null && index >= strlen) {
        return true;
      }
      return isStringLength(str, args.get(0));
    });
  }

  private static boolean checkCodePointBefore(MethodInvocationTree tree) {
    return check(tree, (str, args) -> {
      Integer index = constant(args.get(0));
      if (index != null && index < 1) {
        return true;
      }
      Integer strlen = length(str);
      return index != null && strlen != null && index > strlen;
    });
  }

  private static boolean checkGetChars(MethodInvocationTree tree) {
    return check(tree, (str, args) -> {
      if (isStringLength(str, args.get(0))) {
        return true;
      }

      Integer srcBegin = constant(args.get(0));
      if (srcBegin != null && srcBegin < 0) {
        return true;
      }
      Integer srcEnd = constant(args.get(1));
      if (srcBegin != null && srcEnd != null && srcBegin > srcEnd) {
        return true;
      }
      Integer strlen = length(str);
      if (srcEnd != null && strlen != null && srcEnd > strlen) {
        return true;
      }
      Integer dstBegin = constant(args.get(3));
      return dstBegin != null && dstBegin < 0;
    });
  }

  private static boolean checkOffsetByCodePoints(MethodInvocationTree tree) {
    return check(tree, (str, args) -> {
      if (isStringLength(str, args.get(0))) {
        return true;
      }

      Integer index = constant(args.get(0));
      if (index != null && index < 0) {
        return true;
      }
      Integer strlen = length(str);
      return index != null && strlen != null && index > strlen;
    });
  }

  private static boolean checkSubstring(MethodInvocationTree tree) {
    int arity = tree.arguments().size();
    if (arity == 2) {
      return checkSubsequence(tree);
    }
    return check(tree, (str, args) -> {
      if (isStringLength(str, args.get(0))) {
        return true;
      }
      Integer index = constant(args.get(0));
      if (index != null && index < 0) {
        return true;
      }
      Integer strlen = length(str);
      return index != null && strlen != null && index > strlen;
    });
  }

  private static boolean checkSubsequence(MethodInvocationTree tree) {
    return check(tree, (str, args) -> {
      if (isStringLength(str, args.get(0))) {
        return true;
      }

      Integer beginIndex = constant(args.get(0));
      if (beginIndex != null && beginIndex < 0) {
        return true;
      }
      Integer endIndex = constant(args.get(1));
      if (beginIndex != null && endIndex != null && beginIndex > endIndex) {
        return true;
      }
      Integer strlen = length(str);
      return endIndex != null && strlen != null && endIndex > strlen;
    });
  }

  private static boolean isStringLength(ExpressionTree str, ExpressionTree tree) {
    if (str.is(Kind.IDENTIFIER) && tree.is(Kind.METHOD_INVOCATION)) {
      MethodInvocationTree invocation = (MethodInvocationTree) tree;
      if (STRING_LENGTH.matches(invocation) && invocation.methodSelect().is(Kind.MEMBER_SELECT)) {
        ExpressionTree expr = ((MemberSelectExpressionTree) invocation.methodSelect()).expression();
        return expr.is(Kind.IDENTIFIER) && ((IdentifierTree) str).symbol().equals(((IdentifierTree) expr).symbol());
      }
    }
    return false;
  }

  @CheckForNull
  private static Integer constant(ExpressionTree tree) {
    return tree.asConstant(Integer.class).orElse(null);
  }

  @CheckForNull
  private static Integer length(ExpressionTree tree) {
    return tree.asConstant(String.class).map(String::length).orElse(null);
  }
}
"
S3042,CODE_SMELL,"""writeObject"" should not be the only ""synchronized"" code in a class","package org.sonar.java.checks.synchronization;

import org.sonar.check.Rule;
import org.sonar.java.checks.serialization.SerializableContract;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

import static org.sonar.java.model.ModifiersUtils.hasModifier;
import static org.sonar.plugins.java.api.tree.Modifier.SYNCHRONIZED;
import static org.sonar.plugins.java.api.tree.Tree.Kind.METHOD;

@Rule(key = ""S3042"")
public class WriteObjectTheOnlySynchronizedMethodCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    Symbol.TypeSymbol enclosingClass = methodTree.symbol().enclosingClass();
    String className = enclosingClass.type().fullyQualifiedName();
    MethodMatchers writeObjectMatcher = SerializableContract.writeObjectMatcher(className);
    if (writeObjectMatcher.matches(methodTree) && hasModifier(methodTree.modifiers(), SYNCHRONIZED)) {
      SynchronizationVisitor visitor = new SynchronizationVisitor(methodTree);
      enclosingClass.declaration().accept(visitor);
      if (!visitor.moreThanSingleLock) {
        reportIssue(ModifiersUtils.getModifier(methodTree.modifiers(), SYNCHRONIZED), ""Remove this \""synchronized\"" keyword."");
      }
    }
  }

  private static class SynchronizationVisitor extends BaseTreeVisitor {

    private final MethodTree writeObjectMethodTree;
    private boolean moreThanSingleLock;

    public SynchronizationVisitor(MethodTree writeObjectMethodTree) {
      this.writeObjectMethodTree = writeObjectMethodTree;
    }

    @Override
    public void visitSynchronizedStatement(SynchronizedStatementTree tree) {
      moreThanSingleLock = true;
    }

    @Override
    public void visitMethod(MethodTree tree) {
      if (tree.equals(writeObjectMethodTree) || moreThanSingleLock) {
        return;
      }
      if (hasModifier(tree.modifiers(), SYNCHRONIZED)) {
        moreThanSingleLock = true;
        return;
      }
      super.visitMethod(tree);
    }
  }
}
"
S3046,BUG,"""wait"" should not be called when multiple locks are held","package org.sonar.java.checks.synchronization;

import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.model.ModifiersUtils.findModifier;

@Rule(key = ""S3046"")
public class TwoLocksWaitCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers WAIT_MATCHER = MethodMatchers.create().ofAnyType().names(""wait"").addWithoutParametersMatcher().build();

  private Deque<Counter> synchronizedStack = new LinkedList<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    int initialCounter = findModifier(methodTree.modifiers(), Modifier.SYNCHRONIZED).map(m -> 1).orElse(0);
    synchronizedStack.push(new Counter(initialCounter));
    findWaitInvocation(methodTree);
  }

  @Override
  public void leaveNode(Tree tree) {
    synchronizedStack.pop();
  }

  private void findWaitInvocation(MethodTree tree) {
    findMethodCall(tree, WAIT_MATCHER)
      .ifPresent(wait -> reportIssue(wait, ""Don't use \""wait()\"" here; multiple locks are held."", flowFromTree(tree), null));
  }

  private Optional<MethodInvocationTree> findMethodCall(Tree tree, MethodMatchers methodMatcher) {
    MethodInvocationVisitor visitor = new MethodInvocationVisitor(methodMatcher);
    tree.accept(visitor);
    return visitor.matchedMethods().findAny();
  }

  private static List<JavaFileScannerContext.Location> flowFromTree(Tree tree) {
    SynchronizedKeywordVisitor synchronizedKeywordVisitor = new SynchronizedKeywordVisitor();
    tree.accept(synchronizedKeywordVisitor);
    return synchronizedKeywordVisitor.stream()
      .map(t -> new JavaFileScannerContext.Location(""locking"", t))
      .toList();
  }

  private class MethodInvocationVisitor extends BaseTreeVisitor {

    private final MethodMatchers methodMatcher;
    private Stream.Builder<MethodInvocationTree> matchedMethods = Stream.builder();

    private MethodInvocationVisitor(MethodMatchers methodMatcher) {
      this.methodMatcher = methodMatcher;
    }

    @Override
    public void visitSynchronizedStatement(SynchronizedStatementTree tree) {
      synchronizedStack.peek().increment();
      super.visitSynchronizedStatement(tree);
      synchronizedStack.peek().decrement();
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (methodMatcher.matches(tree) && synchronizedStack.peek().value >= 2) {
        matchedMethods.add(tree);
      }
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // cut visit on lambdas, calls are likely not invoked in this method scope
    }

    @Override
    public void visitClass(ClassTree tree) {
      // cut visit on anonymous and local classes, calls are likely not invoked in this method scope
    }

    private Stream<MethodInvocationTree> matchedMethods() {
      return matchedMethods.build();
    }
  }

  private static class SynchronizedKeywordVisitor extends BaseTreeVisitor {

    private Stream.Builder<SyntaxToken> synchronizedKeywords = Stream.builder();

    @Override
    public void visitSynchronizedStatement(SynchronizedStatementTree tree) {
      synchronizedKeywords.add(tree.synchronizedKeyword());
      super.visitSynchronizedStatement(tree);
    }

    @Override
    public void visitMethod(MethodTree tree) {
      findModifier(tree.modifiers(), Modifier.SYNCHRONIZED)
        .ifPresent(s -> synchronizedKeywords.add(s.keyword()));
      super.visitMethod(tree);
    }

    Stream<SyntaxToken> stream() {
      return synchronizedKeywords.build();
    }
  }

  private static class Counter {
    int value;

    private Counter(int initialValue) {
      this.value = initialValue;
    }

    void increment() {
      value++;
    }

    void decrement() {
      value--;
    }
  }

}
"
S3047,CODE_SMELL,Multiple loops over the same set should be combined,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.JavaTree;
import org.sonar.java.model.LineUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import javax.annotation.Nullable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Rule(key = ""S3047"")
public class LoopsOnSameSetCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    // raise issues only when they appear in the same block
    return Collections.singletonList(Tree.Kind.BLOCK);
  }

  @Override
  public void visitNode(Tree tree) {
    Map<Symbol, Integer> forEachSymbols = new HashMap<>();
    Tree previousForeachIterable = null;
    for (StatementTree item : ((BlockTree) tree).body()) {
      if (item.is(Tree.Kind.FOR_EACH_STATEMENT)) {
        ForEachStatement forEachStatement = (ForEachStatement) item;
        checkForEach(forEachSymbols, previousForeachIterable, forEachStatement);
        previousForeachIterable = forEachStatement.expression();
      } else {
        previousForeachIterable = null;
        item.accept(new InvalidatorVisitor(forEachSymbols));
      }
    }
  }

  private void checkForEach(Map<Symbol, Integer> forEachSymbols, @Nullable Tree previousIterable, ForEachStatement item) {
    ExpressionTree expressionTree = ExpressionUtils.skipParentheses(item.expression());
    if (expressionTree.is(Tree.Kind.IDENTIFIER)) {
      checkForEachIdentifier(forEachSymbols, (IdentifierTree) expressionTree);
    } else if (previousIterable != null) {
      checkForEachExpression(previousIterable, expressionTree);
    }
  }

  private void checkForEachExpression(Tree forEachIterable, ExpressionTree expressionTree) {
    if (SyntacticEquivalence.areEquivalent(expressionTree, forEachIterable)) {
      addIssue(expressionTree, LineUtils.startLine(forEachIterable));
    }
  }

  private void checkForEachIdentifier(Map<Symbol, Integer> forEachSymbols, IdentifierTree node) {
    Symbol symbol = node.symbol();
    if (symbol.owner().isMethodSymbol()) {
      if (forEachSymbols.containsKey(symbol)) {
        addIssue(node, forEachSymbols.get(symbol));
      } else {
        forEachSymbols.put(symbol, ((JavaTree) node).getLine());
      }
    }
  }

  private void addIssue(Tree tree, int line) {
    reportIssue(tree, ""Combine this loop with the one that starts on line "" + line + ""."");
  }

  private static class InvalidatorVisitor extends BaseTreeVisitor {
    private final Map<Symbol, Integer> forEachSymbols;

    InvalidatorVisitor(Map<Symbol, Integer> forEachSymbols) {
      this.forEachSymbols = forEachSymbols;
    }

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      Symbol symbol = tree.symbol();
      if (forEachSymbols.containsKey(symbol)) {
        forEachSymbols.remove(symbol);
      }
      super.visitIdentifier(tree);
    }
  }
}
"
S3052,CODE_SMELL,Fields should not be initialized to default values,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S3052"")
public class DefaultInitializedFieldCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    ((ClassTree) tree).members()
      .stream()
      .filter(member -> member.is(Tree.Kind.VARIABLE))
      .map(VariableTree.class::cast)
      .forEach(this::checkVariable);
  }

  private void checkVariable(VariableTree member) {
    if (ModifiersUtils.hasModifier(member.modifiers(), Modifier.FINAL)) {
      return;
    }
    ExpressionTree initializer = member.initializer();
    if (initializer != null) {
      ExpressionTree cleanedInitializer = ExpressionUtils.skipParentheses(initializer);
      getIfDefault(cleanedInitializer, member.type().symbolType().isPrimitive())
        .ifPresent(value -> reportIssue(cleanedInitializer, String.format(""Remove this initialization to \""%s\"", the compiler will do that for you."", value)));
    }
  }

  private static Optional<String> getIfDefault(ExpressionTree expression, boolean isPrimitive) {
    if (!isPrimitive && !expression.is(Tree.Kind.TYPE_CAST)) {
      return expression.is(Tree.Kind.NULL_LITERAL) ? literalValue(expression) : Optional.empty();
    }
    switch (expression.kind()) {
      case CHAR_LITERAL:
        return literalValue(expression)
          .filter(charValue -> ""'\\u0000'"".equals(charValue) || ""'\\0'"".equals(charValue));
      case BOOLEAN_LITERAL:
        return literalValue(expression)
          .filter(booleanValue -> LiteralUtils.isFalse(expression));
      case INT_LITERAL:
      case LONG_LITERAL:
        return Optional.ofNullable(LiteralUtils.longLiteralValue(expression))
          .filter(numericalValue -> numericalValue == 0)
          .flatMap(numericalValue -> literalValue(expression));
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
        return literalValue(expression)
          .filter(numericalValue -> Double.doubleToLongBits(Double.valueOf(numericalValue)) == 0);
      case TYPE_CAST:
        return getIfDefault(((TypeCastTree) expression).expression(), isPrimitive);
      default:
        return Optional.empty();
    }
  }

  private static Optional<String> literalValue(ExpressionTree expression) {
    return Optional.of(((LiteralTree) expression).value());
  }

}
"
S3064,BUG,Assignment of lazy-initialized members should be the last step with double-checked locking,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3064"")
public class DoubleCheckedLockingAssignmentCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.IF_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    IfStatementTree ifStatementTree = (IfStatementTree) tree;
    StatementTree body = getOnlyStatement(ifStatementTree);
    if (body == null || !body.is(Tree.Kind.SYNCHRONIZED_STATEMENT)) {
      return;
    }
    List<StatementTree> synchronizedBody = ((SynchronizedStatementTree) body).block().body();
    if (synchronizedBody.isEmpty()) {
      return;
    }
    Symbol symbol = nullCheck(ifStatementTree.condition());
    if (symbol == null || !symbol.owner().isTypeSymbol()) {
      return;
    }
    for (StatementTree statementTree : synchronizedBody) {
      if (statementTree.is(Tree.Kind.IF_STATEMENT)) {
        IfStatementTree secondIf = (IfStatementTree) statementTree;
        Symbol secondIfSymbol = nullCheck(secondIf.condition());
        if (symbol.equals(secondIfSymbol)) {
          checkUsageAfterAssignment(symbol, secondIf.thenStatement());
        }
      }
    }
  }

  private void checkUsageAfterAssignment(Symbol symbol, StatementTree thenStatement) {
    if (thenStatement.is(Tree.Kind.BLOCK)) {
      List<StatementTree> body = ((BlockTree) thenStatement).body();
      AssignmentExpressionTree foundAssignment = null;
      UsageVisitor usageVisitor = new UsageVisitor(symbol);
      for (StatementTree statementTree : body) {
        if (foundAssignment != null) {
          statementTree.accept(usageVisitor);
        }
        AssignmentExpressionTree assignment = isAssignmentToSymbol(statementTree, symbol);
        if (assignment != null) {
          foundAssignment = assignment;
        }
      }
      if (foundAssignment != null && !usageVisitor.usages.isEmpty()) {
        reportIssue(foundAssignment, ""Fully initialize \"""" + symbol.name() + ""\"" before assigning it."", usageVisitor.locations(), null);
      }
    }
  }

  @CheckForNull
  private static AssignmentExpressionTree isAssignmentToSymbol(StatementTree statementTree, Symbol symbol) {
    if (!statementTree.is(Tree.Kind.EXPRESSION_STATEMENT)) {
      return null;
    }
    ExpressionTree expr = ((ExpressionStatementTree) statementTree).expression();
    if (expr.is(Tree.Kind.ASSIGNMENT)) {
      AssignmentExpressionTree assignment = (AssignmentExpressionTree) expr;
      if (symbol.equals(symbol(assignment.variable()))) {
        return assignment;
      }
    }
    return null;
  }

  static class UsageVisitor extends BaseTreeVisitor {

    private final Symbol symbol;
    List<IdentifierTree> usages = new ArrayList<>();

    public UsageVisitor(Symbol symbol) {
      this.symbol = symbol;
    }

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      if (symbol.equals(tree.symbol())) {
        usages.add(tree);
      }
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // cut the visit
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      // cut the visit
    }

    @Override
    public void visitMethod(MethodTree tree) {
      // cut the visit
    }

    List<JavaFileScannerContext.Location> locations() {
      return usages.stream()
        .map(u -> new JavaFileScannerContext.Location(""Usage after assignment"", u))
        .toList();
    }
  }

  @CheckForNull
  private static StatementTree getOnlyStatement(IfStatementTree ifStatementTree) {
    StatementTree thenStatement = ifStatementTree.thenStatement();
    if (thenStatement.is(Tree.Kind.EXPRESSION_STATEMENT)) {
      return thenStatement;
    }
    if (thenStatement.is(Tree.Kind.BLOCK)) {
      BlockTree blockTree = (BlockTree) thenStatement;
      if (blockTree.body().size() == 1) {
        return blockTree.body().get(0);
      }
    }
    return null;
  }

  @CheckForNull
  private static Symbol nullCheck(ExpressionTree tree) {
    if (!tree.is(Tree.Kind.EQUAL_TO)) {
      return null;
    }
    BinaryExpressionTree equalTo = (BinaryExpressionTree) tree;
    ExpressionTree lhs = equalTo.leftOperand();
    ExpressionTree rhs = equalTo.rightOperand();
    Symbol symbol = symbol(lhs);
    if (symbol != null && rhs.is(Tree.Kind.NULL_LITERAL)) {
      return symbol;
    }
    symbol = symbol(rhs);
    if (symbol != null && lhs.is(Tree.Kind.NULL_LITERAL)) {
      return symbol;
    }
    return null;
  }

  @CheckForNull
  private static Symbol symbol(ExpressionTree tree) {
    if (tree.is(Tree.Kind.IDENTIFIER)) {
      return ((IdentifierTree) tree).symbol();
    }
    if (tree.is(Tree.Kind.MEMBER_SELECT)) {
      return ((MemberSelectExpressionTree) tree).identifier().symbol();
    }
    return null;
  }

}
"
S3066,CODE_SMELL,"""enum"" fields should not be publicly mutable","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.tree.PrimitiveTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S3066"")
public class EnumMutableFieldCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree enumTree = (ClassTree) tree;
    for (Tree member : enumTree.members()) {
      if (member.is(Tree.Kind.VARIABLE)) {
        VariableTree variableTree = (VariableTree) member;
        ModifiersTree modifiers = variableTree.modifiers();
        ModifierKeywordTree publicModifier = ModifiersUtils.getModifier(modifiers, Modifier.PUBLIC);
        if (publicModifier != null && (isNotStaticOrFinal(variableTree.modifiers())|| isMutableFinalMember(variableTree))) {
          reportIssue(publicModifier, ""Lower the visibility of this field."");
        }
      } else if (member.is(Tree.Kind.METHOD)) {
        MethodTree methodTree = (MethodTree) member;
        ModifierKeywordTree publicModifier = ModifiersUtils.getModifier(methodTree.modifiers(), Modifier.PUBLIC);
        if (publicModifier != null && isSetter(methodTree)) {
          reportIssue(publicModifier, ""Lower the visibility of this setter or remove it altogether."");
        }
      }
    }
  }
  
  private static boolean isNotStaticOrFinal(ModifiersTree modifiersTree) {
    return ModifiersUtils.hasNoneOf(modifiersTree, Modifier.STATIC, Modifier.FINAL);
  }
  
  private static boolean isMutableFinalMember(VariableTree variableTree) {
    ModifiersTree modifiersTree = variableTree.modifiers();
    return !ModifiersUtils.hasModifier(modifiersTree, Modifier.STATIC) && ModifiersUtils.hasModifier(modifiersTree, Modifier.FINAL) && isMutableMember(variableTree);
  }
  
  private static boolean isMutableMember(VariableTree variableTree) {
    return variableTree.type().is(Tree.Kind.ARRAY_TYPE) || isDateOrCollection(variableTree);
  }
  
  private static boolean isDateOrCollection(VariableTree variableTree) {
    Type type = variableTree.symbol().type();
    return type.is(""java.util.Date"") ||
      (type.isSubtypeOf(""java.util.Collection"") && !type.isSubtypeOf(""com.google.common.collect.ImmutableCollection""));
  }

  private static boolean isSetter(MethodTree methodTree) {
    TypeTree returnType = methodTree.returnType();
    BlockTree block = methodTree.block();
    boolean returnsVoid = returnType.is(Tree.Kind.PRIMITIVE_TYPE) && ""void"".equals(((PrimitiveTypeTree) returnType).keyword().text());
    boolean hasAtLeastOneStatement = block == null || !block.body().isEmpty();
    return methodTree.simpleName().name().startsWith(""set"") && methodTree.parameters().size() == 1 && returnsVoid && hasAtLeastOneStatement;
  }
}
"
S3067,BUG,"""getClass"" should not be used for synchronization","package org.sonar.java.checks.synchronization;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

import static org.sonar.plugins.java.api.tree.Tree.Kind.CLASS;
import static org.sonar.plugins.java.api.tree.Tree.Kind.CONSTRUCTOR;
import static org.sonar.plugins.java.api.tree.Tree.Kind.ENUM;
import static org.sonar.plugins.java.api.tree.Tree.Kind.IDENTIFIER;
import static org.sonar.plugins.java.api.tree.Tree.Kind.METHOD;
import static org.sonar.plugins.java.api.tree.Tree.Kind.METHOD_INVOCATION;
import static org.sonar.plugins.java.api.tree.Tree.Kind.SYNCHRONIZED_STATEMENT;

@Rule(key = ""S3067"")
public class SynchronizationOnGetClassCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers GET_CLASS_MATCHER = MethodMatchers.create().ofAnyType().names(""getClass"").addWithoutParametersMatcher().build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(SYNCHRONIZED_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    SynchronizedStatementTree synchronizedTree = (SynchronizedStatementTree) tree;
    if (synchronizedTree.expression().is(METHOD_INVOCATION)) {
      MethodInvocationTree synchronizedExpr = (MethodInvocationTree) synchronizedTree.expression();
      if (GET_CLASS_MATCHER.matches(synchronizedExpr) && !isEnclosingClassFinal(synchronizedExpr.methodSelect())) {
        reportIssue(synchronizedExpr, ""Synchronize on the static class name instead."");
      }
    }
  }

  private static boolean isEnclosingClassFinal(ExpressionTree expressionTree) {
    if (expressionTree.is(IDENTIFIER)) {
      MethodTree methodTree = findMethodTreeAncestor(expressionTree);
      if (methodTree != null) {
        return methodTree.symbol().owner().isFinal();
      }
      return findClassTreeAncestor(expressionTree).symbol().isFinal();
    }
    return ((MemberSelectExpressionTree) expressionTree).expression().symbolType().symbol().isFinal();
  }

  private static ClassTree findClassTreeAncestor(ExpressionTree expressionTree) {
    Tree parent = expressionTree.parent();
    while (!parent.is(CLASS, ENUM)) {
      parent = parent.parent();
    }
    return (ClassTree) parent;
  }

  private static MethodTree findMethodTreeAncestor(ExpressionTree expressionTree) {
    Tree parent = expressionTree.parent();
    while (parent != null) {
      if (parent.is(METHOD, CONSTRUCTOR)) {
        return (MethodTree) parent;
      }
      parent = parent.parent();
    }
    return null;
  }

}
"
S3077,BUG,"Non-primitive fields should not be ""volatile""","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S3077"")
public class VolatileNonPrimitiveFieldCheck extends IssuableSubscriptionVisitor {

  private static final String REF_MESSAGE = ""Use a thread-safe type; adding \""volatile\"" is not enough to make this field thread-safe."";
  private static final String ARRAY_MESSAGE = ""Use an \""Atomic%sArray\"" instead."";

  private static final List<String> STANDARD_IMMUTABLE_TYPES = Arrays.asList(
    ""java.awt.Color"",
    ""java.awt.Cursor"",
    ""java.awt.Font"",
    ""java.io.File"",
    ""java.lang.Boolean"",
    ""java.lang.Byte"",
    ""java.lang.Character"",
    ""java.lang.Double"",
    ""java.lang.Float"",
    ""java.lang.Integer"",
    ""java.lang.Long"",
    ""java.lang.Short"",
    ""java.lang.String"",
    ""java.math.BigDecimal"",
    ""java.math.BigInteger"",
    ""java.net.Inet4Address"",
    ""java.net.Inet6Address"",
    ""java.net.URL"",
    ""java.time.Clock"",
    ""java.time.Instant"",
    ""java.time.LocalDate"",
    ""java.time.LocalDateTime"",
    ""java.time.LocalTime"",
    ""java.time.MonthDay"",
    ""java.time.OffsetDateTime"",
    ""java.time.OffsetTime"",
    ""java.time.Year"",
    ""java.time.YearMonth"",
    ""java.time.ZoneId"",
    ""java.time.ZoneOffset"",
    ""java.time.ZonedDateTime"",
    ""java.time.Duration"",
    ""java.time.Period"",
    ""java.util.Locale"",
    ""java.util.UUID"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    ((ClassTree) tree).members()
      .stream()
      .filter(m -> m.is(Tree.Kind.VARIABLE))
      .map(VariableTree.class::cast)
      .filter(v -> ModifiersUtils.hasModifier(v.modifiers(), Modifier.VOLATILE))
      .filter(v -> isUnsafeVolatile(v.type().symbolType()))
      .forEach(v -> reportIssue(ModifiersUtils.getModifier(v.modifiers(), Modifier.VOLATILE), v.type(), getMessage(v)));
  }

  private static boolean isUnsafeVolatile(Type symbolType) {
    return !symbolType.isUnknown() &&
      !(symbolType.isPrimitive()
      || isImmutableType(symbolType)
      || isSafelyAnnotated(symbolType.symbol().metadata()));
  }

  private static boolean isSafelyAnnotated(SymbolMetadata metadata) {
    return metadata.annotations().stream()
      .map(SymbolMetadata.AnnotationInstance::symbol)
      .map(Symbol::type)
      .anyMatch(type -> type.is(""javax.annotation.concurrent.Immutable"")
        || type.is(""javax.annotation.concurrent.ThreadSafe""));
  }

  private static boolean isImmutableType(Type type) {
    return type.symbol().isEnum() || STANDARD_IMMUTABLE_TYPES.stream().anyMatch(type::is);
  }

  private static String getMessage(VariableTree variableTree) {
    Type varType = variableTree.type().symbolType();
    if (varType.isArray()) {
      String atomicType = ""Reference"";
      Type elementType = ((Type.ArrayType) varType).elementType();
      if (elementType.isPrimitive(Type.Primitives.LONG)) {
        atomicType = ""Long"";
      } else if (elementType.isPrimitive(Type.Primitives.INT)) {
        atomicType = ""Integer"";
      }
      return String.format(ARRAY_MESSAGE, atomicType);
    }
    return REF_MESSAGE;
  }
}
"
S3078,BUG,"""volatile"" variables should not be used with compound operators","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

@Rule(key = ""S3078"")
public class VolatileVariablesOperationsCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.PREFIX_INCREMENT,
      Tree.Kind.POSTFIX_INCREMENT,
      Tree.Kind.PREFIX_DECREMENT,
      Tree.Kind.POSTFIX_DECREMENT,
      Tree.Kind.LOGICAL_COMPLEMENT,
      Tree.Kind.MULTIPLY_ASSIGNMENT,
      Tree.Kind.DIVIDE_ASSIGNMENT,
      Tree.Kind.REMAINDER_ASSIGNMENT,
      Tree.Kind.PLUS_ASSIGNMENT,
      Tree.Kind.MINUS_ASSIGNMENT,
      Tree.Kind.LEFT_SHIFT_ASSIGNMENT,
      Tree.Kind.RIGHT_SHIFT_ASSIGNMENT,
      Tree.Kind.UNSIGNED_RIGHT_SHIFT_ASSIGNMENT,
      Tree.Kind.XOR_ASSIGNMENT,
      Tree.Kind.OR_ASSIGNMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ExpressionTree expression;
    if (tree instanceof UnaryExpressionTree unaryExpressionTree) {
      expression = ExpressionUtils.skipParentheses(unaryExpressionTree.expression());
    } else {
      expression = ((AssignmentExpressionTree) tree).variable();
    }
    IdentifierTree identifier = getVariableIdentifier(expression);
    if (identifier == null || !identifier.symbol().isVolatile()) {
      return;
    }

    if (tree.is(Tree.Kind.LOGICAL_COMPLEMENT)) {
      checkBooleanToggling(tree, identifier.symbol());
    } else {
      checkIncrementDecrement(tree, identifier);
    }
  }

  @Nullable
  private static IdentifierTree getVariableIdentifier(ExpressionTree expressionTree) {
    if (expressionTree.is(Tree.Kind.IDENTIFIER)) {
      return (IdentifierTree) expressionTree;
    }
    if (expressionTree.is(Tree.Kind.MEMBER_SELECT)) {
      return ((MemberSelectExpressionTree) expressionTree).identifier();
    }
    return null;
  }

  private void checkBooleanToggling(Tree tree, Symbol identifierSymbol) {
    Tree parent = tree.parent();
    if (parent.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {
      checkBooleanToggling(parent, identifierSymbol);
    } else if (parent.is(Tree.Kind.ASSIGNMENT)) {
      IdentifierTree variableIdentifier = getVariableIdentifier(((AssignmentExpressionTree) parent).variable());
      if (variableIdentifier != null && identifierSymbol.equals(variableIdentifier.symbol())) {
        reportIssueIfNotInExcludedContext(tree, ""AtomicBoolean"");
      }
    }
  }

  private void checkIncrementDecrement(Tree tree, IdentifierTree identifier) {
    Type symbolType = identifier.symbol().type();
    if (symbolType.is(""int"") || symbolType.is(""java.lang.Integer"")) {
      reportIssueIfNotInExcludedContext(tree, ""AtomicInteger"");
    } else if (symbolType.is(""long"") || symbolType.is(""java.lang.Long"")) {
      reportIssueIfNotInExcludedContext(tree, ""AtomicLong"");
    }
  }

  private void reportIssueIfNotInExcludedContext(Tree tree, String recommendedType) {
    Tree current = tree.parent();
    boolean foundClass = false;
    while (!foundClass) {
      switch (current.kind()) {
        case LAMBDA_EXPRESSION:
        case SYNCHRONIZED_STATEMENT:
        case COMPILATION_UNIT:
          return;
        case METHOD:
          if (ModifiersUtils.hasModifier(((MethodTree) current).modifiers(), Modifier.SYNCHRONIZED)) {
            return;
          }
          break;
        case ENUM:
        case CLASS:
          if (((ClassTree) current).simpleName() == null) {
            return;
          }
          // we got to a non anonymous class, we can safely raise an issue
          foundClass = true;
          break;
      }
      current = current.parent();
    }
    reportIssue(tree, String.format(""Use an \""%s\"" for this field; its operations are atomic."", recommendedType));
  }

}
"
S3242,CODE_SMELL,Method parameters should be declared with base types,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.checks.helpers.AnnotationsHelper.hasUnknownAnnotation;

@Rule(key = ""S3242"")
public class LeastSpecificTypeCheck extends IssuableSubscriptionVisitor {

  private static final Set<String> SPRING_INJECT_ANNOTATIONS = Set.of(
    ""org.springframework.beans.factory.annotation.Autowired"",
    ""javax.inject.Inject"",
    ""jakarta.inject.Inject"",
    ""javax.annotation.Resource"",
    ""jakarta.annotation.Resource"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();
    SymbolMetadata metadata = methodSymbol.metadata();
    if (!methodSymbol.isPublic()
      || !Boolean.FALSE.equals(methodTree.isOverriding())
      || isOverloaded(methodSymbol)
      || hasUnknownAnnotation(metadata)) {
      return;
    }

    boolean springInjectionAnnotated = isSpringInjectionAnnotated(metadata);
    methodTree.parameters().stream()
      .map(VariableTree::symbol)
      .filter(p -> p.type().isClass() && !p.type().symbol().isEnum() && !isStringType(p.type()))
      .filter(p -> !(springInjectionAnnotated && p.type().is(""java.util.Collection"")))
      .forEach(p -> handleParameter(p, springInjectionAnnotated));
  }

  private static boolean isOverloaded(Symbol.MethodSymbol methodSymbol) {
    return ((Symbol.TypeSymbol) methodSymbol.owner()).lookupSymbols(methodSymbol.name()).size() > 1;
  }

  private static boolean isStringType(Type type) {
    return type.isUnknown() || type.is(""java.lang.String"");
  }

  private void handleParameter(Symbol parameter, boolean springInjectionAnnotated) {
    Type parameterType = parameter.type();
    if (parameterType.symbol().metadata().isAnnotatedWith(""java.lang.FunctionalInterface"")) {
      // Exclude functional interface, it's wrong to have issues on UnaryOperator<T> and ask the user to use Function<T,T> instead
      return;
    }

    Type leastSpecificType = findLeastSpecificType(parameter);
    if (parameterType != leastSpecificType
      && !leastSpecificType.is(""java.lang.Object"")) {

      String suggestedType = getSuggestedType(springInjectionAnnotated, leastSpecificType);
      String message = String.format(""Use '%s' here; it is a more general type than '%s'."", suggestedType, parameterType.erasure().name());
      reportIssue(parameter.declaration(), message);
    }
  }

  private static String getSuggestedType(boolean springInjectionAnnotated, Type leastSpecificType) {
    if (springInjectionAnnotated && leastSpecificType.is(""java.lang.Iterable"")) {
      return ""java.util.Collection"";
    }
    return leastSpecificType.fullyQualifiedName().replace('$', '.');
  }

  private static Type findLeastSpecificType(Symbol parameter) {
    InheritanceGraph inheritanceGraph = new InheritanceGraph(parameter.type());
    for (IdentifierTree usage : parameter.usages()) {
      Tree parent = usage.parent();
      while (parent != null && !parent.is(Tree.Kind.ARGUMENTS, Tree.Kind.METHOD_INVOCATION, Tree.Kind.EXPRESSION_STATEMENT, Tree.Kind.FOR_EACH_STATEMENT)) {
        parent = parent.parent();
      }
      if (parent == null || parent.is(Tree.Kind.EXPRESSION_STATEMENT, Tree.Kind.ARGUMENTS)) {
        return parameter.type();
      }
      if (parent.is(Tree.Kind.FOR_EACH_STATEMENT)) {
        findIteratorMethod(parameter).ifPresent(inheritanceGraph::update);
      } else if (parent.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree mit = (MethodInvocationTree) parent;
        if (isMethodInvocationOnParameter(parameter, mit)) {
          inheritanceGraph.update(mit.methodSymbol());
        }
      }
    }
    return inheritanceGraph.leastSpecificType();
  }

  private static Optional<Symbol.MethodSymbol> findIteratorMethod(Symbol parameter) {
    return parameter.type().symbol().lookupSymbols(""iterator"").stream()
      .filter(Symbol::isMethodSymbol)
      .map(Symbol.MethodSymbol.class::cast)
      .filter(methodSymbol -> methodSymbol.parameterTypes().isEmpty())
      .findFirst();
  }

  private static class InheritanceGraph {

    private final Type startType;
    private List<List<Type>> chains = null;

    private InheritanceGraph(Type type) {
      startType = type;
    }

    private void update(Symbol.MethodSymbol m) {
      if (chains == null) {
        chains = computeChains(m, startType);
      } else {
        refineChains(m);
      }
    }

    private List<List<Type>> computeChains(Symbol.MethodSymbol m, Type type) {
      List<List<Type>> result = new ArrayList<>();
      Symbol.TypeSymbol typeSymbol = type.symbol();
      Type superClass = typeSymbol.superClass();
      if (superClass != null) {
        computeChainsForSuperType(result, m, type, superClass);
      }
      for (Type i : typeSymbol.interfaces()) {
        computeChainsForSuperType(result, m, type, i);
      }

      boolean definesSymbol = definesSymbol(m, typeSymbol);
      boolean isSpecialization = !startType.isParameterized() && type.isParameterized();
      if (definesSymbol && !isSpecialization && result.isEmpty()) {
        ArrayList<Type> list = new ArrayList<>();
        list.add(type);
        result.add(list);
      }
      return result;
    }

    private void computeChainsForSuperType(List<List<Type>> result, Symbol.MethodSymbol methodSymbol, Type type, Type superType) {
      for (List<Type> chain : computeChains(methodSymbol, superType)) {
        chain.add(type);
        result.add(chain);
      }
    }

    private static boolean definesOrInheritsSymbol(Symbol.MethodSymbol methodSymbol, Symbol.TypeSymbol typeSymbol) {
      return definesSymbol(methodSymbol, typeSymbol)
        || typeSymbol.superTypes().stream().anyMatch(superType -> definesSymbol(methodSymbol, superType.symbol()));
    }

    private static boolean definesSymbol(Symbol.MethodSymbol methodSymbol, Symbol.TypeSymbol typeSymbol) {
      return typeSymbol.memberSymbols()
        .stream()
        .filter(Symbol::isMethodSymbol)
        .map(Symbol.MethodSymbol.class::cast)
        .filter(memberMethodSymbol -> memberMethodSymbol.name().equals(methodSymbol.name()))
        .anyMatch(memberMethodSymbol -> isOverridingWithSameReturnType(methodSymbol, memberMethodSymbol));
    }

    private void refineChains(Symbol.MethodSymbol m) {
      for (List<Type> chain : chains) {
        Iterator<Type> chainIterator = chain.iterator();
        while (chainIterator.hasNext()) {
          Type type = chainIterator.next();
          if (definesOrInheritsSymbol(m, type.symbol())) {
            break;
          }
          chainIterator.remove();
        }
      }
    }

    private Type leastSpecificType() {
      if (chains == null) {
        return startType;
      }
      chains.forEach(c -> c.removeIf(t -> !t.symbol().isPublic()));
      if (chains.stream().allMatch(List::isEmpty)) {
        return startType;
      }
      // pick longest chain, if multiple have same length, prefer interface, if multiple choices, choose alphabetically
      chains.sort(Comparator.<List<Type>>comparingInt(List::size)
        .thenComparing(chain -> chain.get(0).symbol().isInterface(), Boolean::compare)
        .thenComparing(chain -> chain.get(0), Comparator.comparing(Type::fullyQualifiedName).reversed())
        .reversed());

      List<Type> longestChain = chains.get(0);
      return longestChain.get(0);
    }

    private static boolean isOverridingWithSameReturnType(Symbol.MethodSymbol m, Symbol.MethodSymbol leastSpecificM) {
      return (m.returnType().type() == leastSpecificM.returnType().type() || isGenericReturnType(leastSpecificM))
        && ConfusingOverloadCheck.isPotentialOverride(m, leastSpecificM);
    }

    private static boolean isGenericReturnType(Symbol.MethodSymbol leastSpecificM) {
      return isGenericType(leastSpecificM.returnType().type());
    }

    private static boolean isGenericType(Type type) {
      return type.isTypeVar() || (type.isParameterized() && type.typeArguments().stream().allMatch(InheritanceGraph::isGenericType));
    }
  }

  private static boolean isMethodInvocationOnParameter(Symbol parameter, MethodInvocationTree mit) {
    if (mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mset = (MemberSelectExpressionTree) mit.methodSelect();
      if (mset.expression().is(Tree.Kind.IDENTIFIER)) {
        Symbol symbol = ((IdentifierTree) mset.expression()).symbol();
        return symbol == parameter;
      }
    }
    return false;
  }

  private static boolean isSpringInjectionAnnotated(SymbolMetadata metadata) {
    return SPRING_INJECT_ANNOTATIONS.stream().anyMatch(metadata::isAnnotatedWith);
  }
}
"
S3252,CODE_SMELL,"""static"" base class members should not be accessed via derived types","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3252"")
public class StaticMemberAccessCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers LIST_SET_OF = MethodMatchers.create()
    .ofTypes(""java.util.List"", ""java.util.Set"")
    .names(""of"")
    .withAnyParameters()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.MEMBER_SELECT);
  }


  @Override
  public void visitNode(Tree tree) {
    MemberSelectExpressionTree mse = (MemberSelectExpressionTree) tree;
    Symbol symbol = mse.identifier().symbol();
    if (symbol.isStatic()  && !isListOrSetOf(mse)) {
      ExpressionTree expression = mse.expression();
      Type staticType = symbol.owner().type();
      Type expressionType = expression.symbolType();
      if (!staticType.isUnknown() && !expressionType.isUnknown()
        && !expressionType.erasure().equals(staticType.erasure())) {
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(mse.identifier())
          .withMessage(""Use static access with \""%s\"" for \""%s\""."", staticType.fullyQualifiedName(), symbol.name())
          .withQuickFix(() -> quickFix(expression, staticType))
          .report();
      }
    }
  }

  private static boolean isListOrSetOf(MemberSelectExpressionTree mse) {
    // this is necessary because we incorrectly resolve to Set#of List#of methods on JDK11
    // see SONARJAVA-3095
    Tree parent = mse.parent();
    return parent.is(Tree.Kind.METHOD_INVOCATION) && LIST_SET_OF.matches((MethodInvocationTree) parent);
  }

  private static JavaQuickFix quickFix(ExpressionTree expression, Type staticType) {
    String oldType = expression.symbolType().name();
    String newType = staticType.name();
    return JavaQuickFix.newQuickFix(String.format(""Use \""%s\"" instead of \""%s\"""", newType, oldType))
      .addTextEdit(JavaTextEdit.replaceTree(expression, newType))
      .build();
  }
}
"
S3254,CODE_SMELL,Default annotation parameter values should not be passed as arguments,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.JUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Symbol.TypeSymbol;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3254"")
public class AnnotationDefaultArgumentCheck extends IssuableSubscriptionVisitor {
  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.ANNOTATION);
  }

  @Override
  public void visitNode(Tree tree) {
    AnnotationTree annotationTree = (AnnotationTree) tree;
    TypeSymbol annotationSymbol = annotationTree.symbolType().symbol();
    if (annotationSymbol.isUnknown()) {
      return;
    }

    Map<String, Object> defaultValueByName = annotationSymbol.memberSymbols().stream()
      .filter(Symbol::isMethodSymbol)
      .map(Symbol.MethodSymbol.class::cast)
      .filter(s -> JUtils.defaultValue(s) != null)
      .collect(Collectors.toMap(Symbol::name, JUtils::defaultValue));

    for (ExpressionTree argument : annotationTree.arguments()) {
      ExpressionTree valueSet = argument;
      // Single element annotation : JLS8 9.7.3 : one param must be named value.
      String paramName = ""value"";
      if (argument.is(Tree.Kind.ASSIGNMENT)) {
        AssignmentExpressionTree assignmentTree = (AssignmentExpressionTree) argument;
        IdentifierTree nameTree = (IdentifierTree) assignmentTree.variable();
        paramName = nameTree.name();
        valueSet = assignmentTree.expression();
      }
      if (setValueIsSameAsDefaultValue(defaultValueByName.get(paramName), valueSet)) {
        reportIssue(argument, String.format(""Remove this default value assigned to parameter \""%s\""."", paramName));
      }
    }
  }

  private static boolean setValueIsSameAsDefaultValue(@Nullable Object defaultValue, ExpressionTree valueSet) {
    Optional<String> valueAsStringConstant = valueSet.asConstant(String.class);
    if (valueAsStringConstant.isPresent()) {
      return valueAsStringConstant.get().equals(defaultValue);
    }
    Optional<Integer> valueAsIntConstant = valueSet.asConstant(Integer.class);
    return valueAsIntConstant.map(integer -> integer.equals(defaultValue)).orElse(false);
  }

}
"
S3305,CODE_SMELL,"Factory method injection should be used in ""@Configuration"" classes","package org.sonar.java.checks.spring;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S3305"")
public class SpringConfigurationWithAutowiredFieldsCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE_FORMAT = ""Inject this field value directly into \""%s\"", the only method that uses it."";

  private static final String CONFIGURATION_ANNOTATION = ""org.springframework.context.annotation.Configuration"";
  private static final String BEAN_ANNOTATION = ""org.springframework.context.annotation.Bean"";
  private static final List<String> AUTOWIRED_ANNOTATIONS = Arrays.asList(
    ""org.springframework.beans.factory.annotation.Autowired"",
    ""javax.inject.Inject"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (classTree.symbol().metadata().isAnnotatedWith(CONFIGURATION_ANNOTATION)) {
      Map<Symbol, VariableTree> autowiredFields = new HashMap<>();
      classTree.members().forEach(m -> collectAutowiredFields(m, autowiredFields));

      Map<Symbol, List<MethodTree>> methodsThatUseAutowiredFields = new HashMap<>();
      autowiredFields.keySet().forEach(f -> methodsThatUseAutowiredFields.put(f, new ArrayList<>()));
      classTree.members().forEach(m -> collectMethodsThatUseAutowiredFields(m, methodsThatUseAutowiredFields));

      // report autowired fields that are used by a single method, if that method is @Bean
      methodsThatUseAutowiredFields.entrySet().stream()
        .filter(methodsForField -> methodsForField.getValue().size() == 1 &&
          methodsForField.getValue().get(0).symbol().metadata().isAnnotatedWith(BEAN_ANNOTATION))
        .forEach(methodsForField -> reportIssue(
          autowiredFields.get(methodsForField.getKey()).simpleName(),
          String.format(MESSAGE_FORMAT, methodsForField.getValue().get(0).simpleName().name())));
    }
  }

  private static void collectAutowiredFields(Tree tree, Map<Symbol, VariableTree> autowiredFields) {
    if (!tree.is(Tree.Kind.VARIABLE)) {
      return;
    }
    VariableTree variable = (VariableTree) tree;
    Symbol variableSymbol = variable.symbol();
    SymbolMetadata metadata = variableSymbol.metadata();

    for(String annotation: AUTOWIRED_ANNOTATIONS) {
      List<SymbolMetadata.AnnotationValue> annotationValues = metadata.valuesForAnnotation(annotation);
      if (annotationValues != null) {
        if (annotationValues.stream().anyMatch(SpringConfigurationWithAutowiredFieldsCheck::isRequiredFalse)
          && variable.initializer() != null) {
          // Common pattern used to define a default value.
          continue;
        }
        autowiredFields.put(variableSymbol, variable);
      }
    }
  }

  private static boolean isRequiredFalse(SymbolMetadata.AnnotationValue annotationValue) {
    Object value = annotationValue.value();
    return ""required"".equals(annotationValue.name()) && Boolean.FALSE.equals(value);
  }

  private static void collectMethodsThatUseAutowiredFields(Tree tree, Map<Symbol, List<MethodTree>> methodsThatUseAutowiredFields) {
    if (!tree.is(Tree.Kind.METHOD)) {
      return;
    }
    IdentifiersVisitor identifiersVisitor = new IdentifiersVisitor(methodsThatUseAutowiredFields.keySet());
    tree.accept(identifiersVisitor);
    // for each autowired field that is referenced in this method, add the current method name to the list
    identifiersVisitor.isFieldReferenced.entrySet().stream()
      .filter(Map.Entry::getValue)
      .map(Map.Entry::getKey)
      .forEach(field -> methodsThatUseAutowiredFields.get(field).add((MethodTree) tree));
  }

  private static class IdentifiersVisitor extends BaseTreeVisitor {
    private final Map<Symbol, Boolean> isFieldReferenced = new HashMap<>();

    IdentifiersVisitor(Set<Symbol> autowiredFields) {
      autowiredFields.forEach(f -> isFieldReferenced.put(f, false));
    }

    @Override
    public void visitIdentifier(IdentifierTree identifierTree) {
      isFieldReferenced.computeIfPresent(identifierTree.symbol(), (fieldSym, isPresent) -> true);
    }
  }
}
"
S3306,BUG,Constructor injection should be used instead of field injection,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

@Rule(key = ""S3306"")
public class ConstructorInjectionCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    List<Tree> members = ((ClassTree) tree).members();
    Optional<Tree> first = members.stream().filter(t -> t.is(Tree.Kind.CONSTRUCTOR) && isPrivateConstructor((MethodTree) t)).findFirst();
    if(first.isPresent()) {
      return;
    }
    members.stream()
      .filter(t -> t.is(Tree.Kind.VARIABLE) && isAnnotatedWithInject((VariableTree) t))
      .forEach(field -> reportIssue(((VariableTree) field).simpleName(), ""Use constructor injection for this field."")
    );
  }

  private static boolean isPrivateConstructor(MethodTree constructor) {
    return constructor.symbol().isPrivate();
  }

  private static boolean isAnnotatedWithInject(VariableTree field) {
    return field.symbol().metadata().isAnnotatedWith(""javax.inject.Inject"");
  }

}
"
S3329,VULNERABILITY,Cipher Block Chaining IVs should be unpredictable,"package org.sonar.java.checks.security;

import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.Symbols;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.checks.helpers.ReassignmentFinder.getReassignments;

@Rule(key = ""S3329"")
public class CipherBlockChainingCheck extends AbstractMethodDetection {

  private static final MethodMatchers SECURE_RANDOM_GENERATE_SEED = MethodMatchers.create()
    .ofTypes(""java.security.SecureRandom"")
    .names(""generateSeed"")
    .withAnyParameters()
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofTypes(""javax.crypto.spec.IvParameterSpec"").constructor()
      .addParametersMatcher(types -> !types.isEmpty())
      .build();
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    if (newClassTree.arguments().isEmpty() || isDynamicallyGenerated(newClassTree.arguments().get(0))) {
      return;
    }

    Tree mTree = ExpressionUtils.getEnclosingMethod(newClassTree);
    if (mTree != null) {
      MethodInvocationVisitor mitVisit = new MethodInvocationVisitor(newClassTree);
      mTree.accept(mitVisit);
      if (!mitVisit.secureRandomFound) {
        reportIssue(newClassTree, ""Use a dynamically-generated, random IV."");
      }
    }
  }

  private static boolean isDynamicallyGenerated(ExpressionTree tree) {
    if (tree.is(Tree.Kind.IDENTIFIER)) {
      Symbol symbol = ((IdentifierTree) tree).symbol();
      if (symbol.isParameter()) {
        return true;
      }
      VariableTree declaration = symbol.isVariableSymbol() ? ((Symbol.VariableSymbol) symbol).declaration() : null;
      return declaration != null &&
        (isSecureRandomGenerateSeed(declaration.initializer()) ||
          getReassignments(declaration, symbol.usages()).stream()
            .map(AssignmentExpressionTree::expression)
            .anyMatch(CipherBlockChainingCheck::isSecureRandomGenerateSeed));
    } else {
      return isSecureRandomGenerateSeed(tree);
    }
  }

  private static boolean isSecureRandomGenerateSeed(@Nullable ExpressionTree tree) {
    return tree != null && tree.is(Tree.Kind.METHOD_INVOCATION) && SECURE_RANDOM_GENERATE_SEED.matches((MethodInvocationTree) tree);
  }

  private static class MethodInvocationVisitor extends BaseTreeVisitor {

    private boolean secureRandomFound = false;
    private final NewClassTree ivParameterSpecInstantiation;
    // to be used in case of assignment to a variable
    private final Symbol ivParameterSymbol;

    private static final MethodMatchers SECURE_RANDOM_NEXT_BYTES = MethodMatchers.create()
      .ofTypes(""java.security.SecureRandom"")
      .names(""nextBytes"")
      .withAnyParameters()
      .build();
    private static final MethodMatchers CIPHER_INIT = MethodMatchers.create()
      .ofTypes(""javax.crypto.Cipher"")
      .names(""init"")
      .withAnyParameters()
      .build();

    private static final MethodMatchers BYTEBUFFER_GET = MethodMatchers.create()
      .ofTypes(""java.nio.ByteBuffer"")
      .names(""get"")
      .withAnyParameters()
      .build();

    // value of javax.crypto.Cipher.DECRYPT_MODE
    private static final int CIPHER_INIT_DECRYPT_MODE = 2;

    public MethodInvocationVisitor(NewClassTree newClassTree) {
      ivParameterSpecInstantiation = newClassTree;
      ivParameterSymbol = ivSymbol(newClassTree);
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
      if (SECURE_RANDOM_NEXT_BYTES.matches(methodInvocation)) {
        Symbol initVector = symbol(ivParameterSpecInstantiation.arguments().get(0));
        if (!initVector.isUnknown() && initVector.equals(symbol(methodInvocation.arguments().get(0)))) {
          secureRandomFound = true;
        }
      }
      // make sure it is not used for decryption - in such case you need to reuse one
      if (CIPHER_INIT.matches(methodInvocation) && methodInvocation.arguments().size() > 2) {
        int opMode = methodInvocation.arguments().get(0).asConstant(Integer.class).orElse(-1);
        if (CIPHER_INIT_DECRYPT_MODE == opMode && isPartOfArguments(methodInvocation)) {
          secureRandomFound = true;
        }
      }
      if (isInitVectorCopiedFromByteBuffer(methodInvocation)) {
        secureRandomFound = true;
      }
      if (methodInvocation.methodSymbol().isUnknown()) {
        secureRandomFound = true;
      }

      super.visitMethodInvocation(methodInvocation);
    }

    private boolean isInitVectorCopiedFromByteBuffer(MethodInvocationTree methodInvocation) {
      if (!BYTEBUFFER_GET.matches(methodInvocation)) {
        return false;
      }
      Symbol initVector = symbol(ivParameterSpecInstantiation.arguments().get(0));
      return methodInvocation.arguments().stream()
        .map(MethodInvocationVisitor::symbol)
        .filter(argument -> argument.type().is(""byte[]""))
        .anyMatch(initVector::equals);
    }

    private boolean isPartOfArguments(MethodInvocationTree methodInvocation) {
      return isPartOfArguments(methodInvocation, ivParameterSpecInstantiation)
        || (!ivParameterSymbol.isUnknown() && isPartOfArguments(methodInvocation, ivParameterSymbol));
    }

    private static boolean isPartOfArguments(MethodInvocationTree methodInvocation, ExpressionTree ivParameter) {
      return methodInvocation.arguments()
        .stream()
        .map(ExpressionUtils::skipParentheses)
        .anyMatch(ivParameter::equals);
    }

    private static boolean isPartOfArguments(MethodInvocationTree methodInvocation, Symbol ivParameterSymbol) {
      return methodInvocation.arguments()
        .stream()
        .map(ExpressionUtils::skipParentheses)
        .map(MethodInvocationVisitor::symbol)
        .anyMatch(ivParameterSymbol::equals);
    }

    private static Symbol symbol(ExpressionTree expression) {
      if (expression.is(Tree.Kind.IDENTIFIER)) {
        return ((IdentifierTree) expression).symbol();
      }
      if (expression.is(Tree.Kind.MEMBER_SELECT)) {
        return ((MemberSelectExpressionTree) expression).identifier().symbol();
      }
      return Symbols.unknownSymbol;
    }

    private static Symbol ivSymbol(NewClassTree newClassTree) {
      Tree parent = newClassTree.parent();
      if (parent.is(Tree.Kind.VARIABLE)) {
        return ((VariableTree) parent).symbol();
      }
      if (parent.is(Tree.Kind.ASSIGNMENT)) {
        return symbol(((AssignmentExpressionTree) parent).variable());
      }
      return Symbols.unknownSymbol;
    }
  }
}
"
S3330,SECURITY_HOTSPOT,"Creating cookies without the ""HttpOnly"" flag is security-sensitive","package org.sonar.java.checks.security;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Symbol.VariableSymbol;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S3330"")
public class CookieHttpOnlyCheck extends IssuableSubscriptionVisitor {
  private final Set<Symbol.VariableSymbol> ignoredVariables = new HashSet<>();
  private final Map<VariableSymbol, TypeTree> symbolConstructorMapToReport = new LinkedHashMap<>();
  private final List<MethodInvocationTree> settersToReport = new ArrayList<>();
  private final List<TypeTree> newClassToReport = new ArrayList<>();

  private static final List<String> IGNORED_COOKIE_NAMES = Arrays.asList(""csrf"", ""xsrf"");

  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String JAVA_UTIL_DATE = ""java.util.Date"";
  private static final String INT = ""int"";
  private static final String BOOLEAN = ""boolean"";

  private static final String MESSAGE = ""Make sure creating this cookie without the \""HttpOnly\"" flag is safe."";

  private static final int COOKIE_NAME_ARGUMENT = 0;

  private static final class ClassName {
    private static final String SERVLET_COOKIE = ""javax.servlet.http.Cookie"";
    private static final String JAKARTA_SERVLET_COOKIE = ""jakarta.servlet.http.Cookie"";
    private static final String NET_HTTP_COOKIE = ""java.net.HttpCookie"";
    private static final String JAX_RS_COOKIE = ""javax.ws.rs.core.Cookie"";
    private static final String JAKARTA_RS_COOKIE = ""jakarta.ws.rs.core.Cookie"";
    private static final String JAX_RS_NEW_COOKIE = ""javax.ws.rs.core.NewCookie"";
    private static final String JAKARTA_RS_NEW_COOKIE = ""jakarta.ws.rs.core.NewCookie"";
    private static final String SHIRO_COOKIE = ""org.apache.shiro.web.servlet.SimpleCookie"";
    private static final String PLAY_COOKIE = ""play.mvc.Http$Cookie"";
    private static final String PLAY_COOKIE_BUILDER = ""play.mvc.Http$CookieBuilder"";
    private static final String SPRING_BOOT_COOKIE = ""org.springframework.boot.web.server.Cookie"";
    private static final String SPRING_HTTP_COOKIE_BUILDER = ""org.springframework.http.ResponseCookie$ResponseCookieBuilder"";
    private static final String SPRING_SECURITY_COOKIE_TOKEN_REPO = ""org.springframework.security.web.csrf.CookieCsrfTokenRepository"";
  }

  private static final Set<String> SETTER_NAMES = Set.of(""setHttpOnly"", ""withHttpOnly"", ""httpOnly"");

  private static final Set<String> CLASSES = Set.of(
    ClassName.SERVLET_COOKIE,
    ClassName.JAKARTA_SERVLET_COOKIE,
    ClassName.NET_HTTP_COOKIE,
    ClassName.JAX_RS_COOKIE,
    ClassName.JAKARTA_RS_COOKIE,
    ClassName.SHIRO_COOKIE,
    ClassName.PLAY_COOKIE,
    ClassName.PLAY_COOKIE_BUILDER,
    ClassName.SPRING_BOOT_COOKIE,
    ClassName.SPRING_HTTP_COOKIE_BUILDER);

  private static final MethodMatchers PLAY_COOKIE_BUILDER = MethodMatchers.create()
    .ofTypes(ClassName.PLAY_COOKIE).names(""builder"").withAnyParameters().build();

  private static final MethodMatchers CONSTRUCTORS_WITH_HTTP_ONLY_PARAM = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(ClassName.JAX_RS_NEW_COOKIE)
      .constructor()
      .addParametersMatcher(ClassName.JAX_RS_COOKIE, JAVA_LANG_STRING, INT, JAVA_UTIL_DATE, BOOLEAN, BOOLEAN)
      .build(),
    MethodMatchers.create()
      .ofSubTypes(ClassName.JAKARTA_RS_NEW_COOKIE)
      .constructor()
      .addParametersMatcher(ClassName.JAKARTA_RS_COOKIE, JAVA_LANG_STRING, INT, JAVA_UTIL_DATE, BOOLEAN, BOOLEAN)
      .build(),
    MethodMatchers.create()
      .ofSubTypes(ClassName.JAX_RS_NEW_COOKIE, ClassName.JAKARTA_RS_NEW_COOKIE)
      .constructor()
      .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, INT, JAVA_LANG_STRING, INT, JAVA_UTIL_DATE, BOOLEAN, BOOLEAN)
      .build(),
    MethodMatchers.create()
      .ofSubTypes(ClassName.JAX_RS_NEW_COOKIE, ClassName.JAKARTA_RS_NEW_COOKIE)
      .constructor()
      .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, INT, BOOLEAN, BOOLEAN)
      .build(),
    MethodMatchers.create()
      .ofSubTypes(ClassName.PLAY_COOKIE, ClassName.JAKARTA_RS_NEW_COOKIE)
      .constructor()
      .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING, ""java.lang.Integer"", JAVA_LANG_STRING, JAVA_LANG_STRING, BOOLEAN, BOOLEAN)
      .build());

  private static final MethodMatchers CONSTRUCTORS_WITH_GOOD_DEFAULT = MethodMatchers.create()
    .ofSubTypes(ClassName.SHIRO_COOKIE)
    .constructor()
    .addWithoutParametersMatcher()
    .addParametersMatcher(JAVA_LANG_STRING)
    .build();

  private static final MethodMatchers CONSTRUCTORS_WITH_HTTP_ONLY_PARAM_BEFORE_LAST = MethodMatchers.create()
    .ofTypes(ClassName.PLAY_COOKIE)
    .constructor()
    .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING, ""java.lang.Integer"", JAVA_LANG_STRING, JAVA_LANG_STRING, BOOLEAN, BOOLEAN, ""play.mvc.Http$Cookie$SameSite"")
    .build();

  private static final MethodMatchers UNALLOWED_TOKEN_PROVIDERS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(ClassName.SPRING_SECURITY_COOKIE_TOKEN_REPO)
      .names(""withHttpOnlyFalse"")
      .addWithoutParametersMatcher()
      .build());

  @Override
  public void setContext(JavaFileScannerContext context) {
    ignoredVariables.clear();
    symbolConstructorMapToReport.clear();
    settersToReport.clear();
    newClassToReport.clear();
    super.setContext(context);
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    for (TypeTree typeTree : symbolConstructorMapToReport.values()) {
      reportIssue(typeTree, MESSAGE);
    }
    for (MethodInvocationTree mit : settersToReport) {
      reportIssue(mit.arguments(), MESSAGE);
    }
    for (TypeTree typeTree : newClassToReport) {
      reportIssue(typeTree, MESSAGE);
    }
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.VARIABLE,
      Tree.Kind.ASSIGNMENT,
      Tree.Kind.METHOD_INVOCATION,
      Tree.Kind.RETURN_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.VARIABLE)) {
      checkVariableDeclaration((VariableTree) tree);
    } else if (tree.is(Tree.Kind.ASSIGNMENT)) {
      checkAssignment((AssignmentExpressionTree) tree);
    } else if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree invocationTree = (MethodInvocationTree) tree;
      checkInvocation(invocationTree);
      invocationTree.arguments().forEach(this::categorizeBasedOnConstructor);
    } else {
      categorizeBasedOnConstructor(((ReturnStatementTree) tree).expression());
    }
  }

  private void checkAssignment(AssignmentExpressionTree assignment) {
    checkCookieBuilder(assignment);
    if (shouldVerify(assignment)) {
      categorizeBasedOnConstructor((NewClassTree) assignment.expression(),
        (VariableSymbol) ((IdentifierTree) assignment.variable()).symbol());
    }
  }

  private void checkVariableDeclaration(VariableTree declaration) {
    checkCookieBuilder(declaration);
    if (shouldVerify(declaration)) {
      categorizeBasedOnConstructor((NewClassTree) declaration.initializer(),
        (VariableSymbol) declaration.symbol());
    }
  }

  private void checkCookieBuilder(AssignmentExpressionTree assignment) {
    if (assignment.expression().is(Tree.Kind.METHOD_INVOCATION)
      && (assignment.variable().is(Tree.Kind.IDENTIFIER) || assignment.variable().is(Tree.Kind.MEMBER_SELECT))) {
      MethodInvocationTree mit = (MethodInvocationTree) assignment.expression();
      VariableSymbol variableSymbol = getVariableSymbol(assignment);
      if (variableSymbol != null) {
        addToIgnoredVariables(variableSymbol, mit);
      }
    }
  }

  @CheckForNull
  private static VariableSymbol getVariableSymbol(AssignmentExpressionTree assignment) {
    VariableSymbol variableSymbol = null;
    if (assignment.variable().is(Tree.Kind.IDENTIFIER)) {
      Symbol reference = ((IdentifierTree) assignment.variable()).symbol();
      if (reference.isVariableSymbol()) {
        variableSymbol = (VariableSymbol) reference;
      }
    } else {
      MemberSelectExpressionTree mse = (MemberSelectExpressionTree) assignment.variable();
      if (mse.identifier().symbol().isVariableSymbol()) {
        variableSymbol = (VariableSymbol) mse.identifier().symbol();
      }
    }
    return variableSymbol;
  }

  private void addToIgnoredVariables(VariableSymbol variableSymbol, MethodInvocationTree mit) {
    if (PLAY_COOKIE_BUILDER.matches(mit) && isIgnoredCookieName(mit.arguments())) {
      ignoredVariables.add(variableSymbol);
    }
  }

  private void checkCookieBuilder(VariableTree declaration) {
    Symbol symbol = declaration.symbol();
    if (!symbol.isVariableSymbol()) {
      // might happen in context of lambda, where symbol of variable cannot be resolve
      return;
    }
    ExpressionTree initializer = declaration.initializer();
    if (initializer != null && initializer.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) initializer;
      addToIgnoredVariables((VariableSymbol) symbol, mit);
    }
  }

  private void categorizeBasedOnConstructor(@Nullable ExpressionTree expressionTree) {
    if (expressionTree != null && expressionTree.is(Tree.Kind.NEW_CLASS)) {
      NewClassTree newClass = (NewClassTree) expressionTree;
      if (!isIgnoredCookieName(newClass.arguments()) && !isCompliantConstructorCall(newClass) && CLASSES.stream().anyMatch(newClass.symbolType()::isSubtypeOf)) {
        newClassToReport.add(newClass.identifier());
      }
    }
  }

  private void categorizeBasedOnConstructor(NewClassTree newClassTree, VariableSymbol variableSymbol) {
    if (isIgnoredCookieName(newClassTree.arguments())) {
      ignoredVariables.add(variableSymbol);
    } else if (!isCompliantConstructorCall(newClassTree)) {
      symbolConstructorMapToReport.put(variableSymbol, newClassTree.identifier());
    }
  }

  private static boolean shouldVerify(VariableTree variableDeclaration) {
    ExpressionTree initializer = variableDeclaration.initializer();
    if (initializer != null && initializer.is(Tree.Kind.NEW_CLASS)) {
      boolean isSupportedClass = CLASSES.stream().anyMatch(variableDeclaration.type().symbolType()::isSubtypeOf)
        || CLASSES.stream().anyMatch(initializer.symbolType()::isSubtypeOf);
      return variableDeclaration.symbol().owner().isMethodSymbol() && isSupportedClass;
    }
    return false;
  }

  private static boolean shouldVerify(AssignmentExpressionTree assignment) {
    if (assignment.expression().is(Tree.Kind.NEW_CLASS) && assignment.variable().is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) assignment.variable();
      boolean isMethodVariable = identifier.symbol().isVariableSymbol()
        && identifier.symbol().owner().isMethodSymbol();
      boolean isSupportedClass = CLASSES.stream().anyMatch(identifier.symbolType()::isSubtypeOf)
        || CLASSES.stream().anyMatch(assignment.expression().symbolType()::isSubtypeOf);
      return isMethodVariable && isSupportedClass;
    }
    return false;
  }

  private static boolean isCompliantConstructorCall(NewClassTree newClassTree) {
    Arguments arguments = newClassTree.arguments();
    if (CONSTRUCTORS_WITH_HTTP_ONLY_PARAM.matches(newClassTree)) {
      ExpressionTree lastArgument = arguments.get(arguments.size() - 1);
      return LiteralUtils.isTrue(lastArgument);
    } else if (CONSTRUCTORS_WITH_HTTP_ONLY_PARAM_BEFORE_LAST.matches(newClassTree)) {
      ExpressionTree beforeLastArgument = arguments.get(arguments.size() - 2);
      return LiteralUtils.isTrue(beforeLastArgument);
    } else {
      return CONSTRUCTORS_WITH_GOOD_DEFAULT.matches(newClassTree);
    }
  }

  private static boolean isIgnoredCookieName(Arguments arguments) {
    if (arguments.isEmpty()) {
      return false;
    }
    ExpressionTree nameArgument = arguments.get(COOKIE_NAME_ARGUMENT);
    String name = ExpressionsHelper.getConstantValueAsString(nameArgument).value();
    return name != null && IGNORED_COOKIE_NAMES.stream().anyMatch(cookieName -> name.toLowerCase(Locale.ENGLISH).contains(cookieName));
  }

  private void checkInvocation(MethodInvocationTree mit) {
    if(UNALLOWED_TOKEN_PROVIDERS.matches(mit)) {
      settersToReport.add(mit);
    } else if (isExpectedSetter(mit)) {
      if (mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
        ExpressionTree expression = ((MemberSelectExpressionTree) mit.methodSelect()).expression();
        boolean isCalledOnIdentifier = expression.is(Tree.Kind.IDENTIFIER);
        boolean isCalledOnMemberSelect = expression.is(Tree.Kind.MEMBER_SELECT);
        if (isCalledOnIdentifier || isCalledOnMemberSelect) {
          updateIssuesToReport(mit);
        } else if (!setterArgumentHasCompliantValue(mit.arguments())) {
          // builder method
          settersToReport.add(mit);
        }
      } else if (!setterArgumentHasCompliantValue(mit.arguments())) {
        // sub-class method
        settersToReport.add(mit);
      }
    }
  }

  private static boolean isExpectedSetter(MethodInvocationTree mit) {
    return mit.arguments().size() == 1
      && mit.methodSymbol().isMethodSymbol()
      && CLASSES.stream().anyMatch(mit.methodSymbol().owner().type()::isSubtypeOf)
      && SETTER_NAMES.contains(getIdentifier(mit).name())
      && isIgnoredBuilder(mit);
  }

  private static boolean isIgnoredBuilder(MethodInvocationTree mit) {
    if (!mit.methodSymbol().owner().type().isSubtypeOf(ClassName.PLAY_COOKIE_BUILDER)) {
      return true;
    }
    return getMethodChain(mit)
      .filter(method -> ""builder"".contains(getIdentifier(method).name()))
      .noneMatch(method -> isIgnoredCookieName(method.arguments()));
  }

  private static Stream<MethodInvocationTree> getMethodChain(MethodInvocationTree mit) {
    if (mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree expressionTree = ((MemberSelectExpressionTree) mit.methodSelect()).expression();
      if (expressionTree.is(Tree.Kind.METHOD_INVOCATION)) {
        return Stream.concat(Stream.of(mit), getMethodChain((MethodInvocationTree) expressionTree));
      }
    }
    return Stream.of(mit);
  }

  private void updateIssuesToReport(MethodInvocationTree mit) {
    MemberSelectExpressionTree mse = (MemberSelectExpressionTree) mit.methodSelect();
    VariableSymbol reference;
    if (mse.expression().is(Tree.Kind.IDENTIFIER)) {
      reference = (VariableSymbol) ((IdentifierTree) mse.expression()).symbol();
    } else {
      reference = (VariableSymbol) ((MemberSelectExpressionTree) mse.expression()).identifier().symbol();
    }
    if (ignoredVariables.contains(reference)) {
      // ignore XSRF-TOKEN cookies
      return;
    }
    symbolConstructorMapToReport.remove(reference);
    if (!setterArgumentHasCompliantValue(mit.arguments())) {
      settersToReport.add(mit);
    }
  }

  private static boolean setterArgumentHasCompliantValue(Arguments arguments) {
    ExpressionTree expressionTree = arguments.get(0);
    Boolean booleanValue = ExpressionsHelper.getConstantValueAsBoolean(expressionTree).value();
    return booleanValue == null || booleanValue;
  }

  private static IdentifierTree getIdentifier(MethodInvocationTree mit) {
    IdentifierTree id;
    if (mit.methodSelect().is(Tree.Kind.IDENTIFIER)) {
      id = (IdentifierTree) mit.methodSelect();
    } else {
      id = ((MemberSelectExpressionTree) mit.methodSelect()).identifier();
    }
    return id;
  }
}
"
S3346,BUG,"Expressions used in ""assert"" should not produce side effects","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AssertStatementTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S3346"")
public class AssertOnBooleanVariableCheck extends IssuableSubscriptionVisitor {

  private static final Pattern SIDE_EFFECT_METHOD_NAMES = Pattern.compile(""^(remove|delete|retain|put|set|add|pop|update).*$"", Pattern.CASE_INSENSITIVE);

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.ASSERT_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ((AssertStatementTree) tree).condition().accept(new MethodInvocationVisitor());
  }

  private class MethodInvocationVisitor extends BaseTreeVisitor {

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      IdentifierTree methodNameTree = ExpressionUtils.methodName(tree);
      if (SIDE_EFFECT_METHOD_NAMES.matcher(methodNameTree.name()).find()) {
        reportIssue(methodNameTree, ""Move this \""assert\"" side effect to another statement."");
      } else {
        // only report once
        super.visitMethodInvocation(tree);
      }
    }

    @Override
    public void visitClass(ClassTree tree) {
      // skip anonymous classes
    }
  }

}
"
S3358,CODE_SMELL,Ternary operators should not be nested,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;

@Rule(key = ""S3358"")
public class NestedTernaryOperatorsCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CONDITIONAL_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    ConditionalExpressionTree ternary = (ConditionalExpressionTree) tree;
    Stream.of(ternary.condition(), ternary.trueExpression(), ternary.falseExpression()).forEach(expr -> expr.accept(new TernaryVisitor()));

  }

  private class TernaryVisitor extends BaseTreeVisitor {
    @Override
    public void visitConditionalExpression(ConditionalExpressionTree tree) {
      // cut the exploration to report only 1 level
      reportIssue(tree, ""Extract this nested ternary operation into an independent statement."");
    }

    @Override
    public void visitClass(ClassTree tree) {
      // skip nested anonymous classes which could be declared within condition or true/false branches, and using ternary operator
    }
  }

}
"
S3366,CODE_SMELL,"""this"" should not be exposed from constructors","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3366"")
public class ThisExposedFromConstructorCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    methodTree.block().accept(new ConstructorBodyVisitor(methodTree.symbol().owner()));
  }

  private class ConstructorBodyVisitor extends BaseTreeVisitor {
    private Symbol owner;

    public ConstructorBodyVisitor(Symbol owner) {
      this.owner = owner;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (this.owner == tree.methodSymbol().owner()) {
        return;
      }
      tree.arguments().stream().filter(ExpressionUtils::isThis).forEach(this::report);
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      if (!ExpressionUtils.isThis(tree.expression())) {
        return;
      }
      ExpressionTree variable = tree.variable();
      if (variable.is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) variable;
        // not an issue because ""this"" is assigned to an object of the same type which is also defined as static
        if (memberSelect.expression().symbolType().symbol().equals(this.owner) && memberSelect.identifier().symbol().isStatic()) {
          return;
        }
      } else if (variable.is(Tree.Kind.IDENTIFIER) && (((IdentifierTree) variable).symbol().isStatic())) {
        return;
      }
      report(tree);
    }

    @Override
    public void visitClass(ClassTree tree) {
      // skip nested and anonymous classes
    }

    private void report(ExpressionTree tree) {
      reportIssue(tree, ""Make sure the use of \""this\"" doesn't"" +
        "" expose partially-constructed instances of this class in multi-threaded environments."");
    }
  }
}
"
S3398,CODE_SMELL,"""private"" methods called only by inner classes should be moved to those classes","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.JavaTree;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3398"")
public class CallOuterPrivateMethodCheck extends IssuableSubscriptionVisitor {

  private MethodInvocationVisitor methodInvocationVisitor;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.INTERFACE);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    methodInvocationVisitor = new MethodInvocationVisitor();
    super.setContext(context);
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    methodInvocationVisitor.checkUsages();
    methodInvocationVisitor = null;
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Symbol.TypeSymbol classSymbol = classTree.symbol();
    if (isInnerClass(classSymbol)) {
      methodInvocationVisitor.setClassSymbol(classSymbol);
      classTree.accept(methodInvocationVisitor);
    }
  }

  private static boolean isInnerClass(Symbol symbol) {
    return symbol.owner().isTypeSymbol();
  }

  private class MethodInvocationVisitor extends BaseTreeVisitor {
    private final Map<Symbol.TypeSymbol, Map<Symbol.MethodSymbol, Integer>> usagesByInnerClass = new HashMap<>();
    private final Map<String, Set<MethodInvocationTree>> unknownInvocations = new HashMap<>();
    private Symbol.TypeSymbol classSymbol;
    private Map<Symbol.MethodSymbol, Integer> usages;

    public void setClassSymbol(Symbol.TypeSymbol classSymbol) {
      this.classSymbol = classSymbol;
      usages = new HashMap<>();
      usagesByInnerClass.put(classSymbol, usages);
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      Symbol.MethodSymbol symbol = tree.methodSymbol();
      if (symbol.isUnknown()) {
        String name = ExpressionUtils.methodName(tree).name();
        unknownInvocations.computeIfAbsent(name, k -> new HashSet<>()).add(tree);
      } else if (isPrivateMethodOfOuterClass(symbol) && isInvocationOnCurrentInstance(tree)) {
        if (symbol.isParametrizedMethod() && symbol.declaration() != null) {
          // generic methods requires to use their declaration symbol rather than the parameterized one
          symbol = symbol.declaration().symbol();
        }
        usages.compute(symbol, (k, v) -> v == null ? 1 : (v + 1));
      }
      super.visitMethodInvocation(tree);
    }

    private boolean isInvocationOnCurrentInstance(MethodInvocationTree tree) {
      ExpressionTree expressionTree = tree.methodSelect();
      if (expressionTree.is(Tree.Kind.MEMBER_SELECT)) {
        // Looking for ""A.this.f()""
        ExpressionTree memberSelectExpression = ((MemberSelectExpressionTree) expressionTree).expression();
        if (memberSelectExpression.is(Tree.Kind.MEMBER_SELECT)) {
          return ExpressionUtils.isThis(((MemberSelectExpressionTree) memberSelectExpression).identifier());
        }
      }
      return expressionTree.is(Tree.Kind.IDENTIFIER);
    }

    private boolean isPrivateMethodOfOuterClass(Symbol symbol) {
      return symbol.isPrivate() && symbol.owner().equals(classSymbol.owner()) && !""<init>"".equals(symbol.name());
    }

    void checkUsages() {

      usagesByInnerClass.forEach((symbol, innerClassUsages) -> innerClassUsages.forEach((methodUsed, count) -> {
        boolean matchArity = unknownInvocations.getOrDefault(methodUsed.name(), new HashSet<>())
          .stream()
          .anyMatch(mit -> hasSameArity(methodUsed, mit));

        // if an unknown method has same name and same arity, do not report, likely a FP.
        if (!matchArity && methodUsed.usages().size() == count) {
          reportIssueOnMethod(methodUsed.declaration(), symbol);
        }
      }));
    }

    private boolean hasSameArity(Symbol.MethodSymbol methodUsed, MethodInvocationTree mit) {
      int formalArity = methodUsed.parameterTypes().size();
      int invokedArity = mit.arguments().size();
      return formalArity == invokedArity ||
        (methodUsed.isVarArgsMethod() && invokedArity >= formalArity - 1);
    }

    private void reportIssueOnMethod(@Nullable MethodTree declaration, Symbol.TypeSymbol classSymbol) {
      if (declaration != null && !isIllegalMove(declaration, classSymbol)) {
        String message = ""Move this method into "";
        if (classSymbol.name().isEmpty()) {
          message += ""the anonymous class declared at line "" + ((JavaTree) classSymbol.declaration()).getLine() + ""."";
        } else {
          message += ""\"""" + classSymbol.name() + ""\""."";
        }
        reportIssue(declaration.simpleName(), message);
      }
    }

    private boolean isIllegalMove(MethodTree declaration, Symbol.TypeSymbol classSymbol) {
      return declaration.symbol().isStatic() && !classSymbol.isStatic();
    }

  }
}
"
S3400,CODE_SMELL,Methods should not return constants,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S3400"")
public class ConstantMethodCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    BlockTree body = methodTree.block();
    boolean isSingleStatementMethod = body != null && body.body().size() == 1;
    boolean hasAnnotations = !methodTree.modifiers().annotations().isEmpty();
    if (!isSingleStatementMethod || hasAnnotations) {
      return;
    }
    if (isEffectivelyFinal(methodTree) && Boolean.FALSE.equals(methodTree.isOverriding())) {
      StatementTree uniqueStatement = body.body().get(0);
      if (uniqueStatement.is(Kind.RETURN_STATEMENT)) {
        ExpressionTree returnedExpression = ((ReturnStatementTree) uniqueStatement).expression();
        if (isConstant(returnedExpression)) {
          reportIssue(returnedExpression, ""Remove this method and declare a constant for this value."");
        }
      }
    }
  }

  private static boolean isEffectivelyFinal(MethodTree methodTree) {
    Tree methodParent = methodTree.parent();
    if (!(methodParent instanceof ClassTree) || methodParent.is(Tree.Kind.ANNOTATION_TYPE, Tree.Kind.INTERFACE)) {
      return false;
    } else if (methodParent.is(Tree.Kind.RECORD) || ((ClassTree)methodParent).symbol().isFinal()) {
      return true;
    }
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();
    return methodSymbol.isFinal() || methodSymbol.isPrivate() || methodSymbol.isStatic();
  }

  private static boolean isConstant(@Nullable ExpressionTree returnedExpression) {
    return returnedExpression != null
            && returnedExpression.is(Kind.INT_LITERAL, Kind.LONG_LITERAL,
            Kind.CHAR_LITERAL, Kind.STRING_LITERAL, Kind.TEXT_BLOCK,
            Kind.DOUBLE_LITERAL, Kind.FLOAT_LITERAL, Kind.BOOLEAN_LITERAL);
  }
}
"
S3414,CODE_SMELL,Tests should be kept in a dedicated source directory,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.UnitTestUtils.isTestClass;

@Rule(key = ""S3414"")
public class TestsInSeparateFolderCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (isTestClass(classTree)) {
      reportIssue(classTree.simpleName(), ""Move this test class to the test folder in current project."");
    }
  }
}
"
S3415,CODE_SMELL,Assertion arguments should be passed in the correct order,"package org.sonar.java.checks.tests;

import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.reporting.InternalJavaIssueBuilder;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3415"")
public class AssertionArgumentOrderCheck extends AbstractMethodDetection {

  private static final String ASSERT_ARRAY_EQUALS = ""assertArrayEquals"";
  private static final String ASSERT_EQUALS = ""assertEquals"";
  private static final String ASSERT_ITERABLE_EQUALS = ""assertIterableEquals"";
  private static final String ASSERT_LINES_MATCH = ""assertLinesMatch"";
  private static final String ASSERT_NOT_EQUALS = ""assertNotEquals"";
  private static final String ASSERT_NOT_SAME = ""assertNotSame"";
  private static final String ASSERT_SAME = ""assertSame"";

  private static final String EXPECTED_VALUE_ACTUAL_VALUE = ""expected value, actual value"";
  private static final String ACTUAL_VALUE_EXPECTED_VALUE = ""actual value, expected value"";

  private static final String ORG_JUNIT_ASSERT = ""org.junit.Assert"";
  private static final String ORG_TESTNG_ASSERT = ""org.testng.Assert"";
  private static final String ORG_JUNIT5_ASSERTIONS = ""org.junit.jupiter.api.Assertions"";
  private static final Tree.Kind[] LITERAL_KINDS = {Tree.Kind.STRING_LITERAL, Tree.Kind.INT_LITERAL, Tree.Kind.LONG_LITERAL, Tree.Kind.CHAR_LITERAL,
    Tree.Kind.NULL_LITERAL, Tree.Kind.BOOLEAN_LITERAL, Tree.Kind.DOUBLE_LITERAL, Tree.Kind.FLOAT_LITERAL};
  private static final String MESSAGE_TWO_LITERALS = ""Change this assertion to not compare two literals."";
  private static final String MESSAGE_SWAP = ""Swap these 2 arguments so they are in the correct order: %s."";
  private static final String MESSAGE_REPLACE = ""Replace this literal with the actual expression you want to assert."";

  private static final MethodMatchers COLLECTION_CREATION_CALL = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(""java.util.Collections"")
      .name(name -> name.startsWith(""singleton"") || name.startsWith(""empty""))
      .withAnyParameters()
      .build(),
    MethodMatchers.create().ofTypes(""java.util.Arrays"").names(""asList"").withAnyParameters().build());

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofTypes(ORG_JUNIT_ASSERT)
        .names(ASSERT_EQUALS, ASSERT_SAME, ASSERT_NOT_SAME)
        .withAnyParameters()
        .build(),
      // TestNG
      MethodMatchers.create().ofTypes(ORG_TESTNG_ASSERT)
        .names(ASSERT_EQUALS, ASSERT_NOT_EQUALS, ASSERT_SAME, ASSERT_NOT_SAME)
        .withAnyParameters()
        .build(),
      // JUnit 5
      MethodMatchers.create().ofTypes(ORG_JUNIT5_ASSERTIONS)
        .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS, ASSERT_ITERABLE_EQUALS, ASSERT_LINES_MATCH, ASSERT_NOT_EQUALS, ASSERT_NOT_SAME, ASSERT_SAME)
        .withAnyParameters()
        .build(),
      // AssertJ
      MethodMatchers.create().ofTypes(""org.assertj.core.api.Assertions"")
        .names(""assertThat"", ""assertThatObject"")
        .addParametersMatcher(MethodMatchers.ANY)
        .build()
    );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    Type ownerType = mit.methodSymbol().owner().type();
    if (ownerType.is(ORG_JUNIT5_ASSERTIONS)) {
      checkArguments(mit.arguments().get(0), mit.arguments().get(1), EXPECTED_VALUE_ACTUAL_VALUE);
    } else if (ownerType.is(ORG_JUNIT_ASSERT)) {
      ExpressionTree argToCheck = getActualArgument(mit);
      checkArguments(previousArg(argToCheck, mit), argToCheck, EXPECTED_VALUE_ACTUAL_VALUE);
    } else if (ownerType.is(ORG_TESTNG_ASSERT)) {
      checkArguments(mit.arguments().get(1), mit.arguments().get(0), ACTUAL_VALUE_EXPECTED_VALUE);
    } else {
      Optional<ExpressionTree> expectedValue = getExpectedValue(mit);
      ExpressionTree actualValue = mit.arguments().get(0);
      if (expectedValue.isPresent()) {
        checkArguments(expectedValue.get(), actualValue, ACTUAL_VALUE_EXPECTED_VALUE);
      } else {
        checkArgument(actualValue);
      }
    }
  }

  private void checkArguments(ExpressionTree expectedArgument, ExpressionTree actualArgument, String correctOrder) {
    if (actualArgument.is(LITERAL_KINDS)) {
      // When we have a literal as actual, we are sure to have an issue
      if (expectedArgument.is(LITERAL_KINDS)) {
        // no quick-fixes when both are literals... the fix is something else
        newIssue(expectedArgument, actualArgument, MESSAGE_TWO_LITERALS).report();
      } else {
        newIssue(expectedArgument, actualArgument, MESSAGE_SWAP, correctOrder)
          .withQuickFix(() -> swap(expectedArgument, actualArgument))
          .report();
      }
    } else if (isExpectedPattern(actualArgument) && !isExpectedPattern(expectedArgument)) {
      newIssue(expectedArgument, actualArgument, MESSAGE_SWAP, correctOrder)
        .withQuickFix(() -> swap(expectedArgument, actualArgument))
        .report();
    }
  }

  private JavaQuickFix swap(Tree x, Tree y) {
    String newX = QuickFixHelper.contentForTree(y, context);
    String newY = QuickFixHelper.contentForTree(x, context);
    return JavaQuickFix.newQuickFix(""Swap arguments"")
      .addTextEdit(JavaTextEdit.replaceTree(x, newX))
      .addTextEdit(JavaTextEdit.replaceTree(y, newY))
      .build();
  }

  private void checkArgument(ExpressionTree actualArgument) {
    if (actualArgument.is(LITERAL_KINDS)) {
      // no quick-fixes
      newIssue(actualArgument, MESSAGE_REPLACE).report();
    }
  }

  private InternalJavaIssueBuilder newIssue(ExpressionTree actualArgument, String message, Object... args) {
    return QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(actualArgument)
      .withMessage(message, args);
  }

  private InternalJavaIssueBuilder newIssue(ExpressionTree expectedArgument, ExpressionTree actualArgument, String message, Object... args) {
    return newIssue(actualArgument, message, args)
      .withSecondaries(new JavaFileScannerContext.Location(""Other argument to swap."", expectedArgument));
  }private static Optional<ExpressionTree> getExpectedValue(MethodInvocationTree mit) {
    return MethodTreeUtils.consecutiveMethodInvocation(mit)
      .filter(secondInvocation -> {
        Tree parent = secondInvocation.parent();
        return parent != null && parent.is(Tree.Kind.EXPRESSION_STATEMENT) && secondInvocation.arguments().size() == 1;
      })
      .map(secondInvocation -> secondInvocation.arguments().get(0));
  }

  private static boolean isNewArrayWithConstants(ExpressionTree actualArgument) {
    if (actualArgument.is(Tree.Kind.NEW_ARRAY)) {
      NewArrayTree newArrayTree = (NewArrayTree) actualArgument;
      return newArrayTree.initializers().stream().allMatch(AssertionArgumentOrderCheck::isConstant);
    }
    return false;
  }

  private static boolean isCollectionCreationWithConstants(ExpressionTree actualArgument) {
    if (actualArgument.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) actualArgument;
      return COLLECTION_CREATION_CALL.matches(mit) && mit.arguments().stream().allMatch(AssertionArgumentOrderCheck::isConstant);
    }
    return false;
  }

  private static ExpressionTree previousArg(ExpressionTree argToCheck, MethodInvocationTree mit) {
    return mit.arguments().get(mit.arguments().indexOf(argToCheck) - 1);
  }

  private static ExpressionTree getActualArgument(MethodInvocationTree mit) {
    int arity = mit.arguments().size();
    ExpressionTree arg = mit.arguments().get(arity - 1);
    // Check for assert equals method with delta
    if (arity > 2 && (arity == 4 || mit.methodSymbol().parameterTypes().stream().allMatch(AssertionArgumentOrderCheck::isDoubleOrFloat))) {
      // last arg is actually delta, take the previous last to get the actual arg.
      arg = mit.arguments().get(arity - 2);
    }
    return arg;
  }

  private static boolean isDoubleOrFloat(Type type) {
    return type.isPrimitive(Type.Primitives.DOUBLE) || type.isPrimitive(Type.Primitives.FLOAT);
  }

  private static boolean isExpectedPattern(ExpressionTree actualArgument) {
    return isConstant(actualArgument) || isNewArrayWithConstants(actualArgument) || isCollectionCreationWithConstants(actualArgument);
  }

  private static boolean isConstant(Tree argToCheck) {
    return argToCheck.is(LITERAL_KINDS)
      || (argToCheck.is(Tree.Kind.IDENTIFIER) && isStaticFinal(((IdentifierTree) argToCheck).symbol()))
      || (argToCheck.is(Tree.Kind.MEMBER_SELECT) && isStaticFinal(((MemberSelectExpressionTree) argToCheck).identifier().symbol()));
  }

  private static boolean isStaticFinal(Symbol symbol) {
    return symbol.isStatic() && symbol.isFinal();
  }
}
"
S3416,CODE_SMELL,Loggers should be named for their enclosing classes,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S3416"")
public class LoggerClassCheck extends IssuableSubscriptionVisitor {

  private static final String CLASS = ""java.lang.Class"";
  public static final String STRING = ""java.lang.String"";

  private static final MethodMatchers LOG_FACTORIES = MethodMatchers.or(
    // covers slf4j, log4j, java.util.logging and perhaps many others
    MethodMatchers.create()
      .ofAnyType()
      .names(""getLogger"")
      .addParametersMatcher(CLASS)
      .addParametersMatcher(STRING)
      .build(),
    // Apache commons-logging
    MethodMatchers.create()
      .ofTypes(""org.apache.commons.logging.LogFactory"")
      .names(""getLog"")
      .addParametersMatcher(CLASS)
      .addParametersMatcher(STRING)
      .build(),
    // sonar-api
    MethodMatchers.create()
      .ofTypes(""org.sonar.api.utils.log.Loggers"")
      .names(""get"")
      .addParametersMatcher(CLASS)
      .addParametersMatcher(STRING)
      .build());

  private static final MethodMatchers CLAZZ_GETNAME = MethodMatchers.create()
    .ofTypes(CLASS)
    .names(""getName"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    Symbol.TypeSymbol clazz = ((ClassTree) tree).symbol();
    clazz.memberSymbols().stream()
      .filter(Symbol::isVariableSymbol)
      .map(Symbol.VariableSymbol.class::cast)
      .map(Symbol.VariableSymbol::declaration)
      .filter(Objects::nonNull)
      .map(VariableTree::initializer)
      .filter(Objects::nonNull)
      .forEach(initializer -> checkField(clazz, initializer));
  }

  private void checkField(Symbol.TypeSymbol clazz, ExpressionTree initializer) {
    if (initializer.is(Tree.Kind.METHOD_INVOCATION) && LOG_FACTORIES.matches((MethodInvocationTree) initializer)) {
      ExpressionTree firstArg = ((MethodInvocationTree) initializer).arguments().get(0);
      Symbol classLiteral = classLiteral(firstArg);
      if (classLiteral != null && !clazz.type().erasure().equals(classLiteral.type().erasure())) {
        reportIssue(firstArg, ""Update this logger to use \"""" + clazz.name() + "".class\""."");
      }
    }
  }

  @CheckForNull
  private static Symbol classLiteral(ExpressionTree expression) {
    if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mset = (MemberSelectExpressionTree) expression;
      if (""class"".equals(mset.identifier().name())) {
        return mset.expression().symbolType().symbol();
      }
    }
    if (expression.is(Tree.Kind.METHOD_INVOCATION) && CLAZZ_GETNAME.matches(((MethodInvocationTree) expression))) {
      MethodInvocationTree mit = (MethodInvocationTree) expression;
      if (mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
        return classLiteral(((MemberSelectExpressionTree) mit.methodSelect()).expression());
      }
    }
    return null;
  }

}
"
S3436,BUG,Value-based classes should not be used for locking,"package org.sonar.java.checks.synchronization;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3436"")
public class ValueBasedObjectUsedForLockCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  private static final List<String> VALUE_BASED_TYPES = Arrays.asList(
    ""java.time.chrono.HijrahDate"",
    ""java.time.chrono.JapaneseDate"",
    ""java.time.chrono.MinguoDate"",
    ""java.time.chrono.ThaiBuddhistDate"",
    ""java.util.Optional"",
    ""java.util.OptionalDouble"",
    ""java.util.OptionalLong"",
    ""java.util.OptionalInt"");

  private static final String JAVA_TIME_CLOCK = ""java.time.Clock"";
  private static final Pattern JAVA_TIME_PACKAGE_PATTERN = Pattern.compile(""java\\.time\\.\\w+"");

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava8Compatible();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.SYNCHRONIZED_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ExpressionTree expression = ((SynchronizedStatementTree) tree).expression();
    Type expressionType = expression.symbolType();
    if (isValueBasedType(expressionType)) {
      reportIssue(expression, String.format(""Synchronize on a non-value-based object; synchronizing on a \""%s\"" could lead to contention.%s"",
        expressionType.name(),
        context.getJavaVersion().java8CompatibilityMessage()));
    }
  }

  private static boolean isValueBasedType(Type type) {
    if (type.isUnknown() || type.is(JAVA_TIME_CLOCK)) {
      return false;
    }
    return VALUE_BASED_TYPES.stream().anyMatch(type::is)
      || JAVA_TIME_PACKAGE_PATTERN.matcher(type.fullyQualifiedName()).matches();
  }

}
"
S3437,CODE_SMELL,Value-based objects should not be serialized,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ValueBasedUtils;
import org.sonar.java.checks.serialization.SerializableContract;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S3437"")
public class ValueBasedObjectsShouldNotBeSerializedCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Make this value-based field transient so it is not included in the serialization of this class."";

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.ENUM, Tree.Kind.ANNOTATION_TYPE);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;

    if (classTree.is(Tree.Kind.ANNOTATION_TYPE)) {
      classTree.members().stream()
        .filter(member -> member.is(Kind.METHOD))
        .map(MethodTree.class::cast)
        .filter(ValueBasedObjectsShouldNotBeSerializedCheck::isReturnTypeValueBased)
        .forEach(meth -> reportIssue(meth.simpleName(), MESSAGE));
    } else if (isSerializable(classTree) && !SerializableContract.hasSpecialHandlingSerializationMethods(classTree)) {
      classTree.members().stream()
        .filter(ValueBasedObjectsShouldNotBeSerializedCheck::isVariable)
        .map(VariableTree.class::cast)
        .filter(v -> !isStatic(v))
        .filter(v -> !isTransient(v))
        .filter(ValueBasedObjectsShouldNotBeSerializedCheck::isVarSerializableAndValueBased)
        .forEach(v -> reportIssue(v.simpleName(), MESSAGE));
    }
  }

  private static boolean isVarSerializableAndValueBased(VariableTree variable) {
    return variable.type() != null && isSerializableAndValueBased(variable.type().symbolType());
  }

  private static boolean isReturnTypeValueBased(MethodTree method) {
    return ValueBasedUtils.isValueBased(method.returnType().symbolType());
  }

  private static boolean isSerializableAndValueBased(Type type) {
    // we check first the ParametrizedTypeJavaType, in order to filter out the non-serializable
    // generic value-based class Optional<T>
    if (type.isParameterized()) {
      return isSubtypeOfCollectionApi(type) &&
        type.typeArguments().stream().anyMatch(ValueBasedObjectsShouldNotBeSerializedCheck::isSerializableAndValueBased);
    }
    return ValueBasedUtils.isValueBased(type);
  }

  private static boolean isVariable(Tree member) {
    return member.is(Tree.Kind.VARIABLE, Tree.Kind.ENUM_CONSTANT);
  }

  private static boolean isSerializable(ClassTree classTree) {
    return classTree.symbol().type().isSubtypeOf(""java.io.Serializable"");
  }

  private static boolean isStatic(VariableTree variable) {
    return ModifiersUtils.hasModifier(variable.modifiers(), Modifier.STATIC);
  }

  private static boolean isTransient(VariableTree variable) {
    return ModifiersUtils.hasModifier(variable.modifiers(), Modifier.TRANSIENT);
  }

  private static boolean isSubtypeOfCollectionApi(Type type) {
    return type.isSubtypeOf(""java.util.Collection"") || type.isSubtypeOf(""java.util.Map"");
  }

}
"
S3457,CODE_SMELL,Format strings should be used correctly,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.UnionTypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S3457"")
public class PrintfMisuseCheck extends AbstractPrintfChecker {

  private static final String ORG_SLF4J_LOGGER = ""org.slf4j.Logger"";
  private static final String JAVA_UTIL_LOGGING_LOGGER = ""java.util.logging.Logger"";

  private static final MethodMatchers TO_STRING = MethodMatchers.create()
    .ofAnyType().names(""toString"").addWithoutParametersMatcher().build();
  private static final MethodMatchers GET_LOGGER = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(JAVA_UTIL_LOGGING_LOGGER).names(""getLogger"").addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING).build(),
    MethodMatchers.create()
      .ofTypes(JAVA_UTIL_LOGGING_LOGGER).names(""getAnonymousLogger"").addParametersMatcher(JAVA_LANG_STRING).build());

  private static final MethodMatchers JAVA_UTIL_LOGGER_LOG_LEVEL_STRING = MethodMatchers.create()
    .ofTypes(JAVA_UTIL_LOGGING_LOGGER)
    .names(""log"")
    .addParametersMatcher(""java.util.logging.Level"", JAVA_LANG_STRING)
    .build();
  private static final MethodMatchers JAVA_UTIL_LOGGER_LOG_LEVEL_STRING_ANY = MethodMatchers.create()
    .ofTypes(JAVA_UTIL_LOGGING_LOGGER)
    .names(""log"")
    .addParametersMatcher(""java.util.logging.Level"", JAVA_LANG_STRING, ANY)
    .build();
  private static final MethodMatchers JAVA_UTIL_LOGGER_LOG_MATCHER = MethodMatchers.or(
    JAVA_UTIL_LOGGER_LOG_LEVEL_STRING,
    JAVA_UTIL_LOGGER_LOG_LEVEL_STRING_ANY);

  private static final MethodMatchers SLF4J_METHOD_MATCHERS = MethodMatchers.or(LEVELS.stream()
    .map(l -> MethodMatchers.create().ofTypes(ORG_SLF4J_LOGGER).names(l).withAnyParameters().build())
    .toList());

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    ArrayList<MethodMatchers> matchers = new ArrayList<>();
    matchers.add(SLF4J_METHOD_MATCHERS);
    matchers.add(super.getMethodInvocationMatchers());
    // Add log methods as they only apply to misuse and not error.
    matchers.add(log4jMethods());
    matchers.add(JAVA_UTIL_LOGGER_LOG_LEVEL_STRING);
    matchers.add(JAVA_UTIL_LOGGER_LOG_LEVEL_STRING_ANY);
    return MethodMatchers.or(matchers);
  }

  private static MethodMatchers log4jMethods() {
    List<String> methodNames = new ArrayList<>();
    methodNames.add(PRINTF_METHOD_NAME);
    methodNames.add(""log"");
    methodNames.addAll(LEVELS);
    return MethodMatchers.create()
      .ofTypes(ORG_APACHE_LOGGING_LOG4J_LOGGER)
      .names(methodNames.toArray(new String[0]))
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    boolean isMessageFormat = MESSAGE_FORMAT.matches(mit);
    if (isMessageFormat && !mit.methodSymbol().isStatic()) {
      // only consider the static method
      return;
    }
    if (!isMessageFormat && JAVA_UTIL_LOGGER_LOG_MATCHER.matches(mit) && hasResourceBundle(mit)) {
      return;
    }
    if (!isMessageFormat) {
      isMessageFormat = JAVA_UTIL_LOGGER_LOG_LEVEL_STRING_ANY.matches(mit);
    }
    if (!isMessageFormat) {
      isMessageFormat = isLoggingMethod(mit);
    }
    super.checkFormatting(mit, isMessageFormat);
  }

  private static boolean hasResourceBundle(MethodInvocationTree mit) {
    Tree id;
    if (mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      id = ((MemberSelectExpressionTree) mit.methodSelect()).expression();
    } else {
      // defensive programming : cannot be reached : log methods are not static
      return false;
    }
    if (id.is(Tree.Kind.MEMBER_SELECT)) {
      id = ((MemberSelectExpressionTree) id).identifier();
    }
    if (id.is(Tree.Kind.IDENTIFIER)) {
      Tree decl = ((IdentifierTree) id).symbol().declaration();
      if (decl != null && decl.is(Tree.Kind.VARIABLE)) {
        VariableTree variable = ((VariableTree) decl);
        ExpressionTree initializer = variable.initializer();
        if (initializer != null && initializer.is(Tree.Kind.METHOD_INVOCATION)) {
          return GET_LOGGER.matches((MethodInvocationTree) initializer);
        }
      }
    }
    return false;
  }

  @Override
  protected void handlePrintfFormat(MethodInvocationTree mit, String formatString, List<ExpressionTree> args) {
    handlePrintfFormat(mit, formatString, args, false);
  }

  @Override
  protected void handlePrintfFormatCatchingErrors(MethodInvocationTree mit, String formatString, List<ExpressionTree> args) {
    handlePrintfFormat(mit, formatString, args, true);
  }

  private void handlePrintfFormat(MethodInvocationTree mit, String formatString, List<ExpressionTree> args, boolean catchErrors) {
    List<String> params = getParameters(formatString, mit);
    if (usesMessageFormat(formatString, params)) {
      reportIssue(mit, ""Looks like there is a confusion with the use of java.text.MessageFormat, parameters will be simply ignored here"");
      return;
    }
    checkLineFeed(formatString, mit);
    if (params.isEmpty() && (!args.isEmpty() || !isLoggingMethod(mit))) {
      reportIssue(mit, ""String contains no format specifiers."");
      return;
    }
    cleanupLineSeparator(params);
    if (!params.isEmpty()) {
      if (argIndexes(params).size() <= args.size()) {
        verifyParametersForMisuse(mit, args, params);
      }
      if (catchErrors) {
        // Errors are caught, we can report them in this rule
        if (checkArgumentNumber(mit, argIndexes(params).size(), args.size())) {
          return;
        }
        verifyParametersForErrors(mit, args, params);
      }
    }
  }

  private void verifyParametersForMisuse(MethodInvocationTree mit, List<ExpressionTree> args, List<String> params) {
    int index = 0;
    List<ExpressionTree> unusedArgs = new ArrayList<>(args);
    for (String rawParam : params) {
      String param = rawParam;
      int argIndex = index;
      if (param.contains(""$"")) {
        argIndex = getIndex(param) - 1;
        if (argIndex == -1) {
          reportIssue(mit, ""Arguments are numbered starting from 1."");
          return;
        }
        param = param.substring(param.indexOf('$') + 1);
      } else if (param.charAt(0) == '<') {
        // refers to previous argument
        argIndex = Math.max(0, argIndex - 1);
      } else {
        index++;
      }
      if (argIndex >= args.size()) {
        // indexes are obviously wrong - will be caught by S2275 (PrintfFailCheck)
        return;
      }
      ExpressionTree argExpressionTree = args.get(argIndex);
      unusedArgs.remove(argExpressionTree);
      Type argType = argExpressionTree.symbolType();
      checkBoolean(mit, param, argType);
    }
    reportUnusedArgs(mit, args, unusedArgs);
  }

  @Override
  protected void handleMessageFormat(MethodInvocationTree mit, String formatString, List<ExpressionTree> args) {
    String newFormatString = cleanupDoubleQuote(formatString);
    Set<Integer> indexes = getMessageFormatIndexes(newFormatString, mit);
    List<ExpressionTree> transposedArgs = transposeArgumentArrayAndRemoveThrowable(mit, args, indexes);
    if (transposedArgs == null) {
      return;
    }
    if (indexes.isEmpty() && !transposedArgs.isEmpty()) {
      reportIssue(mit, ""String contains no format specifiers."");
      return;
    }
    if (checkArgumentNumber(mit, indexes.size(), transposedArgs.size())
      || checkUnbalancedQuotes(mit, newFormatString)) {
      return;
    }
    checkToStringInvocation(transposedArgs);
    verifyParameters(mit, transposedArgs, indexes);
  }

  private boolean checkUnbalancedQuotes(MethodInvocationTree mit, String formatString) {
    if (LEVELS.contains(mit.methodSymbol().name())) {
      return false;
    }

    String withoutParam = MESSAGE_FORMAT_PATTERN.matcher(formatString).replaceAll("""");
    int numberQuote = 0;
    for (int i = 0; i < withoutParam.length(); ++i) {
      if (withoutParam.charAt(i) == '\'') {
        numberQuote++;
      }
    }

    boolean unbalancedQuotes = (numberQuote % 2) != 0;

    if (unbalancedQuotes && MESSAGE_FORMAT_PATTERN_PREDICATE.test(formatString)) {
      // Single quotes should be escaped only when unbalanced and in MessageFormat pattern.
      reportIssue(mit.arguments().get(0), ""Single quote \""'\"" must be escaped."");
    }

    return unbalancedQuotes;
  }

  @Nullable
  private static List<ExpressionTree> transposeArgumentArrayAndRemoveThrowable(MethodInvocationTree mit, List<ExpressionTree> args, Set<Integer> indexes) {
    return transposeArgumentArray(args).map(transposedArgs -> {
      if (lastArgumentShouldBeIgnored(mit, args, transposedArgs, indexes)) {
        return transposedArgs.subList(0, transposedArgs.size() - 1);
      } else {
        return transposedArgs;
      }
    }).orElse(null);
  }

  private static boolean lastArgumentShouldBeIgnored(MethodInvocationTree mit, List<ExpressionTree> args, List<ExpressionTree> transposedArgs, Set<Integer> indexes) {
    if (!isLoggingMethod(mit)) {
      return false;
    }
    if (mit.methodSymbol().owner().type().is(JAVA_UTIL_LOGGING_LOGGER)) {
      // Remove the last argument from the count if it's a throwable, since log(Level level, String msg, Throwable thrown) will be called.
      // If the argument is an array, any exception in the array will be considered as Object, behaving as any others.
      return args.size() == 1 && isLastArgumentThrowable(args);
    }
    // org.apache.logging.log4j.Logger and org.slf4j.Logger
    if (transposedArgs.size() == 1) {
      // Logging methods with only one throwable argument will treat it differently (and should be removed from the count).
      return isLastArgumentThrowable(transposedArgs);
    } else {
      // One extra throwable argument can be consumed by logging methods, it should be removed from the count if it exists.
      return (transposedArgs.size() > indexes.size()) && isLastArgumentThrowable(transposedArgs);
    }
  }

  private static boolean isLastArgumentThrowable(List<ExpressionTree> arguments) {
    if (arguments.isEmpty()) {
      return false;
    }
    ExpressionTree lastArgument = arguments.get(arguments.size() - 1);
    if (lastArgument.symbolType().isSubtypeOf(JAVA_LANG_THROWABLE)) {
      return true;
    }
    return hasUnknownExceptionInUnionType(ExpressionUtils.skipParentheses(lastArgument));
  }private static boolean hasUnknownExceptionInUnionType(ExpressionTree lastArgument) {
    if (!lastArgument.is(Tree.Kind.IDENTIFIER)) {
      return false;
    }
    Symbol symbol = ((IdentifierTree) lastArgument).symbol();
    VariableTree declaration = symbol.isVariableSymbol() ? ((Symbol.VariableSymbol) symbol).declaration() : null;
    if (declaration == null) {
      return false;
    }
    TypeTree declarationType = declaration.type();
    return declarationType.is(Tree.Kind.UNION_TYPE)
      && ((UnionTypeTree) declarationType)
        .typeAlternatives()
        .stream()
        .map(TypeTree::symbolType)
        .anyMatch(Type::isUnknown);
  }

  private void checkToStringInvocation(List<ExpressionTree> args) {
    args.stream()
      .filter(arg -> arg.is(Tree.Kind.METHOD_INVOCATION))
      .map(MethodInvocationTree.class::cast)
      .filter(TO_STRING::matches)
      .filter(arg -> arg != args.get(args.size() - 1) || !isMethodOfThrowable(arg))
      .forEach(arg -> reportIssue(arg, getToStringMessage(arg)));
  }

  private static boolean isMethodOfThrowable(MethodInvocationTree argument) {
    Symbol owner = argument.methodSymbol().owner();
    return owner != null && owner.type().isSubtypeOf(JAVA_LANG_THROWABLE);
  }

  private static String getToStringMessage(ExpressionTree arg) {
    if (isInStringArrayInitializer(arg)) {
      return ""No need to call \""toString()\"" method since an array of Objects can be used here."";
    }
    return ""No need to call \""toString()\"" method as formatting and string conversion is done by the Formatter."";
  }

  private static boolean isInStringArrayInitializer(ExpressionTree arg) {
    return Optional.of(arg)
      .map(Tree::parent)
      .filter(tree -> tree.is(Tree.Kind.LIST))
      .map(Tree::parent)
      .filter(tree -> tree.is(Tree.Kind.NEW_ARRAY))
      .map(NewArrayTree.class::cast)
      .map(ExpressionTree::symbolType)
      .filter(Type::isArray)
      .map(Type.ArrayType.class::cast)
      .map(Type.ArrayType::elementType)
      .filter(type -> type.is(JAVA_LANG_STRING))
      .isPresent();
  }

  private void verifyParameters(MethodInvocationTree mit, List<ExpressionTree> args, Set<Integer> indexes) {
    List<ExpressionTree> unusedArgs = new ArrayList<>(args);
    for (int index : indexes) {
      if (index >= args.size()) {
        reportIssue(mit, ""Not enough arguments."");
        return;
      }
      unusedArgs.remove(args.get(index));
    }
    reportUnusedArgs(mit, args, unusedArgs);
  }

  private void reportUnusedArgs(MethodInvocationTree mit, List<ExpressionTree> args, List<ExpressionTree> unusedArgs) {
    for (ExpressionTree unusedArg : unusedArgs) {
      int i = args.indexOf(unusedArg);
      reportIssue(mit, postFixedIndex(i) + "" argument is not used."");
    }
  }

  private static String postFixedIndex(int i) {
    if (i < 1) {
      return ""first"";
    } else if (i < 2) {
      return ""2nd"";
    } else if (i < 3) {
      return ""3rd"";
    } else {
      return (i + 1) + ""th"";
    }
  }

  private void checkBoolean(MethodInvocationTree mit, String param, Type argType) {
    if (param.charAt(0) == 'b' && !(argType.is(""boolean"") || argType.is(""java.lang.Boolean""))) {
      reportIssue(mit, ""Directly inject the boolean value."");
    }
  }

  private void checkLineFeed(String formatString, MethodInvocationTree mit) {
    if (formatString.contains(""\\n"")) {
      reportIssue(mit, ""%n should be used in place of \\n to produce the platform-specific line separator."");
    }
  }

  private static boolean usesMessageFormat(String formatString, List<String> params) {
    return params.isEmpty() && (formatString.contains(""{0"") || formatString.contains(""{1""));
  }

  @Override
  protected void handleOtherFormatTree(MethodInvocationTree mit, ExpressionTree formatTree, List<ExpressionTree> args) {
    if (isIncorrectConcatenation(formatTree)) {
      boolean lastArgumentThrowable = isLastArgumentThrowable(args);
      if (JAVA_UTIL_LOGGER_LOG_MATCHER.matches(mit)) {
        if (lastArgumentThrowable) {
          reportIssue(mit, ""Lambda should be used to defer string concatenation."");
        } else {
          reportIssue(mit, ""Format specifiers or lambda should be used instead of string concatenation."");
        }
      } else if (!(lastArgumentThrowable && SLF4J_METHOD_MATCHERS.matches(mit))) {
        reportIssue(mit, ""Format specifiers should be used instead of string concatenation."");
      }
    }
  }

  private static boolean isIncorrectConcatenation(ExpressionTree formatStringTree) {
    return formatStringTree.is(Tree.Kind.PLUS) && !formatStringTree.asConstant().isPresent();
  }

  private static boolean isLoggingMethod(MethodInvocationTree mit) {
    String methodName = mit.methodSymbol().name();
    return ""log"".equals(methodName) || LEVELS.contains(methodName);
  }
}
"
S3551,BUG,Overrides should match their parent class methods in synchronization,"package org.sonar.java.checks;

import java.util.Collections;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Symbol.MethodSymbol;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.List;

@Rule(key = ""S3551"")
public class SynchronizedOverrideCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Make this method \""synchronized\"" to match the parent class implementation."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();
    List<MethodSymbol> overriddenSymbols = methodSymbol.overriddenSymbols();
    if (overriddenSymbols.isEmpty()) {
      return;
    }
    Symbol.MethodSymbol overriddenSymbol = overriddenSymbols.get(0);
    if (overriddenSymbol.isSynchronizedMethod() && !methodSymbol.isSynchronizedMethod()) {
      List<JavaFileScannerContext.Location> secondaries = Collections.emptyList();
      MethodTree overridenMethodTree = overriddenSymbol.declaration();
      if (overridenMethodTree != null) {
        secondaries = Collections.singletonList(new JavaFileScannerContext.Location("""", overridenMethodTree.simpleName()));
      }
      reportIssue(methodTree.simpleName(), MESSAGE, secondaries, null);
    }
  }

}
"
S3553,CODE_SMELL,"""Optional"" should not be used for parameters","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S3553"")
public class OptionalAsParameterCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_UTIL_OPTIONAL = ""java.util.Optional"";
  private static final String GUAVA_OPTIONAL = ""com.google.common.base.Optional"";
  private static final List<String> PRIMITIVE_OPTIONALS = Arrays.asList(
    ""java.util.OptionalDouble"",
    ""java.util.OptionalInt"",
    ""java.util.OptionalLong"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    final var methodTree = (MethodTree) tree;

    // If the method is overriding something, the user has no control over the parameter type here, so we should not raise an issue.
    if (Boolean.FALSE.equals(methodTree.isOverriding())) {

      for (VariableTree parameter : methodTree.parameters()) {
        SymbolMetadata parameterMetadata = parameter.symbol().metadata();
        if (parameterMetadata.isAnnotatedWith(""org.springframework.web.bind.annotation.RequestParam"")
          || parameterMetadata.isAnnotatedWith(""org.springframework.web.bind.annotation.PathVariable"")) {
          continue;
        }

        TypeTree typeTree = parameter.type();
        Optional<String> msg = expectedTypeInsteadOfOptional(typeTree.symbolType());
        msg.ifPresent(s -> reportIssue(typeTree, s));
      }
    }
  }

  private static Optional<String> expectedTypeInsteadOfOptional(Type type) {
    if (type.is(JAVA_UTIL_OPTIONAL) || type.is(GUAVA_OPTIONAL)) {
      String msg;
      if (type.isParameterized()) {
        String parameterTypeName = type.typeArguments().get(0).erasure().name();
        msg = formatMsg(parameterTypeName);
      } else {
        msg = ""Specify a type instead."";
      }
      return Optional.of(msg);
    }
    return PRIMITIVE_OPTIONALS.stream()
      .filter(type::is)
      .findFirst()
      .map(optional -> formatMsg(optional.substring(JAVA_UTIL_OPTIONAL.length()).toLowerCase()));
  }

  private static String formatMsg(String typeName) {
    return ""Specify a \"""" + typeName + ""\"" parameter instead."";
  }

}
"
S3577,CODE_SMELL,Test classes should comply with a naming convention,"package org.sonar.java.checks.naming;

import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.UnitTestUtils.isTestClass;

@Rule(key = ""S3577"")
public class BadTestClassNameCheck extends IssuableSubscriptionVisitor {

  private static final String STARTING_WITH_TEST = ""(Test|IT)[a-zA-Z0-9_]+"";
  private static final String ENDING_WITH_TEST = ""[A-Z][a-zA-Z0-9_]*(Test|Tests|TestCase|IT|ITCase)"";
  private static final String DEFAULT_FORMAT = ""^("" + STARTING_WITH_TEST + ""|"" + ENDING_WITH_TEST + "")$"";

  @RuleProperty(
    key = ""format"",
    description = ""Regular expression against which test class names are checked."",
    defaultValue = """" + DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;

  private Pattern pattern = null;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    if (pattern == null) {
      pattern = Pattern.compile(format, Pattern.DOTALL);
    }
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    IdentifierTree simpleName = classTree.simpleName();
    if (hasInvalidName(simpleName) && isTestClass(classTree)) {
      reportIssue(simpleName, ""Rename class \"""" + simpleName.name() + ""\"" to match the regular expression: '"" + format + ""'"");
    }
  }

  private boolean hasInvalidName(@Nullable IdentifierTree className) {
    return className != null && !pattern.matcher(className.name()).matches();
  }

}
"
S3578,CODE_SMELL,Test methods should comply with a naming convention,"package org.sonar.java.checks.naming;

import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.UnitTestUtils.hasTestAnnotation;

@Rule(key = ""S3578"")
public class BadTestMethodNameCheck extends IssuableSubscriptionVisitor {

  private static final String DEFAULT_FORMAT = ""^test[A-Z][a-zA-Z0-9]*$"";

  @RuleProperty(
    key = ""format"",
    description = ""Regular expression the test method names are checked against."",
    defaultValue = """" + DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;

  private Pattern pattern = null;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    if (pattern == null) {
      pattern = Pattern.compile(format, Pattern.DOTALL);
    }
    super.setContext(context);
  }


  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (isNotOverriden(methodTree) && hasTestAnnotation(methodTree) && !pattern.matcher(methodTree.simpleName().name()).matches()) {
      reportIssue(methodTree.simpleName(), ""Rename this method name to match the regular expression: '"" + format + ""'"");
    }
  }

  private static boolean isNotOverriden(MethodTree methodTree) {
    return Boolean.FALSE.equals(methodTree.isOverriding());
  }

}
"
S3599,BUG,Double Brace Initialization should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S3599"")
public class DoubleBraceInitializationCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classBody = ((NewClassTree) tree).classBody();
    if (classBody != null) {
      List<Tree> members = classBody.members();
      if (members.size() == 1 && members.get(0).is(Tree.Kind.INITIALIZER)) {
        reportIssue(classBody, ""Use another way to initialize this instance."");
      }
    }
  }

}
"
S3626,CODE_SMELL,Jump statements should not be redundant,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.cfg.CFG;
import org.sonar.java.cfg.CFG.Block;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3626"")
public class RedundantJumpCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.METHOD,
      Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (methodTree.block() != null) {
      CFG cfg = (CFG) methodTree.cfg();
      cfg.blocks().forEach(this::checkBlock);
    }
  }

  private void checkBlock(Block block) {
    Block successorWithoutJump = block.successorWithoutJump();
    Tree terminator = block.terminator();

    if (terminator != null
      && successorWithoutJump != null
      && terminator.is(Tree.Kind.CONTINUE_STATEMENT, Tree.Kind.RETURN_STATEMENT)
      && !isReturnWithExpression(terminator)
      && !isSwitchCaseChild(terminator)) {

      successorWithoutJump = nonEmptySuccessor(successorWithoutJump);
      Block successor = nonEmptySuccessor(block.successors().iterator().next());
      if (successorWithoutJump.equals(successor)) {
        reportIssue(terminator, ""Remove this redundant jump."");
      }
    }
  }

  private static boolean isReturnWithExpression(Tree tree) {
    if (tree.is(Tree.Kind.RETURN_STATEMENT)) {
      return ((ReturnStatementTree) tree).expression() != null;
    }
    return false;
  }

  private static boolean isSwitchCaseChild(Tree tree) {
    return tree.parent().is(Tree.Kind.CASE_GROUP);
  }

  private static Block nonEmptySuccessor(Block initialBlock) {
    Block result = initialBlock;
    Set<Integer> visited = new HashSet<>();
    while (result.elements().isEmpty() && result.successors().size() == 1 && visited.add(result.id())) {
      result = result.successors().iterator().next();
    }
    return result;
  }
}
"
S3631,CODE_SMELL,"""Arrays.stream"" should be used for primitive arrays","package org.sonar.java.checks;

import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3631"")
public class ArraysAsListOfPrimitiveToStreamCheck extends AbstractMethodDetection {

  private static final MethodMatchers ARRAYS_AS_LIST = MethodMatchers.create()
    .ofTypes(""java.util.Arrays"").names(""asList"").withAnyParameters().build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.util.List"").names(""stream"").addWithoutParametersMatcher().build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree expression = ((MemberSelectExpressionTree) methodSelect).expression();
      if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree arrayAsListInvocation = (MethodInvocationTree) expression;
        if (ARRAYS_AS_LIST.matches(arrayAsListInvocation) && shouldUsePrimitiveStream(arrayAsListInvocation)) {
          reportIssue(arrayAsListInvocation.methodSelect(), ""Use \""Arrays.stream\"" instead of \""Arrays.asList\""."");
        }
      }
    }
  }

  private static boolean shouldUsePrimitiveStream(MethodInvocationTree mit) {
    Set<Type> argumentTypes = argumentTypes(mit.arguments());
    return argumentTypes.size() == 1 && isPrimitiveTypeHandledByStream(argumentTypes.iterator().next());
  }

  private static Set<Type> argumentTypes(Arguments arguments) {
    return arguments.stream().map(ExpressionTree::symbolType).collect(Collectors.toSet());
  }

  private static boolean isPrimitiveTypeHandledByStream(Type type) {
    return type.isPrimitive(Type.Primitives.INT) || type.isPrimitive(Type.Primitives.DOUBLE) || type.isPrimitive(Type.Primitives.LONG);
  }

}
"
S3658,CODE_SMELL,Unit tests should throw exceptions,"package org.sonar.java.checks.tests;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.UnitTestUtils.FAIL_METHOD_MATCHER;

@Rule(key = ""S3658"")
public class AssertionFailInCatchBlockCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return FAIL_METHOD_MATCHER;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (isInCatch(mit)) {
      reportIssue(mit, ""Remove this failure assertion and simply add the exception type to the method signature."");
    }
  }

  private static boolean isInCatch(Tree tree) {
    Tree parent = tree.parent();
    return parent != null && !parent.is(Tree.Kind.METHOD) && (parent.is(Tree.Kind.CATCH) || isInCatch(parent));
  }
}
"
S3688,CODE_SMELL,Track uses of disallowed classes,"package org.sonar.java.checks;

import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.IllegalRuleParameterException;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ImportTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S3688"")
public class DisallowedClassCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final MethodMatchers CLASS_FOR_NAME = MethodMatchers.create().ofSubTypes(""java.lang.Class"")
    .names(""forName"")
    .addParametersMatcher(""java.lang.String"")
    .build();

  @RuleProperty(
    key = ""className"",
    description = ""Fully qualified name of the forbidden class. Use a regex to forbid a package."",
    defaultValue = """")
  public String disallowedClass = """";
  private Pattern pattern = null;
  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    if (context.getSemanticModel() != null) {
      scan(context.getTree());
    }
  }

  @Override
  public void visitImport(ImportTree tree) {
    String importName = ExpressionsHelper.concatenate((ExpressionTree) tree.qualifiedIdentifier());
    if (!checkIfDisallowed(importName, tree.qualifiedIdentifier())) {
      int separator = importName.lastIndexOf('.');
      if (separator != -1) {
        checkIfDisallowed(importName.substring(0, separator), tree.qualifiedIdentifier());
      }
    }
    super.visitImport(tree);
  }

  @Override
  public void visitVariable(VariableTree variableTree) {
    String variableTypeName = variableTree.type().symbolType().fullyQualifiedName();
    checkIfDisallowed(variableTypeName, variableTree.type());
    super.visitVariable(variableTree);
  }

  @Override
  public void visitMethod(MethodTree methodTree) {
    if (methodTree.returnType() != null ) {
      String returnTypeName = methodTree.returnType().symbolType().fullyQualifiedName();
      checkIfDisallowed(returnTypeName, methodTree.returnType());
    }
    super.visitMethod(methodTree);
  }

  @Override
  public void visitNewClass(NewClassTree newClassTree) {
    String newClassTypeName = newClassTree.identifier().symbolType().fullyQualifiedName();
    Tree parent = newClassTree.parent();
    if (parent != null && !parent.is(Tree.Kind.VARIABLE)) {
      checkIfDisallowed(newClassTypeName, newClassTree);
    }
    super.visitNewClass(newClassTree );
  }

  @Override
  public void visitClass(ClassTree classTree) {
    TypeTree superClass = classTree.superClass();
    if (superClass != null) {
      String superClassTypeName = superClass.symbolType().fullyQualifiedName();
      checkIfDisallowed(superClassTypeName, superClass);
    }
    super.visitClass(classTree);
  }

  @Override
  public void visitAnnotation(AnnotationTree annotationTree) {
    String annotationTypeName = annotationTree.symbolType().fullyQualifiedName();
    checkIfDisallowed(annotationTypeName, annotationTree.annotationType());
    super.visitAnnotation(annotationTree);
  }

  @Override
  public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
    // Disallowed new class are already reported in visitNewClass
    if(!tree.expression().is(Tree.Kind.NEW_CLASS)) {
      String memberSelectTypeName = tree.expression().symbolType().fullyQualifiedName();
      checkIfDisallowed(memberSelectTypeName, tree);
    }
    super.visitMemberSelectExpression(tree);
  }

  @Override
  public void visitMethodInvocation(MethodInvocationTree tree) {
    if (CLASS_FOR_NAME.matches(tree)) {
      tree.arguments().get(0).asConstant(String.class).ifPresent(
        argumentAsString -> checkIfDisallowed(argumentAsString, tree)
      );
    }
    super.visitMethodInvocation(tree);
  }

  private boolean checkIfDisallowed(String className, Tree tree) {
    if (pattern == null) {
      try {
        pattern = Pattern.compile(disallowedClass);
      } catch (IllegalArgumentException e) {
        throw new IllegalRuleParameterException(""["" + getClass().getSimpleName() + ""] Unable to compile the regular expression: "" + disallowedClass, e);
      }
    }
    if (pattern.matcher(className).matches() && !tree.is(Tree.Kind.INFERED_TYPE)) {
      context.reportIssue(this, tree, ""Remove the use of this forbidden class."");
      return true;
    }
    return false;
  }
}
"
S3725,CODE_SMELL,"Java 8's ""Files.exists"" should not be used","package org.sonar.java.checks;

import java.util.Map;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;

@Rule(key = ""S3725"")
public class FilesExistsJDK8Check extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final String JAVA_NIO_FILE_FILES = ""java.nio.file.Files"";
  private static final String EXISTS = ""exists"";
  private static final String IS_DIRECTORY = ""isDirectory"";
  private static final Map<String, String> messageParam = MapBuilder.<String, String>newMap()
    .put(EXISTS, EXISTS)
    .put(""notExists"", EXISTS)
    .put(""isRegularFile"", ""isFile"")
    .put(IS_DIRECTORY, IS_DIRECTORY)
    .build();

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.asInt() == 8;
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(JAVA_NIO_FILE_FILES)
      .names(EXISTS, ""notExists"", ""isRegularFile"", IS_DIRECTORY)
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    String methodName = mit.methodSymbol().name();
    reportIssue(ExpressionUtils.methodName(mit), ""Replace this with a call to the \""toFile()."" + messageParam.get(methodName) + ""()\"" method"");
  }

  @Override
  protected void onMethodReferenceFound(MethodReferenceTree methodReferenceTree) {
    String methodName = methodReferenceTree.method().symbol().name();
    reportIssue(methodReferenceTree.method(), ""Replace this with a call to the \""toFile()."" + messageParam.get(methodName) + ""()\"" method"");
  }
}
"
S3740,CODE_SMELL,Raw types should not be used,"package org.sonar.java.checks;

import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S3740"")
public class RawTypeCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitMethod(MethodTree tree) {
    if (!Boolean.FALSE.equals(tree.isOverriding())) {
      // only scan body of the method
      scan(tree.block());
    } else {
      checkTypeTree(tree.returnType());
      super.visitMethod(tree);
    }
  }

  @Override
  public void visitParameterizedType(ParameterizedTypeTree tree) {
    tree.typeArguments()
      .forEach(this::checkTypeTree);
    super.visitParameterizedType(tree);
  }

  @Override
  public void visitNewClass(NewClassTree tree) {
    checkTypeTree(tree.identifier());
    super.visitNewClass(tree);
  }

  @Override
  public void visitVariable(VariableTree tree) {
    checkTypeTree(tree.type());
    super.visitVariable(tree);
  }

  @Override
  public void visitClass(ClassTree tree) {
    tree.superInterfaces().forEach(this::checkTypeTree);
    checkTypeTree(tree.superClass());
    super.visitClass(tree);
  }

  private void checkTypeTree(@Nullable TypeTree typeTree) {
    if (typeTree == null) {
      return;
    }
    if (typeTree.is(Tree.Kind.IDENTIFIER)) {
      checkIdentifier((IdentifierTree) typeTree);
    } else if (typeTree.is(Tree.Kind.MEMBER_SELECT)) {
      checkIdentifier(((MemberSelectExpressionTree) typeTree).identifier());
    }
  }

  private void checkIdentifier(IdentifierTree identifier) {
    Type type = identifier.symbolType();
    if (type.isRawType() && !type.equals(type.declaringType())) {
      context.reportIssue(this, identifier, ""Provide the parametrized type for this generic."");
    }
  }
}
"
S3749,CODE_SMELL,Members of Spring components should be injected,"package org.sonar.java.checks.spring;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.checks.helpers.SpringUtils.isScopeSingleton;

@Rule(key = ""S3749"")
public class SpringComponentWithNonAutowiredMembersCheck extends IssuableSubscriptionVisitor {

  @RuleProperty(
    key = ""customInjectionAnnotations"",
    description = ""comma-separated list of FQDN annotation names to consider as valid"",
    defaultValue = """")
  public String customInjectionAnnotations = """";

  private static final List<String> SPRING_INJECTION_ANNOTATION = Arrays.asList(
    ""org.springframework.beans.factory.annotation.Autowired"",
    ""javax.inject.Inject"",
    ""jakarta.inject.Inject"",
    ""javax.annotation.Resource"",
    ""jakarta.annotation.Resource"",
    ""javax.persistence.PersistenceContext"",
    ""jakarta.persistence.PersistenceContext"",
    ""org.springframework.beans.factory.annotation.Value"");

  private static final List<String> SPRING_SINGLETON_ANNOTATION = Arrays.asList(
    ""org.springframework.stereotype.Controller"",
    ""org.springframework.web.bind.annotation.RestController"",
    ""org.springframework.stereotype.Service"",
    ""org.springframework.stereotype.Component"",
    ""org.springframework.stereotype.Repository"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree clazzTree = (ClassTree) tree;
    Set<Symbol> symbolsUsedInConstructors = symbolsUsedInConstructors(clazzTree);

    if (isSpringSingletonComponent(clazzTree.symbol().metadata())) {
      clazzTree.members().stream().filter(v -> v.is(Tree.Kind.VARIABLE))
        .map(VariableTree.class::cast)
        .filter(v -> !v.symbol().isStatic())
        .filter(v -> !isSpringInjectionAnnotated(v.symbol().metadata()))
        .filter(v -> !isCustomInjectionAnnotated(v.symbol().metadata()))
        .filter(v -> !symbolsUsedInConstructors.contains(v.symbol()))
        .forEach(v -> reportIssue(v.simpleName(), ""Annotate this member with \""@Autowired\"", \""@Resource\"", \""@Inject\"", or \""@Value\"", or remove it.""));
    }
  }

  private static boolean isSpringInjectionAnnotated(SymbolMetadata metadata) {
    return SPRING_INJECTION_ANNOTATION.stream().anyMatch(metadata::isAnnotatedWith);
  }

  private boolean isCustomInjectionAnnotated(SymbolMetadata metadata) {
    return Arrays.stream(customInjectionAnnotations.split("",""))
      .map(String::trim)
      .anyMatch(metadata::isAnnotatedWith);
  }

  private static boolean isSpringSingletonComponent(SymbolMetadata clazzMeta) {
    return SPRING_SINGLETON_ANNOTATION.stream().anyMatch(clazzMeta::isAnnotatedWith)
      && !isUsingConfigurationProperties(clazzMeta)
      && isScopeSingleton(clazzMeta);
  }

  private static boolean isUsingConfigurationProperties(SymbolMetadata classMeta) {
    return classMeta.isAnnotatedWith(""org.springframework.boot.context.properties.ConfigurationProperties"");
  }

  private Set<Symbol> symbolsUsedInConstructors(ClassTree clazzTree) {
    List<Symbol.MethodSymbol> constructors = constructors(clazzTree);
    return constructors.stream()
      .filter(ctor -> isAutowired(constructors, ctor))
      .map(Symbol.MethodSymbol::declaration)
      .flatMap(ctorTree -> symbolsUsedInMethod(ctorTree.symbol()).stream())
      .collect(Collectors.toSet());
  }

  private boolean isAutowired(List<Symbol.MethodSymbol> constructors, Symbol.MethodSymbol ctor) {
    return isSpringInjectionAnnotated(ctor.metadata())
      || isCustomInjectionAnnotated(ctor.metadata()) || constructors.size() == 1;
  }

  private static Set<Symbol> symbolsUsedInMethod(Symbol.MethodSymbol methodSymbol) {
    IdentifierCollector identifierCollector = new IdentifierCollector();
    methodSymbol.declaration().accept(identifierCollector);
    return identifierCollector.identifiers;
  }

  private static List<Symbol.MethodSymbol> constructors(ClassTree clazzTree) {
    return clazzTree.symbol().memberSymbols().stream()
      .filter(Symbol::isMethodSymbol)
      .map(s -> (Symbol.MethodSymbol) s)
      .filter(m -> ""<init>"".equals(m.name()))
      .filter(m -> m.declaration() != null)
      .toList();
  }

  private static class IdentifierCollector extends BaseTreeVisitor {

    Set<Symbol> identifiers = new HashSet<>();

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      identifiers.add(tree.symbol());
    }
  }
}
"
S3750,BUG,"Spring ""@Controller"" classes should not use ""@Scope""","package org.sonar.java.checks.spring;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.SpringUtils.SPRING_SCOPE_ANNOTATION;
import static org.sonar.java.checks.helpers.SpringUtils.isScopeSingleton;

@Rule(key = ""S3750"")
public class SpringComponentWithWrongScopeCheck extends IssuableSubscriptionVisitor {


  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree clazzTree = (ClassTree) tree;
    SymbolMetadata clazzMeta = clazzTree.symbol().metadata();

    if (isSpringComponent(clazzMeta)
      && clazzMeta.isAnnotatedWith(SPRING_SCOPE_ANNOTATION)
      && !isScopeSingleton(clazzMeta)) {
      checkScopeAnnotation(clazzTree);
    }
  }

  private static boolean isSpringComponent(SymbolMetadata clazzMeta) {
    return clazzMeta.isAnnotatedWith(""org.springframework.stereotype.Controller"")
      || clazzMeta.isAnnotatedWith(""org.springframework.stereotype.Service"")
      || clazzMeta.isAnnotatedWith(""org.springframework.stereotype.Repository"");
  }

  private void checkScopeAnnotation(ClassTree tree) {
    tree.modifiers().annotations().stream()
      .filter(a -> a.annotationType().symbolType().fullyQualifiedName().equals(SPRING_SCOPE_ANNOTATION))
      .forEach(a -> reportIssue(a, ""Remove this \""@Scope\"" annotation.""));
  }

}
"
S3751,CODE_SMELL,"""@RequestMapping"" methods should not be ""private""","package org.sonar.java.checks.spring;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3751"")
public class RequestMappingMethodPublicCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  private static final List<String> CONTROLLER_ANNOTATIONS = Arrays.asList(
    ""org.springframework.stereotype.Controller"",
    ""org.springframework.web.bind.annotation.RestController""
  );

  private static final List<String> REQUEST_ANNOTATIONS = Arrays.asList(
    ""org.springframework.web.bind.annotation.RequestMapping"",
    ""org.springframework.web.bind.annotation.GetMapping"",
    ""org.springframework.web.bind.annotation.PostMapping"",
    ""org.springframework.web.bind.annotation.PutMapping"",
    ""org.springframework.web.bind.annotation.DeleteMapping"",
    ""org.springframework.web.bind.annotation.PatchMapping""
  );

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();

    if (isClassController(methodSymbol)
      && isRequestMappingAnnotated(methodSymbol)
      && methodSymbol.isPrivate()) {
      reportIssue(methodTree.simpleName(), ""Make this method non \""private\""."");
    }
  }

  private static boolean isClassController(Symbol.MethodSymbol methodSymbol) {
    return CONTROLLER_ANNOTATIONS.stream().anyMatch(methodSymbol.owner().metadata()::isAnnotatedWith);
  }

  private static boolean isRequestMappingAnnotated(Symbol.MethodSymbol methodSymbol) {
    return REQUEST_ANNOTATIONS.stream().anyMatch(methodSymbol.metadata()::isAnnotatedWith);
  }

}
"
S3752,SECURITY_HOTSPOT,Allowing both safe and unsafe HTTP methods is security-sensitive,"package org.sonar.java.checks.spring;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ModifiersTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3752"")
public class SpringRequestMappingMethodCheck extends IssuableSubscriptionVisitor {

  private static final String REQUEST_MAPPING_CLASS = ""org.springframework.web.bind.annotation.RequestMapping"";

  private static final String REQUEST_METHOD = ""method"";
  public static final String MESSAGE = ""Make sure allowing safe and unsafe HTTP methods is safe here."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    findRequestMappingAnnotation(classTree.modifiers())
      .flatMap(SpringRequestMappingMethodCheck::findRequestMethods)
      .filter(SpringRequestMappingMethodCheck::mixSafeAndUnsafeMethods)
      .ifPresent(methods -> reportIssue(methods, MESSAGE));

    classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .forEach(member -> checkMethod((MethodTree) member, classTree.symbol()));
  }

  private void checkMethod(MethodTree method, Symbol.TypeSymbol classSymbol) {
    Optional<AnnotationTree> requestMappingAnnotation = findRequestMappingAnnotation(method.modifiers());
    Optional<ExpressionTree> requestMethods = requestMappingAnnotation
      .flatMap(SpringRequestMappingMethodCheck::findRequestMethods);

    if (requestMethods.isPresent()) {
      requestMethods
        .filter(SpringRequestMappingMethodCheck::mixSafeAndUnsafeMethods)
        .ifPresent(methods -> reportIssue(methods, MESSAGE));
    } else if (requestMappingAnnotation.isPresent() && !inheritRequestMethod(classSymbol)) {
      reportIssue(requestMappingAnnotation.get().annotationType(), MESSAGE);
    }
  }

  private static Optional<AnnotationTree> findRequestMappingAnnotation(ModifiersTree modifiers) {
    return modifiers.annotations().stream()
      .filter(annotation -> annotation.symbolType().is(REQUEST_MAPPING_CLASS))
      .findFirst();
  }

  private static Optional<ExpressionTree> findRequestMethods(AnnotationTree annotation) {
    return annotation.arguments().stream()
      .filter(argument -> argument.is(Tree.Kind.ASSIGNMENT))
      .map(AssignmentExpressionTree.class::cast)
      .filter(assignment -> REQUEST_METHOD.equals(((IdentifierTree) assignment.variable()).name()))
      .map(AssignmentExpressionTree::expression)
      .findFirst();
  }

  private static boolean inheritRequestMethod(Symbol.TypeSymbol symbol) {
    List<SymbolMetadata.AnnotationValue> annotationValues = symbol.metadata().valuesForAnnotation(REQUEST_MAPPING_CLASS);
    if (annotationValues != null && annotationValues.stream().anyMatch(value -> REQUEST_METHOD.equals(value.name()))) {
      return true;
    }
    Type superClass = symbol.superClass();
    if (superClass != null && inheritRequestMethod(superClass.symbol())) {
      return true;
    }
    for (Type type : symbol.interfaces()) {
      if (inheritRequestMethod(type.symbol())) {
        return true;
      }
    }
    return false;
  }

  private static boolean mixSafeAndUnsafeMethods(ExpressionTree requestMethodsAssignment) {
    HttpMethodVisitor visitor = new HttpMethodVisitor();
    requestMethodsAssignment.accept(visitor);
    return visitor.hasSafeMethods && visitor.hasUnsafeMethods;
  }

  private static class HttpMethodVisitor extends BaseTreeVisitor {
    private static final Set<String> SAFE_METHODS = new HashSet<>(Arrays.asList(""GET"", ""HEAD"", ""OPTIONS"", ""TRACE""));
    private static final Set<String> UNSAFE_METHODS = new HashSet<>(Arrays.asList(""DELETE"", ""PATCH"", ""POST"", ""PUT""));

    private boolean hasSafeMethods = false;
    private boolean hasUnsafeMethods = false;

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      hasSafeMethods |= SAFE_METHODS.contains(tree.name());
      hasUnsafeMethods |= UNSAFE_METHODS.contains(tree.name());
    }
  }

}
"
S3753,BUG,"""@Controller"" classes that use ""@SessionAttributes"" must call ""setComplete"" on their ""SessionStatus"" objects","package org.sonar.java.checks.spring;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3753"")
public class ControllerWithSessionAttributesCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    SymbolMetadata classMetadata = classTree.symbol().metadata();
    Optional<AnnotationTree> sessionAttributesAnnotation = classTree.modifiers().annotations()
      .stream()
      .filter(a -> a.annotationType().symbolType().is(""org.springframework.web.bind.annotation.SessionAttributes""))
      .findFirst();

    if (sessionAttributesAnnotation.isPresent()
        && classMetadata.isAnnotatedWith(""org.springframework.stereotype.Controller"")) {
      MethodInvocationVisitor methodInvocationVisitor = new MethodInvocationVisitor();
      classTree.accept(methodInvocationVisitor);
      if (!methodInvocationVisitor.setCompleteIsCalled) {
        reportIssue(sessionAttributesAnnotation.get().annotationType(),
          ""Add a call to \""setComplete()\"" on the SessionStatus object in a \""@RequestMapping\"" method."");
      }
    }
  }private static class MethodInvocationVisitor extends BaseTreeVisitor {
    private static final MethodMatchers SET_COMPLETE = MethodMatchers.create()
      .ofTypes(""org.springframework.web.bind.support.SessionStatus"").names(""setComplete"").withAnyParameters().build();

    boolean setCompleteIsCalled;

    @Override
    public void visitMethodInvocation(MethodInvocationTree methodInvocationTree) {
      if (SET_COMPLETE.matches(methodInvocationTree)) {
        setCompleteIsCalled = true;
      }
    }
  }
}
"
S3776,CODE_SMELL,Cognitive Complexity of methods should not be too high,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.ast.visitors.CognitiveComplexityVisitor;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.metrics.MetricsScannerContext;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S3776"")
public class CognitiveComplexityMethodCheck  extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_MAX = 15;

  @RuleProperty(
          key = ""Threshold"",
          description = ""The maximum authorized complexity."",
          defaultValue = """" + DEFAULT_MAX)
  private int max = DEFAULT_MAX;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree method = (MethodTree) tree;
    if (isExcluded(method)) {
      return;
    }
    var metricsComputer = ((MetricsScannerContext)context).getMetricsComputer();
    CognitiveComplexityVisitor.Result result = metricsComputer.getMethodComplexity(method);
    int total = result.complexity;
    if (total > max) {
      reportIssue(method.simpleName(),
        ""Refactor this method to reduce its Cognitive Complexity from "" + total + "" to the "" + max + "" allowed."", result.locations, total - max);
    }
  }

  public void setMax(int max) {
    this.max = max;
  }

  private static boolean isExcluded(MethodTree methodTree) {
    return MethodTreeUtils.isEqualsMethod(methodTree) || MethodTreeUtils.isHashCodeMethod(methodTree);
  }
}
"
S3864,CODE_SMELL,"""Stream.peek"" should be used with caution","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S3864"")
public class StreamPeekCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(
        ""java.util.stream.Stream"",
        ""java.util.stream.IntStream"",
        ""java.util.stream.LongStream"",
        ""java.util.stream.DoubleStream"")
      .names(""peek"")
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Remove this use of \""Stream.peek\""."");
  }

}
"
S3878,CODE_SMELL,Arrays should not be created for varargs parameters,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;

@Rule(key = ""S3878"")
public class ArrayForVarArgCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    Symbol.MethodSymbol sym;
    Arguments args;
    if (tree.is(Tree.Kind.NEW_CLASS)) {
      NewClassTree nct = (NewClassTree) tree;
      sym = nct.methodSymbol();
      args = nct.arguments();
    } else {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      sym = mit.methodSymbol();
      args = mit.arguments();
    }

    if (!sym.isUnknown() && isLastArgumentVarargs(sym, args)) {
      ExpressionTree lastArg = args.get(args.size() - 1);
      checkInvokedMethod(sym, lastArg);
    }
  }

  private void checkInvokedMethod(Symbol.MethodSymbol methodSymbol, ExpressionTree lastArg) {
    if (lastArg.is(Tree.Kind.NEW_ARRAY)) {
      Type lastParamType = getLastParameterType(methodSymbol.parameterTypes());
      Type lastArgType = lastArg.symbolType();
      if (lastParamType.isUnknown() || lastArgType.isUnknown()) {
        return;
      }
      if (""java.lang.Object[]"".equals(lastParamType.fullyQualifiedName())) {
        reportIssue(lastArg, ""Disambiguate this call by either casting as \""Object\"" or \""Object[]\""."");
      } else if (lastArgType.isSubtypeOf(lastParamType)) {
        reportIssueForSameType(methodSymbol, (NewArrayTree) lastArg);
      }
    }
  }

  private void reportIssueForSameType(Symbol.MethodSymbol methodSymbol, NewArrayTree newArrayTree) {
    String message = ""Remove this array creation"";
    if (newArrayTree.openBraceToken() == null) {
      ExpressionTree expression = newArrayTree.dimensions().get(0).expression();
      Integer literalValue = LiteralUtils.intLiteralValue(expression);
      if (literalValue == null || literalValue != 0 || isCallingOverload(methodSymbol, newArrayTree)) {
        return;
      }
    } else if (!newArrayTree.initializers().isEmpty()) {
      message += "" and simply pass the elements"";
    }
    reportIssue(newArrayTree, message + ""."");
  }

  private static boolean isLastArgumentVarargs(Symbol.MethodSymbol methodSymbol, Arguments args) {
    // If we have less arguments than parameter types, it means that no arguments was pass to the varargs.
    // If we have more, the last argument can not be an array.
    return !args.isEmpty() && methodSymbol.isVarArgsMethod() && args.size() == methodSymbol.parameterTypes().size();
  }

  private static Type getLastParameterType(List<? extends Type> list) {
    return list.get(list.size() - 1);
  }

  private static boolean isCallingOverload(Symbol.MethodSymbol methodSymbol, ExpressionTree lastArg) {
    MethodTree enclosing = ExpressionUtils.getEnclosingMethod(lastArg);
    return enclosing != null && haveSameParamButLast(enclosing.symbol(), methodSymbol);
  }

  private static boolean haveSameParamButLast(Symbol.MethodSymbol enclosing, Symbol.MethodSymbol methodSymbol) {
    return enclosing.name().equals(methodSymbol.name())
      && IntStream.range(0, enclosing.parameterTypes().size()).allMatch(i -> enclosing.parameterTypes().get(i) == methodSymbol.parameterTypes().get(i));
  }
}
"
S3923,BUG,All branches in a conditional structure should not have exactly the same implementation,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.SwitchTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3923"")
public class AllBranchesAreIdenticalCheck extends IdenticalCasesInSwitchCheck {

  private static final String IF_SWITCH_MSG = ""Remove this conditional structure or edit its code blocks so that they're not all the same."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.SWITCH_STATEMENT, Tree.Kind.SWITCH_EXPRESSION, Tree.Kind.IF_STATEMENT, Tree.Kind.CONDITIONAL_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.SWITCH_STATEMENT, Tree.Kind.SWITCH_EXPRESSION)) {
      SwitchTree switchTree = (SwitchTree) tree;
      Map<CaseGroupTree, Set<CaseGroupTree>> identicalBranches = checkSwitchStatement(switchTree);
      if (hasDefaultClause(switchTree) && allBranchesSame(identicalBranches, switchTree.cases().size())) {
        reportIssue(switchTree.switchKeyword(), IF_SWITCH_MSG);
      }
    } else if (tree.is(Tree.Kind.IF_STATEMENT)) {
      IfStatementTree ifStatementTree = (IfStatementTree) tree;
      if (hasElseClause(ifStatementTree) && !tree.parent().is(Tree.Kind.IF_STATEMENT)) {
        IfElseChain ifElseChain = checkIfStatement(ifStatementTree);
        if (allBranchesSame(ifElseChain.branches, ifElseChain.totalBranchCount)) {
          reportIssue(ifStatementTree.ifKeyword(), IF_SWITCH_MSG);
        }
      }
    } else {
      checkConditionalExpression((ConditionalExpressionTree) tree);
    }
  }

  private void checkConditionalExpression(ConditionalExpressionTree node) {
    if (SyntacticEquivalence.areEquivalent(ExpressionUtils.skipParentheses(node.trueExpression()), ExpressionUtils.skipParentheses(node.falseExpression()))) {
      reportIssue(node.condition(), node.questionToken(), ""This conditional operation returns the same value whether the condition is \""true\"" or \""false\""."");
    }
  }
}
"
S3937,CODE_SMELL,Number patterns should be regular,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S3937"")
public class UnderscoreMisplacedOnNumberCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava7Compatible();
  }

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Kind.INT_LITERAL, Kind.LONG_LITERAL);
  }

  @Override
  public void visitNode(Tree tree) {
    LiteralTree literalTree = (LiteralTree) tree;
    String value = literalTree.value();if (isNotABinaryNumber(value) && hasIrregularPattern(value)) {
      reportIssue(literalTree, ""Review this number; its irregular pattern indicates an error."");
    }
  }

  private static boolean isNotABinaryNumber(String literalValue) {
    return !literalValue.startsWith(""0b"") && !literalValue.startsWith(""0B"");
  }

  private static boolean hasIrregularPattern(String literalValue) {
    List<String> groups = Arrays.asList(cleanup(literalValue).split(""_""));
    // groups empty or of size one does not contain ""_""
    if (groups.size() <= 1) {
      return false;
    }
    int firstGroupLength = groups.get(0).length();
    List<Integer> lengths = groups.stream().skip(1).map(String::length).distinct().toList();
    return lengths.size() != 1 || lengths.get(0) < firstGroupLength;
  }

  private static String cleanup(String literalValue) {
    String result = literalValue.toLowerCase();
    if(result.startsWith(""0b"") || result.startsWith(""0x"")) {
      result = result.substring(2);
    }
    if(result.endsWith(""l"")) {
      result = result.substring(0, result.length() - 1);
    }
    return result;
  }

}
"
S3972,CODE_SMELL,Conditionals should start on new lines,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S3972"")
public class ConditionalOnNewLineCheck extends IssuableSubscriptionVisitor {

  private SyntaxToken previousToken;

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.IF_STATEMENT);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    previousToken = null;
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    IfStatementTree ifStatementTree = (IfStatementTree) tree;

    if(previousToken != null && isOnSameLineAsPreviousIf(ifStatementTree)) {
      reportIssue(ifStatementTree.ifKeyword(), ""Move this \""if\"" to a new line or add the missing \""else\""."",
        Collections.singletonList(new JavaFileScannerContext.Location("""", previousToken)), null);
    }

    StatementTree elsePart = ifStatementTree.elseStatement();
    if (elsePart != null) {
      previousToken = elsePart.lastToken();
    } else {
      previousToken = ifStatementTree.thenStatement().lastToken();
    }
  }

  private boolean isOnSameLineAsPreviousIf(IfStatementTree ifStatementTree) {
    // check column for nested if on one line case.
    Position previousTokenStart = Position.startOf(previousToken);
    Position ifStatementStart = Position.startOf(ifStatementTree.ifKeyword());
    return previousTokenStart.line() == ifStatementStart.line() &&
      previousTokenStart.column() < ifStatementStart.column();
  }
}
"
S3973,CODE_SMELL,A conditionally executed single line should be denoted by indentation,"package org.sonar.java.checks;

import java.util.Collections;
import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

@Rule(key = ""S3973"")
public class IndentationAfterConditionalCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitIfStatement(IfStatementTree tree) {
    Tree parentTree = tree.parent();
    if (parentTree.is(Tree.Kind.IF_STATEMENT) && tree.equals(((IfStatementTree) parentTree).elseStatement())) {
      checkForReport(tree.thenStatement(), getAcceptableStartOfElse((IfStatementTree) parentTree), tree.closeParenToken(), tree.ifKeyword().firstToken().text());
    } else {
      checkForReport(tree.thenStatement(), tree.ifKeyword(), tree.closeParenToken(), tree.ifKeyword().text());
    }
    SyntaxToken elseKeyword = tree.elseKeyword();
    if (elseKeyword != null && !tree.elseStatement().is(Tree.Kind.IF_STATEMENT)) {
      checkForReport(tree.elseStatement(), getAcceptableStartOfElse(tree), elseKeyword, elseKeyword.firstToken().text());
    }
    super.visitIfStatement(tree);
  }

  @Override
  public void visitWhileStatement(WhileStatementTree tree) {
    super.visitWhileStatement(tree);
    checkForReport(tree.statement(), tree.whileKeyword(), tree.closeParenToken(), tree.whileKeyword().text());
  }

  @Override
  public void visitForStatement(ForStatementTree tree) {
    super.visitForStatement(tree);
    checkForReport(tree.statement(), tree.forKeyword(), tree.closeParenToken(), tree.forKeyword().text());
  }

  @Override
  public void visitForEachStatement(ForEachStatement tree) {
    super.visitForEachStatement(tree);
    checkForReport(tree.statement(), tree.forKeyword(), tree.closeParenToken(), tree.forKeyword().text());
  }

  private static Tree getAcceptableStartOfElse(IfStatementTree ifStatement) {
    StatementTree thenStatement = ifStatement.thenStatement();
    SyntaxToken elseKeyword = ifStatement.elseKeyword();
    if (thenStatement.is(Tree.Kind.BLOCK)) {
      SyntaxToken closeBrace = ((BlockTree) thenStatement).closeBraceToken();
      if (LineUtils.startLine(closeBrace) == LineUtils.startLine(elseKeyword)) {
        return closeBrace;
      }
    }
    return elseKeyword;
  }

  private void checkForReport(StatementTree statement, Tree startTree, Tree endTree, String name) {
    if (!(statement.is(Tree.Kind.BLOCK) ||
      Position.startOf(statement).column() > Position.startOf(startTree).column())) {
      context.reportIssue(this, startTree, endTree,
        ""Use indentation to denote the code conditionally executed by this \"""" + name + ""\""."",
        Collections.singletonList(new JavaFileScannerContext.Location("""", statement)), null);
    }
  }
}
"
S3981,BUG,Collection sizes and array length comparisons should make sense,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3981"")
public class CollectionSizeAndArrayLengthCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers COLLECTION_SIZE = MethodMatchers.create()
    .ofSubTypes(""java.util.Collection"")
    .names(""size"")
    .addWithoutParametersMatcher()
    .build();

  private static final String COLLECTION_ISSUE_MSG = ""The size of %s is always \"">=0\"", so update this test to use isEmpty()."";
  private static final String ARRAY_ISSUE_MSG = ""The length of %s is always \"">=0\"", so update this test to either \""==0\"" or \"">0\""."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.GREATER_THAN_OR_EQUAL_TO,
      Tree.Kind.GREATER_THAN,
      Tree.Kind.LESS_THAN,
      Tree.Kind.LESS_THAN_OR_EQUAL_TO);
  }

  @Override
  public void visitNode(Tree tree) {
    BinaryExpressionTree bet = (BinaryExpressionTree) tree;
    ExpressionTree leftOperand = ExpressionUtils.skipParentheses(bet.leftOperand());
    ExpressionTree rightOperand = ExpressionUtils.skipParentheses(bet.rightOperand());
    boolean leftIsZero = LiteralUtils.isZero(leftOperand);
    boolean rightIsZero = LiteralUtils.isZero(rightOperand);
    if (!leftIsZero && !rightIsZero) {
      return;
    }
    ExpressionTree testedValue = leftIsZero ? rightOperand : leftOperand;
    if (testedValue.is(Tree.Kind.METHOD_INVOCATION)) {
      checkCollectionSize((MethodInvocationTree) testedValue, bet, leftIsZero);
    } else if (testedValue.is(Tree.Kind.MEMBER_SELECT)) {
      checkArrayLength((MemberSelectExpressionTree) testedValue, bet, leftIsZero);
    }
  }

  private void checkCollectionSize(MethodInvocationTree testedValue, BinaryExpressionTree bet, boolean leftIsZero) {
    if (!COLLECTION_SIZE.matches(testedValue)) {
      return;
    }
    reportIssue(bet, leftIsZero, COLLECTION_ISSUE_MSG, collectionName(testedValue.methodSelect()));
  }

  private static String collectionName(ExpressionTree sizeMethodSelect) {
    if (sizeMethodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree collectionAccess = ((MemberSelectExpressionTree) sizeMethodSelect).expression();
      if (collectionAccess.is(Tree.Kind.IDENTIFIER)) {
        return escape(((IdentifierTree) collectionAccess).name());
      }
    }
    return ""a collection"";
  }

  private static String escape(String s) {
    return ""\"""" + s + ""\"""";
  }

  private void reportIssue(BinaryExpressionTree bet, boolean leftIsZero, String message, String itemName) {
    if ((leftIsZero && bet.is(Tree.Kind.GREATER_THAN, Tree.Kind.LESS_THAN_OR_EQUAL_TO))
      || (!leftIsZero && bet.is(Tree.Kind.LESS_THAN, Tree.Kind.GREATER_THAN_OR_EQUAL_TO))) {
      reportIssue(bet, String.format(message, itemName));
    }
  }

  private void checkArrayLength(MemberSelectExpressionTree testedValue, BinaryExpressionTree bet, boolean leftIsZero) {
    if (!""length"".equals(testedValue.identifier().name())) {
      return;
    }
    ExpressionTree expression = testedValue.expression();
    if (!expression.symbolType().isArray()) {
      return;
    }
    reportIssue(bet, leftIsZero, ARRAY_ISSUE_MSG, arrayName(expression));
  }

  private static String arrayName(ExpressionTree expr) {
    if (expr.is(Tree.Kind.IDENTIFIER)) {
      return escape(((IdentifierTree) expr).name());
    }
    if (expr.is(Tree.Kind.MEMBER_SELECT)) {
      return escape(((MemberSelectExpressionTree) expr).identifier().name());
    }
    return ""an array"";
  }

}
"
S3984,BUG,Exceptions should not be created without being thrown,"package org.sonar.java.checks.unused;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3984"")
public class UnusedThrowableCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    NewClassTree newClassTree = (NewClassTree) tree;
    if (newClassTree.symbolType().isSubtypeOf(""java.lang.Throwable"")) {
      Tree parent = newClassTree.parent();
      if (parent.is(Tree.Kind.EXPRESSION_STATEMENT)) {
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(newClassTree)
          .withMessage(""Throw this exception or remove this useless statement."")
          .withQuickFixes(() -> Arrays.asList(
            JavaQuickFix.newQuickFix(""Add \""throw\"""")
              .addTextEdit(JavaTextEdit.insertBeforeTree(newClassTree, ""throw ""))
              .build(),
            JavaQuickFix.newQuickFix(""Remove the statement"")
              .addTextEdit(
                JavaTextEdit.removeTree(parent)
              ).build()))
          .report();
      }
    }
  }
}
"
S3985,CODE_SMELL,"Unused ""private"" classes should be removed","package org.sonar.java.checks.unused;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.UnresolvedIdentifiersVisitor;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3985"")
public class UnusedPrivateClassCheck extends IssuableSubscriptionVisitor {

  private static final UnresolvedIdentifiersVisitor UNRESOLVED_IDENTIFIERS_VISITOR = new UnresolvedIdentifiersVisitor();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.COMPILATION_UNIT, Tree.Kind.CLASS, Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE, Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      UNRESOLVED_IDENTIFIERS_VISITOR.check(tree);
      return;
    }
    ClassTree classTree = (ClassTree) tree;
    Symbol.TypeSymbol classSymbol = classTree.symbol();
    IdentifierTree identifierTree = classTree.simpleName();
    if(identifierTree != null && classSymbol.isPrivate()
      && classSymbol.usages().isEmpty() && !UNRESOLVED_IDENTIFIERS_VISITOR.isUnresolved(identifierTree.name())) {
      reportIssue(identifierTree, ""Remove this unused private \""""+ classSymbol.name()+""\"" class."");
    }
  }
}
"
S3986,BUG,"Week Year (""YYYY"") should not be used for date formatting","package org.sonar.java.checks;

import java.util.Locale;
import java.util.Optional;
import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.InternalJavaIssueBuilder;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S3986"")
public class DateFormatWeekYearCheck extends AbstractMethodDetection {
  private static final MethodMatchers SIMPLE_DATE_FORMAT_MATCHER = MethodMatchers.create()
    .ofTypes(""java.text.SimpleDateFormat"")
    .constructor()
    .withAnyParameters()
    .build();

  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()
    .ofTypes(""java.time.format.DateTimeFormatter"")
    .names(""ofPattern"")
    .addParametersMatcher(""java.lang.String"")
    .addParametersMatcher(""java.lang.String"", ""java.util.Locale"")
    .build();

  private static final String RECOMMENDATION_YEAR_MESSAGE = ""Make sure that week Year \""%s\"" is expected here instead of Year \""%s\""."";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(SIMPLE_DATE_FORMAT_MATCHER, OF_PATTERN_MATCHER);
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    if (newClassTree.arguments().isEmpty()) {
      return;
    }
    ExpressionTree expressionTree = newClassTree.arguments().get(0);
    inspectPattern(expressionTree);
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree invocation) {
    Arguments arguments = invocation.arguments();
    if (arguments.isEmpty()) {
      return;
    }
    ExpressionTree argument = arguments.get(0);
    inspectPattern(argument);
  }

  private void inspectPattern(ExpressionTree argument) {
    Optional<String> literal = argument.asConstant(String.class);
    if (!literal.isPresent()) {
      return;
    }
    String datePattern = literal.get();
    if (StringUtils.contains(datePattern, 'w')) {
      return;
    }
    int start = datePattern.indexOf('Y');
    if (start > -1) {
      int end = getEndIndexOfYearSequence(datePattern, start);
      String firstYSeq = datePattern.substring(start, end);
      String replacement = firstYSeq.toLowerCase(Locale.ENGLISH);
      String message = String.format(RECOMMENDATION_YEAR_MESSAGE, firstYSeq, replacement);
      InternalJavaIssueBuilder issueBuilder = QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(argument)
        .withMessage(message);
      if (argument.is(Tree.Kind.STRING_LITERAL)) {
        issueBuilder.withQuickFix(() -> computeQuickFix(argument, start, end, replacement));
      }
      issueBuilder.report();
    }
  }

  private static int getEndIndexOfYearSequence(String sequence, int start) {
    int count = start;
    while (count < sequence.length() && sequence.charAt(count) == 'Y') {
      count++;
    }
    return count;
  }

  private static JavaQuickFix computeQuickFix(ExpressionTree argument,
    int literalContentStartIndex, int literalContentEndIndex, String replacement) {

    Position stringLiteralStart = Position.startOf(argument);
    int quoteDelimiterLength = 1;
    return JavaQuickFix.newQuickFix(""Replace year format"")
      .addTextEdit(JavaTextEdit.replaceTextSpan(new AnalyzerMessage.TextSpan(
        stringLiteralStart.line(),
        stringLiteralStart.columnOffset() + quoteDelimiterLength + literalContentStartIndex,
        stringLiteralStart.line(),
        stringLiteralStart.columnOffset() + quoteDelimiterLength + literalContentEndIndex),
        replacement))
      .build();
  }

}
"
S4011,CODE_SMELL,Track uses of disallowed constructors,"package org.sonar.java.checks;

import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.NewClassTree;

@Rule(key = ""S4011"")
public class DisallowedConstructorCheck extends AbstractMethodDetection {

  @RuleProperty(key = ""className"", description = ""Name of the class whose constructor is forbidden. This parameter is mandatory, if absent the rule is disabled."")
  private String className = """";

  @RuleProperty(key = ""argumentTypes"", description = ""Comma-delimited list of argument types, E.G. java.lang.String, int[], int"")
  private String argumentTypes = """";

  @RuleProperty(key = ""allOverloads"", description = ""Set to true to flag all overloads regardless of parameter type"", defaultValue = ""false"")
  private boolean allOverloads = false;

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    if (StringUtils.isEmpty(className)) {
      return MethodMatchers.none();
    }
    MethodMatchers.ParametersBuilder invocationMatcher = MethodMatchers.create().ofTypes(className).constructor();
    if (allOverloads) {
      return invocationMatcher.withAnyParameters().build();
    } else {
      String[] args = StringUtils.split(argumentTypes, "","");
      if (args.length == 0) {
        return invocationMatcher.addWithoutParametersMatcher().build();
      } else {
        String[] trimmedArgs = new String[args.length];
        for (int i = 0; i < trimmedArgs.length; i++) {
          trimmedArgs[i] = StringUtils.trim(args[i]);
        }
        return invocationMatcher.addParametersMatcher(trimmedArgs).build();
      }
    }
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    reportIssue(newClassTree.identifier(), ""Remove this forbidden initialization"");
  }

  public void setClassName(String className) {
    this.className = className;
  }

  public void setArgumentTypes(String argumentTypes) {
    this.argumentTypes = argumentTypes;
  }

  public void setAllOverloads(boolean allOverloads) {
    this.allOverloads = allOverloads;
  }
}
"
S4032,CODE_SMELL,"Packages containing only ""package-info.java"" should be removed","package org.sonar.java.checks;

import java.io.File;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.InputFileScannerContext;
import org.sonar.plugins.java.api.ModuleScannerContext;

@Rule(key = ""S4032"")
public class UselessPackageInfoCheck extends AbstractPackageInfoChecker {

  private final Map<String, InputFileScannerContext> unneededPackageInfoFiles = new HashMap<>();
  private final Set<String> knownPackagesWithOtherFiles = new HashSet<>();

  @Override
  protected void processFile(InputFileScannerContext context, String packageName) {
    if (knownPackagesWithOtherFiles.contains(packageName)) {
      // already processed package
      return;
    }

    File packageDirectory = context.getInputFile().file().getParentFile();
    File packageInfoFile = new File(packageDirectory, ""package-info.java"");
    boolean hasOtherFiles = !isOnlyFileFromPackage(packageDirectory, packageInfoFile);

    if (hasOtherFiles) {
      knownPackagesWithOtherFiles.add(packageName);
    } else if (packageInfoFile.isFile()) {
      unneededPackageInfoFiles.put(packageName, context);
    }
  }

  @Override
  public void endOfAnalysis(ModuleScannerContext context) {
    unneededPackageInfoFiles.keySet().removeAll(knownPackagesWithOtherFiles);
    for (var uselessPackageInfoFileContext : unneededPackageInfoFiles.values()) {
      uselessPackageInfoFileContext.addIssueOnFile(this, ""Remove this package."");
    }
    unneededPackageInfoFiles.clear();
    knownPackagesWithOtherFiles.clear();
  }

  private static boolean isOnlyFileFromPackage(File packageDirectory, File file) {
    File[] filesInPackage = packageDirectory.listFiles(f -> !f.equals(file));
    return filesInPackage != null && filesInPackage.length == 0;
  }
}
"
S4034,CODE_SMELL,"""Stream"" call chains should be simplified when possible","package org.sonar.java.checks;

import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4034"")
public class PreferStreamAnyMatchCheck extends AbstractMethodDetection {

  private static final String[] STREAM_TYPES = {
    ""java.util.stream.Stream"",
    ""java.util.stream.IntStream"",
    ""java.util.stream.LongStream"",
    ""java.util.stream.DoubleStream""
  };

  private static final MethodMatchers FIND_METHODS = MethodMatchers.create()
    .ofTypes(STREAM_TYPES).names(""findFirst"", ""findAny"").addWithoutParametersMatcher().build();

  private static final MethodMatchers MAP_METHODS = MethodMatchers.create()
    .ofTypes(STREAM_TYPES).names(""map"").addParametersMatcher(""java.util.function.Function"").build();

  private static final MethodMatchers FILTER_METHODS = MethodMatchers.create()
    .ofTypes(STREAM_TYPES).names(""filter"").withAnyParameters().build();

  private static final MethodMatchers BOOLEAN_VALUE = MethodMatchers.create()
    .ofTypes(""java.lang.Boolean"")
    .names(""booleanValue"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofTypes(""java.util.Optional"", ""java.util.OptionalInt"", ""java.util.OptionalLong"", ""java.util.OptionalDouble"")
        .names(""isPresent"")
        .addWithoutParametersMatcher()
        .build(),
      MethodMatchers.create()
        .ofTypes(STREAM_TYPES)
        .names(""anyMatch"")
        .addParametersMatcher(""java.util.function.Predicate"")
        .build());
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    String methodName = mit.methodSymbol().name();
    if (""isPresent"".equals(methodName)) {
      handleIsPresent(mit);
    } else if (""anyMatch"".equals(methodName)) {
      handleAnyMatch(mit);
    }
  }

  private void handleAnyMatch(MethodInvocationTree anyMatchMIT) {
    ExpressionTree predicate = anyMatchMIT.arguments().get(0);
    IdentifierTree reportTree = ExpressionUtils.methodName(anyMatchMIT);
    if (anyMatchMIT.parent().is(Tree.Kind.LOGICAL_COMPLEMENT)) {
      if (predicate.is(Tree.Kind.LAMBDA_EXPRESSION) && ((LambdaExpressionTree) predicate).body().is(Tree.Kind.LOGICAL_COMPLEMENT)) {
        // !stream.anyMatch(x -> !(...))
        context.reportIssue(this, reportTree,
          ""Replace this double negation with \""allMatch()\"" and positive predicate."");
      } else {
        context.reportIssue(this, reportTree,
          ""Replace this negation and \""anyMatch()\"" with \""noneMatch()\""."");
      }
    }
    if (predicate.is(Tree.Kind.METHOD_REFERENCE) && isBooleanValueReference((MethodReferenceTree) predicate)) {
      previousMITInChain(anyMatchMIT)
        .filter(MAP_METHODS::matches)
        .ifPresent(mapMIT -> context.reportIssue(this, reportTree,
          ""Use mapper from \""map()\"" directly as predicate in \""anyMatch()\"".""));
    }
  }

  private static boolean isBooleanValueReference(MethodReferenceTree predicate) {
    return BOOLEAN_VALUE.matches(predicate.method().symbol());
  }

  private void handleIsPresent(MethodInvocationTree isPresentMIT) {
    previousMITInChain(isPresentMIT)
      .filter(FIND_METHODS::matches)
      .ifPresent(findMIT ->
        previousMITInChain(findMIT).filter(FILTER_METHODS::matches)
          .ifPresent(filterMIT ->
    context.reportIssue(this, ExpressionUtils.methodName(filterMIT), ExpressionUtils.methodName(isPresentMIT),
      ""Replace this \""filter()."" + ExpressionUtils.methodName(findMIT).name() + ""().isPresent()\"" chain with \""anyMatch()\""."")));
  }

  private static Optional<MethodInvocationTree> previousMITInChain(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree expression = ((MemberSelectExpressionTree) methodSelect).expression();
      if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree previousInvocation = (MethodInvocationTree) expression;
        return Optional.of(previousInvocation);
      }
    }
    return Optional.empty();
  }

}
"
S4036,SECURITY_HOTSPOT,Searching OS commands in PATH is security-sensitive,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.ListTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.checks.helpers.ExpressionsHelper.isNotReassigned;

@Rule(key = ""S4036"")
public class OSCommandsPathCheck extends AbstractMethodDetection {
  private static final String LIST_TYPE = ""java.util.List"";
  private static final String STRING_ARRAY_TYPE = ""java.lang.String[]"";
  private static final String STRING_TYPE = ""java.lang.String"";

  private static final MethodMatchers RUNTIME_EXEC_MATCHER = MethodMatchers.create()
    .ofTypes(""java.lang.Runtime"")
    .names(""exec"")
    .addParametersMatcher(STRING_TYPE)
    .addParametersMatcher(STRING_TYPE, STRING_ARRAY_TYPE)
    .addParametersMatcher(STRING_TYPE, STRING_ARRAY_TYPE, ""java.io.File"")
    .addParametersMatcher(STRING_ARRAY_TYPE)
    .addParametersMatcher(STRING_ARRAY_TYPE, STRING_ARRAY_TYPE)
    .addParametersMatcher(STRING_ARRAY_TYPE, STRING_ARRAY_TYPE, ""java.io.File"")
    .build();

  private static final MethodMatchers PROCESS_BUILDER_MATCHER = MethodMatchers.create()
    .ofTypes(""java.lang.ProcessBuilder"")
    .constructor()
    .withAnyParameters()
    .build();

  private static final MethodMatchers PROCESS_BUILDER_COMMAND_MATCHER = MethodMatchers.create()
    .ofTypes(""java.lang.ProcessBuilder"")
    .names(""command"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers LIST_CREATION_MATCHER = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(""java.util.Arrays"")
      .names(""asList"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofTypes(""java.util.Collections"")
      .names(""singletonList"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofTypes(LIST_TYPE)
      .names(""of"")
      .withAnyParameters()
      .build()
  );

  private static final List<String> STARTS = Arrays.asList(
    ""/"",
    ""./"",
    ""../"",
    ""~/"",
    ""\\"",
    "".\\"",
    ""..\\""
  );

  private static final Pattern WINDOWS_DISK_PATTERN = Pattern.compile(""^[A-Z]:\\\\.*"");

  private static final String MESSAGE = ""Make sure the \""PATH\"" used to find this command includes only what you intend."";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      RUNTIME_EXEC_MATCHER,
      PROCESS_BUILDER_MATCHER,
      PROCESS_BUILDER_COMMAND_MATCHER
    );
  }

  @Override
  protected void onConstructorFound(NewClassTree tree) {
    process(tree.arguments());
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree tree) {
    process(tree.arguments());
  }

  private void process(Arguments arguments) {
    if (arguments.isEmpty()) {
      return;
    }
    ExpressionTree firstArgument = ExpressionUtils.skipParentheses(arguments.get(0));
    processArgument(firstArgument);
  }

  private void processArgument(ExpressionTree argument) {
    switch (argument.kind()) {
      case STRING_LITERAL:
        if (!isStringLiteralCommandValid(argument)) {
          reportIssue(argument, MESSAGE);
        }
        break;
      case NEW_ARRAY:
        if (!isNewArrayCommandValid((NewArrayTree) argument)) {
          reportIssue(argument, MESSAGE);
        }
        break;
      case IDENTIFIER:
        if (!isIdentifierCommandValid((IdentifierTree) argument)) {
          reportIssue(argument, MESSAGE);
        }
        break;
      case METHOD_INVOCATION:
        if (!isListCommandValid((MethodInvocationTree) argument)) {
          reportIssue(argument, MESSAGE);
        }
        break;
      default:
        break;
    }
  }

  private static boolean isCompliant(String command) {
    return STARTS.stream().anyMatch(command::startsWith) ||
      WINDOWS_DISK_PATTERN.matcher(command).matches();
  }

  private static boolean isStringLiteralCommandValid(ExpressionTree expression) {
    Optional<String> command = expression.asConstant(String.class);
    return !command.isPresent() || isCompliant(command.get());
  }
  
  private static boolean isIdentifierCommandValid(IdentifierTree identifier) {
    Symbol symbol = identifier.symbol();
    if (!isNotReassigned(symbol)) {
      return true;
    }
    Type type = symbol.type();
    if (type.is(STRING_TYPE)) {
      return isStringLiteralCommandValid(identifier);
    }
    Optional<ExpressionTree> extraction = extractInitializer(symbol);
    if (extraction.isPresent()) {
      ExpressionTree initializer = extraction.get();
      if (initializer.is(Tree.Kind.NEW_ARRAY)) {
        return isNewArrayCommandValid((NewArrayTree) initializer);
      }
      if (initializer.is(Tree.Kind.METHOD_INVOCATION)) {
        return isListCommandValid((MethodInvocationTree) initializer);
      }
    }
    return true;
  }

  private static Optional<ExpressionTree> extractInitializer(Symbol symbol) {
    Tree declaration = symbol.declaration();
    if (declaration == null || !declaration.is(Tree.Kind.VARIABLE)) {
      return Optional.empty();
    }
    VariableTree variable = (VariableTree) declaration;
    ExpressionTree initializer = variable.initializer();
    if (initializer == null) {
      return Optional.empty();
    }
    return Optional.of(initializer);
  }

  private static boolean isListCommandValid(MethodInvocationTree invocation) {
    Arguments listArguments = invocation.arguments();
    if (!LIST_CREATION_MATCHER.matches(invocation) || listArguments.isEmpty()) {
      return true;
    }
    ExpressionTree firstArgument = ExpressionUtils.skipParentheses(listArguments.get(0));
    if (firstArgument.is(Tree.Kind.STRING_LITERAL)) {
      return isStringLiteralCommandValid(firstArgument);
    }
    if (firstArgument.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) firstArgument;
      return isIdentifierCommandValid(identifier);
    }
    return true;
  }

  private static boolean isNewArrayCommandValid(NewArrayTree newArray) {
    ListTree<ExpressionTree> initializers = newArray.initializers();
    if (initializers.isEmpty()) {
      return true;
    }
    ExpressionTree firstArgument = ExpressionUtils.skipParentheses(initializers.get(0));
    if (firstArgument.is(Tree.Kind.STRING_LITERAL)) {
      return isStringLiteralCommandValid(firstArgument);
    }
    return true;
  }
}
"
S4042,CODE_SMELL,"""java.nio.Files#delete"" should be preferred","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S4042"")
public class NioFileDeleteCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofTypes(""java.io.File"").names(""delete"").addWithoutParametersMatcher().build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Use \""java.nio.file.Files#delete\"" here for better messages on error conditions."");
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava7Compatible();
  }
}
"
S4065,CODE_SMELL,"""ThreadLocal.withInitial"" should be preferred","package org.sonar.java.checks;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4065"")
public class ThreadLocalWithInitialCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final MethodMatchers THREADLOCAL_CONSTRUCTOR = MethodMatchers.create()
    .ofTypes(""java.lang.ThreadLocal"")
    .constructor()
    .addWithoutParametersMatcher()
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return THREADLOCAL_CONSTRUCTOR;
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    ClassTree classTree = newClassTree.classBody();
    if (classTree == null) {
      return;
    }
    List<Tree> members = classTree.members();
    if (members.size() != 1) {
      return;
    }
    members.stream()
      .filter(tree -> tree.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .filter(t -> ""initialValue"".equals(t.simpleName().name()))
      .filter(t -> t.parameters().isEmpty())
      .findFirst().ifPresent(
        t -> reportIssue(newClassTree.identifier(), ""Replace this anonymous class with a call to \""ThreadLocal.withInitial\"".""+context.getJavaVersion().java8CompatibilityMessage())
      );
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava8Compatible();
  }
}
"
S4087,CODE_SMELL,"""close()"" calls should not be redundant","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S4087"")
public class RedundantCloseCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers AUTOCLOSEABLE_CLOSE = MethodMatchers.create()
    .ofSubTypes(""java.lang.AutoCloseable"")
    .names(""close"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRY_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    TryStatementTree tryStatementTree = (TryStatementTree) tree;
    Set<Symbol> resourceSymbols = tryStatementTree.resourceList().stream()
      .map(RedundantCloseCheck::resourceSymbol)
      .filter(s -> !s.isUnknown())
      .collect(Collectors.toSet());
    if (resourceSymbols.isEmpty()) {
      return;
    }
    tryStatementTree.block().accept(new CloseVisitor(resourceSymbols));
  }

  private static Symbol resourceSymbol(Tree resource) {
    // java 7 try-with resource
    if (resource.is(Tree.Kind.VARIABLE)) {
      return ((VariableTree) resource).symbol();
    }
    // java 9 try-with-resource
    if (resource.is(Tree.Kind.IDENTIFIER)) {
      return ((IdentifierTree) resource).symbol();
    }
    return ((MemberSelectExpressionTree) resource).identifier().symbol();
  }

  private class CloseVisitor extends BaseTreeVisitor {

    final Set<Symbol> resourceSymbols;

    public CloseVisitor(Set<Symbol> resourceSymbols) {
      this.resourceSymbols = resourceSymbols;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (!AUTOCLOSEABLE_CLOSE.matches(tree)) {
        return;
      }
      ExpressionTree methodSelect = tree.methodSelect();
      if (!methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
        return;
      }
      MemberSelectExpressionTree mset = (MemberSelectExpressionTree) methodSelect;
      ExpressionTree expression = mset.expression();
      if (!expression.is(Tree.Kind.IDENTIFIER)) {
        return;
      }
      Symbol closedSymbol = ((IdentifierTree) expression).symbol();
      if (resourceSymbols.contains(closedSymbol)) {
        reportIssue(mset.identifier(), tree.arguments().closeParenToken(),
          ""Remove this \""close\"" call; closing the resource is handled automatically by the try-with-resources."");
      }
    }
  }

}
"
S4143,BUG,Map values should not be replaced unconditionally,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ArrayAccessExpressionTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S4143"")
public class OverwrittenKeyCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers MAP_PUT = MethodMatchers.create()
    .ofSubTypes(""java.util.Map"")
    .names(""put"")
    .addParametersMatcher(ANY, ANY)
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.BLOCK);
  }

  @Override
  public void visitNode(Tree tree) {
    Map<CollectionAndKey, List<Tree>> usedKeys = new HashMap<>();
    for (StatementTree statementTree: ((BlockTree) tree).body()){
      CollectionAndKey mapPut = isMapPut(statementTree);
      if (mapPut != null) {
        usedKeys.computeIfAbsent(mapPut, k -> new ArrayList<>()).add(mapPut.keyTree);
      } else {
        CollectionAndKey arrayAssignment = isArrayAssignment(statementTree);
        if (arrayAssignment != null) {
          if (arrayAssignment.collectionOnRHS()) {
            usedKeys.clear();
          }
          usedKeys.computeIfAbsent(arrayAssignment, k -> new ArrayList<>()).add(arrayAssignment.keyTree);
        } else {
          // sequence of setting collection values is interrupted
          reportOverwrittenKeys(usedKeys);
          usedKeys.clear();
        }
      }
    }
    reportOverwrittenKeys(usedKeys);
  }

  private void reportOverwrittenKeys(Map<CollectionAndKey, List<Tree>> usedKeys) {
    usedKeys.forEach( (key, trees) -> {
      if (trees.size() > 1) {
        Tree firstUse = trees.get(0);
        Tree firstOverwrite = trees.get(1);
        List<Tree> rest = trees.subList(2, trees.size());
        reportIssue(firstOverwrite,""Verify this is the "" + key.indexOrKey() + "" that was intended; it was already set before."", secondaryLocations(key, firstUse, rest), 0);
      }
    });
  }

  private static List<JavaFileScannerContext.Location> secondaryLocations(CollectionAndKey key, Tree firstUse, List<Tree> rest) {
    return Stream.concat(
      Stream.of(new JavaFileScannerContext.Location(""Original value"", firstUse)),
      rest.stream().map(t -> new JavaFileScannerContext.Location(""Same "" + key.indexOrKey() + "" is set"", t)))
      .toList();
  }

  private static class CollectionAndKey {
    private final Symbol collection;
    private final Tree keyTree;
    private final Object key;
    private final boolean isArray;
    private ExpressionTree rhs;

    private CollectionAndKey(Symbol collection, Tree keyTree, Object key, boolean isArray, @Nullable ExpressionTree expression) {
      this.collection = collection;
      this.keyTree = keyTree;
      this.key = key;
      this.isArray = isArray;
      this.rhs = expression;
    }

    private boolean collectionOnRHS() {
      FindSymbolUsage findSymbolUsage = new FindSymbolUsage(collection);
      rhs.accept(findSymbolUsage);
      return findSymbolUsage.used;
    }

    private String indexOrKey() {
      return isArray ? ""index"" : ""key"";
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || getClass() != o.getClass()) {
        return false;
      }
      CollectionAndKey that = (CollectionAndKey) o;
      return Objects.equals(collection, that.collection) &&
        Objects.equals(key, that.key);
    }

    @Override
    public int hashCode() {
      return Objects.hash(collection, key);
    }
  }

  @CheckForNull
  private static Symbol symbolFromIdentifier(ExpressionTree collectionExpression) {
    if (collectionExpression.is(Tree.Kind.IDENTIFIER)) {
      Symbol symbol = ((IdentifierTree) collectionExpression).symbol();
      if (!symbol.isUnknown()) {
        return symbol;
      }
    }
    return null;
  }

  @CheckForNull
  private static CollectionAndKey isArrayAssignment(StatementTree statementTree) {
    if (statementTree.is(Tree.Kind.EXPRESSION_STATEMENT)) {
      ExpressionTree expression = ((ExpressionStatementTree) statementTree).expression();
      if (expression.is(Tree.Kind.ASSIGNMENT)) {
        AssignmentExpressionTree assignment = (AssignmentExpressionTree) expression;
        ExpressionTree variable = assignment.variable();
        if (variable.is(Tree.Kind.ARRAY_ACCESS_EXPRESSION)) {
          ArrayAccessExpressionTree aaet = (ArrayAccessExpressionTree) variable;
          Symbol collection = symbolFromIdentifier(aaet.expression());
          ExpressionTree keyTree = aaet.dimension().expression();
          Object key = extractKey(keyTree);
          if (collection != null && key != null) {
            return new CollectionAndKey(collection, keyTree, key, true, assignment.expression());
          }
        }
      }
    }
    return null;
  }

  private static class FindSymbolUsage extends BaseTreeVisitor {

    private final Symbol symbol;
    private boolean used;

    public FindSymbolUsage(Symbol symbol) {
      this.symbol = symbol;
    }

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      if (!used) {
        used = tree.symbol() == symbol;
      }
    }
  }


  @CheckForNull
  private static CollectionAndKey isMapPut(StatementTree statementTree) {
    if (statementTree.is(Tree.Kind.EXPRESSION_STATEMENT)) {
      ExpressionTree expression = ((ExpressionStatementTree) statementTree).expression();
      if (expression.is(Tree.Kind.METHOD_INVOCATION) && MAP_PUT.matches((MethodInvocationTree) expression)) {
        MethodInvocationTree mapPut = (MethodInvocationTree) expression;
        Symbol collection = mapPut.methodSelect().is(Tree.Kind.MEMBER_SELECT) ? symbolFromIdentifier(((MemberSelectExpressionTree) mapPut.methodSelect()).expression()) : null;
        ExpressionTree keyTree = mapPut.arguments().get(0);
        Object key = extractKey(keyTree);
        if (collection != null && key != null) {
          return new CollectionAndKey(collection, keyTree, key, false, null);
        }
      }
    }
    return null;
  }


  @CheckForNull
  private static Object extractKey(ExpressionTree keyArgument) {
    if (keyArgument instanceof LiteralTree literalTree) {
      return literalTree.value();
    }
    return symbolFromIdentifier(keyArgument);
  }
}
"
S4144,CODE_SMELL,Methods should not have identical implementations,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.ast.visitors.AccessorsUtils;
import org.sonar.java.model.LineUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

@Rule(key = ""S4144"")
public class MethodIdenticalImplementationsCheck extends IssuableSubscriptionVisitor {

  private static final String ISSUE_MSG = ""Update this method so that its implementation is not identical to \""%s\"" on line %d."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    List<MethodWithUsedVariables> methods = classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .filter(methodTree -> isDuplicateCandidate(methodTree, classTree))
      .map(MethodWithUsedVariables::new)
      .toList();
    if (methods.size() <= 1) {
      return;
    }
    Set<MethodTree> reported = new HashSet<>();
    for (int i = 0; i < methods.size(); i++) {
      MethodWithUsedVariables methodWithVariables = methods.get(i);
      MethodTree method = methodWithVariables.method;
      SyntaxToken methodIdentifier = method.simpleName().identifierToken();
      List<StatementTree> methodBody = method.block().body();
      methods.stream()
        .skip(i + 1L)
        // avoid reporting multiple times
        .filter(otherMethodWithVariables -> !reported.contains(otherMethodWithVariables.method))
        // skip overloads
        .filter(otherMethodWithVariables -> !methodIdentifier.text().equals(otherMethodWithVariables.method.simpleName().name()))
        // only consider method syntactically equivalent
        .filter(otherMethodWithVariables -> SyntacticEquivalence.areEquivalent(methodBody, otherMethodWithVariables.method.block().body()))
        // only consider method having same types for their variables
        .filter(methodWithVariables::isUsingSameVariablesWithSameTypes)
        .forEach(otherMethodWithVariables -> {
          MethodTree otherMethod = otherMethodWithVariables.method;
          reportIssue(
            otherMethod.simpleName(),
            String.format(ISSUE_MSG, methodIdentifier.text(), LineUtils.startLine(methodIdentifier)),
            Collections.singletonList(new JavaFileScannerContext.Location(""original implementation"", methodIdentifier)),
            null);
          reported.add(otherMethod);
        });
    }
  }

  private static boolean isDuplicateCandidate(MethodTree methodTree, ClassTree classTree) {
    BlockTree block = methodTree.block();
    return AccessorsUtils.isAccessor(classTree, methodTree)
      || (block != null && block.body().size() >= 2);
  }

  private static class MethodWithUsedVariables extends BaseTreeVisitor {
    private final MethodTree method;
    private final Map<String, Type> usedVariablesByNameAndType = new HashMap<>();
    private boolean hasUnknownVariableType = false;

    public MethodWithUsedVariables(MethodTree method) {
      this.method = method;
      method.accept(this);
    }

    public boolean isUsingSameVariablesWithSameTypes(MethodWithUsedVariables otherMethod) {
      return !hasUnknownVariableType
        && !otherMethod.hasUnknownVariableType
        && usedVariablesByNameAndType.equals(otherMethod.usedVariablesByNameAndType);
    }

    @Override
    public void visitIdentifier(IdentifierTree tree) {
      Symbol symbol = tree.symbol();
      Type type = symbol.type();
      if (symbol.isVariableSymbol()) {
        if (type.isUnknown()) {
          hasUnknownVariableType = true;
        } else {
          usedVariablesByNameAndType.putIfAbsent(tree.name(), type);
        }
      }
      super.visitIdentifier(tree);
    }

  }
}
"
S4174,CODE_SMELL,Local constants should follow naming conventions for constants,"package org.sonar.java.checks.naming;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import javax.annotation.Nullable;

import java.util.Collections;
import java.util.List;
import java.util.regex.Pattern;

@Rule(key = ""S4174"")
public class BadLocalConstantNameCheck extends IssuableSubscriptionVisitor {

  private static final String DEFAULT_FORMAT = ""^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"";
  @RuleProperty(
    key = ""format"",
    description = ""Regular expression used to check the constant names against."",
    defaultValue = """" + DEFAULT_FORMAT)
  public String format = DEFAULT_FORMAT;

  private Pattern pattern = null;

  @Override
  public void setContext(JavaFileScannerContext context) {
    if (pattern == null) {
      pattern = Pattern.compile(format, Pattern.DOTALL);
    }
    super.setContext(context);
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.VARIABLE);
  }

  @Override
  public void visitNode(Tree tree) {
    VariableTree variableTree = (VariableTree) tree;
    Symbol symbol = variableTree.symbol();
    if (!symbol.owner().isMethodSymbol() || !symbol.isFinal()) {
      return;
    }
    if (!hasLiteralInitializer(variableTree.initializer())) {
      return;
    }
    IdentifierTree simpleName = variableTree.simpleName();
    if (!pattern.matcher(simpleName.name()).matches()) {
      reportIssue(simpleName, ""Rename this constant name to match the regular expression '"" + format + ""'."");
    }
  }

  private static boolean hasLiteralInitializer(@Nullable ExpressionTree initializer) {
    return initializer != null && ExpressionUtils.skipParentheses(initializer).is(
      Tree.Kind.BOOLEAN_LITERAL,
      Tree.Kind.CHAR_LITERAL,
      Tree.Kind.DOUBLE_LITERAL,
      Tree.Kind.FLOAT_LITERAL,
      Tree.Kind.INT_LITERAL,
      Tree.Kind.LONG_LITERAL,
      Tree.Kind.NULL_LITERAL,
      Tree.Kind.STRING_LITERAL);
  }
}
"
S4201,CODE_SMELL,"Null checks should not be used with ""instanceof""","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.InstanceOfTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

@Rule(key = ""S4201"")
public class NullCheckWithInstanceofCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CONDITIONAL_AND, Tree.Kind.CONDITIONAL_OR);
  }

  @Override
  public void visitNode(Tree tree) {
    BinaryExpressionTree binaryExpression = (BinaryExpressionTree) tree;
    ExpressionTree leftOp = ExpressionUtils.skipParentheses(binaryExpression.leftOperand());
    ExpressionTree rightOp = ExpressionUtils.skipParentheses(binaryExpression.rightOperand());
    if ((is(Tree.Kind.EQUAL_TO, leftOp, rightOp) && nullCheckWithInstanceOf(leftOp, rightOp, binaryExpression.kind(), Tree.Kind.CONDITIONAL_OR)) ||
      (is(Tree.Kind.NOT_EQUAL_TO, leftOp, rightOp) && nullCheckWithInstanceOf(leftOp, rightOp, binaryExpression.kind(), Tree.Kind.CONDITIONAL_AND))) {
      reportIssue(treeToReport(leftOp, rightOp), ""Remove this unnecessary null check; \""instanceof\"" returns false for nulls."");
    }
  }

  private static boolean nullCheckWithInstanceOf(ExpressionTree leftOp, ExpressionTree rightOp, Tree.Kind binaryExpressionKind, Tree.Kind expectedKind) {
    ExpressionTree binaryVariable = Optional.ofNullable(binaryExpressionVariable(leftOp))
      .orElse(binaryExpressionVariable(rightOp));
    if (binaryVariable == null || binaryExpressionKind != expectedKind) {
      return false;
    }
    ExpressionTree instanceofVariable = Optional.ofNullable(instanceofFound(rightOp, binaryExpressionKind))
      .orElse(instanceofFound(leftOp, binaryExpressionKind));
    return instanceofVariable != null && SyntacticEquivalence.areEquivalent(binaryVariable, instanceofVariable);
  }

  private static ExpressionTree treeToReport(ExpressionTree left, ExpressionTree right) {
    return left.is(Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO) ? left : right;
  }

  @CheckForNull
  private static ExpressionTree binaryExpressionVariable(ExpressionTree expression) {
    BinaryExpressionTree binaryExpression = null;
    if (expression.is(Tree.Kind.NOT_EQUAL_TO, Tree.Kind.EQUAL_TO)) {
      binaryExpression = (BinaryExpressionTree) expression;
      if (binaryExpression.leftOperand().is(Tree.Kind.NULL_LITERAL)) {
        return binaryExpression.rightOperand();
      }
      if (binaryExpression.rightOperand().is(Tree.Kind.NULL_LITERAL)) {
        return binaryExpression.leftOperand();
      }
    }
    return null;
  }

  @CheckForNull
  private static ExpressionTree instanceofFound(ExpressionTree expressionTree, Tree.Kind kind) {
    if (kind != Tree.Kind.CONDITIONAL_OR) {
      return instanceofLHS(expressionTree);
    }if (expressionTree.is(Tree.Kind.LOGICAL_COMPLEMENT)) {
      return instanceofLHS(ExpressionUtils.skipParentheses(((UnaryExpressionTree) expressionTree).expression()));
    } else {
      return null;
    }
  }

  @CheckForNull
  private static ExpressionTree instanceofLHS(ExpressionTree expressionTree) {
    if (expressionTree.is(Tree.Kind.INSTANCE_OF)) {
      return ((InstanceOfTree) expressionTree).expression();
    }
    return null;
  }

  private static boolean is(Tree.Kind kind, Tree... trees) {
    return Arrays.stream(trees).anyMatch(tree -> tree.is(kind));
  }
}
"
S4248,CODE_SMELL,Regex patterns should not be created needlessly,"package org.sonar.java.checks;

import java.util.Optional;
import org.apache.commons.lang3.StringEscapeUtils;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S4248"")
public class RegexPatternsNeedlesslyCheck extends AbstractMethodDetection {

  private static final String STRING = ""java.lang.String"";
  private static final String PATTERN = ""java.util.regex.Pattern"";
  private static final MethodMatchers SPLIT_MATCHER = MethodMatchers.create()
    .ofTypes(STRING).names(""split"").withAnyParameters().build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofTypes(PATTERN).names(""compile"").addParametersMatcher(STRING).build(),
      SPLIT_MATCHER,
      MethodMatchers.create().ofTypes(STRING).names(""matches"", ""replaceAll"", ""replaceFirst"").withAnyParameters().build());
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree firstArgument = ExpressionUtils.skipParentheses(mit.arguments().get(0));
    if (SPLIT_MATCHER.matches(mit)) {
      Optional<String> constantValue = firstArgument.asConstant(String.class);
      if (constantValue.filter(RegexPatternsNeedlesslyCheck::exceptionSplitMethod).isPresent()) {
        return;
      }
    }
    if (!storedInStaticFinal(mit) && (firstArgument.is(Tree.Kind.STRING_LITERAL) || isConstant(firstArgument))) {
      reportIssue(ExpressionUtils.methodName(mit), mit.arguments(), ""Refactor this code to use a \""static final\"" Pattern."");
    }
  }

  private static boolean storedInStaticFinal(MethodInvocationTree mit) {
    Tree tree = mit.parent();
    while (!tree.is(Kind.VARIABLE, Kind.ASSIGNMENT, Kind.COMPILATION_UNIT)) {
      tree = tree.parent();
    }
    return isConstant(tree);
  }

  private static boolean isConstant(Tree tree) {
    Symbol symbol = null;
    switch (tree.kind()) {
      case IDENTIFIER:
        symbol = ((IdentifierTree) tree).symbol();
        break;
      case MEMBER_SELECT:
        symbol = (((MemberSelectExpressionTree) tree).identifier()).symbol();
        break;
      case VARIABLE:
        symbol = ((VariableTree) tree).symbol();
        break;
      case ASSIGNMENT:
        return isConstant(((AssignmentExpressionTree) tree).variable());
      default:
        break;
    }
    return symbol != null && symbol.isFinal() && symbol.isStatic();
  }private static boolean exceptionSplitMethod(String argValue) {
    String regex = StringEscapeUtils.unescapeJava(argValue);
    char ch;
    return ((regex.length() == 1 && "".$|()[{^?*+\\"".indexOf(ch = regex.charAt(0)) == -1) ||
      (regex.length() == 2 &&
        regex.charAt(0) == '\\' &&
        (((ch = regex.charAt(1)) - '0') | ('9' - ch)) < 0 &&
        ((ch - 'a') | ('z' - ch)) < 0 &&
        ((ch - 'A') | ('Z' - ch)) < 0)) &&
      (ch < Character.MIN_HIGH_SURROGATE || ch > Character.MAX_LOW_SURROGATE);
  }

}
"
S4266,CODE_SMELL,"""Stream.collect()"" calls should not be redundant","package org.sonar.java.checks;

import java.util.Map;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4266"")
public class RedundantStreamCollectCheck extends AbstractMethodDetection {

  private static final String[] STREAM_TYPES = {
    ""java.util.stream.Stream"",
    ""java.util.stream.IntStream"",
    ""java.util.stream.LongStream"",
    ""java.util.stream.DoubleStream""
  };

  private static final MethodMatchers COUNTING = streamCollectorsMatcher().names(""counting"").addWithoutParametersMatcher().build();
  private static final MethodMatchers MAX_BY = streamCollectorsMatcher().names(""maxBy"").withAnyParameters().build();
  private static final MethodMatchers MIN_BY = streamCollectorsMatcher().names(""minBy"").withAnyParameters().build();
  private static final MethodMatchers MAPPING = streamCollectorsMatcher().names(""mapping"").withAnyParameters().build();
  private static final MethodMatchers REDUCING = streamCollectorsMatcher().names(""reducing"").withAnyParameters().build();
  private static final MethodMatchers SUMMING_INT = streamCollectorsMatcher().names(""summingInt"").withAnyParameters().build();
  private static final MethodMatchers SUMMING_LONG = streamCollectorsMatcher().names(""summingLong"").withAnyParameters().build();
  private static final MethodMatchers SUMMING_DOUBLE = streamCollectorsMatcher().names(""summingDouble"").withAnyParameters().build();

  private static MethodMatchers.NameBuilder streamCollectorsMatcher() {
    return MethodMatchers.create().ofTypes(""java.util.stream.Collectors"");
  }

  private static final Map<MethodMatchers, String> REPLACEMENTS = MapBuilder.<MethodMatchers, String>newMap()
    .put(COUNTING, ""count()"")
    .put(MAX_BY, ""max()"")
    .put(MIN_BY, ""min()"")
    .put(MAPPING, ""map(...).collect()"")
    .put(REDUCING, ""reduce(...).collect()"")
    .put(SUMMING_INT, ""mapToInt(...).sum()"")
    .put(SUMMING_LONG, ""mapToLong(...).sum()"")
    .put(SUMMING_DOUBLE, ""mapToDouble(...).sum()"")
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(STREAM_TYPES).names(""collect"")
      .addParametersMatcher(""java.util.stream.Collector"")
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree collectMIT) {
    ExpressionTree argument = collectMIT.arguments().get(0);
    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree methodInvocation = (MethodInvocationTree) argument;
      REPLACEMENTS.entrySet().stream()
        .filter(e -> e.getKey().matches(methodInvocation))
        .findFirst()
        .ifPresent(e -> context.reportIssue(this, ExpressionUtils.methodName(methodInvocation),
            ""Use \"""" + e.getValue() + ""\"" instead.""));
    }
  }
}
"
S4274,CODE_SMELL,Asserts should not be used to check the parameters of a public method,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssertStatementTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S4274"")
public class AssertsOnParametersOfPublicMethodCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  private final Set<AssertStatementTree> assertReported = new HashSet<>();

  @Override
  public void setContext(JavaFileScannerContext context) {
    assertReported.clear();
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (!methodTree.symbol().isPublic()) {
      return;
    }
    methodTree.parameters().stream()
      .map(VariableTree::symbol)
      .map(Symbol::usages)
      .flatMap(List::stream)
      .forEach(parameter -> checkUsage(parameter, methodTree));
  }

  private void checkUsage(IdentifierTree parameterUsage, MethodTree methodTree) {
    Tree parameterParent = parameterUsage.parent();
    while (!parameterParent.equals(methodTree) && !assertReported.contains(parameterParent)) {
      if (parameterParent.is(Tree.Kind.ASSERT_STATEMENT)) {
        assertReported.add((AssertStatementTree) parameterParent);
        reportIssue(parameterParent, ""Replace this assert with a proper check."");
        return;
      }
      parameterParent = parameterParent.parent();
    }
  }
}
"
S4275,BUG,Getters and setters should access the expected fields,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4275"")
public class GettersSettersOnRightFieldCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    isGetterLike(methodTree.symbol()).ifPresent(fieldName -> checkGetter(fieldName, methodTree));
    isSetterLike(methodTree.symbol()).ifPresent(fieldName -> checkSetter(fieldName, methodTree));
  }

  private static Optional<String> isGetterLike(Symbol.MethodSymbol methodSymbol) {
    if (!methodSymbol.parameterTypes().isEmpty() || isPrivateStaticOrAbstract(methodSymbol)) {
      return Optional.empty();
    }
    String methodName = methodSymbol.name();
    if (methodName.length() > 3 && methodName.startsWith(""get"")) {
      return Optional.of(lowerCaseFirstLetter(methodName.substring(3)));
    }
    if (methodName.length() > 2 && methodName.startsWith(""is"")) {
      return Optional.of(lowerCaseFirstLetter(methodName.substring(2)));
    }
    return Optional.empty();
  }

  private static Optional<String> isSetterLike(Symbol.MethodSymbol methodSymbol) {
    if (methodSymbol.parameterTypes().size() != 1 || isPrivateStaticOrAbstract(methodSymbol)) {
      return Optional.empty();
    }
    String methodName = methodSymbol.name();
    if (methodName.length() > 3 && methodName.startsWith(""set"") && methodSymbol.returnType().type().isVoid()) {
      return Optional.of(lowerCaseFirstLetter(methodName.substring(3)));
    }
    return Optional.empty();
  }

  private static boolean isPrivateStaticOrAbstract(Symbol.MethodSymbol methodSymbol) {
    return methodSymbol.isPrivate() || methodSymbol.isStatic() || methodSymbol.isAbstract();
  }

  private static String lowerCaseFirstLetter(String methodName) {
    return Character.toLowerCase(methodName.charAt(0)) + methodName.substring(1);
  }

  private void checkGetter(String fieldName, MethodTree methodTree) {
    Symbol.TypeSymbol getterOwner = ((Symbol.TypeSymbol) methodTree.symbol().owner());
    if (hasNoPrivateFieldMatchingNameAndType(fieldName, methodTree.symbol().returnType().type(), getterOwner)) {
      return;
    }
    firstAndOnlyStatement(methodTree)
      .filter(statementTree -> statementTree.is(Tree.Kind.RETURN_STATEMENT))
      .map(statementTree -> ((ReturnStatementTree) statementTree).expression())
      .flatMap(GettersSettersOnRightFieldCheck::symbolFromExpression)
      .filter(returnSymbol -> !fieldName.equals(returnSymbol.name()))
      .ifPresent(returnedSymbol -> context.reportIssue(this, methodTree.simpleName(),
        ""Refactor this getter so that it actually refers to the field \"""" + fieldName + ""\"".""));
  }

  private void checkSetter(String fieldName, MethodTree methodTree) {
    Symbol.TypeSymbol setterOwner = ((Symbol.TypeSymbol) methodTree.symbol().owner());
    if (hasNoPrivateFieldMatchingNameAndType(fieldName, methodTree.symbol().parameterTypes().get(0), setterOwner)) {
      return;
    }
    firstAndOnlyStatement(methodTree)
      .filter(statementTree -> statementTree.is(Tree.Kind.EXPRESSION_STATEMENT))
      .map(statementTree -> ((ExpressionStatementTree) statementTree).expression())
      .filter(expressionTree -> expressionTree.is(Tree.Kind.ASSIGNMENT))
      .map(expressionTree -> ((AssignmentExpressionTree) expressionTree).variable())
      .flatMap(GettersSettersOnRightFieldCheck::symbolFromExpression)
      .filter(variableSymbol -> !fieldName.equals(variableSymbol.name()))
      .ifPresent(variableSymbol -> context.reportIssue(this, methodTree.simpleName(),
        ""Refactor this setter so that it actually refers to the field \"""" + fieldName + ""\"".""));
  }

  private static boolean hasNoPrivateFieldMatchingNameAndType(String fieldName, Type fieldType, Symbol.TypeSymbol accessorOwner) {
    return accessorOwner.lookupSymbols(fieldName).stream()
      .filter(Symbol::isVariableSymbol)
      .filter(Symbol::isPrivate)
      .filter(symbol -> symbol.type().equals(fieldType) || symbol.type().isSubtypeOf(fieldType))
      .noneMatch(symbol -> fieldName.equals(symbol.name()));
  }

  private static Optional<Symbol> symbolFromExpression(ExpressionTree returnExpression) {
    if (returnExpression.is(Tree.Kind.IDENTIFIER)) {
      return Optional.of(((IdentifierTree) returnExpression).symbol());
    }
    if (returnExpression.is(Tree.Kind.MEMBER_SELECT)) {
      return Optional.of(((MemberSelectExpressionTree) returnExpression).identifier().symbol());
    }
    return Optional.empty();
  }

  private static Optional<StatementTree> firstAndOnlyStatement(MethodTree methodTree) {
    return Optional.ofNullable(methodTree.block())
      .filter(b -> b.body().size() == 1)
      .map(b -> b.body().get(0));
  }
}
"
S4276,CODE_SMELL,Functional Interfaces should be as specialised as possible,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S4276"")
public class SpecializedFunctionalInterfacesCheck extends IssuableSubscriptionVisitor {

  private static final String AND_THEN = ""andThen"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.VARIABLE);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.CLASS)) {
      checkClassInterfaces(((ClassTree) tree));
    } else {
      checkVariableTypeAndInitializer((VariableTree) tree);
    }
  }

  private void checkClassInterfaces(ClassTree tree) {
    List<InterfaceTreeAndStringPairReport> reportTreeAndStringInterfaces = tree.superInterfaces().stream()
      .map(typeTree -> matchFunctionalInterface(typeTree.symbolType(), Collections.emptyList())
      .map(rs -> new InterfaceTreeAndStringPairReport(rs, typeTree)).orElse(null))
      .filter(Objects::nonNull)
      .toList();
    if (reportTreeAndStringInterfaces.isEmpty()) {
      return;
    }
    List<JavaFileScannerContext.Location> secondaryLocations = reportTreeAndStringInterfaces.stream()
      .map(interf -> new JavaFileScannerContext.Location(""Replace this interface."", interf.classInterface))
      .toList();
    reportIssue(tree.simpleName(), reportMessage(reportTreeAndStringInterfaces), secondaryLocations, null);
  }

  private void checkVariableTypeAndInitializer(VariableTree variableTree) {
    ExpressionTree initializer = variableTree.initializer();
    if ((variableTree.symbol().owner().isMethodSymbol() && !variableTree.parent().is(Tree.Kind.LAMBDA_EXPRESSION))
      || (initializer != null && (initializer.is(Tree.Kind.LAMBDA_EXPRESSION) || isAnonymousClass(initializer)))) {
      matchFunctionalInterface(variableTree.symbol().type(), variableTree.symbol().usages()).ifPresent(reportString -> {
        TypeTree variableType = variableTree.type();
        reportIssue(variableType, reportMessage(new InterfaceTreeAndStringPairReport(reportString, variableType)));
      });
    }
  }

  private static String reportMessage(InterfaceTreeAndStringPairReport onlyOneInterface) {
    return reportMessage(Collections.singletonList(onlyOneInterface));
  }

  private static String reportMessage(List<InterfaceTreeAndStringPairReport> interfacesToBeReported) {
    String functionalInterfaces = interfacesToBeReported.stream().map(x -> x.reportString)
      .collect(Collectors.joining(""', '"", (interfacesToBeReported.size() > 1 ? ""s '"" : "" '""), ""'""));
    return String.format(""Refactor this code to use the more specialised Functional Interface%s"", functionalInterfaces);
  }

  private static boolean isAnonymousClass(ExpressionTree initializeTree) {
    return initializeTree.is(Tree.Kind.NEW_CLASS) && ((NewClassTree) initializeTree).classBody() != null;
  }

  private static Optional<String> matchFunctionalInterface(Type type, List<IdentifierTree> usages) {
    if (type.isUnknown() || !type.isParameterized()) {
      return Optional.empty();
    }
    switch (type.fullyQualifiedName()) {
      case ""java.util.function.Function"":
        return handleFunctionInterface(type, usages);
      case ""java.util.function.BiFunction"":
        return handleBiFunctionInterface(type, usages);
      case ""java.util.function.BiConsumer"":
        return handleBiConsumerInterface(type, usages);
      case ""java.util.function.Supplier"":
        return handleSupplier(type, usages);
      case ""java.util.function.Consumer"":
      case ""java.util.function.Predicate"":
      case ""java.util.function.UnaryOperator"":
      case ""java.util.function.BinaryOperator"":
        return handleSingleParameterFunctions(type, usages);
      default:
        return Optional.empty();
    }
  }

  private static Optional<String> handleSingleParameterFunctions(Type parametrizedType, List<IdentifierTree> usages) {
    if (isReferenced(usages)) {
      return Optional.empty();
    }
    return Optional.ofNullable(new ParameterTypeNameAndTreeType(parametrizedType, 0).paramTypeName)
      .map(s -> s + parametrizedType.name());
  }

  private static Optional<String> handleFunctionInterface(Type parametrizedType,
                                                          List<IdentifierTree> usages) {
    ParameterTypeNameAndTreeType firstArgument = new ParameterTypeNameAndTreeType(parametrizedType, 0);
    ParameterTypeNameAndTreeType secondArgument = new ParameterTypeNameAndTreeType(parametrizedType, 1);
    boolean usedAsMethodReference = isReferenced(usages);
    if (typeEquals(firstArgument.paramType, secondArgument.paramType)) {
      if (firstArgument.paramTypeName != null && !usedAsMethodReference) {
        return functionalInterfaceName(""%sUnaryOperator"", firstArgument.paramTypeName);
      }
      return functionalInterfaceName(""UnaryOperator<%s>"", firstArgument.paramType);
    }
    if (usesMethods(usages, Arrays.asList(""compose"", AND_THEN))) {
      return Optional.empty();
    }
    if (isBoolean(secondArgument) && !usedAsMethodReference) {
      return functionalInterfaceName(""Predicate<%s>"", firstArgument.paramType);
    }
    if (isBoolean(firstArgument)) {
      return Optional.empty();
    }
    if (firstArgument.paramTypeName != null && secondArgument.paramTypeName != null && !usedAsMethodReference) {
      return functionalInterfaceName(""%sTo%sFunction"", firstArgument.paramTypeName, secondArgument.paramTypeName);
    }
    if (secondArgument.paramTypeName != null && !usedAsMethodReference) {
      return functionalInterfaceName(""To%sFunction<%s>"", secondArgument.paramTypeName, firstArgument.paramType);
    }
    if (firstArgument.paramTypeName != null && !usedAsMethodReference) {
      return functionalInterfaceName(""%sFunction<%s>"", firstArgument.paramTypeName, secondArgument.paramType);
    }
    return Optional.empty();
  }

  private static boolean usesMethods(List<IdentifierTree> usages, List<String> methods) {
    return usages.stream()
      .map(IdentifierTree::parent)
      .filter(MemberSelectExpressionTree.class::isInstance)
      .map(MemberSelectExpressionTree.class::cast)
      .map(MemberSelectExpressionTree::identifier)
      .map(IdentifierTree::name)
      .anyMatch(methods::contains);
  }

  private static Optional<String> handleBiFunctionInterface(Type parametrizedType, List<IdentifierTree> usages) {
    ParameterTypeNameAndTreeType firstArgument = new ParameterTypeNameAndTreeType(parametrizedType, 0);
    ParameterTypeNameAndTreeType secondArgument = new ParameterTypeNameAndTreeType(parametrizedType, 1);
    ParameterTypeNameAndTreeType thirdArgument = new ParameterTypeNameAndTreeType(parametrizedType, 2);
    if (typeEquals(firstArgument.paramType, secondArgument.paramType) && typeEquals(firstArgument.paramType, thirdArgument.paramType)) {
      return functionalInterfaceName(""BinaryOperator<%s>"", firstArgument.paramType);
    }
    if (usesMethods(usages, Collections.singletonList(AND_THEN))) {
      return Optional.empty();
    }
    if (isBoolean(thirdArgument)) {
      return functionalInterfaceName(""BiPredicate<%s, %s>"", firstArgument.paramType, secondArgument.paramType);
    }
    return Optional.empty();
  }

  private static Optional<String> functionalInterfaceName(String pattern, Object... args) {
    return Optional.of(String.format(pattern, args));
  }

  private static Optional<String> handleBiConsumerInterface(Type parametrizedType, List<IdentifierTree> usages) {
    if (isReferenced(usages) || usesMethods(usages, Collections.singletonList(AND_THEN))) {
      return Optional.empty();
    }

    ParameterTypeNameAndTreeType firstArgument = new ParameterTypeNameAndTreeType(parametrizedType, 0);
    ParameterTypeNameAndTreeType secondArgument = new ParameterTypeNameAndTreeType(parametrizedType, 1);
    if (secondArgument.paramTypeName != null && !firstArgument.paramType.isPrimitiveWrapper()) {
      return Optional.of(String.format(""Obj%sConsumer<%s>"", secondArgument.paramTypeName, firstArgument.paramType));
    }
    return Optional.empty();
  }

  private static Optional<String> handleSupplier(Type parametrizedType, List<IdentifierTree> usages) {
    if (isReferenced(usages)) {
      return Optional.empty();
    }
    ParameterTypeNameAndTreeType supplierParamType = new ParameterTypeNameAndTreeType(parametrizedType, 0);
    if (isBoolean(supplierParamType)) {
      return Optional.of(""BooleanSupplier"");
    }
    return Optional.ofNullable(supplierParamType.paramTypeName).map(s -> s + ""Supplier"");
  }

  private static class InterfaceTreeAndStringPairReport {
    final String reportString;
    final TypeTree classInterface;

    InterfaceTreeAndStringPairReport(String report, TypeTree interf) {
      reportString = report;
      classInterface = interf;
    }
  }

  private static boolean isBoolean(ParameterTypeNameAndTreeType type) {
    return type.paramType.is(""java.lang.Boolean"");
  }

  private static class ParameterTypeNameAndTreeType {

    final Type paramType;

    @Nullable
    final String paramTypeName;

    ParameterTypeNameAndTreeType(Type parametrizedType, int typeArgumentIndex) {
      paramType = parametrizedType.typeArguments().get(typeArgumentIndex);
      paramTypeName = returnStringFromJavaObject(paramType);
    }

    @CheckForNull
    private static String returnStringFromJavaObject(Type argType) {
      if (argType.is(""java.lang.Integer"")) {
        return ""Int"";
      }
      if (argType.is(""java.lang.Double"") || argType.is(""java.lang.Long"")) {
        return argType.name();
      }
      return null;
    }
  }

  private static boolean isReferenced(List<IdentifierTree> usages) {
    return usages.stream()
      .map(Tree::parent)
      .anyMatch(parent -> parent.is(Tree.Kind.ARGUMENTS, Tree.Kind.ASSIGNMENT, Tree.Kind.VARIABLE));
  }

  private static boolean typeEquals(Type type1, Type type2) {
    return !type1.name().startsWith(""?"") && type1.equals(type2);
  }

}
"
S4288,CODE_SMELL,Spring components should use constructor injection,"package org.sonar.java.checks.spring;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S4288"")
public class SpringConstructorInjectionCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (isClassTreeAnnotatedWith(classTree,
      ""org.springframework.stereotype.Controller"",
      ""org.springframework.stereotype.Repository"",
      ""org.springframework.stereotype.Service"")) {
      List<Tree> toReport = classTree.members()
        .stream()
        .filter(SpringConstructorInjectionCheck::isMemberAutowired)
        .map(SpringConstructorInjectionCheck::toReportTree)
        .toList();

      if (!toReport.isEmpty()) {
        int cost = toReport.size();
        List<JavaFileScannerContext.Location> secondaries = new ArrayList<>();

        // find constructor
        classTree.members().stream()
          .filter(m -> m.is(Tree.Kind.CONSTRUCTOR))
          .map(m -> ((MethodTree) m).simpleName())
          .findFirst()
          .map(id -> new JavaFileScannerContext.Location(""Constructor where you can inject these fields."", id))
          .ifPresent(secondaries::add);

        toReport.stream().skip(1).map(i -> new JavaFileScannerContext.Location(""Also remove this annotation."", i)).forEach(secondaries::add);

        reportIssue(toReport.get(0), ""Remove this annotation and use constructor injection instead."", secondaries, cost);
      }
    }
  }

  private static boolean isMemberAutowired(Tree member) {
    Symbol s = null;
    if (member.is(Tree.Kind.VARIABLE)) {
      s = ((VariableTree) member).symbol();
    } else if (member.is(Tree.Kind.METHOD)) {
      s = ((MethodTree) member).symbol();
    }
    return s != null && !s.isStatic() && isAutowired(s);
  }

  private static boolean isAutowired(Symbol s) {
    return s.metadata().isAnnotatedWith(""org.springframework.beans.factory.annotation.Autowired"");
  }

  private static Tree toReportTree(Tree member) {
    Stream<AnnotationTree> stream = Stream.empty();
    if (member.is(Tree.Kind.VARIABLE)) {
      stream = ((VariableTree) member).modifiers().annotations().stream();
    } else if (member.is(Tree.Kind.METHOD)) {
      stream = ((MethodTree) member).modifiers().annotations().stream();
    }
    return stream
      .filter(a -> a.annotationType().symbolType().is(""org.springframework.beans.factory.annotation.Autowired""))
      .findFirst()
      .orElseThrow(() -> new IllegalStateException(""Mapping a tree to something unexpected""));
  }

  private static boolean isClassTreeAnnotatedWith(ClassTree classTree, String... annotationName) {
    return Arrays.stream(annotationName).anyMatch(annotation -> classTree.symbol().metadata().isAnnotatedWith(annotation));
  }
}
"
S4347,VULNERABILITY,Secure random number generators should not output predictable values,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4347"")
public class PredictableSeedCheck extends AbstractMethodDetection {
  private static final Tree.Kind[] LITERAL_KINDS = {Tree.Kind.STRING_LITERAL, Tree.Kind.INT_LITERAL, Tree.Kind.LONG_LITERAL, Tree.Kind.CHAR_LITERAL,
    Tree.Kind.NULL_LITERAL, Tree.Kind.BOOLEAN_LITERAL, Tree.Kind.DOUBLE_LITERAL, Tree.Kind.FLOAT_LITERAL};
  private static final String JAVA_SECURITY_SECURE_RANDOM = ""java.security.SecureRandom"";
  private static final MethodMatchers GET_BYTES = MethodMatchers.create()
    .ofTypes(""java.lang.String"")
    .names(""getBytes"")
    .withAnyParameters()
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofTypes(JAVA_SECURITY_SECURE_RANDOM)
        .constructor()
        .addParametersMatcher(""byte[]"")
        .build(),
      MethodMatchers.create()
        .ofTypes(JAVA_SECURITY_SECURE_RANDOM)
        .names(""setSeed"")
        .addParametersMatcher(""byte[]"")
        .addParametersMatcher(""long"")
        .build());
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    checkSeed(mit.arguments().get(0));
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    checkSeed(newClassTree.arguments().get(0));
  }

  private void checkSeed(ExpressionTree seedExpression) {
    if (isPredictable(seedExpression)) {
      reportIssue(seedExpression, ""Change this seed value to something unpredictable, or remove the seed."");
    }
  }

  private static boolean isPredictable(ExpressionTree expressionTree) {
    return expressionTree.is(LITERAL_KINDS)
      || expressionTree.is(Tree.Kind.NEW_ARRAY)
      || isStaticFinal(expressionTree)
      || isStringLiteralToBytes(expressionTree);
  }

  private static boolean isStringLiteralToBytes(ExpressionTree expressionTree) {
    if (!expressionTree.is(Tree.Kind.METHOD_INVOCATION)) {
      return false;
    }
    MethodInvocationTree mit = (MethodInvocationTree) expressionTree;
    return GET_BYTES.matches(mit) && ((MemberSelectExpressionTree) mit.methodSelect()).expression().is(Tree.Kind.STRING_LITERAL);
  }

  private static boolean isStaticFinal(ExpressionTree expressionTree) {
    if (!expressionTree.is(Tree.Kind.IDENTIFIER)) {
      return false;
    }
    Symbol symbol = ((IdentifierTree) expressionTree).symbol();
    return symbol.isStatic() && symbol.isFinal();
  }
}
"
S4348,BUG,"""iterator"" should not return ""this""","package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4348"")
public class IterableIteratorCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers ITERATOR = MethodMatchers.create()
    .ofSubTypes(""java.lang.Iterable"").names(""iterator"").addWithoutParametersMatcher().build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ReturnThis returnThis = new ReturnThis();
    ClassTree classTree = (ClassTree) tree;
    Type classType = classTree.symbol().type();
    if(!(classType.isSubtypeOf(""java.util.Iterator"") && classType.isSubtypeOf(""java.lang.Iterable""))) {
      return;
    }
    classTree.members().stream()
      .filter(m -> m.is(Tree.Kind.METHOD))
      .filter(m -> ITERATOR.matches(((MethodTree) m)))
      .forEach(t -> t.accept(returnThis));
    if (!returnThis.issueLocations.isEmpty()) {
      reportIssue(returnThis.issueLocations.get(0), ""Refactor this code so that the Iterator supports multiple traversal"",
        returnThis.issueLocations.stream().skip(1)
          .map(t -> new JavaFileScannerContext.Location("""", t)).toList(),
        null);
    }
  }

  private static class ReturnThis extends BaseTreeVisitor {
    private List<Tree> issueLocations = new ArrayList<>();

    @Override
    public void visitClass(ClassTree tree) {
      // cut the visit for inner classes
    }

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      ExpressionTree returnedExpression = tree.expression();
      if (ExpressionUtils.isThis(returnedExpression)) {
        issueLocations.add(returnedExpression);
      }
      super.visitReturnStatement(tree);
    }
  }
}
"
S4349,CODE_SMELL,"""write(byte[],int,int)"" should be overridden","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4349"")
public class OutputStreamOverrideWriteCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers WRITE_BYTES_INT_INT = MethodMatchers.create().ofAnyType()
    .names(""write"")
    .addParametersMatcher(""byte[]"", ""int"", ""int"")
    .build();

  private static final MethodMatchers WRITE_INT = MethodMatchers.create().ofAnyType()
    .names(""write"")
    .addParametersMatcher(""int"")
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Type superType = classTree.symbol().superClass();
    IdentifierTree className = classTree.simpleName();
    if (className == null || classTree.symbol().isAbstract() || superType == null || !(superType.is(""java.io.OutputStream"") || superType.is(""java.io.FilterOutputStream""))) {
      return;
    }
    Optional<MethodTree> writeByteIntInt = findMethod(classTree, WRITE_BYTES_INT_INT);
    if (!writeByteIntInt.isPresent()) {
      String message = ""Provide an override of \""write(byte[],int,int)\"" for this class."";
      Optional<MethodTree> writeInt = findMethod(classTree, WRITE_INT);
      if (writeInt.isPresent()) {
        MethodTree writeIntTree = writeInt.get();
        if (writeIntTree.block().body().isEmpty()) {
          message = ""Provide an empty override of \""write(byte[],int,int)\"" for this class as well."";
        }
      }
      reportIssue(className, message);
    }

  }

  private static Optional<MethodTree> findMethod(ClassTree classTree, MethodMatchers methodMatcher) {
    return classTree.members()
      .stream()
      .filter(m -> m.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .filter(methodMatcher::matches)
      .findFirst();
  }
}
"
S4351,BUG,"""compareTo"" should not be overloaded","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4351"")
public class CompareToNotOverloadedCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (isCompareToMethod(methodTree) && Boolean.FALSE.equals(methodTree.isOverriding())) {
      Symbol.TypeSymbol ownerType = (Symbol.TypeSymbol) methodTree.symbol().owner();
      ownerType.superTypes().stream().filter(supertype -> supertype.is(""java.lang.Comparable"")).findFirst().ifPresent(
        comparableType -> {
          String name = ""Object"";
          if (comparableType.isParameterized()) {
            name = comparableType.typeArguments().get(0).symbol().name();
          }
          reportIssue(methodTree.parameters().get(0), ""Refactor this method so that its argument is of type '"" + name + ""'."");
        });
    }
  }

  private static boolean isCompareToMethod(MethodTree tree) {
    return ""compareTo"".equals(tree.simpleName().name()) && tree.parameters().size() == 1;
  }

}
"
S4423,VULNERABILITY,Weak SSL/TLS protocols should not be used,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4423"")
public class WeakSSLContextCheck extends IssuableSubscriptionVisitor {

  private static final String ISSUE_MESSAGE = ""Change this code to use a stronger protocol."";
  private static final String SECONDARY_LOCATION_MESSAGE = ""Other weak protocol."";

  private static final Set<String> STRONG_PROTOCOLS = new HashSet<>(Arrays.asList(""TLSv1.2"", ""DTLSv1.2"", ""TLSv1.3"", ""DTLSv1.3""));
  private static final Set<String> STRONG_AFTER_JAVA_8 = new HashSet<>(Arrays.asList(""TLS"", ""DTLS""));
  private static final Set<String> WEAK_FOR_OK_HTTP = new HashSet<>(Arrays.asList(""TLSv1"", ""TLSv1.1"", ""TLS_1_0"", ""TLS_1_1""));
  private static final Set<String> WEAK_FOR_SET_ENABLED_PROTOCOLS = new HashSet<>(Set.of(""TLSv1.0"", ""TLSv1.1""));

  private static final MethodMatchers SSLCONTEXT_GETINSTANCE_MATCHER = MethodMatchers.create()
    .ofTypes(""javax.net.ssl.SSLContext"")
    .names(""getInstance"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers OK_HTTP_TLS_VERSION = MethodMatchers.create()
    .ofTypes(""okhttp3.ConnectionSpec$Builder"")
    .names(""tlsVersions"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers OPTIONS_ENABLED_PROTOCOLS = MethodMatchers.create()
    .ofTypes(""org.springframework.boot.autoconfigure.ssl.SslBundleProperties$Options"")
    .names(""setEnabledProtocols"")
    .addParametersMatcher(""java.util.Set"")
    .build();

  private boolean javaVersionNotSetOr8OrHigher;

  @Override
  public void setContext(JavaFileScannerContext context) {
    javaVersionNotSetOr8OrHigher = context.getJavaVersion().isJava8Compatible();
    super.setContext(context);
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;
    Arguments arguments = mit.arguments();
    if (SSLCONTEXT_GETINSTANCE_MATCHER.matches(mit)) {
      ExpressionTree firstArgument = arguments.get(0);
      firstArgument.asConstant(String.class).ifPresent(protocol -> {
        if (!isStrongProtocol(protocol)) {
          reportIssue(firstArgument, ISSUE_MESSAGE);
        }
      });
    } else if (OK_HTTP_TLS_VERSION.matches(mit)) {
      List<ExpressionTree> unsecureVersions = getUnsecureVersionsInArguments(arguments);
      if (!unsecureVersions.isEmpty()) {
        List<JavaFileScannerContext.Location> secondaries = unsecureVersions.stream()
          .skip(1)
          .map(secondary -> new JavaFileScannerContext.Location(SECONDARY_LOCATION_MESSAGE, secondary))
          .toList();
        reportIssue(unsecureVersions.get(0), ISSUE_MESSAGE, secondaries, null);
      }
    } else if (OPTIONS_ENABLED_PROTOCOLS.matches(mit)) {
      ExpressionTree argument = arguments.get(0);
      if (argument instanceof MethodInvocationTree methodInvocation) {
        List<JavaFileScannerContext.Location> secondaryLocations = methodInvocation.arguments().stream()
          .filter(arg -> {
            var argValue = ExpressionUtils.resolveAsConstant(arg);
            return argValue != null && WEAK_FOR_SET_ENABLED_PROTOCOLS.contains(argValue);
          })
          .map(arg -> new JavaFileScannerContext.Location(SECONDARY_LOCATION_MESSAGE, arg))
          .toList();
        if (!secondaryLocations.isEmpty()) {
          reportIssue(((MemberSelectExpressionTree) mit.methodSelect()).identifier(), ISSUE_MESSAGE, secondaryLocations, null);
        }
      }
    }
  }

  private boolean isStrongProtocol(String protocol) {
    // A project with a version not set is very likely to be >= Java 8
    return STRONG_PROTOCOLS.contains(protocol) || (javaVersionNotSetOr8OrHigher && STRONG_AFTER_JAVA_8.contains(protocol));
  }

  private static List<ExpressionTree> getUnsecureVersionsInArguments(Arguments arguments) {
    return arguments.stream()
      .filter(WeakSSLContextCheck::isUnsecureVersion)
      .toList();
  }

  private static boolean isUnsecureVersion(ExpressionTree expressionTree) {
    String argumentValue = null;
    Optional<String> stringArgument = expressionTree.asConstant(String.class);
    if (stringArgument.isPresent()) {
      argumentValue = stringArgument.get();
    } else if (expressionTree.is(Tree.Kind.IDENTIFIER)) {
      argumentValue = ((IdentifierTree) expressionTree).name();
    } else if (expressionTree.is(Tree.Kind.MEMBER_SELECT)) {
      argumentValue = ((MemberSelectExpressionTree) expressionTree).identifier().name();
    }
    return WEAK_FOR_OK_HTTP.contains(argumentValue);
  }

}
"
S4425,CODE_SMELL,"""Integer.toHexString"" should not be used to build hexadecimal strings","package org.sonar.java.checks.security;

import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4425"")
public class IntegerToHexStringCheck extends AbstractMethodDetection {

  private static final MethodMatchers APPEND_MATCHER = MethodMatchers.create()
    .ofSubTypes(""java.lang.AbstractStringBuilder"")
    .names(""append"")
    .addParametersMatcher(""java.lang.String"")
    .build();

  private static final MethodMatchers PRINT_MATCHER = MethodMatchers.create()
    .ofSubTypes(""java.io.PrintStream"")
    .names(""print"")
    .addParametersMatcher(""java.lang.String"")
    .build();

  private static final MethodMatchers JOINER_MATCHER = MethodMatchers.create()
    .ofSubTypes(""java.util.StringJoiner"")
    .names(""add"")
    .addParametersMatcher(""java.lang.CharSequence"")
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.lang.Integer"")
      .names(""toHexString"")
      .addParametersMatcher(""int"")
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree method) {
    if (isArgumentAppended(method) && typeIsByte(method.arguments().get(0))) {
      reportIssue(method.methodSelect(), ""Use String.format( \""%02X\"", ...) instead."");
    }
  }

  private static boolean isArgumentAppended(MethodInvocationTree method) {
    return Optional.of(method)
      .map(Tree::parent)
      .filter(tree -> tree.is(Tree.Kind.ARGUMENTS))
      .map(Tree::parent)
      .filter(tree -> tree.is(Tree.Kind.METHOD_INVOCATION))
      .map(MethodInvocationTree.class::cast)
      .filter(parentMethod -> APPEND_MATCHER.matches(parentMethod) ||
        PRINT_MATCHER.matches(parentMethod) ||
        JOINER_MATCHER.matches(parentMethod))
      .isPresent();
  }

  private static boolean typeIsByte(ExpressionTree expression) {
    return expression.symbolType().isSubtypeOf(""byte"") ||
      ExpressionUtils.isSecuringByte(expression);
  }
}
"
S4426,VULNERABILITY,Cryptographic keys should be robust,"package org.sonar.java.checks.security;

import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;

import static org.sonar.java.model.ExpressionUtils.getAssignedSymbol;
import static org.sonar.java.model.ExpressionUtils.isInvocationOnVariable;

@Rule(key = ""S4426"")
public class CryptographicKeySizeCheck extends AbstractMethodDetection {

  private static final String KEY_PAIR_GENERATOR = ""java.security.KeyPairGenerator"";
  private static final String KEY_GENERATOR = ""javax.crypto.KeyGenerator"";
  private static final String EC_GEN_PARAMETER_SPEC = ""java.security.spec.ECGenParameterSpec"";
  private static final String GET_INSTANCE_METHOD = ""getInstance"";
  private static final String STRING = ""java.lang.String"";

  private static final int EC_MIN_KEY = 224;
  private static final Pattern EC_KEY_PATTERN = Pattern.compile(""^(secp|prime|sect|c2tnb)(\\d+)"");

  private static final Map<String, Integer> ALGORITHM_KEY_SIZE_MAP = MapBuilder.<String, Integer>newMap()
    .put(""RSA"", 2048)
    .put(""DH"", 2048)
    .put(""DIFFIEHELLMAN"", 2048)
    .put(""DSA"", 2048)
    .put(""AES"", 128)
    .build();

  private static final MethodMatchers KEY_GEN = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(KEY_GENERATOR)
      .names(""init"")
      .addParametersMatcher(""int"")
      .build(),
    MethodMatchers.create()
      .ofTypes(KEY_PAIR_GENERATOR)
      .names(""initialize"")
      .addParametersMatcher(""int"")
      .addParametersMatcher(""int"", ""java.security.SecureRandom"")
      .build()) ;

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofTypes(KEY_GENERATOR, KEY_PAIR_GENERATOR)
        .names(GET_INSTANCE_METHOD)
        .addParametersMatcher(STRING)
        .build(),
      MethodMatchers.create()
        .ofTypes(EC_GEN_PARAMETER_SPEC)
        .constructor()
        .addParametersMatcher(STRING)
        .build());
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    MethodTree methodTree = ExpressionUtils.getEnclosingMethod(mit);
    String getInstanceArg = ExpressionsHelper.getConstantValueAsString(mit.arguments().get(0)).value();
    if (methodTree != null && getInstanceArg != null) {
      Optional<Symbol> assignedSymbol = getAssignedSymbol(mit);
      MethodVisitor methodVisitor = new MethodVisitor(getInstanceArg, assignedSymbol.orElse(null));
      methodTree.accept(methodVisitor);
    }
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    String firstArgument = ExpressionsHelper.getConstantValueAsString(newClassTree.arguments().get(0)).value();
    if (firstArgument != null) {
      Matcher matcher = EC_KEY_PATTERN.matcher(firstArgument);
      if (matcher.find() && Integer.valueOf(matcher.group(2)) < EC_MIN_KEY) {
        reportIssue(newClassTree, ""Use a key length of at least "" + EC_MIN_KEY + "" bits for EC cipher algorithm."");
      }
    }
  }

  private class MethodVisitor extends BaseTreeVisitor {

    private final String algorithm;
    private final Integer minKeySize;
    private final Symbol variable;

    public MethodVisitor(String getInstanceArg, @Nullable Symbol variable) {
      this.algorithm = getInstanceArg;
      this.minKeySize = ALGORITHM_KEY_SIZE_MAP.get(this.algorithm.toUpperCase(Locale.ENGLISH));
      this.variable = variable;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree mit) {
      if (minKeySize != null && KEY_GEN.matches(mit)) {
        Integer keySize = LiteralUtils.intLiteralValue(mit.arguments().get(0));
        if (keySize != null && keySize < minKeySize && isInvocationOnVariable(mit, variable, false)) {
          reportIssue(mit, ""Use a key length of at least "" + minKeySize + "" bits for "" + algorithm + "" cipher algorithm."");
        }
      }
    }
  }
}
"
S4433,VULNERABILITY,LDAP connections should be authenticated,"package org.sonar.java.checks.security;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.JavaPropertiesHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4433"")
public class LDAPAuthenticatedConnectionCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofSubTypes(""java.util.Map"")
      .names(""put"")
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree methodTree) {
    if (methodTree.arguments().size() != 2) {
      return;
    }
    ExpressionTree putKey = methodTree.arguments().get(0);
    ExpressionTree putValue = methodTree.arguments().get(1);
    ExpressionTree defaultPropertyValue = JavaPropertiesHelper.retrievedPropertyDefaultValue(putValue);
    ExpressionTree mechanismTree = defaultPropertyValue == null ? putValue : defaultPropertyValue;
    if (isSecurityAuthenticationConstant(putKey) && LiteralUtils.hasValue(mechanismTree, ""none"")) {
      reportIssue(putValue, ""Change authentication to \""simple\"" or stronger."");
    }
  }

  private static boolean isSecurityAuthenticationConstant(ExpressionTree tree) {
    if (tree.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree constantExpression = (MemberSelectExpressionTree) tree;
      return ""javax.naming.Context"".equals(constantExpression.expression().symbolType().fullyQualifiedName())
        && ""SECURITY_AUTHENTICATION"".equals(constantExpression.identifier().name());
    }
    return LiteralUtils.hasValue(tree, ""java.naming.security.authentication"");
  }
}
"
S4434,SECURITY_HOTSPOT,Allowing deserialization of LDAP objects is security-sensitive,"package org.sonar.java.checks.security;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;

@Rule(key = ""S4434"")
public class LDAPDeserializationCheck extends AbstractMethodDetection {
  private static final String CONSTRUCTOR_NAME = ""<init>"";
  private static final String CLASS_NAME = ""javax.naming.directory.SearchControls"";
  private static final int RET_OBJ_INDEX = 4;

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofSubTypes(CLASS_NAME).names(CONSTRUCTOR_NAME).withAnyParameters().build(),
      MethodMatchers.create().ofSubTypes(CLASS_NAME).names(""setReturningObjFlag"").addParametersMatcher(""boolean"").build());
  }
  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    checkConstructorArguments(newClassTree.arguments());
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree methodTree) {
    if (CONSTRUCTOR_NAME.equals(methodTree.methodSymbol().name())) {
      // when calling super() for classes extending SearchControls
      checkConstructorArguments(methodTree.arguments());
    } else {
      ExpressionTree setValue = methodTree.arguments().get(0);
      reportIfTrue(setValue);
    }
  }

  private void checkConstructorArguments(Arguments args) {
    if (args.size() <= RET_OBJ_INDEX) {
      return;
    }
    ExpressionTree retObjArgument = args.get(RET_OBJ_INDEX);
    reportIfTrue(retObjArgument);
  }

  private void reportIfTrue(ExpressionTree toUnderline) {
    if (LiteralUtils.isTrue(toUnderline)) {
      reportIssue(toUnderline, ""Disable object deserialization."");
    }
  }
}
"
S4454,CODE_SMELL,"""equals"" method parameters should not be marked ""@Nonnull""","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.SymbolMetadata.AnnotationInstance;
import org.sonar.plugins.java.api.semantic.SymbolMetadata.NullabilityLevel;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@Rule(key = ""S4454"")
public class EqualsParametersMarkedNonNullCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (!MethodTreeUtils.isEqualsMethod(methodTree)) {
      return;
    }
    VariableTree variable = methodTree.parameters().get(0);
    SymbolMetadata.NullabilityData nullabilityData = variable.symbol().metadata().nullabilityData();
    AnnotationInstance annotation = nullabilityData.annotation();
    Tree annotationTree = nullabilityData.declaration();
    if (annotationTree != null && annotation != null && nullabilityData.isNonNull(NullabilityLevel.VARIABLE, true, false)) {
      String annotationName = annotation.symbol().name();
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(annotationTree)
        .withMessage(""\""equals\"" method parameters should not be marked \""@%s\""."", annotationName)
        .withQuickFix(() -> JavaQuickFix.newQuickFix(""Remove \""@%s\"""", annotationName)
          .addTextEdit(JavaTextEdit.removeTextSpan(textSpanBetween(annotationTree, true,
            QuickFixHelper.nextToken(annotationTree), false)))
          .build())
        .report();
    }
  }

}
"
S4488,CODE_SMELL,"Composed ""@RequestMapping"" variants should be preferred","package org.sonar.java.checks.spring;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4488"")
public class SpringComposedRequestMappingCheck extends IssuableSubscriptionVisitor {

  private static final Map<String, String> PREFERRED_METHOD_MAP = buildPreferredMethodMap();

  private static Map<String, String> buildPreferredMethodMap() {
    Map<String, String> map = new HashMap<>();
    map.put(""GET"", ""@GetMapping"");
    map.put(""POST"", ""@PostMapping"");
    map.put(""PUT"", ""@PutMapping"");
    map.put(""PATCH"", ""@PatchMapping"");
    map.put(""DELETE"", ""@DeleteMapping"");
    return map;
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.ANNOTATION);
  }

  @Override
  public void visitNode(Tree tree) {
    AnnotationTree annotation = (AnnotationTree) tree;
    if (annotation.symbolType().is(""org.springframework.web.bind.annotation.RequestMapping"")) {
      List<ExpressionTree> methodValues = annotation.arguments().stream()
        .filter(argument -> ""method"".equals(attributeName(argument)))
        .flatMap(SpringComposedRequestMappingCheck::extractValues)
        .toList();

      if (methodValues.size() == 1) {
        ExpressionTree requestMethod = methodValues.get(0);
        String currentMethod = getRequestMethodEnumEntry(requestMethod);
        String preferredMethod = PREFERRED_METHOD_MAP.get(currentMethod);
        if (preferredMethod != null) {
          reportIssue(annotation.annotationType(),
            ""Replace \""@RequestMapping(method = RequestMethod."" + currentMethod + "")\"" with \"""" + preferredMethod + ""\"""",
            Collections.singletonList(new JavaFileScannerContext.Location("""", requestMethod)),
            null);
        }
      }
    }
  }

  private static String getRequestMethodEnumEntry(ExpressionTree requestMethod) {
    ExpressionTree expression = requestMethod;
    if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      expression = ((MemberSelectExpressionTree) requestMethod).identifier();
    }
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      Symbol symbol = ((IdentifierTree) expression).symbol();
      if (symbol.type().is(""org.springframework.web.bind.annotation.RequestMethod"")) {
        return symbol.name();
      }
    }
    return """";
  }

  private static String attributeName(ExpressionTree expression) {
    if (expression.is(Tree.Kind.ASSIGNMENT)) {
      AssignmentExpressionTree assignment = (AssignmentExpressionTree) expression;
      // assignment.variable() in annotation is always a Tree.Kind.IDENTIFIER
      return ((IdentifierTree) assignment.variable()).name();
    }
    return ""value"";
  }

  private static Stream<ExpressionTree> extractValues(ExpressionTree argument) {
    ExpressionTree expression = argument;
    if (expression.is(Tree.Kind.ASSIGNMENT)) {
      expression = ((AssignmentExpressionTree) expression).expression();
    }
    if (expression.is(Tree.Kind.NEW_ARRAY)) {
      return ((NewArrayTree) expression).initializers().stream()
        .flatMap(SpringComposedRequestMappingCheck::extractValues);
    }
    return Stream.of(expression);
  }
}
"
S4502,SECURITY_HOTSPOT,Disabling CSRF protections is security-sensitive,"package org.sonar.java.checks.spring;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4502"")
public class SpringSecurityDisableCSRFCheck extends AbstractMethodDetection {

  private static final String CSRF_CONFIGURER_CLASS = ""org.springframework.security.config.annotation.web.configurers.CsrfConfigurer"";
  private static final String MESSAGE = ""Make sure disabling Spring Security's CSRF protection is safe here."";

  private static final MethodMatchers DISALLOWED_METHODS = MethodMatchers.create()
      .ofSubTypes(""org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer"")
      .names(""disable"", ""ignoringAntMatchers"", ""requireCsrfProtectionMatcher"", ""ignoringRequestMatchers"")
      .withAnyParameters()
      .build();


  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return DISALLOWED_METHODS;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree selectExpression = (MemberSelectExpressionTree) mit.methodSelect();
      if (selectExpression.expression().symbolType().is(CSRF_CONFIGURER_CLASS)) {
        reportIssue(selectExpression.identifier(), MESSAGE);
      }
    }
  }

  @Override
  protected void onMethodReferenceFound(MethodReferenceTree methodReferenceTree) {
    var typeArgs = methodReferenceTree.symbolType().typeArguments();
    if (typeArgs.size() == 1 && typeArgs.get(0).is(CSRF_CONFIGURER_CLASS)) {
      reportIssue(methodReferenceTree.method(), MESSAGE);
    }
  }
}
"
S4507,SECURITY_HOTSPOT,Delivering code in production with debug features activated is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4507"")
public class DebugFeatureEnabledCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Make sure this debug feature is deactivated before delivering the code in production."";

  private static final MethodMatchers PRINT_STACK_TRACE_MATCHER = MethodMatchers.create()
    .ofSubTypes(""java.lang.Throwable"").names(""printStackTrace"").addWithoutParametersMatcher().build();

  private static final MethodMatchers SET_WEB_CONTENTS_DEBUGGING_ENABLED = MethodMatchers.create()
      .ofSubTypes(""android.webkit.WebView"", ""android.webkit.WebViewFactoryProvider$Statics"")
      .names(""setWebContentsDebuggingEnabled"").addParametersMatcher(""boolean"").build();

  private static final MethodMatchers DEBUG_MATCHER = MethodMatchers.create()
    .ofSubTypes(""org.springframework.security.config.annotation.web.builders.WebSecurity"")
    .names(""debug"").addParametersMatcher(""boolean"").build();

  private final Deque<Symbol.TypeSymbol> enclosingClass = new LinkedList<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.ANNOTATION, Tree.Kind.CLASS, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    switch (tree.kind()) {
      case ANNOTATION:
        checkAnnotation((AnnotationTree) tree);
        break;
      case METHOD_INVOCATION:
        checkMethodInvocation((MethodInvocationTree) tree);
        break;
      default:
        ClassTree classTree = (ClassTree) tree;
        enclosingClass.push(classTree.symbol());
        break;
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree instanceof ClassTree) {
      enclosingClass.pop();
    }
  }

  private void checkMethodInvocation(MethodInvocationTree mit) {
    if (isPrintStackTraceIllegalUsage(mit) || isSetWebContentsDebuggingEnabled(mit) || isDebugWithTrueArgument(mit)) {
      reportIssue(ExpressionUtils.methodName(mit), MESSAGE);
    }
  }

  private boolean isPrintStackTraceIllegalUsage(MethodInvocationTree mit) {
    return !enclosingClassExtendsThrowable() && PRINT_STACK_TRACE_MATCHER.matches(mit);
  }

  private static boolean isSetWebContentsDebuggingEnabled(MethodInvocationTree mit) {
    return SET_WEB_CONTENTS_DEBUGGING_ENABLED.matches(mit) &&
      Boolean.TRUE.equals(ExpressionUtils.resolveAsConstant(mit.arguments().get(0)));
  }

  private static boolean isDebugWithTrueArgument(MethodInvocationTree mit){
    if (!DEBUG_MATCHER.matches(mit.methodSymbol())){
      return false;
    }
    var cstArg = mit.arguments().get(0).asConstant();
    return cstArg.isPresent() && cstArg.get().equals(true);
  }

  private void checkAnnotation(AnnotationTree annotation) {
    if (annotation.symbolType().is(""org.springframework.security.config.annotation.web.configuration.EnableWebSecurity"")) {
      annotation.arguments().stream()
        .map(DebugFeatureEnabledCheck::getDebugArgument)
        .filter(Objects::nonNull)
        .findFirst()
        .filter(assignment -> Boolean.TRUE.equals(ExpressionsHelper.getConstantValueAsBoolean(assignment.expression()).value()))
        .ifPresent(assignment -> reportIssue(assignment, MESSAGE));
    }
  }

  @CheckForNull
  private static AssignmentExpressionTree getDebugArgument(ExpressionTree expression) {
    if (expression.is(Tree.Kind.ASSIGNMENT)) {
      AssignmentExpressionTree assignment = (AssignmentExpressionTree) expression;
      if (assignment.variable().is(Tree.Kind.IDENTIFIER) &&
        ""debug"".equals(((IdentifierTree) assignment.variable()).name())) {
        return assignment;
      }
    }
    return null;
  }

  private boolean enclosingClassExtendsThrowable() {
    return enclosingClass.peek() != null && enclosingClass.peek().type().isSubtypeOf(""java.lang.Throwable"");
  }

}
"
S4512,SECURITY_HOTSPOT,Setting JavaBean properties is security-sensitive,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S4512"")
public class PopulateBeansCheck extends AbstractMethodDetection {

  private static final MethodMatchers METHOD_MATCHERS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(""org.apache.commons.beanutils.BeanUtils"", ""org.apache.commons.beanutils.BeanUtilsBean"")
      .names(""populate"", ""setProperty"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofTypes(""org.springframework.beans.PropertyAccessor"")
      .names(""setPropertyValue"", ""setPropertyValues"")
      .withAnyParameters()
      .build());

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return METHOD_MATCHERS;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(mit, ""Make sure that setting JavaBean properties is safe here."");
  }

}
"
S4517,BUG,InputSteam.read() implementation should not return a signed byte,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4517"")
public class InputStreamReadCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers INPUT_STREAM_READ = MethodMatchers.create()
    .ofSubTypes(""java.io.InputStream"").names(""read"").addWithoutParametersMatcher().build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree method = (MethodTree) tree;
    if (method.block() != null && INPUT_STREAM_READ.matches(method)) {
      method.accept(new ReturnStatementVisitor());
    }
  }

  private class ReturnStatementVisitor extends BaseTreeVisitor {

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      ExpressionTree expression = tree.expression();
      if (expression.symbolType().is(""byte"")) {
        reportIssue(expression, ""Convert this signed byte into an unsigned byte."");
      }
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // skip lambdas
    }

    @Override
    public void visitClass(ClassTree tree) {
      // skip inner or annonymous classes
    }
  }
}
"
S4524,CODE_SMELL,"""default"" clauses should be last","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.ast.api.JavaKeyword;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.CaseLabelTree;
import org.sonar.plugins.java.api.tree.SwitchTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4524"")
public class SwitchDefaultLastCaseCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.SWITCH_STATEMENT, Tree.Kind.SWITCH_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    SwitchTree switchTree = (SwitchTree) tree;
    getDefaultLabelAtWrongPosition(switchTree).ifPresent(defaultLabel -> reportIssue(defaultLabel, ""Move this default to the end of the switch.""));
  }

  private static Optional<CaseLabelTree> getDefaultLabelAtWrongPosition(SwitchTree switchTree) {
    List<CaseGroupTree> cases = switchTree.cases();
    for (int i = 0; i < cases.size(); i++) {
      List<CaseLabelTree> labels = cases.get(i).labels();
      for (int j = 0; j < labels.size(); j++) {
        CaseLabelTree label = labels.get(j);
        boolean defaultExists = isDefault(label);
        if (defaultExists && ((j != labels.size() - 1) || (i == cases.size() - 1))) {return Optional.empty();
        } else if (defaultExists) {
          return Optional.of(label);
        }
      }
    }
    return Optional.empty();
  }

  private static boolean isDefault(CaseLabelTree caseLabelTree) {
    return JavaKeyword.DEFAULT.getValue().equals(caseLabelTree.caseOrDefaultKeyword().text());
  }
}
"
S4544,SECURITY_HOTSPOT,Using unsafe Jackson deserialization configuration is security-sensitive,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4544"")
public class JacksonDeserializationCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers ENABLE_DEFAULT_TYPING = MethodMatchers.create()
    .ofTypes(
      ""com.fasterxml.jackson.databind.ObjectMapper"",
      ""org.codehaus.jackson.map.ObjectMapper"")
    .names(""enableDefaultTyping"")
    .addWithoutParametersMatcher()
    .build();

  private static final String MESSAGE = ""Make sure using this Jackson deserialization configuration is safe here."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.ANNOTATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION) && ENABLE_DEFAULT_TYPING.matches((MethodInvocationTree) tree)) {
      reportIssue(tree, MESSAGE);
    } else if (tree.is(Tree.Kind.ANNOTATION)) {
      AnnotationTree annotationTree = (AnnotationTree) tree;
      if (isJsonTypeInfo(annotationTree) && isAnnotationOnClassOrField(annotationTree)) {
        findUseArgument(annotationTree).ifPresent(useAnnotationArgument ->
            reportIssue(useAnnotationArgument, MESSAGE));
      }
    }
  }

  private static boolean isJsonTypeInfo(AnnotationTree annotationTree) {
    Type annotationType = annotationTree.annotationType().symbolType();
    return annotationType.is(""com.fasterxml.jackson.annotation.JsonTypeInfo"")
        || annotationType.is(""org.codehaus.jackson.annotate.JsonTypeInfo"");
  }

  private static boolean isAnnotationOnClassOrField(AnnotationTree annotationTree) {
    if (annotationTree.parent().is(Tree.Kind.MODIFIERS)) {
      Tree modifiers = annotationTree.parent();
      return modifiers.parent().is(Tree.Kind.CLASS, Tree.Kind.INTERFACE, Tree.Kind.VARIABLE);
    }
    return false;
  }

  private static Optional<ExpressionTree> findUseArgument(AnnotationTree annotationTree) {
    for (ExpressionTree tree : annotationTree.arguments()) {
      if (tree.is(Tree.Kind.ASSIGNMENT)) {
        AssignmentExpressionTree assignment = (AssignmentExpressionTree) tree;
        if (""use"".equals(((IdentifierTree) assignment.variable()).name())
            && isJsonTypeIdEnumValue(assignment.expression())) {
          return Optional.of(assignment.expression());
        }
      }
    }
    return Optional.empty();
  }

  private static boolean isJsonTypeIdEnumValue(ExpressionTree tree) {
    if (!isJsonTypeId(tree)) {
      return false;
    }
    String valueName;
    if (tree.is(Tree.Kind.MEMBER_SELECT)) {
      valueName = ((MemberSelectExpressionTree) tree).identifier().name();
    } else {
      valueName = ((IdentifierTree) tree).name();
    }
    return ""CLASS"".equals(valueName) || ""MINIMAL_CLASS"".equals(valueName);
  }

  private static boolean isJsonTypeId(ExpressionTree tree) {
    Type type = tree.symbolType();
    return type.is(""com.fasterxml.jackson.annotation.JsonTypeInfo$Id"")
        || type.is(""org.codehaus.jackson.annotate.JsonTypeInfo$Id"");
  }
}

"
S4551,CODE_SMELL,"Enum values should be compared with ""==""","package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4551"")
public class EnumEqualCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofAnyType().names(""equals"").addParametersMatcher(""java.lang.Object"").build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mse = (MemberSelectExpressionTree) mit.methodSelect();
      if (isEnum(mse.expression()) || isEnum(mit.arguments().get(0))) {
        reportIssue(mse.identifier(), ""Use \""==\"" to perform this enum comparison instead of using \""equals\"""");
      }
    }
  }

  private static boolean isEnum(ExpressionTree exp) {
    return exp.symbolType().symbol().isEnum();
  }
}
"
S4601,VULNERABILITY,"""HttpSecurity"" URL patterns should be correctly ordered","package org.sonar.java.checks.spring;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.annotations.VisibleForTesting;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S4601"")
public class SpringAntMatcherOrderCheck extends AbstractMethodDetection {

  private static final Pattern MATCHER_SPECIAL_CHAR = Pattern.compile(""[?*{]"");

  private static final MethodMatchers ANT_MATCHERS = MethodMatchers.create()
    .ofSubTypes(""org.springframework.security.config.annotation.web.AbstractRequestMatcherRegistry"")
    .names(""antMatchers"")
    .addParametersMatcher(""java.lang.String[]"")
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""org.springframework.security.config.annotation.web.builders.HttpSecurity"")
      .names(""authorizeRequests"")
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree method) {
    List<StringConstant> antPatterns = collectAntPatterns(method);
    for (int indexToCheck = 1; indexToCheck < antPatterns.size(); indexToCheck++) {
      checkAntPatternAt(antPatterns, indexToCheck);
    }
  }

  private void checkAntPatternAt(List<StringConstant> antPatterns, int indexToCheck) {
    StringConstant patternToCheck = antPatterns.get(indexToCheck);
    StringConstant incompatiblePattern = firstIncompatiblePreviousPattern(patternToCheck, antPatterns, indexToCheck);
    if (incompatiblePattern != null) {
      List<JavaFileScannerContext.Location> secondary = Collections.singletonList(
        new JavaFileScannerContext.Location(""Less restrictive"", incompatiblePattern.expression));

      reportIssue(patternToCheck.expression, ""Reorder the URL patterns from most to less specific, the pattern \"""" +
        patternToCheck.value + ""\"" should occurs before \"""" + incompatiblePattern.value + ""\""."", secondary, null);
    }
  }

  @CheckForNull
  private static StringConstant firstIncompatiblePreviousPattern(StringConstant patternToCheck, List<StringConstant> antPatterns, int antPatternsSize) {
    for (int i = 0; i < antPatternsSize; i++) {
      StringConstant previousPattern = antPatterns.get(i);
      if (matches(previousPattern.value, patternToCheck.value)) {
        return previousPattern;
      }
    }
    return null;
  }

  private static List<StringConstant> collectAntPatterns(MethodInvocationTree method) {
    List<StringConstant> antPatterns = new ArrayList<>();
    Optional<MethodInvocationTree> parentMethod = MethodTreeUtils.consecutiveMethodInvocation(method);
    while (parentMethod.isPresent()) {
      if (ANT_MATCHERS.matches(parentMethod.get())) {
        antPatterns.addAll(antMatchersPatterns(parentMethod.get()));
      }
      parentMethod = MethodTreeUtils.consecutiveMethodInvocation(parentMethod.get());
    }
    return antPatterns;
  }

  @VisibleForTesting
  static boolean matches(String pattern, String text) {
    if (pattern.equals(text)) {
      return true;
    }
    if (pattern.endsWith(""**"") && text.startsWith(pattern.substring(0, pattern.length() - 2))) {
      return true;
    }
    boolean antPatternContainsRegExp = pattern.contains(""{"");
    boolean textIsAlsoAnAntPattern = MATCHER_SPECIAL_CHAR.matcher(text).find();
    if (pattern.isEmpty() || antPatternContainsRegExp || textIsAlsoAnAntPattern) {
      return false;
    }
    return text.matches(antMatcherToRegEx(pattern));
  }

  @VisibleForTesting
  static String antMatcherToRegEx(String pattern) {
    // Note, regexp is not supported: {spring:[a-z]+} matches the regexp [a-z]+ as a path variable named ""spring""

    // escape regexp special characters
    return escapeRegExpChars(pattern)
      // ? matches one character
      .replace(""?"", ""[^/]"")
      // ** matches zero or more directories in a path (""$$"" is a temporary place holder)
      .replace(""**"", ""$$"")
      // * matches zero or more characters
      .replace(""*"", ""[^/]*"")
      .replace(""$$"", "".*"");
  }

  @VisibleForTesting
  static String escapeRegExpChars(String pattern) {
    return pattern.replaceAll(""([.(){}+|^$\\[\\]\\\\])"", ""\\\\$1"");
  }

  private static List<StringConstant> antMatchersPatterns(MethodInvocationTree mit) {
    return mit.arguments().stream()
      .map(StringConstant::of)
      .filter(Objects::nonNull)
      .toList();
  }

  private static class StringConstant {
    private final ExpressionTree expression;
    private final String value;

    private StringConstant(ExpressionTree expression, String value) {
      this.expression = expression;
      this.value = value;
    }

    @CheckForNull
    private static StringConstant of(ExpressionTree expression) {
      String value = ExpressionsHelper.getConstantValueAsString(expression).value();
      if (value != null) {
        return new StringConstant(expression, value);
      }
      return null;
    }
  }

}
"
S4602,BUG,"""@SpringBootApplication"" and ""@ComponentScan"" should not be used in the default package","package org.sonar.java.checks.spring;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4602"")
public class SpringScanDefaultPackageCheck extends IssuableSubscriptionVisitor {

  private static final String DEFAULT_ATTRIBUTE = ""value"";

  private static final Map<String, Set<String>> SCAN_PACKAGE_ATTRIBUTES = buildScanPackageAttributes();

  private static Map<String, Set<String>> buildScanPackageAttributes() {
    Map<String, Set<String>> map = new HashMap<>();

    map.put(""org.springframework.context.annotation.ComponentScan"",
      new HashSet<>(Arrays.asList(DEFAULT_ATTRIBUTE, ""basePackages"", ""basePackageClasses"")));

    map.put(""org.springframework.boot.autoconfigure.SpringBootApplication"",
      new HashSet<>(Arrays.asList(""scanBasePackages"", ""scanBasePackageClasses"")));

    map.put(""org.springframework.boot.web.servlet.ServletComponentScan"",
      new HashSet<>(Arrays.asList(DEFAULT_ATTRIBUTE, ""basePackages"", ""basePackageClasses"")));

    return map;
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.ANNOTATION);
  }

  @Override
  public void visitNode(Tree tree) {
    AnnotationTree annotation = (AnnotationTree) tree;
    Set<String> scanPackageAttributeNames = SCAN_PACKAGE_ATTRIBUTES.get(annotation.symbolType().fullyQualifiedName());
    if (scanPackageAttributeNames != null) {
      List<ExpressionTree> scanPackageAttributeValues = annotation.arguments().stream()
        .filter(argument -> scanPackageAttributeNames.contains(attributeName(argument)))
        .flatMap(SpringScanDefaultPackageCheck::extractValues)
        .toList();

      checkAnnotationPackageAttributes(annotation, scanPackageAttributeValues);
    }
  }

  private void checkAnnotationPackageAttributes(AnnotationTree annotation, List<ExpressionTree> scanPackageAttributeValues) {
    if (scanPackageAttributeValues.isEmpty()) {
      if (isNodeInDefaultPackage(annotation)) {
        reportIssue(annotation.annotationType(), ""Remove the annotation \""@"" + annotation.symbolType().name() +
          ""\"" or move the annotated class out of the default package."");
      }
    } else {
      scanPackageAttributeValues.stream()
        .map(SpringScanDefaultPackageCheck::findEmptyString)
        .forEach(opt -> opt.ifPresent(expression -> reportIssue(expression, ""Define packages to scan. Don't rely on the default package."")));

      scanPackageAttributeValues.stream()
        .map(SpringScanDefaultPackageCheck::findClassInDefaultPackage)
        .forEach(opt -> opt.ifPresent(identifier -> reportIssue(identifier, ""Remove the annotation \""@"" + annotation.symbolType().name() +
          ""\"" or move the \"""" + identifier.name() + ""\"" class out of the default package."")));
    }
  }

  private static String attributeName(ExpressionTree expression) {
    if (expression.is(Tree.Kind.ASSIGNMENT)) {
      AssignmentExpressionTree assignment = (AssignmentExpressionTree) expression;
      // assignment.variable() in annotation is always a Tree.Kind.IDENTIFIER
      return ((IdentifierTree) assignment.variable()).name();
    }
    return DEFAULT_ATTRIBUTE;
  }

  private static Stream<ExpressionTree> extractValues(ExpressionTree argument) {
    ExpressionTree expression = argument;
    if (expression.is(Tree.Kind.ASSIGNMENT)) {
      expression = ((AssignmentExpressionTree) expression).expression();
    }
    if (expression.is(Tree.Kind.NEW_ARRAY)) {
      return ((NewArrayTree) expression).initializers().stream()
        .flatMap(SpringScanDefaultPackageCheck::extractValues);
    }
    return Stream.of(expression);
  }

  private static Optional<ExpressionTree> findEmptyString(ExpressionTree expression) {
    return expression.asConstant(String.class)
      .filter(String::isEmpty)
      .map(s -> expression);
  }

  private static Optional<IdentifierTree> findClassInDefaultPackage(ExpressionTree expression) {
    if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) expression;
      if (""class"".equals(memberSelect.identifier().name()) && memberSelect.expression().is(Tree.Kind.IDENTIFIER)) {
        IdentifierTree identifier = (IdentifierTree) memberSelect.expression();
        if (isTypeInDefaultPackage(identifier.symbol())) {
          return Optional.of(identifier);
        }
      }
    }
    return Optional.empty();
  }

  private static boolean isTypeInDefaultPackage(Symbol symbol) {
    if (!symbol.isTypeSymbol()) {
      return false;
    }
    Symbol parent = symbol.owner();
    while (!parent.isPackageSymbol()) {
      parent = parent.owner();
    }
    return parent.name().isEmpty();
  }

  private static boolean isNodeInDefaultPackage(Tree tree) {
    while (!tree.is(Tree.Kind.COMPILATION_UNIT)) {
      tree = tree.parent();
    }
    return ((CompilationUnitTree) tree).packageDeclaration() == null;
  }

}
"
S4604,CODE_SMELL,"""@EnableAutoConfiguration"" should be fine-tuned","package org.sonar.java.checks.spring;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4604"")
public class SpringAutoConfigurationCheck extends IssuableSubscriptionVisitor {

  private static final List<String> ANNOTATIONS = Arrays.asList(
    ""org.springframework.boot.autoconfigure.SpringBootApplication"",
    ""org.springframework.boot.autoconfigure.EnableAutoConfiguration"");

  private static final Set<String> EXCLUDE_ELEMENTS = new HashSet<>(Arrays.asList(""exclude"", ""excludeName""));

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ((ClassTree) tree).modifiers().annotations().stream()
      .filter(SpringAutoConfigurationCheck::isAutoConfiguration)
      .filter(annotation -> !hasExclude(annotation.arguments()))
      .forEach(annotation -> reportIssue(annotation, ""Exclude from the auto-configuration mechanism the beans you don't need.""));
  }

  private static boolean isAutoConfiguration(AnnotationTree annotationTree) {
    return ANNOTATIONS.stream().anyMatch(annotationTree.annotationType().symbolType()::is);
  }

  private static boolean hasExclude(Arguments arguments) {
    return arguments.stream()
      .filter(arg -> arg.is(Tree.Kind.ASSIGNMENT))
      .map(AssignmentExpressionTree.class::cast)
      .anyMatch(SpringAutoConfigurationCheck::isExcludeElement);
  }

  private static boolean isExcludeElement(AssignmentExpressionTree assignment) {
    ExpressionTree expression = assignment.expression();
    boolean isExcludeElement = EXCLUDE_ELEMENTS.contains(assignment.variable().toString());
    boolean arrayNotEmpty = expression.is(Tree.Kind.NEW_ARRAY) && !((NewArrayTree) expression).initializers().isEmpty();
    return isExcludeElement && arrayNotEmpty;
  }
}
"
S4605,CODE_SMELL,"Spring beans should be considered by ""@ComponentScan""","package org.sonar.java.checks.spring;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.check.Rule;
import org.sonar.java.model.DefaultJavaFileScannerContext;
import org.sonar.java.model.DefaultModuleScannerContext;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.plugins.java.api.InputFileScannerContext;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.ModuleScannerContext;
import org.sonar.plugins.java.api.internal.EndOfAnalysis;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.collections.SetUtils;

@Rule(key = ""S4605"")
public class SpringBeansShouldBeAccessibleCheck extends IssuableSubscriptionVisitor implements EndOfAnalysis {

  private static final Logger LOG = LoggerFactory.getLogger(SpringBeansShouldBeAccessibleCheck.class);

  private static final String MESSAGE_FORMAT = ""'%s' is not reachable by @ComponentScan or @SpringBootApplication. ""
    + ""Either move it to a package configured in @ComponentScan or update your @ComponentScan configuration."";

  private static final String[] SPRING_BEAN_ANNOTATIONS = {
    ""org.springframework.stereotype.Component"",
    ""org.springframework.stereotype.Service"",
    ""org.springframework.stereotype.Repository"",
    ""org.springframework.stereotype.Controller"",
    ""org.springframework.web.bind.annotation.RestController""
  };

  private static final String COMPONENT_SCAN_ANNOTATION = ""org.springframework.context.annotation.ComponentScan"";
  private static final Set<String> COMPONENT_SCAN_ARGUMENTS = SetUtils.immutableSetOf(""basePackages"", ""value"");

  private static final String SPRING_BOOT_APP_ANNOTATION = ""org.springframework.boot.autoconfigure.SpringBootApplication"";
  private static final String CACHE_KEY_PREFIX = ""java:S4605:targeted:"";private final Map<String, List<AnalyzerMessage>> messagesPerPackage = new HashMap<>();private final Set<String> packagesScannedBySpringAtProjectLevel = new HashSet<>();private final Set<String> packagesScannedBySpringAtFileLevel = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public boolean scanWithoutParsing(InputFileScannerContext inputFileScannerContext) {
    return readFromCache(inputFileScannerContext).map(targetedPackages -> {
      packagesScannedBySpringAtProjectLevel.addAll(targetedPackages);
      return true;
    }).orElse(false);
  }

  @Override
  public void endOfAnalysis(ModuleScannerContext context) {
    var defaultContext = (DefaultModuleScannerContext) context;
    messagesPerPackage.entrySet().stream()
      // support sub-packages
      .filter(entry -> packagesScannedBySpringAtProjectLevel.stream().noneMatch(entry.getKey()::contains))
      .forEach(entry -> entry.getValue().forEach(defaultContext::reportIssue));
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;

    if (classTree.simpleName() == null) {
      return;
    }

    String classPackageName = packageNameOf(classTree.symbol());
    SymbolMetadata classSymbolMetadata = classTree.symbol().metadata();


    List<SymbolMetadata.AnnotationValue> componentScanValues = classSymbolMetadata.valuesForAnnotation(COMPONENT_SCAN_ANNOTATION);
    if (componentScanValues != null) {
      componentScanValues.forEach(this::addToScannedPackages);
    } else if (hasAnnotation(classSymbolMetadata, SPRING_BOOT_APP_ANNOTATION)) {
      var targetedPackages = targetedPackages(classPackageName, classSymbolMetadata);
      packagesScannedBySpringAtProjectLevel.addAll(targetedPackages);
      packagesScannedBySpringAtFileLevel.addAll(targetedPackages);
    } else if (hasAnnotation(classSymbolMetadata, SPRING_BEAN_ANNOTATIONS)) {
      addMessageToMap(classPackageName, classTree.simpleName());
    }
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    packagesScannedBySpringAtFileLevel.clear();
    super.setContext(context);
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    super.leaveFile(context);
    if (context.getCacheContext().isCacheEnabled()) {
      writeToCache(context, packagesScannedBySpringAtFileLevel);
    }
    packagesScannedBySpringAtFileLevel.clear();
  }

  private static String cacheKey(InputFile inputFile) {
    return CACHE_KEY_PREFIX + inputFile.key();
  }

  private static void writeToCache(InputFileScannerContext context, Collection<String> targetedPackages) {
    var cacheKey = cacheKey(context.getInputFile());
    var data = String.join("";"", targetedPackages).getBytes(StandardCharsets.UTF_8);
    try {
      context.getCacheContext().getWriteCache().write(cacheKey, data);
    } catch (IllegalArgumentException e) {
      LOG.trace(""Tried to write multiple times to cache key '{}'. Ignoring writes after the first."", cacheKey);
    }
  }

  private static Optional<List<String>> readFromCache(InputFileScannerContext context) {
    var cacheKey = cacheKey(context.getInputFile());
    var bytes = context.getCacheContext().getReadCache().readBytes(cacheKey);
    if (bytes != null) {
      context.getCacheContext().getWriteCache().copyFromPrevious(cacheKey);
      return Optional.of(Arrays.asList(new String(bytes, StandardCharsets.UTF_8).split("";"")));
    } else {
      return Optional.empty();
    }
  }

  private static List<String> targetedPackages(String classPackageName, SymbolMetadata classSymbolMetadata) {
    // annotation is necessarily there already
    return Objects.requireNonNull(classSymbolMetadata.valuesForAnnotation(SPRING_BOOT_APP_ANNOTATION))
      .stream()
      .filter(v -> ""scanBasePackages"".equals(v.name()))
      .map(SymbolMetadata.AnnotationValue::value)
      .findFirst()
      // list of packages to scan
      .filter(Object[].class::isInstance)
      .map(Object[].class::cast)
      .map(SpringBeansShouldBeAccessibleCheck::asStringList)
      // Using this annotation without arguments tells Spring to scan the current package and all of its sub-packages.
      .orElse(Collections.singletonList(classPackageName));
  }

  private static List<String> asStringList(Object[] array) {
    return Arrays.asList(array)
      .stream()
      .filter(String.class::isInstance)
      .map(String.class::cast)
      .toList();
  }

  private void addMessageToMap(String classPackageName, IdentifierTree classNameTree) {
    DefaultJavaFileScannerContext defaultContext = (DefaultJavaFileScannerContext) context;
    AnalyzerMessage analyzerMessage = defaultContext.createAnalyzerMessage(this, classNameTree, String.format(MESSAGE_FORMAT, classNameTree.name()));
    messagesPerPackage.computeIfAbsent(classPackageName, k -> new ArrayList<>()).add(analyzerMessage);
  }

  private void addToScannedPackages(SymbolMetadata.AnnotationValue annotationValue) {
    if (!COMPONENT_SCAN_ARGUMENTS.contains(annotationValue.name())) {
      return;
    }
    if (annotationValue.value() instanceof Object[] objects) {
      for (Object o : objects) {
        if (o instanceof String oString) {
          packagesScannedBySpringAtProjectLevel.add(oString);
        }
      }
    }
  }

  private static String packageNameOf(Symbol symbol) {
    Symbol owner = symbol.owner();
    while (!owner.isPackageSymbol()) {
      owner = owner.owner();
    }
    return owner.name();
  }

  private static boolean hasAnnotation(SymbolMetadata classSymbolMetadata, String... annotationName) {
    return Arrays.stream(annotationName).anyMatch(classSymbolMetadata::isAnnotatedWith);
  }
}
"
S4635,CODE_SMELL,String offset-based methods should be preferred for finding substrings from offsets,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4635"")
public class StringOffsetMethodsCheck extends AbstractMethodDetection {

  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String INT = ""int"";
  private static final MethodMatchers SUBSTRING = MethodMatchers.create()
    .ofTypes(JAVA_LANG_STRING)
    .names(""substring"")
    .addParametersMatcher(INT)
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofTypes(JAVA_LANG_STRING)
        .names(""indexOf"", ""lastIndexOf"")
        .addParametersMatcher(INT)
        .build(),
      MethodMatchers.create()
        .ofTypes(JAVA_LANG_STRING)
        .names(""indexOf"", ""lastIndexOf"", ""startsWith"")
        .addParametersMatcher(JAVA_LANG_STRING)
        .build());
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    // defensive programming : methodSelect can only be a MemberSelect (methods are instance method of java.lang.String).
    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree expression = ((MemberSelectExpressionTree) methodSelect).expression();
      if (expression.is(Tree.Kind.METHOD_INVOCATION) && SUBSTRING.matches(((MethodInvocationTree) expression).methodSymbol())) {
        reportIssue(ExpressionUtils.methodName((MethodInvocationTree) expression), mit,
          String.format(""Replace \""%s\"" with the overload that accepts an offset parameter."", mit.methodSymbol().name()));
      }
    }
  }
}
"
S4682,CODE_SMELL,"""@CheckForNull"" or ""@Nullable"" should not be used on primitive types","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;
import static org.sonar.plugins.java.api.semantic.SymbolMetadata.NullabilityLevel.METHOD;

@Rule(key = ""S4682"")
public final class PrimitivesMarkedNullableCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    TypeTree returnType = methodTree.returnType();
    if (returnType.symbolType().isPrimitive()) {
      SymbolMetadata.NullabilityData nullabilityData = methodTree.symbol().metadata().nullabilityData();
      if (nullabilityData.isNullable(METHOD, true, false)) {
        SymbolMetadata.AnnotationInstance annotation = nullabilityData.annotation();
        Tree annotationTree = nullabilityData.declaration();
        // Both ""annotation"" and ""declaration"" should never be null, as we only target directly annotated methods. We keep the check for defensive programming.
        if (annotation != null && annotationTree != null) {
          String annotationName = annotation.symbol().name();
          QuickFixHelper.newIssue(context)
            .forRule(this)
            .onTree(returnType)
            .withMessage(""\""@%s\"" annotation should not be used on primitive types"", annotationName)
            .withSecondaries(new JavaFileScannerContext.Location(""Child annotation"", annotationTree))
            .withQuickFix(() ->
              JavaQuickFix.newQuickFix(""Remove \""@%s\"""", annotationName)
                .addTextEdit(JavaTextEdit.removeTextSpan(textSpanBetween(annotationTree, true,
                  QuickFixHelper.nextToken(annotationTree), false)))
                .build())
            .report();
        }
      }
    }
  }

}
"
S4684,VULNERABILITY,"Persistent entities should not be used as arguments of ""@RequestMapping"" methods","package org.sonar.java.checks.spring;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S4684"")
public class PersistentEntityUsedAsRequestParameterCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  private static final List<String> PARAMETER_ANNOTATION_EXCEPTIONS = List.of(
    ""org.springframework.web.bind.annotation.PathVariable"",
    ""org.springframework.security.core.annotation.AuthenticationPrincipal""
  );

  private static final List<String> REQUEST_ANNOTATIONS = List.of(
    ""org.springframework.web.bind.annotation.RequestMapping"",
    ""org.springframework.web.bind.annotation.GetMapping"",
    ""org.springframework.web.bind.annotation.PostMapping"",
    ""org.springframework.web.bind.annotation.PutMapping"",
    ""org.springframework.web.bind.annotation.DeleteMapping"",
    ""org.springframework.web.bind.annotation.PatchMapping""
  );

  private static final List<String> ENTITY_ANNOTATIONS = List.of(
    ""javax.persistence.Entity"",
    ""org.springframework.data.mongodb.core.mapping.Document"",
    ""org.springframework.data.elasticsearch.annotations.Document""
  );

  private static final String JSON_CREATOR_ANNOTATION = ""com.fasterxml.jackson.annotation.JsonCreator"";

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    Symbol.MethodSymbol methodSymbol = methodTree.symbol();

    if (isRequestMappingAnnotated(methodSymbol)) {
      methodTree.parameters().stream()
        .filter(PersistentEntityUsedAsRequestParameterCheck::hasNoAllowedAnnotations)
        .filter(PersistentEntityUsedAsRequestParameterCheck::isPersistentEntity)
        .filter(PersistentEntityUsedAsRequestParameterCheck::hasNoCustomSerialization)
        .forEach(p -> reportIssue(p.simpleName(), ""Replace this persistent entity with a simple POJO or DTO object.""));
    }
  }

  private static boolean isRequestMappingAnnotated(Symbol.MethodSymbol methodSymbol) {
    return REQUEST_ANNOTATIONS.stream().anyMatch(methodSymbol.metadata()::isAnnotatedWith);
  }

  private static boolean isPersistentEntity(VariableTree variableTree) {
    return ENTITY_ANNOTATIONS.stream().anyMatch(variableTree.type().symbolType().symbol().metadata()::isAnnotatedWith);
  }

  private static boolean hasNoAllowedAnnotations(VariableTree variableTree) {
    return PARAMETER_ANNOTATION_EXCEPTIONS.stream().noneMatch(variableTree.symbol().metadata()::isAnnotatedWith);
  }

  private static boolean hasNoCustomSerialization(VariableTree variableTree) {
    Symbol.TypeSymbol entitySymbol = variableTree.type().symbolType().symbol();
    return entitySymbol.memberSymbols().stream().noneMatch(member -> member.isMethodSymbol() && member.metadata().isAnnotatedWith(JSON_CREATOR_ANNOTATION));
  }
}
"
S4719,CODE_SMELL,"""StandardCharsets"" constants should be preferred","package org.sonar.java.checks;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonarsource.analyzer.commons.collections.ListUtils;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4719"")
public class StandardCharsetsConstantsCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final String INT = ""int"";
  private static final String BOOLEAN = ""boolean"";
  private static final String BYTE_ARRAY = ""byte[]"";

  private static final String TO_STRING = ""toString"";
  private static final String WRITE = ""write"";

  private static final String JAVA_IO_FILE = ""java.io.File"";
  private static final String JAVA_IO_INPUTSTREAM = ""java.io.InputStream"";
  private static final String JAVA_IO_OUTPUTSTREAM = ""java.io.OutputStream"";
  private static final String JAVA_IO_OUTPUTSTREAMWRITER = ""java.io.OutputStreamWriter"";
  private static final String JAVA_IO_INPUTSTREAMREADER = ""java.io.InputStreamReader"";
  private static final String JAVA_IO_BYTEARRAYOUTPUTSTREAM = ""java.io.ByteArrayOutputStream"";
  private static final String JAVA_IO_WRITER = ""java.io.Writer"";
  private static final String JAVA_IO_READER = ""java.io.Reader"";
  private static final String JAVA_NIO_CHARSET = ""java.nio.charset.Charset"";
  private static final String JAVA_NIO_STANDARD_CHARSETS = ""java.nio.charset.StandardCharsets"";
  private static final String JAVA_NIO_FILE_PATH = ""java.nio.file.Path"";
  private static final String JAVA_NIO_CHANNELS_READABLEBYTECHANNEL = ""java.nio.channels.ReadableByteChannel"";
  private static final String JAVA_NET_URI = ""java.net.URI"";
  private static final String JAVA_NET_URL = ""java.net.URL"";
  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String JAVA_LANG_STRINGBUFFER = ""java.lang.StringBuffer"";
  private static final String JAVA_LANG_CHARSEQUENCE = ""java.lang.CharSequence"";
  private static final String JAVA_UTIL_COLLECTION = ""java.util.Collection"";
  private static final String JAVA_UTIL_SCANNER = ""java.util.Scanner"";

  private static final String COMMONS_CODEC_CHARSETS = ""org.apache.commons.codec.Charsets"";
  private static final String COMMONS_CODEC_HEX = ""org.apache.commons.codec.binary.Hex"";
  private static final String COMMONS_CODEC_QUOTEDPRINTABLECODEC = ""org.apache.commons.codec.net.QuotedPrintableCodec"";
  private static final String COMMONS_IO = ""org.apache.commons.io"";
  private static final String COMMONS_IO_CHARSETS = COMMONS_IO + "".Charsets"";
  private static final String COMMONS_IO_FILEUTILS = COMMONS_IO + "".FileUtils"";
  private static final String COMMONS_IO_IOUTILS = COMMONS_IO + "".IOUtils"";
  private static final String COMMONS_IO_CHARSEQUENCEINPUTSTREAM = COMMONS_IO + "".input.CharSequenceInputStream"";
  private static final String COMMONS_IO_READERINPUTSTREAM = COMMONS_IO + "".input.ReaderInputStream"";
  private static final String COMMONS_IO_REVERSEDLINESFILEREADER = COMMONS_IO + "".input.ReversedLinesFileReader"";
  private static final String COMMONS_IO_LOCKABLEFILEWRITER = COMMONS_IO + "".output.LockableFileWriter"";
  private static final String COMMONS_IO_WRITEROUTPUTSTREAM = COMMONS_IO + "".output.WriterOutputStream"";
  private static final String REPLACE_WITH_STANDARD_CHARSETS = ""Replace with \""StandardCharsets."";


  private static final List<Charset> STANDARD_CHARSETS = Arrays.asList(
          StandardCharsets.ISO_8859_1,
          StandardCharsets.US_ASCII,
          StandardCharsets.UTF_16,
          StandardCharsets.UTF_16BE,
          StandardCharsets.UTF_16LE,
          StandardCharsets.UTF_8);

  private static final Map<String, String> ALIAS_TO_CONSTANT = createAliasToConstantNameMap();
  private static final int JAVA_10 = 10;

  private QuickFixHelper.ImportSupplier importSupplier;

  private static final MethodMatchers JAVA10_METHOD_MATCHERS = MethodMatchers.or(
    MethodMatchers.create().ofTypes(JAVA_IO_BYTEARRAYOUTPUTSTREAM).names(TO_STRING)
      .addParametersMatcher(JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(JAVA_UTIL_SCANNER).constructor()
      .addParametersMatcher(JAVA_IO_INPUTSTREAM, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_IO_FILE, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_NIO_FILE_PATH, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_NIO_CHANNELS_READABLEBYTECHANNEL, JAVA_LANG_STRING)
      .build());

  private static final MethodMatchers JAVA8_METHOD_MATCHERS = MethodMatchers.or(
    MethodMatchers.create().ofTypes(JAVA_NIO_CHARSET).names(""forName"")
      .addParametersMatcher(JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(JAVA_LANG_STRING).names(""getBytes"")
      .addParametersMatcher(JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_NIO_CHARSET)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_CODEC_CHARSETS, COMMONS_IO_CHARSETS).names(""toCharset"")
      .addParametersMatcher(JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_FILEUTILS).names(""readFileToString"", ""readLines"")
      .addParametersMatcher(JAVA_IO_FILE, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_FILEUTILS).names(WRITE)
      .addParametersMatcher(JAVA_IO_FILE, JAVA_LANG_CHARSEQUENCE, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_IO_FILE, JAVA_LANG_CHARSEQUENCE, JAVA_LANG_STRING, BOOLEAN)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_FILEUTILS).names(""writeStringToFile"")
      .addParametersMatcher(JAVA_IO_FILE, JAVA_LANG_STRING, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_IO_FILE, JAVA_LANG_STRING, JAVA_LANG_STRING, BOOLEAN)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_IOUTILS).names(""copy"")
      .addParametersMatcher(JAVA_IO_INPUTSTREAM, JAVA_IO_WRITER, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_IO_READER, JAVA_IO_OUTPUTSTREAM, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_IOUTILS).names(""lineIterator"")
      .addParametersMatcher(JAVA_IO_INPUTSTREAM, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_IOUTILS).names(""readLines"")
      .addParametersMatcher(JAVA_IO_INPUTSTREAM, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_IOUTILS).names(""toByteArray"")
      .addParametersMatcher(JAVA_IO_READER, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_IOUTILS).names(""toCharArray"")
      .addParametersMatcher(JAVA_IO_INPUTSTREAM, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_IOUTILS).names(""toInputStream"")
      .addParametersMatcher(JAVA_LANG_CHARSEQUENCE, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_IOUTILS).names(TO_STRING)
      .addParametersMatcher(BYTE_ARRAY, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_IO_INPUTSTREAM, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_NET_URI, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_NET_URL, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_IOUTILS).names(WRITE)
      .addParametersMatcher(BYTE_ARRAY, JAVA_IO_WRITER, JAVA_LANG_STRING)
      .addParametersMatcher(""char[]"", JAVA_IO_OUTPUTSTREAM, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_LANG_CHARSEQUENCE, JAVA_IO_OUTPUTSTREAM, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_LANG_STRING, JAVA_IO_OUTPUTSTREAM, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_LANG_STRINGBUFFER, JAVA_IO_OUTPUTSTREAM, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_IOUTILS).names(""writeLines"")
      .addParametersMatcher(JAVA_UTIL_COLLECTION, JAVA_LANG_STRING, JAVA_IO_OUTPUTSTREAM, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(JAVA_LANG_STRING).constructor()
      .addParametersMatcher(BYTE_ARRAY, JAVA_LANG_STRING)
      .addParametersMatcher(BYTE_ARRAY, INT, INT, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(JAVA_IO_INPUTSTREAMREADER).constructor()
      .addParametersMatcher(JAVA_IO_INPUTSTREAM, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(JAVA_IO_OUTPUTSTREAMWRITER).constructor()
      .addParametersMatcher(JAVA_IO_OUTPUTSTREAM, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_CHARSEQUENCEINPUTSTREAM).constructor()
      .addParametersMatcher(JAVA_LANG_CHARSEQUENCE, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_LANG_CHARSEQUENCE, JAVA_LANG_STRING, INT)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_READERINPUTSTREAM).constructor()
      .addParametersMatcher(JAVA_IO_READER, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_IO_READER, JAVA_LANG_STRING, INT)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_REVERSEDLINESFILEREADER).constructor()
      .addParametersMatcher(JAVA_IO_FILE, INT, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_LOCKABLEFILEWRITER).constructor()
      .addParametersMatcher(JAVA_IO_FILE, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_IO_FILE, JAVA_LANG_STRING, BOOLEAN, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_IO_WRITEROUTPUTSTREAM).constructor()
      .addParametersMatcher(JAVA_IO_WRITER, JAVA_LANG_STRING)
      .addParametersMatcher(JAVA_IO_WRITER, JAVA_LANG_STRING, INT, BOOLEAN)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_CODEC_HEX).constructor()
      .addParametersMatcher(JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create().ofTypes(COMMONS_CODEC_QUOTEDPRINTABLECODEC).constructor()
      .addParametersMatcher(JAVA_LANG_STRING)
      .build());

  private static Map<String, String> createAliasToConstantNameMap() {
    MapBuilder<String, String> constantNames = MapBuilder.newMap();
    for (Charset charset : STANDARD_CHARSETS) {
      String constantName = charset.name().replace(""-"", ""_"");
      constantNames.put(charset.name(), constantName);

      for (String alias : charset.aliases()) {
        constantNames.put(alias.toUpperCase(Locale.ROOT), constantName);
      }
    }

    return constantNames.build();
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    super.setContext(context);
    importSupplier = null;
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    importSupplier = null;
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS, Tree.Kind.IDENTIFIER);
  }

  @Override
  public void visitNode(Tree tree) {
    super.visitNode(tree);
    if (tree.is(Tree.Kind.IDENTIFIER)) {
      onMemberSelectExpressionFound((IdentifierTree) tree);
    }
  }

  private void onMemberSelectExpressionFound(IdentifierTree identifierTree) {
    Symbol symbol = identifierTree.symbol();
    if (symbol.isVariableSymbol() && symbol.owner().type().is(""com.google.common.base.Charsets"")) {
      String identifier = identifierTree.name();
      String aliasedIdentifier = identifier.replace(""_"", ""-"");
      if (STANDARD_CHARSETS.stream().anyMatch(c -> c.name().equals(aliasedIdentifier))) {
        reportQuickfixOnMemberSelect(identifierTree, identifier);
      }
    }
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    checkCall(mit, mit.methodSymbol(), mit.arguments());
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    checkCall(newClassTree, newClassTree.methodSymbol(), newClassTree.arguments());
  }

  private void checkCall(ExpressionTree callExpression, Symbol.MethodSymbol symbol, Arguments arguments) {
    getCharsetNameArgument(symbol, arguments)
      .ifPresent(charsetNameArgument -> getConstantName(charsetNameArgument)
        .ifPresent(constantName -> {
          String methodRef = getMethodRef(symbol);
          switch (methodRef) {
            case ""Charset.forName"":
            case ""Charsets.toCharset"":
              reportQuickfixOnCharsetCall(callExpression, constantName, methodRef);
              break;
            case ""IOUtils.toString"":
              if (arguments.size() == 2 && arguments.get(0).symbolType().is(BYTE_ARRAY)) {
                String issueMsg = String.format(""Replace IOUtils.toString() call with new String(..., StandardCharsets.%s);"", constantName);
                reportIssue(callExpression, issueMsg);
              } else {
                reportDefaultQuickfix(charsetNameArgument, constantName);
              }
              break;
            default:
              reportDefaultQuickfix(charsetNameArgument, constantName);
              break;
          }
        }));
  }

  private void reportQuickfixOnMemberSelect(IdentifierTree identifierTree, String identifier) {
    String issueMsg = String.format(""Replace \""com.google.common.base.Charsets.%s\"" with \""StandardCharsets.%s\""."", identifier, identifier);
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(identifierTree)
      .withMessage(issueMsg)
      .withQuickFixes(() -> quickFixesOnMemberSelect(identifierTree))
      .report();
  }

  private void reportQuickfixOnCharsetCall(ExpressionTree callExpression, String constantName, String methodRef) {
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(callExpression)
      .withMessage(String.format(""Replace %s() call with StandardCharsets.%s"", methodRef, constantName))
      .withQuickFix(() -> quickfixOnCharsetCall(callExpression, constantName))
      .report();
  }

  private JavaQuickFix quickfixOnCharsetCall(ExpressionTree callExpression, String constantName) {
    List<JavaTextEdit> edits = new ArrayList<>();
    edits.add(JavaTextEdit.replaceTree(callExpression, ""StandardCharsets."" + constantName));

    getImportSupplier()
      .newImportEdit(JAVA_NIO_STANDARD_CHARSETS)
      .ifPresent(edits::add);

    return JavaQuickFix.newQuickFix(REPLACE_WITH_STANDARD_CHARSETS + constantName + ""\"""")
        .addTextEdits(edits)
        .build();
  }

  private List<JavaQuickFix> quickFixesOnMemberSelect(IdentifierTree identifierTree) {
    Tree parent = identifierTree.parent();
    if (parent.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree parentMemberSelect = (MemberSelectExpressionTree) parent;

      List<JavaTextEdit> edits = new ArrayList<>();
      edits.add(JavaTextEdit.replaceTree(parentMemberSelect.expression(), ""StandardCharsets""));

      getImportSupplier()
        .newImportEdit(JAVA_NIO_STANDARD_CHARSETS)
        .ifPresent(edits::add);

      return List.of(
        JavaQuickFix.newQuickFix(REPLACE_WITH_STANDARD_CHARSETS + identifierTree.name() + ""\"""")
          .addTextEdits(edits)
          .build()
      );
    }
    return Collections.emptyList();
  }

  private void reportDefaultQuickfix(ExpressionTree charsetNameArgument, String constantName) {
    List<JavaTextEdit> edits = new ArrayList<>();
    edits.add(JavaTextEdit.replaceTree(charsetNameArgument, ""StandardCharsets."" + constantName));

    getImportSupplier()
      .newImportEdit(JAVA_NIO_STANDARD_CHARSETS)
      .ifPresent(edits::add);

    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(charsetNameArgument)
      .withMessage(String.format(""Replace charset name argument with StandardCharsets.%s"", constantName))
      .withQuickFix(() -> JavaQuickFix.newQuickFix(REPLACE_WITH_STANDARD_CHARSETS + constantName + ""\"""")
          .addTextEdits(edits)
          .build())
      .report();
  }

  private QuickFixHelper.ImportSupplier getImportSupplier() {
    if (importSupplier == null) {
      importSupplier = QuickFixHelper.newImportSupplier(context);
    }
    return importSupplier;
  }

  private static Optional<ExpressionTree> getCharsetNameArgument(Symbol symbol, Arguments arguments) {
    List<ExpressionTree> stringArguments = arguments.stream().filter(
      argument -> argument.symbolType().is(JAVA_LANG_STRING)).toList();
    if (stringArguments.isEmpty()) {
      return Optional.empty();
    }
    if (stringArguments.size() == 1) {
      return Optional.of(stringArguments.get(0));
    }
    switch (getMethodRef(symbol)) {
      case ""FileUtils.writeStringToFile"":
      case ""IOUtils.toInputStream"":
      case ""IOUtils.write"":
      case ""IOUtils.writeLines"":
        return Optional.of(ListUtils.getLast(stringArguments));
      case ""LockableFileWriter.<init>"":
        return Optional.of(stringArguments.get(0));
      default:
        return Optional.empty();
    }
  }

  private static String getMethodRef(Symbol symbol) {
    return symbol.enclosingClass().name() + ""."" + symbol.name();
  }

  private static Optional<String> getConstantName(ExpressionTree argument) {
    return argument.asConstant(String.class)
      .map(String::toUpperCase)
      .map(ALIAS_TO_CONSTANT::get);
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava7Compatible();
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    if (context.getJavaVersion().asInt() >= JAVA_10) {
      return MethodMatchers.or(JAVA8_METHOD_MATCHERS, JAVA10_METHOD_MATCHERS);
    } else {
      return JAVA8_METHOD_MATCHERS;
    }
  }
}
"
S4738,CODE_SMELL,Java features should be preferred to Guava,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S4738"")
public class ReplaceGuavaWithJavaCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final String USE_INSTEAD = ""Use \""%s\"" instead."";

  private static final String GUAVA_BASE_ENCODING = ""com.google.common.io.BaseEncoding"";
  private static final String GUAVA_OPTIONAL = ""com.google.common.base.Optional"";
  private static final String GUAVA_FILES = ""com.google.common.io.Files"";
  private static final String GUAVA_IMMUTABLE_SET = ""com.google.common.collect.ImmutableSet"";
  private static final String GUAVA_IMMUTABLE_LIST = ""com.google.common.collect.ImmutableList"";
  private static final String GUAVA_IMMUTABLE_MAP = ""com.google.common.collect.ImmutableMap"";

  private static final Map<String, String> GUAVA_TO_JAVA_UTIL_TYPES = MapBuilder.<String, String>newMap()
    .put(""com.google.common.base.Predicate"", ""java.util.function.Predicate"")
    .put(""com.google.common.base.Function"", ""java.util.function.Function"")
    .put(""com.google.common.base.Supplier"", ""java.util.function.Supplier"")
    .put(GUAVA_OPTIONAL, ""java.util.Optional"")
    .build();

  private static final Map<String, String> GUAVA_OPTIONAL_TO_JAVA_UTIL_METHODS = MapBuilder.<String, String>newMap()
    .put(""of"", ""of"")
    .put(""absent"", ""empty"")
    .put(""fromNullable"", ""ofNullable"")
    .build();

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava8Compatible();
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofTypes(GUAVA_BASE_ENCODING).names(""base64"", ""base64Url"").addWithoutParametersMatcher().build(),
      MethodMatchers.create().ofTypes(GUAVA_OPTIONAL).names(""absent"").addWithoutParametersMatcher().build(),
      MethodMatchers.create().ofTypes(GUAVA_OPTIONAL).names(""fromNullable"", ""of"").withAnyParameters().build(),
      MethodMatchers.create().ofTypes(GUAVA_FILES).names(""createTempDir"").addWithoutParametersMatcher().build(),
      MethodMatchers.create().ofTypes(GUAVA_IMMUTABLE_LIST, GUAVA_IMMUTABLE_SET, GUAVA_IMMUTABLE_MAP)
        .names(""of"").withAnyParameters().build());
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    ArrayList<Tree.Kind> kinds = new ArrayList<>(super.nodesToVisit());
    kinds.add(Tree.Kind.VARIABLE);
    return kinds;
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.VARIABLE)) {
      checkTypeToReplace((VariableTree) tree);
    } else {
      super.visitNode(tree);
    }
  }

  private void checkTypeToReplace(VariableTree variableTree) {
    String fullyQualifiedTypeName = variableTree.type().symbolType().fullyQualifiedName();
    if (GUAVA_TO_JAVA_UTIL_TYPES.containsKey(fullyQualifiedTypeName)) {
      reportIssue(variableTree.type(), replacementMessage(GUAVA_TO_JAVA_UTIL_TYPES.get(fullyQualifiedTypeName)));
    }
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    switch(mit.methodSymbol().owner().type().fullyQualifiedName()) {
      case GUAVA_BASE_ENCODING:
        reportIssue(mit, replacementMessage(""java.util.Base64""));
        break;
      case GUAVA_OPTIONAL:
        reportIssue(mit, replacementMessage(""java.util.Optional."" + GUAVA_OPTIONAL_TO_JAVA_UTIL_METHODS.get(mit.methodSymbol().name())));
        break;
      case GUAVA_FILES:
        reportIssue(mit, replacementMessage(""java.nio.file.Files.createTempDirectory""));
        break;
      case GUAVA_IMMUTABLE_LIST:
        reportJava9Issue(mit, ""java.util.List.of()"");
        break;
      case GUAVA_IMMUTABLE_SET:
        reportJava9Issue(mit, ""java.util.Set.of()"");
        break;
      case GUAVA_IMMUTABLE_MAP:
        reportJava9Issue(mit, ""java.util.Map.of()\"" or \""java.util.Map.ofEntries()"");
        break;
      default:
        break;
    }
  }

  private void reportJava9Issue(MethodInvocationTree mit, String replacement) {
    if (context.getJavaVersion().isJava9Compatible()) {
      reportIssue(mit, replacementMessage(replacement));
    }
  }

  private String replacementMessage(String replacement) {
    return String.format(USE_INSTEAD, replacement) + context.getJavaVersion().java8CompatibilityMessage();
  }
}
"
S4790,SECURITY_HOTSPOT,Using weak hashing algorithms is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Optional;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.AbstractHashAlgorithmChecker;
import org.sonarsource.analyzer.commons.collections.SetUtils;

@Rule(key = ""S4790"")
public class DataHashingCheck extends AbstractHashAlgorithmChecker {

  private static final Set<String> DEPRECATED_HASH_CLASSES = SetUtils.immutableSetOf(
    DeprecatedSpringPasswordEncoder.MD5.classFqn,
    DeprecatedSpringPasswordEncoder.SHA.classFqn,
    DeprecatedSpringPasswordEncoder.LDAP.classFqn,
    DeprecatedSpringPasswordEncoder.MD4.classFqn,
    DeprecatedSpringPasswordEncoder.MESSAGE_DIGEST.classFqn,
    DeprecatedSpringPasswordEncoder.NO_OP.classFqn,
    DeprecatedSpringPasswordEncoder.STANDARD.classFqn
  );

  private static final String MESSAGE = ""Make sure this weak hash algorithm is not used in a sensitive context here."";

  @Override
  protected Optional<String> getMessageForClass(String className) {
    return DEPRECATED_HASH_CLASSES.contains(className) ? Optional.of(MESSAGE) : Optional.empty();
  }

  @Override
  protected String getMessageForAlgorithm(String algorithmName) {
    return MESSAGE;
  }
}
"
S4792,SECURITY_HOTSPOT,Configuring loggers is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

@Rule(key = ""S4792"")
public class LogConfigurationCheck extends AbstractMethodDetection {

  private static final String LOG4J_CONFIGURATOR = ""org.apache.logging.log4j.core.config.Configurator"";
  private static final String LOG4J_CONFIGURATION_SOURCE = ""org.apache.logging.log4j.core.config.ConfigurationSource"";
  private static final String MESSAGE = ""Make sure that this logger's configuration is safe."";
  private static final String SET_LEVEL = ""setLevel"";
  private static final String ADD_APPENDER = ""addAppender"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS, Tree.Kind.METHOD_REFERENCE, Tree.Kind.CLASS);
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofTypes(""org.apache.logging.log4j.core.config.builder.api.ConfigurationBuilderFactory"")
        .names(""newConfigurationBuilder"")
        .addWithoutParametersMatcher()
        .build(),
      MethodMatchers.create()
        .ofTypes(LOG4J_CONFIGURATOR)
        .names(""setAllLevels"", SET_LEVEL, ""setRootLevel"")
        .withAnyParameters()
        .build(),
      MethodMatchers.create()
        .ofTypes(""org.apache.logging.log4j.core.config.Configuration"")
        .names(ADD_APPENDER)
        .withAnyParameters()
        .build(),
      MethodMatchers.create()
        .ofTypes(""org.apache.logging.log4j.core.config.LoggerConfig"")
        .names(ADD_APPENDER, SET_LEVEL)
        .withAnyParameters()
        .build(),
      MethodMatchers.create()
        .ofTypes(""org.apache.logging.log4j.core.LoggerContext"")
        .names(""setConfigLocation"")
        .withAnyParameters()
        .build(),
      MethodMatchers.create().ofTypes(LOG4J_CONFIGURATION_SOURCE).names(""<init>"", ""fromResource"", ""fromUri"").withAnyParameters().build(),
      MethodMatchers.create().ofTypes(""java.util.logging.LogManager"").names(""readConfiguration"").withAnyParameters().build(),
      MethodMatchers.create().ofTypes(""java.util.logging.Logger"").names(SET_LEVEL, ""addHandler"").withAnyParameters().build(),
      MethodMatchers.create().ofTypes(""ch.qos.logback.classic.Logger"").names(ADD_APPENDER, SET_LEVEL).withAnyParameters().build(),
      MethodMatchers.create().ofTypes(""ch.qos.logback.classic.joran.JoranConfigurator"").constructor().withAnyParameters().build(),
      MethodMatchers.create().ofTypes(""java.lang.System"").names(""setProperty"").addParametersMatcher(""java.lang.String"", ""java.lang.String"").build());
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.CLASS)) {
      checkConfigurationFactoryExtension(((ClassTree) tree));
    } else {
      super.visitNode(tree);
    }
  }

  private void checkConfigurationFactoryExtension(ClassTree tree) {
    TypeTree superClass = tree.superClass();
    if (superClass != null && superClass.symbolType().is(""org.apache.logging.log4j.core.config.ConfigurationFactory"")) {
      reportIssue(superClass, MESSAGE);
    }
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (""setProperty"".equals(mit.methodSymbol().name())) {
      String stringConstant = ExpressionsHelper.getConstantValueAsString(mit.arguments().get(0)).value();
      if (""logback.configurationFile"".equals(stringConstant)) {
        reportIssue(mit, MESSAGE);
      }
    } else {
      reportIssue(mit, MESSAGE);
    }
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    reportIssue(newClassTree, MESSAGE);
  }
}
"
S4830,VULNERABILITY,Server certificates should be verified during SSL/TLS connections,"package org.sonar.java.checks.security;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;@Rule(key = ""S4830"")
public class ServerCertificatesCheck extends IssuableSubscriptionVisitor {
  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String X509_CERTIFICATE_ARRAY = ""java.security.cert.X509Certificate[]"";

  private static final MethodMatchers TRUST_MANAGER_MATCHER = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(""javax.net.ssl.X509TrustManager"")
      .names(""checkClientTrusted"", ""checkServerTrusted"")
      .addParametersMatcher(X509_CERTIFICATE_ARRAY, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""javax.net.ssl.X509ExtendedTrustManager"")
      .names(""checkClientTrusted"", ""checkServerTrusted"")
      .addParametersMatcher(X509_CERTIFICATE_ARRAY, JAVA_LANG_STRING, ""java.net.Socket"")
      .addParametersMatcher(X509_CERTIFICATE_ARRAY, JAVA_LANG_STRING, ""javax.net.ssl.SSLEngine"")
      .build()
  );

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    BlockTree blockTree = methodTree.block();
    if (blockTree == null) {
      return;
    }
    if (TRUST_MANAGER_MATCHER.matches(methodTree) &&
      (blockTree.body().isEmpty() || !ThrowExceptionVisitor.throwsException(blockTree))) {
      reportIssue(methodTree.simpleName(), ""Enable server certificate validation on this SSL/TLS connection."");
    }
  }

  private static class ThrowExceptionVisitor extends BaseTreeVisitor {
    boolean throwsException = false;

    private static boolean throwsException(Tree tree) {
      ThrowExceptionVisitor visitor = new ThrowExceptionVisitor();
      tree.accept(visitor);
      return visitor.throwsException;
    }

    @Override
    public void visitThrowStatement(ThrowStatementTree tree) {
      super.visitThrowStatement(tree);
      throwsException = true;
    }

    @Override
    public void visitNewClass(NewClassTree tree) {
      super.visitNewClass(tree);
      visitMethodSymbol(tree.methodSymbol());
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      super.visitMethodInvocation(tree);
      visitMethodSymbol(tree.methodSymbol());
    }

    private void visitMethodSymbol(Symbol.MethodSymbol symbol) {
      if (!symbol.isUnknown()) {
        throwsException |= !symbol.thrownTypes().isEmpty();
      } else {
        // JavaSymbolNotFound, to avoid FP, assumes it throws exceptions
        throwsException = true;
      }
    }

  }

}
"
S4838,CODE_SMELL,An iteration on a Collection should be performed on the type handled by the Collection,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;

@Rule(key = ""S4838"")
public class ForLoopVariableTypeCheck extends IssuableSubscriptionVisitor {

  private static final String PRIMARY_MESSAGE = ""Change \""%s\"" to the type handled by the Collection."";
  private static final String SECONDARY_MESSAGE = ""Collection item type is \""%s\"""";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.FOR_EACH_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ForEachStatement actualStatement = (ForEachStatement) tree;
    Type variableType = actualStatement.variable().type().symbolType();
    Type collectionItemType = getCollectionItemType(actualStatement.expression());

    if (collectionItemType == null || collectionItemType.isUnknown() || variableType.isUnknown()) {
      return;
    }

    if (!isMostPreciseType(variableType, collectionItemType)) {
      // Second pass: check if the variable is down-cast in the statement block
      DownCastVisitor downCastVisitor = new DownCastVisitor(actualStatement.variable().symbol());
      actualStatement.statement().accept(downCastVisitor);

      if (downCastVisitor.hasDownCastOfLoopVariable) {
        List<JavaFileScannerContext.Location> locations = Collections.singletonList(
          new JavaFileScannerContext.Location(String.format(SECONDARY_MESSAGE, collectionItemType.name()), actualStatement.expression()));
        reportIssue(actualStatement.variable().type(), String.format(PRIMARY_MESSAGE, variableType.name()),
          locations, 0);
      }
    }
  }

  @CheckForNull
  private static Type getCollectionItemType(ExpressionTree expression) {
    Type expressionType = expression.symbolType();
    if (expressionType.isSubtypeOf(""java.util.Collection"") && !expressionType.isParameterized()) {
      // Ignoring raw collections (too many FP)
      return null;
    }
    if (expressionType.isArray()) {
      return ((Type.ArrayType) expressionType).elementType();
    }
    if(expressionType.isClass()) {
      return expressionType.symbol().superTypes().stream()
        .filter(t -> t.is(""java.lang.Iterable"") && t.isParameterized())
        .findFirst()
        .map(iter -> iter.typeArguments().get(0))
        .orElse(null);
    }
    return null;
  }

  private static boolean isMostPreciseType(Type variableType, Type collectionItemType) {
    return variableType.erasure().equals(collectionItemType.erasure());
  }

  private static class DownCastVisitor extends BaseTreeVisitor {

    private final Symbol symbol;
    private boolean hasDownCastOfLoopVariable;

    private DownCastVisitor(Symbol symbol) {
      this.symbol = symbol;
      this.hasDownCastOfLoopVariable = false;
    }

    @Override
    public void visitTypeCast(TypeCastTree tree) {
      if (hasDownCastOfLoopVariable) {
        return;
      }
      ExpressionTree expression = tree.expression();
      if (expression.is(Tree.Kind.IDENTIFIER) && ((IdentifierTree) expression).symbol().equals(symbol)) {
        hasDownCastOfLoopVariable = true;
      } else {
        super.visitTypeCast(tree);
      }
    }
  }
}
"
S4925,CODE_SMELL,"""Class.forName()"" should not load JDBC 4.0+ drivers","package org.sonar.java.checks;

import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S4925"")
public class JdbcDriverExplicitLoadingCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final Set<String> JDBC_4_DRIVERS = SetUtils.immutableSetOf(
    ""com.mysql.jdbc.Driver"",
    ""oracle.jdbc.driver.OracleDriver"",
    ""com.ibm.db2.jdbc.app.DB2Driver"",
    ""com.ibm.db2.jdbc.net.DB2Driver"",
    ""com.sybase.jdbc.SybDriver"",
    ""com.sybase.jdbc2.jdbc.SybDriver"",
    ""com.teradata.jdbc.TeraDriver"",
    ""com.microsoft.sqlserver.jdbc.SQLServerDriver"",
    ""org.postgresql.Driver"",
    ""sun.jdbc.odbc.JdbcOdbcDriver"",
    ""org.hsqldb.jdbc.JDBCDriver"",
    ""org.h2.Driver"",
    ""org.firebirdsql.jdbc.FBDriver"",
    ""net.sourceforge.jtds.jdbc.Driver"",
    ""com.ibm.db2.jcc.DB2Driver""
  );

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.lang.Class"")
      .names(""forName"")
      .addParametersMatcher(""java.lang.String"")
      .build();
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava6Compatible();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    mit.arguments().get(0).asConstant(String.class).ifPresent(driverClassName -> {
      if (JDBC_4_DRIVERS.contains(driverClassName)) {
        reportIssue(ExpressionUtils.methodName(mit), ""Remove this \""Class.forName()\"", it is useless."" + context.getJavaVersion().java6CompatibilityMessage());
      }
    });
  }
}
"
S4926,CODE_SMELL,"""serialVersionUID"" should not be declared blindly","package org.sonar.java.checks.serialization;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4926"")
public class BlindSerialVersionUidCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    Symbol.TypeSymbol symbol = ((ClassTree) tree).symbol();
    if (isSerializable(symbol.type())) {
      findSerialVersionUid(symbol)
        .filter(BlindSerialVersionUidCheck::isValidSerialVersionUid)
        .map(serialVersionUidSymbol -> serialVersionUidSymbol.declaration().simpleName())
        .ifPresent(declarationTree -> reportIssue(declarationTree, ""Remove this \""serialVersionUID\"".""));
    }
  }

  private static Optional<Symbol.VariableSymbol> findSerialVersionUid(Symbol.TypeSymbol symbol) {
    return symbol.lookupSymbols(""serialVersionUID"").stream()
      .filter(Symbol::isVariableSymbol)
      .map(Symbol.VariableSymbol.class::cast)
      .findFirst();
  }

  private static boolean isValidSerialVersionUid(Symbol.VariableSymbol serialVersionUidSymbol) {
    return serialVersionUidSymbol.isStatic() &&
      serialVersionUidSymbol.isFinal() &&
      serialVersionUidSymbol.type().isPrimitive(Type.Primitives.LONG);
  }

  private static boolean isSerializable(Type type) {
    return type.isSubtypeOf(""java.io.Serializable"");
  }
}
"
S4929,CODE_SMELL,"""read(byte[],int,int)"" should be overridden","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4929"")
public class InputStreamOverrideReadCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers READ_BYTES_INT_INT = MethodMatchers.create()
    .ofAnyType().names(""read"").addParametersMatcher(""byte[]"", ""int"", ""int"").build();
  private static final MethodMatchers READ_INT = MethodMatchers.create()
    .ofAnyType().names(""read"").addParametersMatcher(""int"").build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    Type superType = classTree.symbol().superClass();
    IdentifierTree className = classTree.simpleName();
    if (className == null || classTree.symbol().isAbstract() || superType == null || !(superType.is(""java.io.InputStream"") || superType.is(""java.io.FilterInputStream""))) {
      return;
    }

    Optional<MethodTree> readByteIntInt = findMethod(classTree, READ_BYTES_INT_INT);
    if (!readByteIntInt.isPresent()) {
      String message = findMethod(classTree, READ_INT)
        .filter(readIntTree -> readIntTree.block().body().isEmpty())
        .map(readIntTree -> ""Provide an empty override of \""read(byte[],int,int)\"" for this class as well."")
        .orElse(""Provide an override of \""read(byte[],int,int)\"" for this class."");
      reportIssue(className, message);
    }

  }

  private static Optional<MethodTree> findMethod(ClassTree classTree, MethodMatchers methodMatcher) {
    return classTree.members()
      .stream()
      .filter(m -> m.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .filter(methodMatcher::matches)
      .findFirst();
  }
}
"
S4968,CODE_SMELL,"The upper bound of type variables and wildcards should not be ""final"" ","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeParameterTree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.WildcardTree;

@Rule(key = ""S4968"")
public class TypeUpperBoundNotFinalCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.TYPE_PARAMETER, Tree.Kind.EXTENDS_WILDCARD);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.TYPE_PARAMETER)) {
      handleBounds(((TypeParameterTree) tree).bounds(), tree);
    } else if (tree.is(Tree.Kind.EXTENDS_WILDCARD)) {
      handleBounds(Collections.singletonList(((WildcardTree) tree).bound()), tree);
    }
  }

  private void handleBounds(List<TypeTree> bounds, Tree treeToReport) {
    bounds.stream()
      .map(TypeUpperBoundNotFinalCheck::getIdentifier)
      .flatMap(Optional::stream)
      .filter(bound -> isFinal(bound) && !inOverridingMethodDeclaration(treeToReport))
      .findFirst()
      .ifPresent(identifierTree -> reportIssue(treeToReport, ""Replace this type parametrization by the 'final' type `"" + identifierTree.name() + ""`.""));
  }

  private static Optional<IdentifierTree> getIdentifier(TypeTree t) {
    if (t.is(Tree.Kind.IDENTIFIER)) {
      return Optional.of((IdentifierTree) t);
    } else if (t.is(Tree.Kind.PARAMETERIZED_TYPE)) {
      ParameterizedTypeTree type = (ParameterizedTypeTree) t;
      return getIdentifier(type.type());
    }

    return Optional.empty();
  }

  private static boolean isFinal(IdentifierTree bound) {
    return bound.symbol().isFinal();
  }private static boolean inOverridingMethodDeclaration(Tree type) {
    return getMethodDeclaration(type).filter(TypeUpperBoundNotFinalCheck::isOverriding).isPresent();
  }private static Optional<MethodTree> getMethodDeclaration(Tree type) {
    Tree parent = type.parent();
    while (parent != null && !parent.is(Tree.Kind.BLOCK)) {
      if (parent.is(Tree.Kind.METHOD)) {
        return Optional.of((MethodTree) parent);
      }
      parent = parent.parent();
    }
    return Optional.empty();
  }

  private static boolean isOverriding(MethodTree method) {
    return !Boolean.FALSE.equals(method.isOverriding());
  }
}
"
S4970,CODE_SMELL,Derived exceptions should not hide their parents' catch blocks,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonar.java.model.JProblem;
import org.sonar.java.model.JWarning;
import org.sonar.java.model.JavaTree.CompilationUnitTreeImpl;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext.Location;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.UnionTypeTree;

@Rule(key = ""S4970"")
public class UnreachableCatchCheck extends IssuableSubscriptionVisitor {

  private final List<JWarning> warnings = new ArrayList<>();
  private static final Comparator<Location> LOCATION_COMPARATOR = Comparator.comparing(loc -> Position.startOf(loc.syntaxNode));

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.COMPILATION_UNIT, Tree.Kind.TRY_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      warnings.clear();
      warnings.addAll(((CompilationUnitTreeImpl) tree).warnings(JProblem.Type.MASKED_CATCH));
      return;
    }
    checkWarnings((TryStatementTree) tree);
  }

  private void checkWarnings(TryStatementTree tryStatementTree) {
    List<TypeTree> typesWithWarnings = new ArrayList<>(warnings.size());
    List<UnionTypeTree> unionTypes = new ArrayList<>();
    Map<TypeTree, Type> typeByExceptions = new HashMap<>();
    Map<TypeTree, Tree> reportTrees = new HashMap<>();

    for (CatchTree catchTree : tryStatementTree.catches()) {
      SyntaxToken catchKeyword = catchTree.catchKeyword();
      TypeTree caughtException = catchTree.parameter().type();

      boolean withinUnionType = caughtException.is(Tree.Kind.UNION_TYPE);
      if (withinUnionType) {
        // in case we need to report on the entire union type
        reportTrees.put(caughtException, catchKeyword);
        unionTypes.add((UnionTypeTree) caughtException);
      }

      for (TypeTree typeTree : caughtExceptionTypes(caughtException)) {
        typeByExceptions.put(typeTree, typeTree.symbolType());
        // types from union types should be reported individually
        reportTrees.put(typeTree, withinUnionType ? typeTree : catchKeyword);

        warnings.stream()
          .filter(warning -> typeTree.equals(warning.syntaxTree()))
          .forEach(warning -> typesWithWarnings.add(typeTree));
      }
    }
    reportUnreacheableCatch(typesWithWarnings, typeByExceptions, reportTrees, unionTypes);
  }

  private static List<TypeTree> caughtExceptionTypes(TypeTree caughtException) {
    if (caughtException.is(Tree.Kind.UNION_TYPE)) {
      return ((UnionTypeTree) caughtException).typeAlternatives();
    }
    return Collections.singletonList(caughtException);
  }

  private void reportUnreacheableCatch(List<TypeTree> typesWithWarnings, Map<TypeTree, Type> typeByExceptions, Map<TypeTree, Tree> reportTrees, List<UnionTypeTree> unionTypes) {
    for (TypeTree type : typesToReport(typesWithWarnings, unionTypes)) {
      reportIssue(reportTrees.get(type), message(reportTrees.get(type)), secondaries(type, typeByExceptions), null);
    }
  }

  private static List<TypeTree> typesToReport(List<TypeTree> typesWithWarnings, List<UnionTypeTree> unionTypes) {
    List<TypeTree> typesToReport = new ArrayList<>(typesWithWarnings);
    for (UnionTypeTree unionType : unionTypes) {
      List<TypeTree> typeAlternatives = unionType.typeAlternatives();
      if (typesWithWarnings.containsAll(typeAlternatives)) {
        typesToReport.add(unionType);
        typesToReport.removeAll(typeAlternatives);
      }
    }
    return typesToReport;
  }

  private static String message(Tree reportTree) {
    if (reportTree.is(Tree.Kind.TOKEN)) {
      return ""Remove or refactor this catch clause because it is unreachable, hidden by previous catch block(s)."";
    }
    // reporting on the type alternative of an union type
    return ""Remove this type because it is unreachable, hidden by previous catch block(s)."";
  }

  private static List<Location> secondaries(TypeTree type, Map<TypeTree, Type> typeByExceptions) {
    List<Type> targets;
    if (type.is(Tree.Kind.UNION_TYPE)) {
      targets = ((UnionTypeTree) type).typeAlternatives()
        .stream()
        .map(typeByExceptions::get)
        .toList();
    } else {
      targets = Collections.singletonList(typeByExceptions.get(type));
    }
    return childrenExceptionTypes(targets, typeByExceptions);
  }

  private static List<Location> childrenExceptionTypes(List<Type> targets, Map<TypeTree, Type> exceptionTypes) {
    List<Location> secondaries = new ArrayList<>();
    targets.forEach(target -> {
      for (Map.Entry<TypeTree, Type> exceptionType : exceptionTypes.entrySet()) {
        TypeTree tree = exceptionType.getKey();
        Type type = exceptionType.getValue();
        if (!type.equals(target) && type.isSubtypeOf(target)) {
          secondaries.add(new Location(""Already catch the exception"", tree));
        }
      }
    });
    secondaries.sort(LOCATION_COMPARATOR);
    return secondaries;
  }
}
"
S4973,BUG,"Strings and Boxed types should be compared using ""equals()""","package org.sonar.java.checks;

import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S4973"")
public class CompareStringsBoxedTypesWithEqualsCheck extends CompareWithEqualsVisitor {

  private static final String ISSUE_MESSAGE = ""Strings and Boxed types should be compared using \""equals()\""."";
  private static final String QUICK_FIX_MESSAGE = ""Replace with boxed comparison"";
  private static final String DOT_EQUALS_AND_OPENING_PARENTHESIS = "".equals("";

  private QuickFixHelper.ImportSupplier importSupplier;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    importSupplier = null;
    super.scanFile(context);
  }

  @Override
  protected void checkEqualityExpression(BinaryExpressionTree tree) {
    Type leftOpType = tree.leftOperand().symbolType();
    Type rightOpType = tree.rightOperand().symbolType();
    if (!isNullComparison(leftOpType, rightOpType)
      && !isCompareWithBooleanConstant(tree.leftOperand(), tree.rightOperand())
      && (isStringType(leftOpType, rightOpType) || isBoxedType(leftOpType, rightOpType))) {
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(tree.operatorToken())
        .withMessage(ISSUE_MESSAGE)
        .withQuickFix(() -> computeConciseQuickFix(tree).orElseGet(() -> computeDefaultQuickFix(tree)))
        .report();
    }
  }

  private static boolean isCompareWithBooleanConstant(ExpressionTree left, ExpressionTree right) {
    return ExpressionsHelper.getConstantValueAsBoolean(left).value() != null ||
      ExpressionsHelper.getConstantValueAsBoolean(right).value() != null;
  }

  private static Optional<JavaQuickFix> computeConciseQuickFix(BinaryExpressionTree tree) {
    ExpressionTree leftOperand = tree.leftOperand();
    ExpressionTree rightOperand = tree.rightOperand();
    if (leftOperand.is(Tree.Kind.STRING_LITERAL)) {
      AnalyzerMessage.TextSpan interOperandSpace = AnalyzerMessage.textSpanBetween(
        leftOperand, false,
        rightOperand, false
      );
      JavaQuickFix.Builder quickFix = JavaQuickFix.newQuickFix(QUICK_FIX_MESSAGE)
        .addTextEdit(JavaTextEdit.insertAfterTree(rightOperand, "")""))
        .addTextEdit(JavaTextEdit.replaceTextSpan(interOperandSpace, DOT_EQUALS_AND_OPENING_PARENTHESIS));
      if (tree.is(Tree.Kind.NOT_EQUAL_TO)) {
        quickFix.addTextEdit(JavaTextEdit.insertBeforeTree(leftOperand, ""!""));
      }
      return Optional.of(quickFix.build());
    } else if (rightOperand.is(Tree.Kind.STRING_LITERAL)) {
      String callEqualsOnLiteral = ((LiteralTree) rightOperand).value() + DOT_EQUALS_AND_OPENING_PARENTHESIS;
      String callToEquals = tree.is(Tree.Kind.NOT_EQUAL_TO) ? (""!"" + callEqualsOnLiteral) : callEqualsOnLiteral;
      AnalyzerMessage.TextSpan leftOfOperatorToEndOfComparison = AnalyzerMessage.textSpanBetween(
        leftOperand, false,
        rightOperand, true
      );
      return Optional.of(
        JavaQuickFix.newQuickFix(QUICK_FIX_MESSAGE)
          .addTextEdit(JavaTextEdit.replaceTextSpan(leftOfOperatorToEndOfComparison, "")""))
          .addTextEdit(JavaTextEdit.insertBeforeTree(leftOperand, callToEquals))
          .build()
      );
    }
    return Optional.empty();
  }

  private JavaQuickFix computeDefaultQuickFix(BinaryExpressionTree tree) {
    String callToEquals = tree.is(Tree.Kind.NOT_EQUAL_TO) ? ""!Objects.equals("" : ""Objects.equals("";
    AnalyzerMessage.TextSpan interOperandSpace = AnalyzerMessage.textSpanBetween(
      tree.leftOperand(), false,
      tree.rightOperand(), false
    );
    JavaQuickFix.Builder builder = JavaQuickFix.newQuickFix(QUICK_FIX_MESSAGE)
      .addTextEdit(JavaTextEdit.insertAfterTree(tree.rightOperand(), "")""))
      .addTextEdit(JavaTextEdit.replaceTextSpan(interOperandSpace, "", ""))
      .addTextEdit(JavaTextEdit.insertBeforeTree(tree.leftOperand(), callToEquals));

    if (importSupplier == null) {
      importSupplier = QuickFixHelper.newImportSupplier(context);
    }

    importSupplier.newImportEdit(""java.util.Objects"")
      .ifPresent(builder::addTextEdit);

    return builder.build();
  }

}
"
S4977,CODE_SMELL,Type parameters should not shadow other type parameters,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.TypeParameters;

@Rule(key = ""S4977"")
public class TypeParametersShadowingCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String ISSUE_MESSAGE = ""Rename \""%s\"" which hides a type parameter from the outer scope."";

  private JavaFileScannerContext context;

  private Map<String, IdentifierTree> currentTypeParametersInScope;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    currentTypeParametersInScope = new HashMap<>();
    scan(context.getTree());
  }

  @Override
  public void visitClass(ClassTree tree) {
    processTree(tree, tree.typeParameters(), tree.symbol().isStatic(), super::visitClass);
  }

  @Override
  public void visitMethod(MethodTree tree) {
    processTree(tree, tree.typeParameters(), tree.symbol().isStatic(), super::visitMethod);
  }

  private <T> void processTree(T tree, TypeParameters typeParameters, boolean isStatic, Consumer<T> visitTree) {
    Map<String, IdentifierTree> oldScope = currentTypeParametersInScope;
    if (isStatic) {
      currentTypeParametersInScope = new HashMap<>();
    }
    Map<String, IdentifierTree> declaredTypeParameters = processAndGetTypeParameters(typeParameters);
    currentTypeParametersInScope.putAll(declaredTypeParameters);
    visitTree.accept(tree);
    declaredTypeParameters.forEach(currentTypeParametersInScope::remove);
    if (isStatic) {
      currentTypeParametersInScope = oldScope;
    }
  }

  private Map<String, IdentifierTree> processAndGetTypeParameters(TypeParameters typeParameters) {
    Map<String, IdentifierTree> declaredTypeParameters = new HashMap<>();
    typeParameters.forEach(typeParameter -> {
      IdentifierTree id = typeParameter.identifier();
      String name = id.toString();

      IdentifierTree shadowedId = currentTypeParametersInScope.get(name);
      if (shadowedId != null) {
        context.reportIssue(this, id,
          String.format(ISSUE_MESSAGE, name),
          Collections.singletonList(new JavaFileScannerContext.Location(""Shadowed type parameter"", shadowedId)
        ), null);
      } else {
        // Entry added only in the else part, because we want to store only the first and outer most appearance of a type.
        // If a type is shadowed multiple times, we use only the outer most as secondary location.
        declaredTypeParameters.put(name, id);
      }
    });
    return declaredTypeParameters;
  }
}
"
S5042,SECURITY_HOTSPOT,Expanding archive files without controlling resource consumption is security-sensitive,"package org.sonar.java.checks.security;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5042"")
public class ZipEntryCheck extends IssuableSubscriptionVisitor {

  private static final String ISSUE_MESSAGE = ""Make sure that expanding this archive file is safe here."";

  private static final MethodMatchers SENSITIVE_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(""java.util.zip.ZipFile"")
      .names(""entries"")
      .addWithoutParametersMatcher()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""java.util.zip.ZipEntry"")
      .names(""getSize"")
      .addWithoutParametersMatcher()
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""java.util.zip.ZipInputStream"")
      .names(""getNextEntry"")
      .addWithoutParametersMatcher()
      .build()
  );

  private static final MethodMatchers INPUT_STREAM_READ = MethodMatchers.create()
    .ofSubTypes(""java.io.InputStream"")
    .names(""read"")
    .withAnyParameters()
    .build();

  private boolean isSafe = false;

  private boolean insideMethod = false;

  private final List<MethodInvocationTree> calls = new ArrayList<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      isSafe = false;
      calls.clear();
      insideMethod = true;
    } else {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      if (insideMethod && INPUT_STREAM_READ.matches(mit)) {
        isSafe = true;
      } else if (SENSITIVE_METHODS.matches(mit)) {
        if (insideMethod) {
          calls.add(mit);
        } else {
          report(mit);
        }
      }
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      if (!isSafe) {
        for (MethodInvocationTree mit : calls) {
          report(mit);
        }
      }
      insideMethod = false;
    }
  }

  private void report(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ISSUE_MESSAGE);
  }
}
"
S5122,SECURITY_HOTSPOT,Having a permissive Cross-Origin Resource Sharing policy is security-sensitive,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext.Location;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5122"")
public class CORSCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers SET_ADD_HEADER_MATCHER = MethodMatchers.create()
    .ofTypes(""javax.servlet.http.HttpServletResponse"", ""jakarta.servlet.http.HttpServletResponse"")
    .names(""setHeader"", ""addHeader"")
    .withAnyParameters()
    .build();

  private static final String ACCESS_CONTROL_ALLOW_ORIGIN = ""access-control-allow-origin"";
  private static final Set<String> ANNOTATION_ORIGINS_KEY_ALIAS = SetUtils.immutableSetOf(""origins"", ""value"");

  private static final MethodMatchers ADD_ALLOWED_ORIGIN_MATCHER = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(""org.springframework.web.cors.CorsConfiguration"")
      .names(""addAllowedOrigin"", ""setAllowedOrigins"", ""setAllowedOriginPatterns"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create().ofTypes(""org.springframework.web.servlet.config.annotation.CorsRegistration"")
      .names(""allowedOrigins"", ""allowedOriginPatterns"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create().ofTypes(""org.springframework.web.servlet.config.annotation.CorsRegistry"")
      .names(""addMapping"")
      .withAnyParameters()
      .build());

  private static final MethodMatchers LIST_INITIALIZER_MATCHER = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(""java.util.Arrays"")
      .names(""asList"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create().ofTypes(""java.util.List"")
      .names(""of"")
      .withAnyParameters()
      .build());

  private static final MethodMatchers APPLY_PERMIT_DEFAULT_VALUES = MethodMatchers.create()
    .ofTypes(""org.springframework.web.cors.CorsConfiguration"")
    .names(""applyPermitDefaultValues"")
    .withAnyParameters()
    .build();

  public static final String MESSAGE = ""Make sure that enabling CORS is safe here."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.ANNOTATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      checkMethod(tree);
    } else if (((AnnotationTree) tree).symbolType().is(""org.springframework.web.bind.annotation.CrossOrigin"")) {
      checkAnnotation((AnnotationTree) tree);
    }
  }

  private void checkMethod(Tree tree) {
    MethodInvocationVisitor visitor = new MethodInvocationVisitor();
    tree.accept(visitor);
    if (!visitor.addAllowedOrigin.isEmpty() && !visitor.applyPermit.isEmpty()) {
      visitor.addAllowedOrigin.forEach(mit -> {
        List<Location> locations = visitor.applyPermit.stream()
          .map(t -> new Location(MESSAGE, t))
          .toList();
        reportIssue(mit.methodSelect(), MESSAGE, locations, null);
      });
    } else {
      visitor.addAllowedOrigin.forEach(this::reportTree);
      visitor.applyPermit.forEach(this::reportTree);
    }
  }

  private void checkAnnotation(AnnotationTree tree) {
    if (tree.arguments().stream().noneMatch(CORSCheck::setSpecificOrigins)) {
      reportTree(tree.annotationType());
    }
  }

  private static boolean setSpecificOrigins(ExpressionTree tree) {
    if (tree.is(Tree.Kind.ASSIGNMENT)) {
      AssignmentExpressionTree assignment = (AssignmentExpressionTree) tree;
      ExpressionTree variable = assignment.variable();
      return variable.is(Tree.Kind.IDENTIFIER) &&
        ANNOTATION_ORIGINS_KEY_ALIAS.contains(((IdentifierTree) variable).name()) &&
        !isStar(assignment.expression());
    }
    return !isStar(tree);
  }

  private void reportTree(MethodInvocationTree mit) {
    reportTree(ExpressionUtils.methodName(mit));
  }

  private void reportTree(Tree tree) {
    reportIssue(tree, MESSAGE);
  }

  private static boolean isStar(ExpressionTree expressionTree) {
    if (expressionTree instanceof NewArrayTree tree) {
      return containsStar(tree.initializers());
    }
    if (expressionTree instanceof MethodInvocationTree tree) {
      return LIST_INITIALIZER_MATCHER.matches(tree) && containsStar(tree.arguments());
    }
    return ""*"".equals(ExpressionsHelper.getConstantValueAsString(expressionTree).value());
  }

  private static boolean containsStar(List<ExpressionTree> list) {
    return list.stream().anyMatch(CORSCheck::isStar);
  }

  private class MethodInvocationVisitor extends BaseTreeVisitor {
    List<MethodInvocationTree> addAllowedOrigin = new ArrayList<>();
    List<MethodInvocationTree> applyPermit = new ArrayList<>();

    @Override
    public void visitMethodInvocation(MethodInvocationTree mit) {
      if (SET_ADD_HEADER_MATCHER.matches(mit)) {
        String headerName = ExpressionsHelper.getConstantValueAsString(mit.arguments().get(0)).value();
        if (ACCESS_CONTROL_ALLOW_ORIGIN.equalsIgnoreCase(headerName) && isStar(mit.arguments().get(1))) {
          reportTree(mit);
        }
      } else if (APPLY_PERMIT_DEFAULT_VALUES.matches(mit)) {
        applyPermit.add(mit);
      } else if (ADD_ALLOWED_ORIGIN_MATCHER.matches(mit) && containsStar(mit.arguments())) {
        addAllowedOrigin.add(mit);
      }
      super.visitMethodInvocation(mit);
    }

    @Override
    public void visitClass(ClassTree tree) {
      // cut the visit
    }
  }
}
"
S5128,CODE_SMELL,"""Bean Validation"" (JSR 380) should be properly configured","package org.sonar.java.checks;

import java.text.MessageFormat;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S5128"")
public class MissingBeanValidationCheck extends IssuableSubscriptionVisitor {
  private static final String JAVAX_VALIDATION_VALID = ""javax.validation.Valid"";
  private static final String JAVAX_VALIDATION_CONSTRAINT = ""javax.validation.Constraint"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    for (Tree member : classTree.members()) {
      if (member.is(Tree.Kind.VARIABLE)) {
        checkField((VariableTree) member);
      } else if (member.is(Tree.Kind.METHOD)) {
        checkMethod((MethodTree) member);
      }
    }
  }

  private void checkField(VariableTree field) {
    getIssueMessage(field).ifPresent(message -> reportIssue(field.type(), message));
  }

  private void checkMethod(MethodTree method) {
    if (!isExcluded(method)) {
      for (VariableTree parameter : method.parameters()) {
        getIssueMessage(parameter).ifPresent(message -> reportIssue(parameter.type(), message));
      }
    }
  }

  private static boolean isExcluded(MethodTree methodTree) {
    return methodTree.symbol().isPrivate() || isInConstraintValidator(methodTree);
  }

  private static boolean isInConstraintValidator(MethodTree methodTree) {
    Symbol.TypeSymbol enclosingClass = methodTree.symbol().enclosingClass();
    return enclosingClass != null && enclosingClass.type().isSubtypeOf(""javax.validation.ConstraintValidator"");
  }

  private static Optional<String> getIssueMessage(VariableTree variable) {
    if (!validationEnabled(variable) && validationSupported(variable)) {
      return Optional.of(MessageFormat.format(""Add missing \""@Valid\"" on \""{0}\"" to validate it with \""Bean Validation\""."", variable.simpleName()));
    }
    return Optional.empty();
  }

  private static boolean validationEnabled(VariableTree variable) {
    if (variable.symbol().metadata().isAnnotatedWith(JAVAX_VALIDATION_VALID)) {
      return true;
    }
    return typeArgumentAnnotations(variable).anyMatch(annotation -> annotation.is(JAVAX_VALIDATION_VALID));
  }

  private static Stream<Type> typeArgumentAnnotations(VariableTree variable) {
    return typeArgumentTypeTrees(variable).flatMap(type -> type.annotations().stream()).map(ExpressionTree::symbolType);
  }

  private static Stream<TypeTree> typeArgumentTypeTrees(VariableTree variable) {
    TypeTree variableType = variable.type();
    if (!variableType.is(Tree.Kind.PARAMETERIZED_TYPE)) {
      return Stream.empty();
    }
    return ((ParameterizedTypeTree) variableType).typeArguments().stream();
  }

  private static boolean validationSupported(VariableTree variable) {
    return annotationInstances(variable).anyMatch(MissingBeanValidationCheck::isConstraintAnnotation);
  }

  private static Stream<SymbolMetadata.AnnotationInstance> annotationInstances(VariableTree variable) {
    if (variable.type().is(Tree.Kind.PARAMETERIZED_TYPE)) {
      return typeArgumentAnnotationInstances(variable);
    }
    Symbol.TypeSymbol classSymbol = variable.symbol().type().symbol();
    return classAndFieldAnnotationInstances(classSymbol);
  }

  private static Stream<SymbolMetadata.AnnotationInstance> typeArgumentAnnotationInstances(VariableTree variable) {
    return typeArgumentTypeTrees(variable).map(TypeTree::symbolType).map(Type::symbol).flatMap(MissingBeanValidationCheck::classAndFieldAnnotationInstances);
  }

  private static Stream<SymbolMetadata.AnnotationInstance> classAndFieldAnnotationInstances(Symbol.TypeSymbol classSymbol) {
    return Stream.concat(classAnnotationInstances(classSymbol), fieldAnnotationInstances(classSymbol));
  }

  private static Stream<SymbolMetadata.AnnotationInstance> classAnnotationInstances(Symbol classSymbol) {
    return classSymbol.metadata().annotations().stream();
  }

  private static Stream<SymbolMetadata.AnnotationInstance> fieldAnnotationInstances(Symbol.TypeSymbol classSymbol) {
    return classSymbol.memberSymbols().stream().flatMap(MissingBeanValidationCheck::classAnnotationInstances);
  }

  private static boolean isConstraintAnnotation(SymbolMetadata.AnnotationInstance annotationInstance) {
    return annotationInstance.symbol().metadata().isAnnotatedWith(JAVAX_VALIDATION_CONSTRAINT);
  }
}
"
S5164,BUG,"""ThreadLocal"" variables should be cleaned up when no longer used ","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S5164"")
public class ThreadLocalCleanupCheck extends IssuableSubscriptionVisitor {

  private static final String THREAD_LOCAL = ""java.lang.ThreadLocal"";
  private static final MethodMatchers THREADLOCAL_SET = MethodMatchers.create()
    .ofTypes(THREAD_LOCAL).names(""set"").addParametersMatcher(ANY).build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.CLASS)) {
      Symbol.TypeSymbol clazz = ((ClassTree) tree).symbol();
      Type superClass = clazz.superClass();
      if (clazz.type().isSubtypeOf(THREAD_LOCAL) || (superClass != null && superClass.isUnknown())) {
        return;
      }
      clazz.memberSymbols().stream()
        .filter(Symbol::isVariableSymbol)
        .filter(s -> s.isPrivate() && s.type().is(THREAD_LOCAL))
        .forEach(this::checkThreadLocalField);
    } else {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      if (THREADLOCAL_SET.matches(mit) && mit.arguments().get(0).is(Tree.Kind.NULL_LITERAL)) {
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(mit)
          .withMessage(""Use \""remove()\"" instead of \""set(null)\""."")
          .withQuickFix(() -> JavaQuickFix.newQuickFix(""Replace with \""remove()\"""")
            .addTextEdit(JavaTextEdit.replaceBetweenTree(ExpressionUtils.methodName(mit), mit.arguments(), ""remove()""))
            .build())
          .report();
      }
    }
  }

  private void checkThreadLocalField(Symbol field) {
    if (field.usages().stream().noneMatch(ThreadLocalCleanupCheck::usageIsRemove)) {
      reportIssue(((VariableTree) field.declaration()).simpleName(), ""Call \""remove()\"" on \"""" + field.name() + ""\""."");
    }
  }

  private static boolean usageIsRemove(IdentifierTree usage) {
    return MethodTreeUtils.consecutiveMethodInvocation(usage)
      // At this point, we know that ""usage"" is of type ThreadLocal, we don't have to check the full type, the name is enough.
      .filter(mit -> ""remove"".equals(ExpressionUtils.methodName(mit).name()))
      .isPresent();
  }
}

"
S5194,CODE_SMELL,"Use Java 14 ""switch"" expression","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SwitchStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.plugins.java.api.tree.Tree.Kind.BLOCK;
import static org.sonar.plugins.java.api.tree.Tree.Kind.BREAK_STATEMENT;
import static org.sonar.plugins.java.api.tree.Tree.Kind.EXPRESSION_STATEMENT;
import static org.sonar.plugins.java.api.tree.Tree.Kind.MEMBER_SELECT;
import static org.sonar.plugins.java.api.tree.Tree.Kind.RETURN_STATEMENT;
import static org.sonar.plugins.java.api.tree.Tree.Kind.SWITCH_STATEMENT;
import static org.sonar.plugins.java.api.tree.Tree.Kind.THROW_STATEMENT;

@Rule(key = ""S5194"")
public class UseSwitchExpressionCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(SWITCH_STATEMENT);
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    // switch-expression is standard since Java 14
    return version.asInt() >= 14;
  }

  @Override
  public void visitNode(Tree tree) {
    SwitchStatementTree switchTree = (SwitchStatementTree) tree;
    Symbol switchAssigningVariable = isSwitchAssigningVariable(switchTree);
    if (switchAssigningVariable != null) {
      reportIssue(switchTree.switchKeyword(), ""Use \""switch\"" expression to set value of \"""" + switchAssigningVariable.name() + ""\""."");
    } else if (isSwitchReturningValue(switchTree)) {
      reportIssue(switchTree.switchKeyword(), ""Use \""switch\"" expression to return the value from method."");
    }
  }

  @CheckForNull
  private static Symbol isSwitchAssigningVariable(SwitchStatementTree switchStatementTree) {
    Set<Symbol> assignedVariables = switchStatementTree.cases().stream()
      .filter(caseGroup -> !hasSingleStatement(caseGroup.body(), THROW_STATEMENT))
      .map(UseSwitchExpressionCheck::assigningVariable)
      .collect(Collectors.toSet());
    return assignedVariables.size() == 1 ? assignedVariables.iterator().next() : null;
  }

  private static boolean isSwitchReturningValue(SwitchStatementTree switchStatementTree) {
    return switchStatementTree.cases().stream()
      .map(CaseGroupTree::body)
      .allMatch(body -> hasSingleStatement(body, THROW_STATEMENT, RETURN_STATEMENT));
  }

  @CheckForNull
  private static Symbol assigningVariable(CaseGroupTree caseGroup) {
    List<StatementTree> body = caseGroup.body();
    if (isArrowOrBreaks(caseGroup)) {
      return variableFromAssignment(body);
    }
    return null;
  }

  @CheckForNull
  private static Symbol variableFromAssignment(List<StatementTree> body) {
    if (body.isEmpty()) {
      return null;
    }
    StatementTree statementTree = body.get(0);
    if (statementTree.is(EXPRESSION_STATEMENT)) {
      ExpressionTree expression = ((ExpressionStatementTree) statementTree).expression();
      if (expression.is(Tree.Kind.ASSIGNMENT)) {
        Symbol variable = getVariableSymbol((AssignmentExpressionTree) expression);
        if (variable != null && !variable.isUnknown()) {
          return variable;
        }
      }
    }
    if (statementTree.is(BLOCK)) {
      return variableFromAssignment(((BlockTree) statementTree).body());
    }
    return null;
  }

  private static boolean isArrowOrBreaks(CaseGroupTree caseGroup) {
    List<StatementTree> body = caseGroup.body();
    return !caseGroup.labels().get(0).isFallThrough() ||
      hasBreak(body) ||
      (hasSingleStatement(body, BLOCK) && hasBreak(((BlockTree) body.get(0)).body()));
  }

  private static boolean hasBreak(List<StatementTree> body) {
    return body.size() == 2 && body.get(1).is(BREAK_STATEMENT);
  }

  @CheckForNull
  private static Symbol getVariableSymbol(AssignmentExpressionTree expression) {
    ExpressionTree variable = expression.variable();
    if (variable.is(Tree.Kind.IDENTIFIER)) {
      return ((IdentifierTree) variable).symbol();
    }
    if (variable.is(MEMBER_SELECT)) {
      return ((MemberSelectExpressionTree) variable).identifier().symbol();
    }
    return null;
  }

  private static boolean hasSingleStatement(List<StatementTree> body, Tree.Kind... statement) {
    if (body.size() != 1) {
      return false;
    }
    StatementTree onlyStatement = body.get(0);
    return onlyStatement.is(statement) ||
      (onlyStatement.is(BLOCK) && hasSingleStatement(((BlockTree) onlyStatement).body(), statement));
  }

}
"
S5247,SECURITY_HOTSPOT,Disabling auto-escaping in template engines is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5247"")
public class DisableAutoEscapingCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Make sure disabling auto-escaping feature is safe here."";

  private static final String MUSTACHE_ESCAPERS = ""com.samskivert.mustache.Escapers"";
  private static final String FREEMARKER_CONFIGURATION = ""freemarker.template.Configuration"";

  private static final MethodMatchers MUSTACHE_COMPILER_ESCAPE_HTML = MethodMatchers.create()
    .ofTypes(""com.samskivert.mustache.Mustache$Compiler"")
    .names(""escapeHTML"")
    .addParametersMatcher(""boolean"")
    .build();

  private static final MethodMatchers MUSTACHE_COMPILER_WITH_ESCAPER = MethodMatchers.create()
    .ofTypes(""com.samskivert.mustache.Mustache$Compiler"")
    .names(""withEscaper"")
    .addParametersMatcher(""com.samskivert.mustache.Mustache$Escaper"")
    .build();

  private static final MethodMatchers MUSTACHE_ESCAPERS_SIMPLE = MethodMatchers.create()
    .ofTypes(MUSTACHE_ESCAPERS)
    .names(""simple"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers FREEMARKER_SET_AUTO_ESCAPING_POLICY = MethodMatchers.create()
    .ofTypes(FREEMARKER_CONFIGURATION)
    .names(""setAutoEscapingPolicy"")
    .addParametersMatcher(""int"")
    .build();


  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;
    if (FREEMARKER_SET_AUTO_ESCAPING_POLICY.matches(mit)) {
      handleFreeMarker(mit);
    } else {
      handleJMustache(mit);
    }
  }

  private void handleFreeMarker(MethodInvocationTree mit) {
    ExpressionTree policy = mit.arguments().get(0);
    if (isFieldFromClassWithName(policy, FREEMARKER_CONFIGURATION, ""DISABLE_AUTO_ESCAPING_POLICY"")) {
      reportIssue(policy, MESSAGE);
    }
  }

  private void handleJMustache(MethodInvocationTree mit) {
    if (MUSTACHE_COMPILER_ESCAPE_HTML.matches(mit)) {
      ExpressionTree argument = mit.arguments().get(0);
      argument.asConstant(Boolean.class)
        .filter(Boolean.FALSE::equals)
        .ifPresent(cst -> reportIssue(argument, MESSAGE));
    } else if (MUSTACHE_COMPILER_WITH_ESCAPER.matches(mit)) {
      ExpressionTree argument = mit.arguments().get(0);
      if (isSimpleEscaper(argument) || isFieldFromClassWithName(argument, MUSTACHE_ESCAPERS, ""NONE"")) {
        reportIssue(argument, MESSAGE);
      }
    }
  }

  private static boolean isSimpleEscaper(Tree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      // Escapers.simple has a varargs argument, we have to rely on the list of arguments and cannot use the matcher.
      return mit.arguments().isEmpty() && MUSTACHE_ESCAPERS_SIMPLE.matches(mit);
    }
    return false;
  }

  private static boolean isFieldFromClassWithName(Tree tree, String classType, String name) {
    return extractIdentifier(tree)
      .map(identifier -> checkOwner(identifier, classType, name))
      .orElse(false);
  }

  private static Optional<IdentifierTree> extractIdentifier(Tree tree) {
    if (tree.is(Tree.Kind.MEMBER_SELECT)) {
      return Optional.of(((MemberSelectExpressionTree) tree).identifier());
    } else if (tree.is(Tree.Kind.IDENTIFIER)) {
      return Optional.of((IdentifierTree) tree);
    }
    return Optional.empty();
  }

  private static boolean checkOwner(IdentifierTree identifier, String classType, String name) {
    Symbol owner = identifier.symbol().owner();
    return owner != null
      && owner.type().is(classType)
      && name.equals(identifier.name());
  }

}
"
S5261,CODE_SMELL,"""else"" statements should be clearly matched with an ""if""","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S5261"")
public class DanglingElseStatementsCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.IF_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    IfStatementTree ifstmt = (IfStatementTree) tree;
    if (hasElse(ifstmt) && isNested(ifstmt)) {
      reportIssue(ifstmt.elseKeyword(), ""Add explicit curly braces to avoid dangling else."");
    }
  }

  private static boolean hasElse(IfStatementTree ifstmt) {
    return ifstmt.elseStatement() != null;
  }

  private static boolean isNested(IfStatementTree ifstmt) {
    return ifstmt.parent().is(Kind.IF_STATEMENT) && ((IfStatementTree) ifstmt.parent()).thenStatement() == ifstmt;
  }
}
"
S5301,VULNERABILITY,"""ActiveMQConnectionFactory"" should not be vulnerable to malicious code deserialization","package org.sonar.java.checks.security;

import java.util.Optional;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.model.ExpressionUtils.getAssignedSymbol;
import static org.sonar.java.model.ExpressionUtils.isInvocationOnVariable;
import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S5301"")
public class XxeActiveMQCheck extends AbstractMethodDetection {
  private static final String CONSTRUCTOR = ""<init>"";

  private static final String MQ_CONNECTION_FACTORY_CLASS_NAME = ""org.apache.activemq.ActiveMQConnectionFactory"";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofTypes(MQ_CONNECTION_FACTORY_CLASS_NAME)
      .names(CONSTRUCTOR).withAnyParameters().build();
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    Tree enclosingMethod = ExpressionUtils.getEnclosingMethod(newClassTree);
    if (enclosingMethod == null) {
      return;
    }

    Optional<Symbol> assignedSymbol = getAssignedSymbol(newClassTree);
    MethodBodyVisitor visitor = new MethodBodyVisitor(assignedSymbol.orElse(null));
    enclosingMethod.accept(visitor);
    if (!visitor.foundCallsToSecuringMethods()) {
      reportIssue(newClassTree,
        ""Secure this \""ActiveMQConnectionFactory\"" by whitelisting the trusted packages using the \""setTrustedPackages\"" method and ""
          + ""make sure the \""setTrustAllPackages\"" is not set to true."");
    }
  }

  private static class MethodBodyVisitor extends BaseTreeVisitor {

    private static final MethodMatchers SET_TRUSTED_PACKAGES = MethodMatchers.create()
      .ofSubTypes(MQ_CONNECTION_FACTORY_CLASS_NAME).names(""setTrustedPackages"")
      .addParametersMatcher(ANY)
      .build();

    private static final MethodMatchers SET_TRUST_ALL_PACKAGES = MethodMatchers.create()
      .ofSubTypes(MQ_CONNECTION_FACTORY_CLASS_NAME).names(""setTrustAllPackages"")
      .addParametersMatcher(""boolean"")
      .build();

    private boolean hasTrustedPackages = false;
    private boolean hasTrustAllPackages = false;
    private boolean callArgumentsOfSetTrustedPackages = false;

    private Symbol variable;

    MethodBodyVisitor(@Nullable Symbol variable) {
      this.variable = variable;
    }

    private boolean foundCallsToSecuringMethods() {
      return hasTrustedPackages && !hasTrustAllPackages;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
      if (isInvocationOnVariable(methodInvocation, variable, true)) {
        Arguments arguments = methodInvocation.arguments();
        if (SET_TRUSTED_PACKAGES.matches(methodInvocation)) {
          hasTrustedPackages |= !arguments.get(0).is(Tree.Kind.NULL_LITERAL);
          callArgumentsOfSetTrustedPackages = true;
        } else if (SET_TRUST_ALL_PACKAGES.matches(methodInvocation)) {
          hasTrustAllPackages |= Boolean.TRUE.equals(arguments.get(0).asConstant(Boolean.class).orElse(null));
        }
      }
      super.visitMethodInvocation(methodInvocation);
      callArgumentsOfSetTrustedPackages = false;
    }

    @Override
    public void visitLiteral(LiteralTree tree) {
      if (callArgumentsOfSetTrustedPackages &&
        tree.is(Tree.Kind.STRING_LITERAL) &&
        ""*"".equals(LiteralUtils.trimQuotes(tree.value()))) {
        hasTrustAllPackages = true;
      }
      super.visitLiteral(tree);
    }
  }
}
"
S5320,SECURITY_HOTSPOT,Broadcasting intents is security-sensitive,"package org.sonar.java.checks.security;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

import static org.sonar.plugins.java.api.tree.Tree.Kind.NULL_LITERAL;

@Rule(key = ""S5320"")
public class AndroidBroadcastingCheck extends AbstractMethodDetection {

  private static final String MESSAGE = ""Make sure that broadcasting intents is safe here."";

  private static final MethodMatchers SEND_BROADCAST = androidContext().names(""sendBroadcast"").withAnyParameters().build();
  private static final MethodMatchers SEND_BROADCAST_AS_USER = androidContext().names(""sendBroadcastAsUser"").withAnyParameters().build();
  private static final MethodMatchers SEND_ORDERED_BROADCAST = androidContext().names(""sendOrderedBroadcast"").withAnyParameters().build();
  private static final MethodMatchers SEND_ORDERED_BROADCAST_AS_USER = androidContext().names(""sendOrderedBroadcastAsUser"").withAnyParameters().build();
  private static final MethodMatchers SEND_STICKY_BROADCAST = androidContext().names(""sendStickyBroadcast"").withAnyParameters().build();
  private static final MethodMatchers SEND_STICKY_BROADCAST_AS_USER = androidContext().names(""sendStickyBroadcastAsUser"").withAnyParameters().build();
  private static final MethodMatchers SEND_STICKY_ORDERED_BROADCAST = androidContext().names(""sendStickyOrderedBroadcast"").withAnyParameters().build();
  private static final MethodMatchers SEND_STICKY_ORDERED_BROADCAST_AS_USER = androidContext().names(""sendStickyOrderedBroadcastAsUser"").withAnyParameters().build();
  private static final MethodMatchers STICKY_BROADCAST = MethodMatchers.or(SEND_STICKY_BROADCAST,
    SEND_STICKY_BROADCAST_AS_USER, SEND_STICKY_ORDERED_BROADCAST, SEND_STICKY_ORDERED_BROADCAST_AS_USER);

  private static MethodMatchers.NameBuilder androidContext() {
    return MethodMatchers.create().ofSubTypes(""android.content.Context"");
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      SEND_BROADCAST,
      SEND_BROADCAST_AS_USER,
      SEND_ORDERED_BROADCAST,
      SEND_ORDERED_BROADCAST_AS_USER,
      SEND_STICKY_BROADCAST,
      SEND_STICKY_BROADCAST_AS_USER,
      SEND_STICKY_ORDERED_BROADCAST,
      SEND_STICKY_ORDERED_BROADCAST_AS_USER
    );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (isSendBroadcast(mit) || isSendBroadcastAsUser(mit) || isSendOrderedBroadcast(mit) ||
      isSendOrderedBroadcastAsUser(mit) || STICKY_BROADCAST.matches(mit)) {
      reportIssue(mit.methodSelect(), MESSAGE);
    }
  }

  private static boolean isSendBroadcast(MethodInvocationTree mit) {
    return SEND_BROADCAST.matches(mit) && (mit.arguments().size() < 2 || mit.arguments().get(1).is(NULL_LITERAL));
  }

  private static boolean isSendBroadcastAsUser(MethodInvocationTree mit) {
    return SEND_BROADCAST_AS_USER.matches(mit) && (mit.arguments().size() < 3 || mit.arguments().get(2).is(NULL_LITERAL));
  }

  private static boolean isSendOrderedBroadcast(MethodInvocationTree mit) {
    return SEND_ORDERED_BROADCAST.matches(mit) && mit.arguments().size() > 1 && mit.arguments().get(1).is(NULL_LITERAL);
  }

  private static boolean isSendOrderedBroadcastAsUser(MethodInvocationTree mit) {
    return SEND_ORDERED_BROADCAST_AS_USER.matches(mit) && mit.arguments().size() > 2 && mit.arguments().get(2).is(NULL_LITERAL);
  }
}
"
S5322,SECURITY_HOTSPOT,Receiving intents is security-sensitive,"package org.sonar.java.checks.security;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

import static org.sonar.plugins.java.api.tree.Tree.Kind.NULL_LITERAL;

@Rule(key = ""S5322"")
public class ReceivingIntentsCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofSubTypes(""android.content.Context"")
      .names(""registerReceiver"")
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (mit.arguments().size() < 4 || mit.arguments().get(2).is(NULL_LITERAL)) {
      reportIssue(mit.methodSelect(), ""Make sure that intents are received safely here."");
    }
  }
}
"
S5324,SECURITY_HOTSPOT,Accessing Android external storage is security-sensitive,"package org.sonar.java.checks.security;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S5324"")
public class AndroidExternalStorageCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofTypes(""android.os.Environment"")
        .names(""getExternalStorageDirectory"", ""getExternalStoragePublicDirectory"")
        .withAnyParameters()
        .build(),
      MethodMatchers.create()
        .ofSubTypes(""android.content.Context"")
        .names(""getExternalFilesDir"", ""getExternalFilesDirs"", ""getExternalMediaDirs"", ""getExternalCacheDir"", ""getExternalCacheDirs"", ""getObbDir"", ""getObbDirs"")
        .withAnyParameters()
        .build()
    );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(mit, ""Make sure that external files are accessed safely here."");
  }
}
"
S5329,CODE_SMELL,Collection constructors should not be used as java.util.function.Function,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5329"")
public class CollectionConstructorReferenceCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(
        ""java.util.ArrayList"",
        ""java.util.HashMap"",
        ""java.util.HashSet"",
        ""java.util.Hashtable"",
        ""java.util.IdentityHashMap"",
        ""java.util.LinkedHashMap"",
        ""java.util.LinkedHashSet"",
        ""java.util.PriorityQueue"",
        ""java.util.Vector"",
        ""java.util.WeakHashMap"")
      .constructor()
      .addParametersMatcher(""int"")
      .build();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_REFERENCE);
  }

  @Override
  protected void onMethodReferenceFound(MethodReferenceTree methodReference) {
    if (""java.util.function.Function"".equals(methodReference.symbolType().fullyQualifiedName())) {
      String methodOwnerTypeName = ((ExpressionTree) methodReference.expression()).symbolType().name();
      reportIssue(methodReference, String.format(
        ""Replace this method reference by a lambda to explicitly show the usage of %1$s(int %2$s) or %1$s()."",
        methodOwnerTypeName,
        ""IdentityHashMap"".equals(methodOwnerTypeName) ? ""expectedMaxSize"" : ""initialCapacity""));
    }
  }

}
"
S5332,SECURITY_HOTSPOT,Using clear-text protocols is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S5332"")
public class ClearTextProtocolCheck extends IssuableSubscriptionVisitor {

  private static final Map<String, Protocol> PROTOCOLS = new HashMap<>();

  private static final String MESSAGE = ""Using %s protocol is insecure. Use %s instead."";
  private static final String MESSAGE_HTTP = ""Using HTTP protocol is insecure. Use HTTPS instead."";
  private static final String MESSAGE_ANDROID_MIXED_CONTENT = ""Using a relaxed mixed content policy is security-sensitive."";

  static {
    PROTOCOLS.put(""org.apache.commons.net.ftp.FTPClient"", new Protocol(""FTP"", ""SFTP, SCP or FTPS""));
    PROTOCOLS.put(""org.apache.commons.net.smtp.SMTPClient"", new Protocol(""clear-text SMTP"", ""SMTP over SSL/TLS or SMTP with STARTTLS""));
    PROTOCOLS.put(""org.apache.commons.net.telnet.TelnetClient"", new Protocol(""Telnet"", ""SSH""));
  }

  private static final MethodMatchers UNSECURE_CLIENTS = MethodMatchers.create()
    .ofTypes(PROTOCOLS.keySet().toArray(new String[0]))
    .constructor()
    .withAnyParameters()
    .build();

  private static final MethodMatchers OK_HTTP_CONNECTION_SPEC_BUILDERS = MethodMatchers.create()
    .ofTypes(""okhttp3.ConnectionSpec$Builder"")
    .constructor()
    .addParametersMatcher(""okhttp3.ConnectionSpec"")
    .build();

  private static final MethodMatchers OK_HTTP_BUILDERS = MethodMatchers.create()
    .ofTypes(""okhttp3.OkHttpClient$Builder"")
    .names(""connectionSpecs"")
    .addParametersMatcher(ANY)
    .build();

  private static final MethodMatchers ANDROID_SET_MIXED_CONTENT_MODE = MethodMatchers.create()
    .ofSubTypes(""android.webkit.WebSettings"")
    .names(""setMixedContentMode"")
    .addParametersMatcher(""int"")
    .build();

  public static final Integer MIXED_CONTENT_ALWAYS_ALLOW = 0;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.NEW_CLASS)) {
      NewClassTree newClassTree = (NewClassTree) tree;
      if (UNSECURE_CLIENTS.matches(newClassTree)) {
        Protocol protocol = PROTOCOLS.get(newClassTree.symbolType().fullyQualifiedName());
        String message = String.format(MESSAGE, protocol.protocolName, protocol.alternatives);
        reportIssue(newClassTree.identifier(), message);
      } else if (OK_HTTP_CONNECTION_SPEC_BUILDERS.matches(newClassTree)) {
        reportIfUsesClearText(newClassTree.arguments());
      }
    } else {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      if (OK_HTTP_BUILDERS.matches(mit)) {
        reportIfUsesClearText(mit.arguments());
      } else if (ANDROID_SET_MIXED_CONTENT_MODE.matches(mit)) {
        reportIfAlwaysAllow(mit.arguments().get(0));
      }
    }
  }

  private void reportIfAlwaysAllow(ExpressionTree setMixedContentModeArgument) {
    if (MIXED_CONTENT_ALWAYS_ALLOW.equals(ExpressionUtils.resolveAsConstant(setMixedContentModeArgument))) {
      reportIssue(setMixedContentModeArgument, MESSAGE_ANDROID_MIXED_CONTENT);
    }
  }

  private void reportIfUsesClearText(Arguments arguments) {
    arguments.accept(new ClearTextVisitor());
  }

  class ClearTextVisitor extends BaseTreeVisitor {
    @Override
    public void visitIdentifier(IdentifierTree tree) {
      if (""CLEARTEXT"".equals(tree.name())) {
        reportIssue(tree, MESSAGE_HTTP);
      }
    }
  }

  private static class Protocol {
    String protocolName;
    String alternatives;

    Protocol(String protocolName, String alternatives) {
      this.protocolName = protocolName;
      this.alternatives = alternatives;
    }
  }
}
"
S5344,VULNERABILITY,Passwords should not be stored in plaintext or with a fast hashing algorithm,"package org.sonar.java.checks.security;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5344"")
public class PasswordEncoderCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers JDBC_AUTHENTICATION = MethodMatchers.create()
    .ofSubTypes(""org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder"")
    .names(""jdbcAuthentication"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers USER_DETAIL_SERVICE = MethodMatchers.create()
    .ofSubTypes(""org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder"")
    .names(""userDetailsService"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers PASSWORD_ENCODER_SETTER = MethodMatchers.create()
    .ofSubTypes(""org.springframework.security.config.annotation.authentication.configurers.userdetails.AbstractDaoAuthenticationConfigurer"")
    .names(""passwordEncoder"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers UNSAFE_PASSWORD_ENCODER_CONSTRUCTORS = MethodMatchers.create()
    .ofTypes(
      ""org.springframework.security.authentication.encoding.ShaPasswordEncoder"",
      ""org.springframework.security.authentication.encoding.Md5PasswordEncoder"",
      ""org.springframework.security.crypto.password.LdapShaPasswordEncoder"",
      ""org.springframework.security.crypto.password.Md4PasswordEncoder"",
      ""org.springframework.security.crypto.password.MessageDigestPasswordEncoder"",
      ""org.springframework.security.crypto.password.StandardPasswordEncoder"",
      ""org.springframework.security.crypto.scrypt.SCryptPasswordEncoder"")
    .constructor()
    .withAnyParameters()
    .build();

  private static final MethodMatchers UNSAFE_PASSWORD_ENCODER_METHODS = MethodMatchers.create()
    .ofTypes(""org.springframework.security.crypto.password.NoOpPasswordEncoder"")
    .names(""getInstance"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.NEW_CLASS, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree instanceof NewClassTree nct && UNSAFE_PASSWORD_ENCODER_CONSTRUCTORS.matches(nct)) {
      reportIssue(nct.identifier(), ""Use secure \""PasswordEncoder\"" implementation."");
    } else if (tree instanceof MethodInvocationTree mit && UNSAFE_PASSWORD_ENCODER_METHODS.matches(mit)) {
      reportIssue(ExpressionUtils.methodName(mit), ""Use secure \""PasswordEncoder\"" implementation."");
    } else if (tree.is(Tree.Kind.METHOD)) {
      MethodInvocationVisitor visitor = new MethodInvocationVisitor();
      tree.accept(visitor);
      if (visitor.hasAuthentication && !visitor.setsPasswordEncoder) {
        reportIssue(visitor.tree, ""Don't use the default \""PasswordEncoder\"" relying on plain-text."");
      }
    }
  }

  static class MethodInvocationVisitor extends BaseTreeVisitor {

    private boolean hasAuthentication;
    private boolean setsPasswordEncoder;
    private MethodInvocationTree tree;

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (JDBC_AUTHENTICATION.matches(tree) || USER_DETAIL_SERVICE.matches(tree)) {
        hasAuthentication = true;
        this.tree = tree;
      }
      if (PASSWORD_ENCODER_SETTER.matches(tree)) {
        setsPasswordEncoder = true;
      }
      super.visitMethodInvocation(tree);
    }
  }
}
"
S5361,CODE_SMELL,"""String#replace"" should be preferred to ""String#replaceAll""","package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.ast.RegexTree;
import org.sonarsource.analyzer.commons.regex.ast.SequenceTree;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S5361"")
public class StringReplaceCheck extends AbstractRegexCheck {

  private static final String LANG_STRING = ""java.lang.String"";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(LANG_STRING)
      .names(""replaceAll"")
      .addParametersMatcher(LANG_STRING, LANG_STRING)
      .build();
  }

  @Override
  protected boolean filterAnnotation(AnnotationTree annotation) {
    return false;
  }

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    RegexTree regex = regexForLiterals.getResult();
    if (!regexForLiterals.hasSyntaxErrors() && isPlainString(regex)) {
      reportIssue(ExpressionUtils.methodName((MethodInvocationTree) methodInvocationOrAnnotation),
        ""Replace this call to \""replaceAll()\"" by a call to the \""replace()\"" method."");
    }
  }

  private static boolean isPlainString(RegexTree regex) {
    return regex.is(RegexTree.Kind.CHARACTER)
      || (regex.is(RegexTree.Kind.SEQUENCE)
      && ((SequenceTree) regex).getItems().stream().allMatch(item -> item.is(RegexTree.Kind.CHARACTER)));
  }
}
"
S5411,CODE_SMELL,"Avoid using boxed ""Boolean"" types directly in boolean expressions","package org.sonar.java.checks;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type.Primitives;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.DoWhileStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.TypeCastTree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S5411"")
public class BoxedBooleanExpressionsCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final String MESSAGE = ""Use a primitive boolean expression here."";
  private static final String MESSAGE_QUICKFIX = ""Use a primitive boolean expression"";

  private static final MethodMatchers OPTIONAL_OR_ELSE = MethodMatchers.create()
    .ofTypes(""java.util.Optional"").names(""orElse"").addParametersMatcher(ANY).build();

  private static final String BOOLEAN = ""java.lang.Boolean"";
  private JavaFileScannerContext context;

  private static final Map<Tree, IfStatementTree> ifStatementCache = new HashMap<>();
  private static final Map<Symbol, ExpressionTree> firstNullCheckCache = new HashMap<>();

  @Override
  public void scanFile(JavaFileScannerContext context) {
    ifStatementCache.clear();
    firstNullCheckCache.clear();
    this.context = context;
    if (context.getSemanticModel() != null) {
      scan(context.getTree());
    }
  }

  @Override
  public void visitForStatement(ForStatementTree tree) {
    if (tree.condition() != null && !isSafeBooleanExpression(tree.condition())) {
      scan(tree.initializer());
      scan(tree.update());
      scan(tree.statement());
    } else {
      super.visitForStatement(tree);
    }
  }

  @Override
  public void visitWhileStatement(WhileStatementTree tree) {
    if (!isSafeBooleanExpression(tree.condition())) {
      scan(tree.statement());
    } else {
      super.visitWhileStatement(tree);
    }
  }

  @Override
  public void visitDoWhileStatement(DoWhileStatementTree tree) {
    if (!isSafeBooleanExpression(tree.condition())) {
      scan(tree.statement());
    } else {
      super.visitDoWhileStatement(tree);
    }
  }

  @Override
  public void visitIfStatement(IfStatementTree tree) {
    if (!isSafeBooleanExpression(tree.condition())) {
      scan(tree.thenStatement());
      scan(tree.elseStatement());
    } else {
      super.visitIfStatement(tree);
    }
  }

  @Override
  public void visitConditionalExpression(ConditionalExpressionTree tree) {
    if (!isSafeBooleanExpression(tree.condition())) {
      scan(tree.trueExpression());
      scan(tree.falseExpression());
    } else {
      super.visitConditionalExpression(tree);
    }
  }

  private boolean isSafeBooleanExpression(ExpressionTree tree) {
    ExpressionTree boxedBoolean = findBoxedBoolean(tree);
    if (boxedBoolean != null) {
      // The rule is relaxed if the first usage of the variable is a test against nullness.
      // A more thorough approach would require tracing all possible paths to lookup the test using symbolic execution.
      if (isFirstUsageANullCheck(boxedBoolean)) {
        return true;
      }
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(boxedBoolean)
        .withMessage(MESSAGE)
        .withQuickFixes(() -> getQuickFix(tree, boxedBoolean))
        .report();
      return false;
    }
    return true;
  }

  private static boolean isFirstUsageANullCheck(ExpressionTree boxedBoolean) {
    if (boxedBoolean.is(Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) boxedBoolean;
      // Usages are not guaranteed to be ordered
      List<IdentifierTree> usages = identifier.symbol().usages();
      Tree firstUsage = usages.get(0).parent();
      // Test if the first usage in our list is a null check
      if (firstUsage.is(Kind.EQUAL_TO, Kind.NOT_EQUAL_TO) && isNullCheck((ExpressionTree) firstUsage)) {
        return true;
      }
      // Return false if the only usage is not a null check
      if (usages.size() == 1) {
        return false;
      }
      // Fetch the first null check in the usages list
      Optional<ExpressionTree> firstNullCheck = getFirstNullCheck(identifier.symbol());
      if (!firstNullCheck.isPresent()) {
        return false;
      }
      // Test if the first null check and the first usage are part of the same higher if structure
      Optional<IfStatementTree> ifStatementWithNullCheck = getParentConditionalBranch(firstNullCheck.get());
      Optional<IfStatementTree> ifStatementWithFirstUsage = getParentConditionalBranch(firstUsage);
      return ifStatementWithNullCheck.equals(ifStatementWithFirstUsage);
    }
    if (boxedBoolean.is(Kind.TYPE_CAST)) {
      TypeCastTree typeCast = (TypeCastTree) boxedBoolean;
      return isFirstUsageANullCheck(typeCast.expression());
    }
    return false;
  }

  private static Optional<ExpressionTree> getFirstNullCheck(Symbol symbol) {
    if (firstNullCheckCache.containsKey(symbol)) {
      return Optional.ofNullable(firstNullCheckCache.get(symbol));
    }
    Optional<ExpressionTree> firstNullCheck = symbol.usages().stream()
      .map(IdentifierTree::parent)
      .filter(tree -> tree.is(Kind.EQUAL_TO, Kind.NOT_EQUAL_TO) && isNullCheck((ExpressionTree) tree))
      .map(ExpressionTree.class::cast)
      .findFirst();
    firstNullCheckCache.put(symbol, firstNullCheck.orElse(null));
    return firstNullCheck;
  }


  private static Optional<IfStatementTree> getParentConditionalBranch(Tree tree) {
    Deque<Tree> trees = new ArrayDeque<>();
    Tree current = tree;
    IfStatementTree ifStatementTree = null;

    while (current != null && ifStatementTree == null) {
      if (ifStatementCache.containsKey(tree)) {
        ifStatementTree = ifStatementCache.get(tree);
      } else if (current.is(Kind.IF_STATEMENT)) {
        ifStatementTree = (IfStatementTree) current;
      }
      trees.add(current);
      current = current.parent();
    }

    while (!trees.isEmpty()) {
      ifStatementCache.put(trees.pop(), ifStatementTree);
    }

    return Optional.ofNullable(ifStatementTree);
  }

  @CheckForNull
  private static ExpressionTree findBoxedBoolean(ExpressionTree tree) {
    if (tree.symbolType().is(BOOLEAN) && !isValidMethodInvocation(tree)) {
      return tree;
    }
    if (tree.is(Kind.LOGICAL_COMPLEMENT)) {
      return findBoxedBoolean(((UnaryExpressionTree) tree).expression());
    }
    if (tree instanceof BinaryExpressionTree expr) {
      if (findBoxedBoolean(expr.leftOperand()) != null && expr.rightOperand().symbolType().isPrimitive(Primitives.BOOLEAN)) {
        return expr.leftOperand();
      }
      if (findBoxedBoolean(expr.rightOperand()) != null && expr.leftOperand().symbolType().isPrimitive(Primitives.BOOLEAN) && !isNullCheck(expr.leftOperand())) {
        return expr.rightOperand();
      }
    }
    return null;
  }

  private static boolean isNullCheck(ExpressionTree tree) {
    if (tree.is(Kind.NOT_EQUAL_TO, Kind.EQUAL_TO)) {
      BinaryExpressionTree expr = (BinaryExpressionTree) tree;
      return expr.leftOperand().is(Kind.NULL_LITERAL) || expr.rightOperand().is(Kind.NULL_LITERAL);
    }
    return false;
  }

  private static boolean isValidMethodInvocation(ExpressionTree tree) {
    if (tree.is(Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      return isOptionalInvocation(mit) || isAnnotatedNonnull(mit);
    }
    return false;
  }

  private static boolean isOptionalInvocation(MethodInvocationTree mit) {
    return OPTIONAL_OR_ELSE.matches(mit) && !mit.arguments().get(0).is(Kind.NULL_LITERAL);
  }

  private static boolean isAnnotatedNonnull(MethodInvocationTree mit) {
    return mit.methodSymbol().metadata()
      .annotations()
      .stream()
      .map(SymbolMetadata.AnnotationInstance::symbol)
      .map(Symbol::name)
      .anyMatch(name -> ""nonNull"".equalsIgnoreCase(name) || ""notNull"".equalsIgnoreCase(name));
  }

  private static List<JavaQuickFix> getQuickFix(ExpressionTree tree, ExpressionTree boxedBoolean) {
    if (tree.is(Kind.METHOD_INVOCATION) && OPTIONAL_OR_ELSE.matches((MethodInvocationTree) tree)) {
      // We do not suggest a quick fix when we have an optional
      return Collections.emptyList();
    }
    List<JavaTextEdit> edits = new ArrayList<>(2);
    if (tree.is(Kind.LOGICAL_COMPLEMENT)) {
      edits.add(JavaTextEdit.replaceTree(((UnaryExpressionTree) tree).operatorToken(), ""Boolean.FALSE.equals(""));
    } else {
      edits.add(JavaTextEdit.insertBeforeTree(boxedBoolean, ""Boolean.TRUE.equals(""));
    }
    edits.add(JavaTextEdit.insertAfterTree(boxedBoolean, "")""));

    return Collections.singletonList(JavaQuickFix.newQuickFix(MESSAGE_QUICKFIX)
      .addTextEdits(edits)
      .build());
  }
}
"
S5413,CODE_SMELL,'List.remove()' should not be used in ascending 'for' loops,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BreakStatementTree;
import org.sonar.plugins.java.api.tree.ContinueStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S5413"")
public class SuspiciousListRemoveCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers LIST_REMOVE = MethodMatchers.create()
    .ofTypes(""java.util.List"")
    .names(""remove"")
    .addParametersMatcher(""int"")
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.FOR_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    ForStatementTree forStatementTree = (ForStatementTree) tree;
    Symbol counter = findLoopCounter(forStatementTree);
    if (counter == null || !isIncrementingLoop(forStatementTree, counter)) {
      return;
    }
    StatementTree loopBody = forStatementTree.statement();
    LoopBodyVisitor loopBodyVisitor = new LoopBodyVisitor(counter);
    loopBody.accept(loopBodyVisitor);
    if (loopBodyVisitor.hasIssue()) {
      reportIssue(loopBodyVisitor.listRemove, ""Verify that \""remove()\"" is used correctly."");
    }
  }

  @CheckForNull
  private static Symbol findLoopCounter(ForStatementTree forStatementTree) {
    if (forStatementTree.initializer().size() != 1) {
      return null;
    }
    StatementTree initializer = forStatementTree.initializer().get(0);
    if (!initializer.is(Tree.Kind.VARIABLE)) {
      return null;
    }
    return  ((VariableTree) initializer).symbol();
  }

  private static boolean isIncrementingLoop(ForStatementTree forStatementTree, Symbol counter) {
    if (forStatementTree.update().size() != 1) {
      return false;
    }
    StatementTree loopUpdate = forStatementTree.update().get(0);
    if (loopUpdate.is(Tree.Kind.EXPRESSION_STATEMENT)
      && ((ExpressionStatementTree) loopUpdate).expression().is(Tree.Kind.POSTFIX_INCREMENT, Tree.Kind.PREFIX_INCREMENT)) {
      ExpressionTree expression = ((UnaryExpressionTree) ((ExpressionStatementTree) loopUpdate).expression()).expression();
      return expression.is(Tree.Kind.IDENTIFIER) && counter.equals(((IdentifierTree) expression).symbol());
    }
    return false;
  }

  private static class LoopBodyVisitor extends BaseTreeVisitor {
    private final Symbol counter;
    private MethodInvocationTree listRemove;
    private boolean hasBreakOrContinueOrReturn;
    private boolean isCounterAssigned;

    public LoopBodyVisitor(Symbol counter) {
      this.counter = counter;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (LIST_REMOVE.matches(tree)) {
        listRemove = tree;
      }
      super.visitMethodInvocation(tree);
    }

    @Override
    public void visitBreakStatement(BreakStatementTree tree) {
      hasBreakOrContinueOrReturn = true;
      super.visitBreakStatement(tree);
    }

    @Override
    public void visitContinueStatement(ContinueStatementTree tree) {
      hasBreakOrContinueOrReturn = true;
      super.visitContinueStatement(tree);
    }

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      hasBreakOrContinueOrReturn = true;
      super.visitReturnStatement(tree);
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      if (tree.variable().is(Tree.Kind.IDENTIFIER)) {
        isCounterAssigned |= counter.equals(((IdentifierTree) tree.variable()).symbol());
      }
      super.visitAssignmentExpression(tree);
    }

    @Override
    public void visitUnaryExpression(UnaryExpressionTree tree) {
      if (tree.expression().is(Tree.Kind.IDENTIFIER)) {
        isCounterAssigned |= counter.equals(((IdentifierTree) tree.expression()).symbol());
      }
      super.visitUnaryExpression(tree);
    }

    boolean hasIssue() {
      return listRemove != null && !hasBreakOrContinueOrReturn && !isCounterAssigned;
    }
  }

}
"
S5443,SECURITY_HOTSPOT,Using publicly writable directories is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.checks.helpers.ExpressionsHelper.getInvokedSymbol;

@Rule(key = ""S5443"")
public class PubliclyWritableDirectoriesCheck extends IssuableSubscriptionVisitor {

  private static final String STRING_TYPE = ""java.lang.String"";
  private static final String JAVA_NIO_FILE_FILES = ""java.nio.file.Files"";
  private static final String JAVA_NIO_FILE_PATHS = ""java.nio.file.Paths"";
  private static final String JAVA_NIO_FILE_PATH = ""java.nio.file.Path"";
  private static final String JAVA_IO_FILE = ""java.io.File"";

  private static final String MESSAGE = ""Make sure publicly writable directories are used safely here."";
  
  private static final List<String> PUBLIC_WRITABLE_DIRS = Arrays.asList(
    ""/tmp"",
    ""/var/tmp"",
    ""/usr/tmp"",
    ""/dev/shm"",
    ""/dev/mqueue"",
    ""/run/lock"",
    ""/var/run/lock"",
    ""/Library/Caches"",
    ""/Users/Shared"",
    ""/private/tmp"",
    ""/private/var/tmp"",
    ""\\\\Windows\\\\Temp"",
    ""\\\\Temp"",
    ""\\\\TMP"");

  private static final Set<String> TMP_DIR_ENV = SetUtils.immutableSetOf(""TMP"", ""TMPDIR"");

  private static final MethodMatchers CREATE_FILE_MATCHERS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(JAVA_NIO_FILE_PATHS, JAVA_NIO_FILE_PATH)
      .names(""get"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofTypes(JAVA_NIO_FILE_PATH)
      .names(""of"")
      .withAnyParameters()
      .build());

  private static final MethodMatchers CREATE_FILE_CONSTRUCTOR_MATCHERS = MethodMatchers.create()
    .ofTypes(JAVA_IO_FILE, ""java.io.FileReader"")
    .constructor()
    .addParametersMatcher(STRING_TYPE)
    .addParametersMatcher(STRING_TYPE, STRING_TYPE)
    .addParametersMatcher(STRING_TYPE, ""java.nio.charset.Charset"")
    .build();

  private static final MethodMatchers TEMP_DIR_MATCHER = MethodMatchers.create()
    .ofTypes(JAVA_IO_FILE)
    .names(""createTempFile"")
    .addParametersMatcher(STRING_TYPE, STRING_TYPE)
    .build();

  private static final MethodMatchers NIO_TEMP_DIR_MATCHER = MethodMatchers.create()
    .ofTypes(JAVA_NIO_FILE_FILES)
    .names(""createTempDirectory"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers NIO_TEMP_FILE_MATCHER = MethodMatchers.create()
    .ofTypes(JAVA_NIO_FILE_FILES)
    .names(""createTempFile"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers MAP_GET = MethodMatchers.create()
    .ofSubTypes(""java.util.Map"")
    .names(""get"")
    .addParametersMatcher(""java.lang.Object"")
    .build();

  private static final MethodMatchers SYSTEM_GETENV = MethodMatchers.create()
    .ofSubTypes(""java.lang.System"")
    .names(""getenv"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      if (createdInTempDir(mit) || hasSensitiveFileName(mit) || usesSystemTempDir(mit)) {
        reportIssue(tree, MESSAGE);
      }
    } else {
      NewClassTree newClassTree = (NewClassTree) tree;
      if (CREATE_FILE_CONSTRUCTOR_MATCHERS.matches(newClassTree) &&
        isSensitiveFileName(newClassTree.arguments().get(0))) {
        reportIssue(tree, MESSAGE);
      }
    }
  }

  private static boolean hasSensitiveFileName(MethodInvocationTree mit) {
    return CREATE_FILE_MATCHERS.matches(mit) &&
      isSensitiveFileName(mit.arguments().get(0));
  }

  private static boolean usesSystemTempDir(MethodInvocationTree mit) {
    return MAP_GET.matches(mit) && hasTMPAsArgument(mit) && isInitializedWithSystemGetEnv(mit);
  }

  private static boolean hasTMPAsArgument(MethodInvocationTree mit) {
    return mit.arguments().get(0).asConstant(String.class)
      .map(TMP_DIR_ENV::contains)
      .orElse(false);
  }

  private static boolean createdInTempDir(MethodInvocationTree mit) {
    return TEMP_DIR_MATCHER.matches(mit) ||
      (NIO_TEMP_DIR_MATCHER.matches(mit) && (mit.arguments().size() == 1)) ||
      (NIO_TEMP_FILE_MATCHER.matches(mit) && (mit.arguments().size() == 2));
  }

  private static boolean isSensitiveFileName(ExpressionTree expressionTree) {
    return expressionTree.asConstant(String.class)
      .filter(path -> PUBLIC_WRITABLE_DIRS.stream().anyMatch(path::startsWith))
      .isPresent();
  }

  private static boolean isInitializedWithSystemGetEnv(MethodInvocationTree mit) {
    return getInvokedSymbol(mit)
      .filter(ExpressionsHelper::isNotReassigned)
      .map(Symbol::declaration)
      .filter(decl -> decl.is(Tree.Kind.VARIABLE))
      .map(VariableTree.class::cast)
      .map(VariableTree::initializer)
      .map(ExpressionUtils::skipParentheses)
      .filter(initializer -> initializer.is(Tree.Kind.METHOD_INVOCATION))
      .map(MethodInvocationTree.class::cast)
      .map(SYSTEM_GETENV::matches)
      .orElse(false);
  }

}
"
S5445,VULNERABILITY,Insecure temporary file creation methods should not be used,"package org.sonar.java.checks;

import org.sonar.check.Rule;

@Rule(key = ""S5445"")
public class InsecureCreateTempFileCheck extends AbstractCreateTempFileChecker {

  @Override
  public String getMessage() {
    return ""Use \""Files.createTempDirectory\"" to create this directory instead."" +
      context.getJavaVersion().java7CompatibilityMessage();
  }
}
"
S5527,VULNERABILITY,Server hostnames should be verified during SSL/TLS connections,"package org.sonar.java.checks.security;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.ExpressionsHelper.getConstantValueAsString;
import static org.sonar.java.model.ExpressionUtils.extractIdentifierSymbol;
import static org.sonar.java.model.ExpressionUtils.isInvocationOnVariable;

@Rule(key = ""S5527"")
public class VerifiedServerHostnamesCheck extends IssuableSubscriptionVisitor {

  private static final String ISSUE_MESSAGE = ""Enable server hostname verification on this SSL/TLS connection."";

  private static final String JAVAX_NET_SSL_HOSTNAME_VERIFIER = ""javax.net.ssl.HostnameVerifier"";
  private static final MethodMatchers HOSTNAME_VERIFIER = MethodMatchers.create()
    .ofSubTypes(JAVAX_NET_SSL_HOSTNAME_VERIFIER)
    .names(""verify"")
    .addParametersMatcher(""java.lang.String"", ""javax.net.ssl.SSLSession"")
    .build();

  private static final String APACHE_EMAIL = ""org.apache.commons.mail.Email"";
  private static final Set<String> ENABLING_SSL_METHOD_NAMES = new HashSet<>(Arrays.asList(
    ""setSSL"",
    ""setSSLOnConnect"",
    ""setTLS"",
    ""setStartTLSEnabled"",
    ""setStartTLSRequired""));
  private static final MethodMatchers ENABLING_SSL_METHODS = MethodMatchers.create()
    .ofSubTypes(APACHE_EMAIL)
    .name(ENABLING_SSL_METHOD_NAMES::contains)
    .addParametersMatcher(""boolean"")
    .build();

  private static final MethodMatchers HASHTABLE_PUT = MethodMatchers.create()
    .ofSubTypes(""java.util.Hashtable"")
    .names(""put"")
    .withAnyParameters()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.METHOD, Tree.Kind.LAMBDA_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    switch (tree.kind()) {
      case METHOD:
        checkMethodDefinition((MethodTree) tree);
        break;
      case LAMBDA_EXPRESSION:
        checkLambdaDefinition(((LambdaExpressionTree) tree));
        break;
      case METHOD_INVOCATION:
        checkMethodInvocation((MethodInvocationTree) tree);
        break;
      default:
        // can not happen
        break;
    }
  }

  private void checkMethodDefinition(MethodTree tree) {
    BlockTree blockTree = tree.block();
    if (blockTree == null) {
      return;
    }
    if (HOSTNAME_VERIFIER.matches(tree)) {
      checkBlock(blockTree);
    }
  }

  private void checkLambdaDefinition(LambdaExpressionTree lambdaExpression) {
    Tree lambdaBody = lambdaExpression.body();
    if (isHostnameVerifierSignature(lambdaExpression)) {
      if (lambdaBody.is(Tree.Kind.BLOCK)) {
        checkBlock((BlockTree) lambdaBody);
      } else if (isTrueLiteral(lambdaBody)) {
        reportIssue(lambdaBody, ISSUE_MESSAGE);
      }
    }
  }

  private void checkBlock(BlockTree blockTree) {
    List<StatementTree> innerBlock = blockTree.body();
    while (innerBlock.size() == 1 && innerBlock.get(0).is(Tree.Kind.BLOCK)) {
      innerBlock = ((BlockTree) innerBlock.get(0)).body();
    }

    List<StatementTree> statementTreeList = innerBlock.stream()
      .filter(statementTree -> !statementTree.is(Tree.Kind.EMPTY_STATEMENT))
      .toList();
    if (isReturnTrueStatement(statementTreeList)) {
      reportIssue(statementTreeList.get(0), ISSUE_MESSAGE);
    }
  }

  private static boolean isHostnameVerifierSignature(LambdaExpressionTree lambdaExpressionTree) {
    return lambdaExpressionTree.symbolType().isSubtypeOf(JAVAX_NET_SSL_HOSTNAME_VERIFIER);
  }

  private static boolean isReturnTrueStatement(List<StatementTree> statementTreeList) {
    if (statementTreeList.size() == 1 && statementTreeList.get(0).is(Tree.Kind.RETURN_STATEMENT)) {
      ExpressionTree expression = ((ReturnStatementTree) statementTreeList.get(0)).expression();
      return isTrueLiteral(expression);
    }
    return false;
  }

  private static boolean isTrueLiteral(Tree tree) {
    if (tree.is(Tree.Kind.PARENTHESIZED_EXPRESSION) || tree.is(Tree.Kind.BOOLEAN_LITERAL)) {
      ExpressionTree expression = ExpressionUtils.skipParentheses((ExpressionTree) tree);
      return LiteralUtils.isTrue(expression);
    }
    return false;
  }

  private void checkMethodInvocation(MethodInvocationTree mit) {
    MethodTree method = ExpressionUtils.getEnclosingMethod(mit);
    if (method == null) {
      return;
    }

    ExpressionTree methodSelect = mit.methodSelect();

    if (!methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      return;
    }

    Symbol extractedIdentifier = extractIdentifierSymbol(((MemberSelectExpressionTree) methodSelect).expression()).orElse(null);

    if (ENABLING_SSL_METHODS.matches(mit) && LiteralUtils.isTrue(mit.arguments().get(0))) {
      MethodBodyApacheVisitor apacheVisitor = new MethodBodyApacheVisitor(extractedIdentifier);
      method.accept(apacheVisitor);
      if (!apacheVisitor.isSecured) {
        reportIssue(mit, ISSUE_MESSAGE);
      }
    } else if (HASHTABLE_PUT.matches(mit) && isSettingSSL(mit.arguments())) {
      MethodBodyHashtableVisitor hashtableVisitor = new MethodBodyHashtableVisitor(extractedIdentifier);
      method.accept(hashtableVisitor);
      if (!hashtableVisitor.isSecured) {
        reportIssue(mit, ""Enable server hostname verification on this SSL/TLS connection, by setting \""mail.smtp.ssl.checkserveridentity\"" to true."");
      }
    }
  }

  private static boolean isSettingSSL(Arguments args) {
    return ""mail.smtp.socketFactory.class"".equals(getConstantValueAsString(args.get(0)).value())
      && ""javax.net.ssl.SSLSocketFactory"".equals(getConstantValueAsString(args.get(1)).value());
  }

  private static boolean isNotFalse(ExpressionTree expression) {
    return !LiteralUtils.isFalse(expression);
  }

  private static class MethodBodyApacheVisitor extends BaseTreeVisitor {
    private boolean isSecured = false;
    private Symbol variable;

    private static final MethodMatchers SET_SSL_CHECK_SERVER_ID = MethodMatchers.create()
      .ofSubTypes(APACHE_EMAIL)
      .names(""setSSLCheckServerIdentity"")
      .addParametersMatcher(""boolean"")
      .build();

    MethodBodyApacheVisitor(@Nullable Symbol variable) {
      this.variable = variable;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree mit) {
      if (isInvocationOnVariable(mit, variable, true) && SET_SSL_CHECK_SERVER_ID.matches(mit) && isNotFalse(mit.arguments().get(0))) {
        this.isSecured = true;
      }
      super.visitMethodInvocation(mit);
    }
  }

  private static class MethodBodyHashtableVisitor extends BaseTreeVisitor {
    private boolean isSecured = false;
    private Symbol variable;

    MethodBodyHashtableVisitor(@Nullable Symbol variable) {
      this.variable = variable;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree mit) {
      if (isInvocationOnVariable(mit, variable, true)) {
        Arguments args = mit.arguments();
        if (HASHTABLE_PUT.matches(mit)
          && ""mail.smtp.ssl.checkserveridentity"".equals(getConstantValueAsString(args.get(0)).value())
          && isNotFalse(args.get(1))) {
          this.isSecured = true;
        }
      }
      super.visitMethodInvocation(mit);
    }
  }
}
"
S5542,VULNERABILITY,Encryption algorithms should be used with secure mode and padding scheme,"package org.sonar.java.checks.security;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.JavaPropertiesHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5542"")
public class EncryptionAlgorithmCheck extends AbstractMethodDetection {

  private static final Pattern ALGORITHM_PATTERN = Pattern.compile(""([^/]+)/([^/]+)/([^/]+)"");

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""javax.crypto.Cipher"")
      .names(""getInstance"")
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (mit.arguments().isEmpty()) {
      return;
    }
    ExpressionTree firstArgument = mit.arguments().get(0);
    ExpressionTree algorithmTree = firstArgument;
    // Improve the review experience by helping to understand what is inside the first argument in case it's not hardcoded.
    List<JavaFileScannerContext.Location> transformationDefinition = new ArrayList<>();

    ExpressionTree defaultPropertyValue = JavaPropertiesHelper.retrievedPropertyDefaultValue(firstArgument);
    if (defaultPropertyValue != null) {
      algorithmTree = defaultPropertyValue;
      transformationDefinition.add(new JavaFileScannerContext.Location(""Default transformation"", defaultPropertyValue));
    } else if (firstArgument.is(Tree.Kind.IDENTIFIER)) {
      Tree declaration = ((IdentifierTree) firstArgument).symbol().declaration();
      if (declaration != null) {
        // We expect that most of the time, the identifier will directly lead to a constant, so this is already enough.
        // ""getConstantValueAsString"" can be smarter and rebuild a constant from more complex tree (concatenation, ...)
        // in this case, the secondary will not be perfect, but still a first step to understand easily the issue.
        transformationDefinition.add(new JavaFileScannerContext.Location(""Transformation definition"", declaration));
      }
    }
    String algorithmName = ExpressionsHelper.getConstantValueAsString(algorithmTree).value();
    if (algorithmName != null) {
      getInsecureAlgorithmMessage(algorithmName).ifPresent(msg -> reportIssue(firstArgument, msg, transformationDefinition, null));
    }
  }

  private static Optional<String> getInsecureAlgorithmMessage(String algorithmName) {
    Matcher matcher = ALGORITHM_PATTERN.matcher(algorithmName);
    if (matcher.matches()) {
      String algorithm = matcher.group(1);
      String mode = matcher.group(2);
      String padding = matcher.group(3);

      boolean isRSA = ""RSA"".equalsIgnoreCase(algorithm);

      if (""ECB"".equalsIgnoreCase(mode) && !isRSA) {
        return Optional.of(""Use a secure cipher mode."");
      }

      if (""CBC"".equalsIgnoreCase(mode) && !""NoPadding"".equalsIgnoreCase(padding)) {
        return Optional.of(""Use another cipher mode or disable padding."");
      }

      if (isRSA && !(padding.toUpperCase(Locale.ROOT).startsWith(""OAEP""))) {
        return Optional.of(""Use a secure padding scheme."");
      }

      return Optional.empty();
    }
    // By default, ECB is used.
    return Optional.of(""Use a secure padding scheme."");
  }
}
"
S5547,VULNERABILITY,Cipher algorithms should be robust,"package org.sonar.java.checks;

import java.util.Locale;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.JavaPropertiesHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;

@Rule(key = ""S5547"")
public class StrongCipherAlgorithmCheck extends AbstractMethodDetection {

  private static final String MESSAGE = ""Use a strong cipher algorithm."";

  private static final Set<String> VULNERABLE_ALGORITHMS = Stream.of(
    ""DES"", ""DESede"", ""DESedeWrap"",
    ""RC2"", ""ARC2"",
    ""RC4"", ""ARC4"", ""ARCFOUR"",
    ""Blowfish"")
    .map(name -> name.toUpperCase(Locale.ROOT))
    .collect(Collectors.toSet());

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofTypes(""javax.crypto.Cipher"").names(""getInstance"").withAnyParameters().build(),
      MethodMatchers.create().ofTypes(""javax.crypto.NullCipher"").constructor().withAnyParameters().build());
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    reportIssue(newClassTree.identifier(), MESSAGE);
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree firstArg = mit.arguments().get(0);
    ExpressionTree defaultValue = JavaPropertiesHelper.retrievedPropertyDefaultValue(firstArg);
    String firstArgStringValue = ExpressionsHelper.getConstantValueAsString(defaultValue != null ? defaultValue : firstArg).value();
    if (firstArgStringValue != null) {
      checkIssue(firstArg, firstArgStringValue);
    }
  }

  private void checkIssue(ExpressionTree argumentForReport, String algorithm) {
    String[] transformationElements = algorithm.split(""/"");
    if (transformationElements.length > 0 && VULNERABLE_ALGORITHMS.contains(transformationElements[0].toUpperCase(Locale.ROOT))) {
      reportIssue(argumentForReport, MESSAGE);
    }
  }

}
"
S5612,CODE_SMELL,Lambdas should not have too many lines,"package org.sonar.java.checks;

import java.util.Collections;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.ast.visitors.LinesOfCodeVisitor;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5612"")
public class LambdaTooBigCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final int DEFAULT_MAX = 10;

  @RuleProperty(key = ""Max"",
    description = ""Maximum allowed lines in a lambda"",
    defaultValue = """" + DEFAULT_MAX)
  public int max = DEFAULT_MAX;

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
    int lines = getNumberOfLines(lambdaExpressionTree);
    if (lines > max) {
      SyntaxToken firstToken = lambdaExpressionTree.firstToken();
      SyntaxToken lastSyntaxToken = lambdaExpressionTree.lastToken();
      JavaFileScannerContext.Location lastTokenLocation = new JavaFileScannerContext.Location(lines + "" lines"", lastSyntaxToken);
      context.reportIssue(this, firstToken, lambdaExpressionTree.arrowToken(),
        ""Reduce this lambda expression number of lines from "" + lines + "" to at most "" + max + ""."", Collections.singletonList(lastTokenLocation), null);
    }
    super.visitLambdaExpression(lambdaExpressionTree);
  }

  private static int getNumberOfLines(Tree tree) {
    return new LinesOfCodeVisitor().linesOfCode(tree);
  }
}
"
S5659,VULNERABILITY,JWT should be signed and verified with strong cipher algorithms,"package org.sonar.java.checks.security;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S5659"")
public class JWTWithStrongCipherCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE_STRONG_CIPHER = ""Use only strong cipher algorithms when %s this JWT."";

  private static final String AUTH0_JWT_ALGORITHM = ""com.auth0.jwt.algorithms.Algorithm"";

  private static final MethodMatchers AUTH0_JWT_REQUIRE = MethodMatchers.create()
    .ofTypes(""com.auth0.jwt.JWT"")
    .names(""require"")
    .addParametersMatcher(AUTH0_JWT_ALGORITHM)
    .build();

  private static final MethodMatchers AUTH0_JWT_SIGN = MethodMatchers.create()
    .ofTypes(""com.auth0.jwt.JWTCreator$Builder"")
    .names(""sign"")
    .addParametersMatcher(AUTH0_JWT_ALGORITHM)
    .build();

  private static final MethodMatchers ALGORITHM_NONE = MethodMatchers.create()
    .ofTypes(AUTH0_JWT_ALGORITHM)
    .names(""none"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers JWTK_JJWT_PARSE = MethodMatchers.create()
    .ofTypes(""io.jsonwebtoken.JwtParser"")
    .names(""parse"")
    .addParametersMatcher(""java.lang.String"")
    .build();

  private static final MethodMatchers JWTK_JJWT_COMPACT = MethodMatchers.create()
    .ofTypes(""io.jsonwebtoken.JwtBuilder"")
    .names(""compact"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers JWTK_JJWT_BUILDER = MethodMatchers.create()
    .ofTypes(""io.jsonwebtoken.Jwts"")
    .names(""builder"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers JWTK_JJWT_SIGN_WITH = MethodMatchers.create()
    .ofTypes(""io.jsonwebtoken.JwtBuilder"")
    .names(""signWith"")
    .withAnyParameters()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;
    handleAuth0Jwt(mit);
    handleJwtkJwt(mit);
  }

  private void handleAuth0Jwt(MethodInvocationTree mit) {
    if (AUTH0_JWT_REQUIRE.matches(mit)) {
      reportIfAlgorithmIsNone(mit.arguments().get(0), ""verifying the signature of"");
    } else if (AUTH0_JWT_SIGN.matches(mit)) {
      reportIfAlgorithmIsNone(mit.arguments().get(0), ""signing"");
    }
  }

  private void reportIfAlgorithmIsNone(ExpressionTree expressionTree, String action) {
    if (expressionTree.is(Tree.Kind.METHOD_INVOCATION) && ALGORITHM_NONE.matches((MethodInvocationTree) expressionTree)) {
      reportIssue(expressionTree, String.format(MESSAGE_STRONG_CIPHER, action));
    }
  }

  private void handleJwtkJwt(MethodInvocationTree mit) {
    if (JWTK_JJWT_PARSE.matches(mit)) {
      reportIssue(ExpressionUtils.methodName(mit), ""The JWT signature (JWS) should be verified before using this token."");
    } else if (JWTK_JJWT_COMPACT.matches(mit) && !isSigned(mit)) {
      reportIssue(ExpressionUtils.methodName(mit), ""Sign this token using a strong cipher algorithm."");
    }
  }

  private static boolean isSigned(MethodInvocationTree mit) {
    if (JWTK_JJWT_SIGN_WITH.matches(mit)) {
      return true;
    }
    if (JWTK_JJWT_BUILDER.matches(mit)) {
      // We reach the creation of the builder without signing the token
      return false;
    }
    ExpressionTree methodSelect = mit.methodSelect();
    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree expression = ((MemberSelectExpressionTree) methodSelect).expression();
      if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
        return isSigned((MethodInvocationTree) expression);
      } else if (expression.is(Tree.Kind.IDENTIFIER)) {
        Symbol symbol = ((IdentifierTree) expression).symbol();
        return symbol.usages().stream().anyMatch(JWTWithStrongCipherCheck::canSignToken) || declarationIsSigned(symbol);
      }
    }

    // The token is created somewhere else, we consider it as signed to avoid FP.
    return true;
  }

  private static boolean canSignToken(IdentifierTree tokenIdentifier) {
    Tree parent = tokenIdentifier.parent();
    // When given as argument, we consider it as signed to avoid FP.
    return (parent != null && parent.is(Tree.Kind.ARGUMENTS)) ||
      MethodTreeUtils.subsequentMethodInvocation(tokenIdentifier, JWTK_JJWT_SIGN_WITH).isPresent();
  }

  private static boolean declarationIsSigned(Symbol symbol) {
    if (symbol.isLocalVariable()) {
      Tree declaration = symbol.declaration();
      if (declaration instanceof VariableTree variableTree) {
        ExpressionTree initializer = variableTree.initializer();
        return initializer instanceof MethodInvocationTree methodInvocationTree && isSigned(methodInvocationTree);
      }
    }
    // Can be signed anywhere (field, other file), we consider it as signed
    return true;
  }
}
"
S5663,CODE_SMELL,Simple string literal should be used for single line strings,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5663"")
public class SimpleStringLiteralForSingleLineStringsCheck extends IssuableSubscriptionVisitor {
  private static final String MESSAGE = ""Use simple literal for a single-line string."";
  
  @Override
  public List<Tree.Kind> nodesToVisit() { 
    return Collections.singletonList(Tree.Kind.TEXT_BLOCK);
  }

  @Override
  public void visitNode(Tree tree) {
    LiteralTree textBlock = (LiteralTree) tree;
    String value = textBlock.value();

    if (value.split(""(\r?\n)|\r"").length <= 2) {
      reportIssue(tree, MESSAGE);
    }
  }
}
"
S5664,CODE_SMELL,Whitespace for text block indent should be consistent,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5664"")
public class TextBlockTabsAndSpacesCheck extends IssuableSubscriptionVisitor {
  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TEXT_BLOCK);
  }

  private static char indentationCharacter(String[] lines) {
    for (String line : lines) {
      if (!line.isEmpty() && line.charAt(0) != '""') {
        return line.charAt(0);
      }
    }
    // If the string doesn't contain any indentation characters, it doesn't matter what we return
    return '\0';
  }

  private static boolean containsWrongIndentation(String line, int indent, char indentationCharacter) {
    for (int i = 0; i < line.length() && i < indent; i++) {
      if (line.charAt(i) != indentationCharacter) {
        return true;
      }
    }
    return false;
  }

  private static boolean containsWrongIndentation(LiteralTree textBlock) {
    String[] lines = textBlock.value().split(""\r?\n|\r"");
    int indent = LiteralUtils.indentationOfTextBlock(lines);
    char indentationCharacter = indentationCharacter(lines);
    return indent> 0 && Arrays.stream(lines).skip(1)
      .anyMatch(line -> containsWrongIndentation(line, indent, indentationCharacter));
  }

  @Override
  public void visitNode(Tree tree) {
    LiteralTree textBlock = (LiteralTree) tree;
    if (containsWrongIndentation(textBlock)) {
      reportIssue(tree, ""Use only spaces or only tabs for indentation"");
    }
  }
}
"
S5665,CODE_SMELL,Escape sequences should not be used in text blocks,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5665"")
public class UnnecessaryEscapeSequencesInTextBlockCheck extends IssuableSubscriptionVisitor {
  private static final String MESSAGE = ""Remove this unnecessary escape sequence."";
  private static final String TRIPLE_QUOTE_MESSAGE = ""Use '\\\""\""\""' to escape \""\""\""."";
  private static final Set<String> ESCAPED = SetUtils.immutableSetOf(""\\n"", ""\\'"", ""\\\"""");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TEXT_BLOCK);
  }

  @Override
  public void visitNode(Tree tree) {
    LiteralTree textBlock = (LiteralTree) tree;
    int startLine = LineUtils.startLine(textBlock.token());
    String value = textBlock.value();
    String[] lines = value.split(""\r?\n|\r"");
    
    for (int i = 0; i < lines.length; ++i) {
      lines[i] = lines[i].replace(""\\\\"","""");
      if (lines[i].contains(""\\\""\\\""\\\"""")) {
        addIssue(startLine + i, TRIPLE_QUOTE_MESSAGE);
      } else {
        String replaced = lines[i].replace(""\\\""\""\"""", """");
        if (ESCAPED.stream().anyMatch(replaced::contains)) {
          addIssue(startLine + i, MESSAGE);
        }
      }
    }
  }
}
"
S5669,CODE_SMELL,Vararg method arguments should not be confusing,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5669"")
public class ConfusingVarargCheck extends IssuableSubscriptionVisitor {

  // these methods explicitly handle vararg argument as being null
  private static final MethodMatchers ALLOWED_VARARG_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(""java.lang.Class"")
      .names(""getMethod"", ""getDeclaredMethod"")
      .addParametersMatcher(""java.lang.String"", ""java.lang.Class[]"")
      .build(),
    MethodMatchers.create()
      .ofTypes(""java.lang.Class"")
      .names(""getConstructor"", ""getDeclaredConstructor"")
      .addParametersMatcher(""java.lang.Class[]"")
      .build(),
    MethodMatchers.create()
      .ofTypes(""java.lang.reflect.Method"")
      .names(""invoke"")
      .addParametersMatcher(""java.lang.Object"", ""java.lang.Object[]"")
      .build(),
    MethodMatchers.create()
      .ofTypes(""java.lang.reflect.Constructor"")
      .names(""newInstance"")
      .addParametersMatcher(""java.lang.Object[]"")
      .build());

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    Symbol.MethodSymbol symbol;
    Arguments arguments;
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      symbol = mit.methodSymbol();
      arguments = mit.arguments();
    } else {
      NewClassTree nct = (NewClassTree) tree;
      symbol = nct.methodSymbol();
      arguments = nct.arguments();
    }
    if (!symbol.isUnknown() && !ALLOWED_VARARG_METHODS.matches(symbol)) {
      checkConfusingVararg(symbol, arguments);
    }
  }

  private void checkConfusingVararg(Symbol.MethodSymbol method, Arguments arguments) {
    if (!method.isVarArgsMethod()) {
      return;
    }
    List<Type> parameterTypes = method.parameterTypes();
    if (arguments.size() != parameterTypes.size()) {
      // providing more arguments: implicitly filling the array
      // providing less arguments: not using the vararg
      return;
    }
    Type varargParameter = parameterTypes.get(parameterTypes.size() - 1);
    ExpressionTree varargArgument = ExpressionUtils.skipParentheses(arguments.get(arguments.size() - 1));
    Type varargArgumentType = varargArgument.symbolType();
    if (varargArgument.is(Tree.Kind.NULL_LITERAL) || isIncompatibleArray(varargArgumentType, varargParameter)) {
      reportIssue(varargArgument, message(varargParameter, varargArgumentType));
    }
  }

  private static boolean isIncompatibleArray(Type varargArgument, Type varargParameter) {
    return isPrimitiveArray(varargArgument)
      && !isPrimitiveArray(varargParameter)
      && !varargArgument.equals(((Type.ArrayType) varargParameter).elementType());
  }

  private static boolean isPrimitiveArray(Type type) {
    return type.isArray() && ((Type.ArrayType) type).elementType().isPrimitive();
  }

  private static String message(Type varargParameter, Type varargArgument) {
    String message = ""Cast this argument to '%s' to pass a single element to the vararg method."";
    Type parameterType = ((Type.ArrayType) varargParameter).elementType();
    if (parameterType.isPrimitive()) {
      message = ""Remove this argument or pass an empty '%s' array to the vararg method."";
    } else if (isPrimitiveArray(varargArgument)) {
      Type argumentType = ((Type.ArrayType) varargArgument).elementType();
      return String.format(""Use an array of '%s' instead of an array of '%s'."", argumentType.primitiveWrapperType().name(), argumentType.name());
    }
    return String.format(message, parameterType.name());
  }

}
"
S5679,VULNERABILITY,OpenSAML2 should be configured to prevent authentication bypass,"package org.sonar.java.checks.security;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S5679"")
public class OpenSAML2AuthenticationBypassCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofSubTypes(""org.opensaml.xml.parse.BasicParserPool"", ""org.opensaml.xml.parse.StaticBasicParserPool"")
      .names(""setIgnoreComments"")
      .addParametersMatcher(""boolean"")
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree arg0 = mit.arguments().get(0);
    arg0.asConstant(Boolean.class)
      .filter(Boolean.FALSE::equals)
      .ifPresent(value -> reportIssue(arg0, ""Change \""setIgnoreComments\"" to \""true\"" or remove the call to \""setIgnoreComments\"" to prevent the authentication bypass.""));
  }

}
"
S5689,SECURITY_HOTSPOT,Disclosing fingerprints from web application technologies is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5689"")
public class DisclosingTechnologyFingerprintsCheck extends IssuableSubscriptionVisitor {
  
  private static final String MESSAGE = ""Make sure disclosing version information of this web technology is safe here."";

  public static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final MethodMatchers SET_RESPONSE_HEADERS = MethodMatchers.or(
    MethodMatchers.create()
    .ofSubTypes(""javax.servlet.http.HttpServletResponse"", 
      ""javax.servlet.http.HttpServletResponseWrapper"", 
      ""org.apache.wicket.request.http.WebResponse"",
      ""org.apache.wicket.protocol.http.BufferedWebResponse"", 
      ""org.apache.wicket.protocol.http.servlet.ServletWebResponse"")
    .names(""addHeader"", ""setHeader"")
    .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING)
    .build(),
    MethodMatchers.create()
      .ofSubTypes(""org.springframework.http.HttpHeaders"")
      .names(""add"", ""set"")
      .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""org.rapidoid.http.Resp"")
      .names(""header"")
      .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING)
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""org.springframework.http.ResponseEntity$HeadersBuilder"")
      .names(""header"")
      .withAnyParameters()
      .build()
  );
  
  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree methodInvocationTree = (MethodInvocationTree) tree;
    if (SET_RESPONSE_HEADERS.matches(methodInvocationTree)) {
      methodInvocationTree.arguments().get(0).asConstant(String.class)
        .ifPresent(header -> {
          if (""server"".equalsIgnoreCase(header) ||
            ""x-powered-by"".equalsIgnoreCase(header)) {
            reportIssue(methodInvocationTree, MESSAGE);
          }
        });
    }
  }
}
"
S5693,SECURITY_HOTSPOT,Allowing requests with excessive content length is security-sensitive,"package org.sonar.java.checks.security;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.AnalysisException;
import org.sonar.java.model.DefaultJavaFileScannerContext;
import org.sonar.java.model.DefaultModuleScannerContext;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.plugins.java.api.InputFileScannerContext;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.ModuleScannerContext;
import org.sonar.plugins.java.api.caching.CacheContext;
import org.sonar.plugins.java.api.caching.JavaReadCache;
import org.sonar.plugins.java.api.caching.JavaWriteCache;
import org.sonar.plugins.java.api.internal.EndOfAnalysis;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.security.ExcessiveContentRequestCheck.CachedResult.toBytes;
import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S5693"")
public class ExcessiveContentRequestCheck extends IssuableSubscriptionVisitor implements EndOfAnalysis {

  @RuleProperty(
    key = ""fileUploadSizeLimit"",
    description = ""The maximum size of HTTP requests handling file uploads (in bytes)."",
    defaultValue = """" + DEFAULT_MAX)
  public long fileUploadSizeLimit = DEFAULT_MAX;

  private static final long BYTES_PER_KB = 1_024L;
  private static final long BYTES_PER_MB = 1_048_576L;
  private static final long BYTES_PER_GB = 1_073_741_824L;
  private static final long BYTES_PER_TB = 1_099_511_627_776L;

  private static final long DEFAULT_MAX = 8 * BYTES_PER_MB;

  private static final String MESSAGE_EXCEED_SIZE = ""The content length limit of %d bytes is greater than the defined limit of %d; make sure it is safe here."";
  private static final String MESSAGE_SIZE_NOT_SET = ""Make sure not setting any maximum content length limit is safe here."";

  private static final String DATA_SIZE = ""org.springframework.util.unit.DataSize"";
  private static final Pattern DATA_SIZE_PATTERN = Pattern.compile(""^([+\\-]?\\d+)([a-zA-Z]{0,2})$"");

  private static final String MULTIPART_RESOLVER = ""org.springframework.web.multipart.commons.CommonsMultipartResolver"";
  private static final String MULTIPART_CONFIG = ""org.springframework.boot.web.servlet.MultipartConfigFactory"";
  private static final String MULTIPART_PROPERTIES = ""org.springframework.boot.autoconfigure.web.servlet.MultipartProperties"";

  private static final MethodMatchers METHODS_SETTING_MAX_SIZE = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(MULTIPART_RESOLVER)
      .names(""setMaxUploadSize"")
      .addParametersMatcher(""long"")
      .build(),
    MethodMatchers.create()
      .ofSubTypes(MULTIPART_CONFIG)
      .names(""setMaxFileSize"", ""setMaxRequestSize"")
      .addParametersMatcher(""long"")
      .addParametersMatcher(""java.lang.String"")
      .build(),
    MethodMatchers.create()
      .ofSubTypes(MULTIPART_PROPERTIES)
      .names(""setMaxFileSize"", ""setMaxRequestSize"")
      .addParametersMatcher(DATA_SIZE)
      .build()
  );

  private static final MethodMatchers MULTIPART_CONSTRUCTOR = MethodMatchers.create()
    .ofSubTypes(MULTIPART_RESOLVER, MULTIPART_CONFIG)
    .constructor()
    .withAnyParameters()
    .build();


  private static final MethodMatchers DATA_SIZE_OF_SOMETHING = MethodMatchers.create()
    .ofSubTypes(DATA_SIZE)
    .name(name -> name.startsWith(""of""))
    .addParametersMatcher(""long"")
    .build();

  private static final MethodMatchers DATA_SIZE_WITH_UNIT = MethodMatchers.create()
    .ofSubTypes(DATA_SIZE)
    .names(""parse"", ""of"")
    .addParametersMatcher(ANY, ""org.springframework.util.unit.DataUnit"")
    .build();

  private static final MethodMatchers DATA_SIZE_PARSE = MethodMatchers.create()
    .ofSubTypes(DATA_SIZE)
    .names(""parse"")
    .addParametersMatcher(""java.lang.CharSequence"")
    .build();

  public static final String CACHE_KEY_CACHED = ""java:S5693:cached"";
  public static final String CACHE_KEY_INSTANTIATE = ""java:S5693:instantiate"";
  public static final String CACHE_KEY_SET_MAXIMUM_SIZE = ""java:S5693:maximumSize"";

  private static final Logger LOGGER = LoggerFactory.getLogger(ExcessiveContentRequestCheck.class);

  private final List<AnalyzerMessage> multipartConstructorIssues = new ArrayList<>();
  private boolean sizeSetSomewhere = false;

  private Set<String> filesCached = new HashSet<>();

  private boolean currentFileSetsMaximumSize = false;
  private boolean currentFileInstantiates = false;

  @Override
  public boolean scanWithoutParsing(InputFileScannerContext context) {
    InputFile unchangedFile = context.getInputFile();
    CacheContext cacheContext = context.getCacheContext();
    // Check if results have been cached previously for this unchanged file
    Optional<CachedResult> cachedEntry = loadFromPreviousAnalysis(cacheContext, unchangedFile);
    if (cachedEntry.isEmpty()) {
      LOGGER.trace(""No cached data for rule java:S5693 on file {}"", unchangedFile);
      return false;
    }
    boolean inputFileSetsMaximumSize = cachedEntry.get().setMaximumSize;
    if (inputFileSetsMaximumSize) {
      sizeSetSomewhere = true;
    }
    keepForNextAnalysis(cacheContext, context.getInputFile());
    filesCached.add(unchangedFile.key());

    return true;
  }

  @Override
  public void endOfAnalysis(ModuleScannerContext context) {
    if (!sizeSetSomewhere) {
      var defaultContext = (DefaultModuleScannerContext) context;
      multipartConstructorIssues.forEach(defaultContext::reportIssue);
    }
    filesCached.clear();
    multipartConstructorIssues.clear();
    sizeSetSomewhere = false;
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    DefaultJavaFileScannerContext defaultContext = (DefaultJavaFileScannerContext) context;
    if (tree.is(Tree.Kind.NEW_CLASS)) {
      NewClassTree newClassTree = (NewClassTree) tree;
      if (MULTIPART_CONSTRUCTOR.matches(newClassTree)) {
        // Create an issue that we will report only at the end of the analysis if the maximum size was never set.
        AnalyzerMessage analyzerMessage = defaultContext.createAnalyzerMessage(this, newClassTree, MESSAGE_SIZE_NOT_SET);
        multipartConstructorIssues.add(analyzerMessage);
        currentFileInstantiates = true;
      }
    } else {
      MethodInvocationTree mit = (MethodInvocationTree) tree;
      if (METHODS_SETTING_MAX_SIZE.matches(mit)) {
        currentFileSetsMaximumSize = true;
        sizeSetSomewhere = true;
        getIfExceedSize(mit.arguments().get(0))
          .map(bytesExceeding -> defaultContext.createAnalyzerMessage(this, mit, String.format(MESSAGE_EXCEED_SIZE, bytesExceeding, fileUploadSizeLimit)))
          .ifPresent(defaultContext::reportIssue);
      }
    }
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    super.leaveFile(context);
    CacheContext cacheContext = context.getCacheContext();
    if (cacheContext.isCacheEnabled()) {
      writeForNextAnalysis(cacheContext, context.getInputFile(), currentFileInstantiates, currentFileSetsMaximumSize);
    }
    currentFileSetsMaximumSize = false;
    currentFileInstantiates = false;
  }

  private Optional<Long> getIfExceedSize(ExpressionTree expressionTree) {
    if (expressionTree.is(Tree.Kind.METHOD_INVOCATION)) {
      return getSizeFromDataSize((MethodInvocationTree) expressionTree)
        .filter(b -> b > fileUploadSizeLimit);
    }
    return getNumberOfBytes(expressionTree).filter(b -> b > fileUploadSizeLimit);
  }

  private static Optional<Long> getSizeFromDataSize(MethodInvocationTree mit) {
    if (DATA_SIZE_PARSE.matches(mit)) {
      return getNumberOfBytes(mit.arguments().get(0));
    } else if (DATA_SIZE_OF_SOMETHING.matches(mit)) {
      return getNumberOfBytes(mit.arguments().get(0))
        .map(b -> b * getMultiplierFromName(ExpressionUtils.methodName(mit).name()));
    } else if (DATA_SIZE_WITH_UNIT.matches(mit)) {
      Optional<Long> multiplier = getIdentifierName(mit.arguments().get(1))
        .map(ExcessiveContentRequestCheck::getMultiplierFromName);
      if (multiplier.isPresent()) {
        return getNumberOfBytes(mit.arguments().get(0))
          .map(l -> l * multiplier.get());
      }
    }
    return Optional.empty();
  }

  private static Optional<Long> getNumberOfBytes(ExpressionTree expression) {
    Optional<Integer> integerOptional = expression.asConstant(Integer.class);
    if (integerOptional.isPresent()) {
      return Optional.of(integerOptional.get().longValue());
    }

    Optional<String> stringOptional = expression.asConstant(String.class);
    if (stringOptional.isPresent()) {
      return getLongValueFromString(stringOptional.get());
    }

    return expression.asConstant(Long.class);
  }

  private static Optional<Long> getLongValueFromString(String s) {
    Matcher matcher = DATA_SIZE_PATTERN.matcher(s);
    if (matcher.matches()) {
      return Optional.of(Long.parseLong(matcher.group(1)) * getMultiplierFromName(matcher.group(2)));
    }
    return Optional.empty();
  }

  private static Long getMultiplierFromName(String name) {
    switch (name.toUpperCase(Locale.ENGLISH)) {
      case ""OFKILOBYTES"":
      case ""KILOBYTES"":
      case ""KB"":
        return BYTES_PER_KB;
      case ""OFMEGABYTES"":
      case ""MEGABYTES"":
      case ""MB"":
        return BYTES_PER_MB;
      case ""OFGIGABYTES"":
      case ""GIGABYTES"":
      case ""GB"":
        return BYTES_PER_GB;
      case ""OFTERABYTES"":
      case ""TERABYTES"":
      case ""TB"":
        return BYTES_PER_TB;
      default:
        return 1L;
    }
  }

  private static Optional<String> getIdentifierName(ExpressionTree expression) {
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      return Optional.of(((IdentifierTree) expression).name());
    } else if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      return Optional.of(((MemberSelectExpressionTree) expression).identifier().name());
    }
    return Optional.empty();
  }

  private static String computeCacheKey(InputFile inputFile) {
    return ""java:S5693:"" + inputFile.key();
  }

  private static Optional<CachedResult> loadFromPreviousAnalysis(CacheContext cacheContext, InputFile inputFile) {
    JavaReadCache readCache = cacheContext.getReadCache();
    String cacheKey = computeCacheKey(inputFile);
    byte[] rawValue = readCache.readBytes(cacheKey);
    if (rawValue == null) {
      return Optional.empty();
    }
    try {
      return Optional.ofNullable(CachedResult.fromBytes(rawValue));
    } catch (IllegalArgumentException ignored) {
      LOGGER.trace(""Cached entry is unreadable for rule java:S5693 on file {}"", inputFile);
      return Optional.empty();
    }
  }

  private static void keepForNextAnalysis(CacheContext cacheContext, InputFile inputFile) {
    JavaWriteCache writeCache = cacheContext.getWriteCache();
    try {
      writeCache.copyFromPrevious(computeCacheKey(inputFile));
    } catch (IllegalArgumentException e) {
      String message = String.format(""Failed to copy from previous cache for file %s"", inputFile);
      LOGGER.trace(message);
      throw new AnalysisException(message, e);
    }
  }

  private static void writeForNextAnalysis(CacheContext cacheContext, InputFile inputFile, boolean instantiates, boolean setsMaximumSize) {
    JavaWriteCache writeCache = cacheContext.getWriteCache();
    try {
      writeCache.write(computeCacheKey(inputFile), toBytes(new CachedResult(instantiates, setsMaximumSize)));
    } catch (IllegalArgumentException e) {
      String message = String.format(""Failed to write to cache for file %s"", inputFile);
      LOGGER.trace(message);
      throw new AnalysisException(message, e);
    }
  }

  static class CachedResult {
    public static final byte INSTANTIATES_VALUE = 1;
    public static final byte SETS_MAXIMUM_SIZE_VALUE = 2;
    public final boolean instantiates;
    public final boolean setMaximumSize;

    CachedResult(boolean instantiates, boolean setMaximumSize) {
      this.instantiates = instantiates;
      this.setMaximumSize = setMaximumSize;
    }

    static CachedResult fromBytes(byte[] raw) {
      if (raw.length != 1) {
        throw new IllegalArgumentException(
          String.format(""Could not decode cached result: unexpected length (expected = 1, actual = %d)"", raw.length)
        );
      }
      return new CachedResult(
        (raw[0] & INSTANTIATES_VALUE) == INSTANTIATES_VALUE,
        (raw[0] & SETS_MAXIMUM_SIZE_VALUE) == SETS_MAXIMUM_SIZE_VALUE
      );
    }

    static byte[] toBytes(CachedResult cachedResult) {
      byte value = 0;
      if (cachedResult.instantiates) {
        value |= INSTANTIATES_VALUE;
      }
      if (cachedResult.setMaximumSize) {
        value |= SETS_MAXIMUM_SIZE_VALUE;
      }
      return new byte[]{value};
    }
  }
}
"
S5738,CODE_SMELL,"""@Deprecated"" code marked for removal should never be used","package org.sonar.java.checks;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;

@Rule(key = ""S5738"")
public class CallToDeprecatedCodeMarkedForRemovalCheck extends AbstractCallToDeprecatedCodeChecker {

  private static final String MESSAGE = ""Remove this call to a deprecated %s, it has been marked for removal."";

  @Override
  void checkDeprecatedIdentifier(IdentifierTree identifierTree, Symbol deprecatedSymbol) {
    if (!isFlaggedForRemoval(deprecatedSymbol)) {
      // do not overlap with S1874
      return;
    }
    String deprecatedCode = ""code"";
    if (deprecatedSymbol.isMethodSymbol()) {
      deprecatedCode = ""method"";
    } else if (deprecatedSymbol.isTypeSymbol()) {
      deprecatedCode = ""class"";
    } else if (deprecatedSymbol.isVariableSymbol()) {
      deprecatedCode = ""field"";
    }
    reportIssue(identifierTree, String.format(MESSAGE, deprecatedCode));
  }

  @Override
  void checkOverridingMethod(MethodTree methodTree, List<Symbol.MethodSymbol> deprecatedSymbols) {
    if (deprecatedSymbols.stream().anyMatch(this::isFlaggedForRemoval)) {
      reportIssue(methodTree.simpleName(), ""Don't override this deprecated method, it has been marked for removal."");
    }
  }
}
"
S5776,CODE_SMELL,Exception testing via JUnit ExpectedException rule should not be mixed with other assertions,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.JavaFileScannerContext.Location;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;

import static org.sonar.java.checks.helpers.UnitTestUtils.ASSERTIONS_METHOD_MATCHER;

@Rule(key = ""S5776"")
public class ExpectedExceptionCheck extends AbstractMethodDetection {

  private static final String MESSAGE = ""Consider using org.junit.Assert.assertThrows before other assertions."";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofTypes(""org.junit.rules.ExpectedException"").names(""expect"").withAnyParameters().build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    MethodTree enclosingMethod = ExpressionUtils.getEnclosingMethod(mit);
    BlockTree methodBody = enclosingMethod != null ? enclosingMethod.block() : null;
    if (methodBody == null) {
      return;
    }
    IdentifierTree methodIdentifier = ExpressionUtils.methodName(mit);
    int collectAfterLine = LineUtils.startLine(methodIdentifier.identifierToken());
    AssertionCollector assertionCollector = new AssertionCollector(collectAfterLine);
    methodBody.accept(assertionCollector);
    if (!assertionCollector.assertions.isEmpty()) {
      reportIssue(methodIdentifier, MESSAGE, assertionCollector.assertions, null);
    }
  }

  private static class AssertionCollector extends BaseTreeVisitor {

    private int collectAfterLine;
    private List<Location> assertions = new ArrayList<>();

    public AssertionCollector(int collectAfterLine) {
      this.collectAfterLine = collectAfterLine;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
      if (LineUtils.startLine(methodInvocation) > collectAfterLine &&
        ASSERTIONS_METHOD_MATCHER.matches(methodInvocation)) {
        assertions.add(new Location(""Other assertion"", ExpressionUtils.methodName(methodInvocation)));
      }
    }

    @Override
    public void visitClass(ClassTree tree) {
      // Skip class
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // Skip lambdas
    }

  }

}
"
S5777,CODE_SMELL,Exception testing via JUnit @Test annotation should be avoided,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.UnitTestUtils.ASSERTIONS_METHOD_MATCHER;

@Rule(key = ""S5777"")
public class TestAnnotationWithExpectedExceptionCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree method = (MethodTree) tree;
    findExpectedException(method.modifiers().annotations()).ifPresent(expected -> {
      AssertionCollector assertionCollector = new AssertionCollector();
      method.accept(assertionCollector);
      if (!assertionCollector.assertions.isEmpty()) {
        reportIssue(
          expected,
          ""Move assertions into separate method or use assertThrows or try-catch instead."",
          assertionCollector.assertions,
          null
        );
      }
    });
  }

  private static Optional<ExpressionTree> findExpectedException(List<AnnotationTree> annotations) {
    for (AnnotationTree annotation : annotations) {
      if (annotation.annotationType().symbolType().is(""org.junit.Test"")) {
        for (ExpressionTree argument : annotation.arguments()) {
          if (argument.is(Tree.Kind.ASSIGNMENT)) {
            AssignmentExpressionTree assignment = (AssignmentExpressionTree) argument;
            if (""expected"".equals(((IdentifierTree) assignment.variable()).name())) {
              return Optional.of(assignment);
            }
          }
        }
      }
    }
    return Optional.empty();
  }

  private static class AssertionCollector extends BaseTreeVisitor {

    private final List<JavaFileScannerContext.Location> assertions = new ArrayList<>();

    @Override
    public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
      if (ASSERTIONS_METHOD_MATCHER.matches(methodInvocation)) {
        assertions.add(new JavaFileScannerContext.Location(
          ""Assertion in method with expected exception"",
          ExpressionUtils.methodName(methodInvocation)
        ));
      }
    }

  }

}
"
S5778,CODE_SMELL,Only one method invocation is expected when testing runtime exceptions,"package org.sonar.java.checks.tests;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.UnitTestUtils.FAIL_METHOD_MATCHER;

@Rule(key = ""S5778"")
public class OneExpectedRuntimeExceptionCheck extends AbstractOneExpectedExceptionRule {

  private static final MethodMatchers MOCKITO_MOCK_METHOD_MATCHERS = MethodMatchers.create()
    .ofTypes(""org.mockito.Mockito"")
    .names(""mock"")
    .addParametersMatcher(""java.lang.Class"").addParametersMatcher(""java.lang.Class"", ""java.lang.String"")
    .build();
  private static final MethodMatchers AUTHORIZED_METHODS = MethodMatchers.or(FAIL_METHOD_MATCHER, MOCKITO_MOCK_METHOD_MATCHERS);

  @Override
  void reportMultipleCallInTree(List<Type> expectedExceptions, Tree treeToVisit, Tree reportLocation, String placeToRefactor) {
    List<Type> checkedTypes = expectedExceptions.stream()
      .filter(e -> !isChecked(e))
      .toList();

    if (checkedTypes.isEmpty()) {
      return;
    }

    MethodTreeUtils.MethodInvocationCollector visitor = new MethodTreeUtils.MethodInvocationCollector(symbol -> !AUTHORIZED_METHODS.matches(symbol));
    treeToVisit.accept(visitor);
    List<Tree> invocationTree = visitor.getInvocationTree();
    if (invocationTree.size() > 1) {
      reportIssue(reportLocation,
        String.format(""Refactor the %s to have only one invocation possibly throwing a runtime exception."", placeToRefactor),
        secondaryLocations(invocationTree, ""May throw a runtime exception""),
        null);
    }
  }

}
"
S5779,BUG,Assertion methods should not be used within the try block of a try-catch catching an Error,"package org.sonar.java.checks.tests;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.CatchTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TryStatementTree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.checks.helpers.UnitTestUtils.COMMON_ASSERTION_MATCHER;

@Rule(key = ""S5779"")
public class AssertionInTryCatchCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.TRY_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    TryStatementTree tryStatementTree = (TryStatementTree) tree;
    getUnusedCatchAssertionErrorParameter(tryStatementTree.catches()).ifPresent(catchTree ->
      tryStatementTree.block().accept(new TryBodyVisitor(catchTree))
    );
  }

  private static Optional<VariableTree> getUnusedCatchAssertionErrorParameter(List<CatchTree> catches) {
    return catches.stream()
      .map(CatchTree::parameter)
      .filter(param -> {
        Type symbolType = param.type().symbolType();
        return param.symbol().usages().isEmpty() &&
          (symbolType.isSubtypeOf(""java.lang.AssertionError"")
            || symbolType.is(""java.lang.Error"")
            || symbolType.is(""java.lang.Throwable""));
      }).findFirst();
  }

  private class TryBodyVisitor extends BaseTreeVisitor {
    private final List<JavaFileScannerContext.Location> secondaryLocation;

    public TryBodyVisitor(VariableTree catchTree) {
      this.secondaryLocation = Collections.singletonList(new JavaFileScannerContext.Location(
        ""This parameter will catch the AssertionError"",
        catchTree.type()));
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
      if (COMMON_ASSERTION_MATCHER.matches(methodInvocation)) {
        IdentifierTree identifier = ExpressionUtils.methodName(methodInvocation);
        reportIssue(identifier,
          String.format(""Don't use %s() inside a try-catch catching an AssertionError."", identifier.name()),
          secondaryLocation,
          null);
      }
    }

    @Override
    public void visitClass(ClassTree tree) {
      // Skip class
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // Skip lambdas
    }

  }

}
"
S5783,BUG,Only one method invocation is expected when testing checked exceptions,"package org.sonar.java.checks.tests;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5783"")
public class OneExpectedCheckedExceptionCheck extends AbstractOneExpectedExceptionRule {

  @Override
  void reportMultipleCallInTree(List<Type> expectedExceptions, Tree treeToVisit, Tree reportLocation, String placeToRefactor) {
    List<Type> checkedTypes = expectedExceptions.stream()
      .filter(AbstractOneExpectedExceptionRule::isChecked)
      .toList();

    if (checkedTypes.isEmpty()) {
      return;
    }

    MethodTreeUtils.MethodInvocationCollector visitor = new MethodTreeUtils.MethodInvocationCollector(symbol -> throwExpectedException(symbol, checkedTypes));
    treeToVisit.accept(visitor);
    List<Tree> invocationTree = visitor.getInvocationTree();
    if (invocationTree.size() > 1) {
      reportIssue(reportLocation,
        String.format(""Refactor the %s to not have multiple invocations throwing the same checked exception."", placeToRefactor),
        secondaryLocations(invocationTree, ""Throws an exception""),
        null);
    }
  }

  private static boolean throwExpectedException(Symbol.MethodSymbol symbol, List<Type> checkedTypes) {
    return !symbol.isUnknown()
      && symbol.thrownTypes().stream().anyMatch(t -> checkedTypes.stream().anyMatch(t::isSubtypeOf));
  }

}
"
S5785,CODE_SMELL,JUnit assertTrue/assertFalse should be simplified to the corresponding dedicated assertion,"package org.sonar.java.checks.tests;

import java.util.Collections;
import java.util.Map;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

import static org.sonar.plugins.java.api.tree.Tree.Kind.NULL_LITERAL;

@Rule(key = ""S5785"")
public class AssertTrueInsteadOfDedicatedAssertCheck extends AbstractMethodDetection {

  private static final String JAVA_LANG_OBJECT = ""java.lang.Object"";

  private static final MethodMatchers EQUALS_METHODS = MethodMatchers.or(
    MethodMatchers.create().ofAnyType().names(""equals"").addParametersMatcher(JAVA_LANG_OBJECT).build(),
    MethodMatchers.create().ofTypes(""java.util.Objects"").names(""equals"").addParametersMatcher(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT)
      .build());

  private static final String[] ASSERT_METHOD_NAMES = {""assertTrue"", ""assertFalse""};
  private static final String[] ASSERTION_CLASSES = {
    // JUnit4
    ""org.junit.Assert"",
    ""junit.framework.TestCase"",
    // JUnit4 (deprecated)
    ""junit.framework.Assert"",
    // JUnit5
    ""org.junit.jupiter.api.Assertions""
  };

  private static final Map<Assertion, Assertion> COMPLEMENTS = MapBuilder.<Assertion, Assertion>newMap()
    .put(Assertion.NULL, Assertion.NOT_NULL)
    .put(Assertion.NOT_NULL, Assertion.NULL)
    .put(Assertion.SAME, Assertion.NOT_SAME)
    .put(Assertion.NOT_SAME, Assertion.SAME)
    .put(Assertion.EQUALS, Assertion.NOT_EQUALS)
    .put(Assertion.NOT_EQUALS, Assertion.EQUALS)
    .build();

  private enum Assertion {
    NULL(""Null"", ""A null-check""),
    NOT_NULL(""NotNull"", ""A null-check""),
    SAME(""Same"", ""An object reference comparison""),
    NOT_SAME(""NotSame"", ""An object reference comparison""),
    EQUALS(""Equals"", ""An equals check""),
    NOT_EQUALS(""NotEquals"", ""An equals check"");

    public final String methodName;
    public final String useInsteadMessage;
    public final String secondaryExplanationMessage;

    Assertion(String namePostfix, String actionDescription) {
      this.methodName = ""assert"" + namePostfix;
      this.useInsteadMessage = String.format(""Use %s instead."", methodName);
      this.secondaryExplanationMessage =
        String.format(""%s is performed here, which is better expressed with %s."", actionDescription, methodName);
    }
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofTypes(ASSERTION_CLASSES).names(ASSERT_METHOD_NAMES).withAnyParameters().build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    mit.arguments().stream()
      .filter(argument -> argument.symbolType().isPrimitive(Type.Primitives.BOOLEAN))
      .findFirst()
      .ifPresent(argument -> checkBooleanExpressionInAssertMethod(ExpressionUtils.methodName(mit), argument));
  }

  private void checkBooleanExpressionInAssertMethod(IdentifierTree problematicAssertionCallIdentifier, ExpressionTree argumentExpression) {
    Optional<Assertion> replacementAssertionOpt = getReplacementAssertion(argumentExpression);
    if (""assertFalse"".equals(problematicAssertionCallIdentifier.name())) {
      replacementAssertionOpt = replacementAssertionOpt.map(COMPLEMENTS::get);
    }

    replacementAssertionOpt.ifPresent(replacementAssertion -> reportIssue(
      problematicAssertionCallIdentifier,
      replacementAssertion.useInsteadMessage,
      Collections.singletonList(new JavaFileScannerContext.Location(replacementAssertion.secondaryExplanationMessage, argumentExpression)),
      null));
  }private static Optional<Assertion> getReplacementAssertion(ExpressionTree argumentExpression) {
    Assertion assertion = null;

    switch (argumentExpression.kind()) {
      case EQUAL_TO:
        if (isCheckForNull((BinaryExpressionTree) argumentExpression)) {
          assertion = Assertion.NULL;
        } else if (isPrimitiveComparison((BinaryExpressionTree) argumentExpression)) {
          assertion = Assertion.EQUALS;
        } else {
          assertion = Assertion.SAME;
        }
        break;
      case NOT_EQUAL_TO:
        if (isCheckForNull((BinaryExpressionTree) argumentExpression)) {
          assertion = Assertion.NOT_NULL;
        } else if (isPrimitiveComparison((BinaryExpressionTree) argumentExpression)) {
          assertion = Assertion.NOT_EQUALS;
        } else {
          assertion = Assertion.NOT_SAME;
        }
        break;
      case METHOD_INVOCATION:
        if (EQUALS_METHODS.matches((MethodInvocationTree) argumentExpression)) {
          assertion = Assertion.EQUALS;
        }
        break;
      case LOGICAL_COMPLEMENT:
        return getReplacementAssertion(((UnaryExpressionTree) argumentExpression).expression()).map(COMPLEMENTS::get);
      default:
    }

    return Optional.ofNullable(assertion);
  }

  private static boolean isCheckForNull(BinaryExpressionTree bet) {
    return bet.leftOperand().is(NULL_LITERAL) || bet.rightOperand().is(NULL_LITERAL);
  }

  private static boolean isPrimitiveComparison(BinaryExpressionTree bet) {
    return bet.leftOperand().symbolType().isPrimitive() || bet.rightOperand().symbolType().isPrimitive();
  }
}
"
S5786,CODE_SMELL,JUnit5 test classes and methods should have default package visibility,"package org.sonar.java.checks.tests;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;

@Rule(key = ""S5786"")
public class JUnit5DefaultPackageClassAndMethodCheck extends AbstractJUnit5NotCompliantModifierChecker {

  @Override
  protected boolean isNonCompliantModifier(Modifier modifier, boolean isMethod) {
    // All visibility modifiers except 'private' handled by S5810
    return modifier == Modifier.PUBLIC || modifier == Modifier.PROTECTED;
  }

  @Override
  protected void raiseIssueOnNonCompliantReturnType(MethodTree methodTree) {
    // Handled by S5810
  }

  @Override
  protected void raiseIssueOnNonCompliantModifier(ModifierKeywordTree modifier) {
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(modifier)
      .withMessage(WRONG_MODIFIER_ISSUE_MESSAGE, modifier.keyword().text())
      .withQuickFix(() -> quickFix(modifier))
      .report();
  }

  private static JavaQuickFix quickFix(ModifierKeywordTree modifier) {
    return JavaQuickFix.newQuickFix(""Remove \""%s\"" modifier"", modifier.keyword().text())
      .addTextEdit(JavaTextEdit.removeTextSpan(AnalyzerMessage.textSpanBetween(modifier, true, QuickFixHelper.nextToken(modifier), false)))
      .build();
  }
}
"
S5790,BUG,JUnit5 inner test classes should be annotated with @Nested,"package org.sonar.java.checks.tests;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.UnitTestUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5790"")
public class JunitNestedAnnotationCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    IdentifierTree className = classTree.simpleName();
    if (className == null) {
      return;
    }
    Symbol.TypeSymbol classSymbol = classTree.symbol();
    if (isNestedClass(classSymbol) && hasJUnit5TestMethods(classTree)) {
      boolean hasNestedAnnotation = UnitTestUtils.hasNestedAnnotation(classTree);
      if (classSymbol.isStatic() && hasNestedAnnotation) {
        reportIssue(className, ""Remove @Nested from this static nested test class or convert it into an inner class"");
      } else if (!classSymbol.isStatic() && !hasNestedAnnotation) {
        reportIssue(className, ""Add @Nested to this inner test class"");
      }
    }
  }

  private static boolean hasJUnit5TestMethods(ClassTree classTree) {
    return classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .anyMatch(UnitTestUtils::hasJUnit5TestAnnotation);
  }

  private static boolean isNestedClass(Symbol.TypeSymbol classSymbol) {
    return !classSymbol.isAbstract() &&
      Optional.ofNullable(classSymbol.owner())
      .map(Symbol::isTypeSymbol)
      .orElse(false);
  }

}
"
S5793,CODE_SMELL,Migrate your tests from JUnit4 to the new JUnit5 annotations,"package org.sonar.java.checks.tests;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5793"")
public class JUnit4AnnotationsCheck extends IssuableSubscriptionVisitor {

  private static final Map<String, String> OLD_NEW_ANNOTATIONS_MAP = MapBuilder.<String, String>newMap()
    .put(""org.junit.Test"", ""org.junit.jupiter.api.Test"")
    .put(""org.junit.Before"", ""org.junit.jupiter.api.BeforeEach"")
    .put(""org.junit.After"", ""org.junit.jupiter.api.AfterEach"")
    .put(""org.junit.BeforeClass"", ""org.junit.jupiter.api.BeforeAll"")
    .put(""org.junit.AfterClass"", ""org.junit.jupiter.api.AfterAll"")
    .put(""org.junit.Ignore"", ""org.junit.jupiter.api.Disabled"")
    .put(""org.junit.experimental.categories.Category"", ""org.junit.jupiter.api.Tag"")
    .put(""org.junit.Rule"", ""org.junit.jupiter.api.extension.ExtendWith"")
    .put(""org.junit.ClassRule"", ""org.junit.jupiter.api.extension.RegisterExtension"")
    .put(""org.junit.runner.RunWith"", ""org.junit.jupiter.api.extension.ExtendWith"")
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.ANNOTATION);
  }

  @Override
  public void visitNode(Tree tree) {
    String qualifiedName = ((AnnotationTree) tree).annotationType().symbolType().fullyQualifiedName();
    if (OLD_NEW_ANNOTATIONS_MAP.containsKey(qualifiedName)) {
      reportIssue(tree, String.format(""Change this JUnit4 %s to the equivalent JUnit5 %s annotation."",
        qualifiedName, OLD_NEW_ANNOTATIONS_MAP.get(qualifiedName)));
    }
  }
}
"
S5803,CODE_SMELL,"Class members annotated with ""@VisibleForTesting"" should not be accessed from production code","package org.sonar.java.checks;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata.AnnotationInstance;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5803"")
public class VisibleForTestingUsageCheck extends IssuableSubscriptionVisitor {
  
  private final Set<Symbol> reportedSymbols = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.IDENTIFIER);
  }

  @Override
  public void visitNode(Tree tree) {
    IdentifierTree identifier = (IdentifierTree) tree;

    Symbol symbol = identifier.symbol();
    if (symbol.isUnknown() || symbol.metadata().annotations().isEmpty() || reportedSymbols.contains(symbol)) {
      return;
    }
    if (isMisusedVisibleForTesting(symbol)) {
      List<JavaFileScannerContext.Location> locations = symbol.usages().stream()
        .filter(identifierTree -> !tree.equals(identifierTree))
        .map(identifierTree -> new JavaFileScannerContext.Location(""usage of @VisibleForTesting in production"", identifierTree))
        .toList();

      reportIssue(identifier, String.format(""Remove this usage of \""%s\"", it is annotated with @VisibleForTesting and should not be accessed from production code."",
        identifier.name()), locations, null);

      reportedSymbols.add(symbol);
    }
  }

  private static boolean isMisusedVisibleForTesting(Symbol symbol) {
    Symbol owner = Objects.requireNonNull(symbol.owner(), ""Owner is never null if unknown symbols are filtered out"");
    return isFieldMethodOrClass(symbol, owner) && !inTheSameFile(symbol)
      && symbol.metadata().annotations().stream().anyMatch(VisibleForTestingUsageCheck::isVisibleForTestingAnnotation);
  }

  private static boolean isVisibleForTestingAnnotation(AnnotationInstance annotationInstance) {
    return ""VisibleForTesting"".equals(annotationInstance.symbol().name());
  }

  private static boolean inTheSameFile(Symbol symbol) {
    return symbol.declaration() != null;
  }

  private static boolean isFieldMethodOrClass(Symbol symbol, Symbol owner) {
    return symbol.isTypeSymbol() || owner.isTypeSymbol();
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    reportedSymbols.clear();
    super.leaveFile(context);
  }
}
"
S5804,SECURITY_HOTSPOT,Allowing user enumeration is security-sensitive,"package org.sonar.java.checks.security;

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5804"")
public class UserEnumerationCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Make sure allowing user enumeration is safe here."";
  private static final String ABSTRACT_USER_DETAILS_AUTHENTICATION_PROVIDER = ""org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider"";
  private static final String SPRING_SEC_LDAP_AUTHENTICATION_PROVIDER = ""org.springframework.security.ldap.authentication.LdapAuthenticationProvider"";
  private static final String USER_DETAILS_SERVICE = ""org.springframework.security.core.userdetails.UserDetailsService"";
  private static final String USERNAME_NOT_FOUND_EXCEPTION = ""org.springframework.security.core.userdetails.UsernameNotFoundException"";
  private static final String HIDE_USER_NOT_FOUND_EXCEPTIONS = ""setHideUserNotFoundExceptions"";
  private static final String LOAD_USER_BY_USERNAME = ""loadUserByUsername"";
  private static final String BOOLEAN = ""boolean"";
  private static final String STRING = ""java.lang.String"";
  private static final String THROWABLE = ""java.lang.Throwable"";

  private final Deque<MethodTree> stack = new ArrayDeque<>();

  private static final MethodMatchers SET_HIDE_USER_MATCHER = MethodMatchers.create()
    .ofSubTypes(ABSTRACT_USER_DETAILS_AUTHENTICATION_PROVIDER, SPRING_SEC_LDAP_AUTHENTICATION_PROVIDER)
    .names(HIDE_USER_NOT_FOUND_EXCEPTIONS)
    .addParametersMatcher(BOOLEAN)
    .build();

  private static final MethodMatchers LOAD_USER_MATCHER = MethodMatchers.create()
    .ofSubTypes(USER_DETAILS_SERVICE)
    .names(LOAD_USER_BY_USERNAME)
    .addParametersMatcher(STRING)
    .build();


  @Override
  public void setContext(JavaFileScannerContext context) {
    super.setContext(context);
    stack.clear();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.THROW_STATEMENT, Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      stack.push(((MethodTree) tree));
      return;
    }

    if (tree.is(Tree.Kind.THROW_STATEMENT)) {
      ThrowStatementTree throwStatementTree = (ThrowStatementTree) tree;
      if (throwStatementTree.expression().symbolType().is(USERNAME_NOT_FOUND_EXCEPTION) && !isInsideLoadUserByUserName()) {
        reportIssue(throwStatementTree.expression(), MESSAGE);
      }
      return;
    }

    MethodInvocationTree methodInvocationTree = (MethodInvocationTree) tree;
    Arguments arguments = methodInvocationTree.arguments();
    if (arguments.isEmpty()) {
      return;
    }
    ExpressionTree firstArgument = arguments.get(0);

    checkHiddenUserNotFoundException(methodInvocationTree, firstArgument);
    checkLoadUserArgUsedInExceptions(methodInvocationTree, firstArgument);
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      stack.pop();
    }
  }

  private void checkLoadUserArgUsedInExceptions(MethodInvocationTree methodInvocationTree, ExpressionTree expression) {
    if (LOAD_USER_MATCHER.matches(methodInvocationTree) && expression.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifierTree = (IdentifierTree) expression;
      identifierTree.symbol().usages()
        .stream().filter(UserEnumerationCheck::checkParentIsThrowable)
        .forEach(value -> reportIssue(value, MESSAGE));
    }
  }

  private void checkHiddenUserNotFoundException(MethodInvocationTree methodInvocationTree, ExpressionTree expression) {
    if (SET_HIDE_USER_MATCHER.matches(methodInvocationTree) && !expression.asConstant(Boolean.class).orElse(true)) {
      reportIssue(methodInvocationTree, MESSAGE);
    }
  }

  private static boolean checkParentIsThrowable(Tree tree) {
    Tree current = tree.parent();
    while (current instanceof ExpressionTree || current instanceof Arguments) {
      if (current.is(Tree.Kind.NEW_CLASS) && ((NewClassTree) current).symbolType().isSubtypeOf(THROWABLE)) {
        return true;
      }
      current = current.parent();
    }
    return false;
  }

  private boolean isInsideLoadUserByUserName() {
    return LOAD_USER_MATCHER.matches(stack.peekFirst());
  }
}
"
S5808,VULNERABILITY,Authorizations should be based on strong decisions,"package org.sonar.java.checks.security;

import java.util.Collections;
import java.util.List;
import java.util.function.Predicate;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5808"")
public class AuthorizationsStrongDecisionsCheck extends IssuableSubscriptionVisitor {

  private static final String AUTHENTICATION = ""org.springframework.security.core.Authentication"";
  private static final String JAVA_OBJECT = ""java.lang.Object"";

  private static final MethodMatchers ACCESS_DECISION_VOTER_VOTE = MethodMatchers.create()
    .ofSubTypes(""org.springframework.security.access.AccessDecisionVoter"")
    .names(""vote"")
    .addParametersMatcher(AUTHENTICATION, JAVA_OBJECT, ""java.util.Collection"")
    .build();

  private static final MethodMatchers PERMISSION_EVALUATOR_HAS_PERMISSION = MethodMatchers.create()
    .ofSubTypes(""org.springframework.security.access.PermissionEvaluator"")
    .names(""hasPermission"")
    .addParametersMatcher(AUTHENTICATION, JAVA_OBJECT, JAVA_OBJECT)
    .addParametersMatcher(AUTHENTICATION, ""java.io.Serializable"", ""java.lang.String"", JAVA_OBJECT)
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (ACCESS_DECISION_VOTER_VOTE.matches(methodTree)) {
      reportNoStrongDecision(methodTree, AuthorizationsStrongDecisionsCheck::isStrongVoteDecision, ""vote"", ""ACCESS_DENIED"");
    } else if (PERMISSION_EVALUATOR_HAS_PERMISSION.matches(methodTree)) {
      reportNoStrongDecision(methodTree, AuthorizationsStrongDecisionsCheck::isStrongHasPermissionDecision, ""hasPermission"", ""false"");
    }
  }

  private void reportNoStrongDecision(MethodTree methodTree, Predicate<ExpressionTree> isStrongDecision, String methodName, String strongDecision) {
    ReturnStatementVisitor returnStatementVisitor = new ReturnStatementVisitor(isStrongDecision);
    methodTree.accept(returnStatementVisitor);
    if (!returnStatementVisitor.takesStrongDecision()) {
      reportIssue(methodTree.simpleName(), String.format(""\""%s\"" method should return at least one time %s."", methodName, strongDecision));
    }
  }

  private static boolean isStrongVoteDecision(ExpressionTree expression) {
    if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      expression = ((MemberSelectExpressionTree) expression).identifier();
    }
    if (expression instanceof LiteralTree || expression.is(Tree.Kind.UNARY_MINUS, Tree.Kind.UNARY_PLUS)) {
      // Returning literals (even the value for DENIED) is considered as not strong.
      return false;
    } else if (expression.is(Tree.Kind.IDENTIFIER)) {
      String name = ((IdentifierTree) expression).name();
      if (""ACCESS_DENIED"".equals(name)) {
        return true;
      } else if (""ACCESS_GRANTED"".equals(name) || ""ACCESS_ABSTAIN"".equals(name)) {
        return false;
      }
    }
    // Expression is not a literal or a known identifier, we consider it as strong to avoid FPs.
    return true;
  }

  private static boolean isStrongHasPermissionDecision(ExpressionTree expression) {
    if (expression instanceof LiteralTree) {
      return expression.asConstant(Boolean.class).filter(Boolean.FALSE::equals).isPresent();
    }
    return true;
  }

  private static class ReturnStatementVisitor extends BaseTreeVisitor {

    private final Predicate<ExpressionTree> isStrongDecision;
    private boolean takesStrongDecision = false;

    ReturnStatementVisitor(Predicate<ExpressionTree> isStrongDecision) {
      this.isStrongDecision = isStrongDecision;
    }

    public boolean takesStrongDecision() {
      return takesStrongDecision;
    }

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      ExpressionTree expression = tree.expression();
      if (expression != null && isStrongDecision.test(expression)) {
        takesStrongDecision = true;
      }
    }

    @Override
    public void visitThrowStatement(ThrowStatementTree tree) {
      // Throwing an exception is considered as taking a strong decision
      takesStrongDecision = true;
    }

    @Override
    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
      // skip lambdas
    }

    @Override
    public void visitClass(ClassTree tree) {
      // skip inner classes
    }
  }

}
"
S5810,BUG,JUnit5 test classes and methods should not be silently ignored,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.TypeTree;

@Rule(key = ""S5810"")
public class JUnit5SilentlyIgnoreClassAndMethodCheck extends AbstractJUnit5NotCompliantModifierChecker {

  @Override
  protected boolean isNonCompliantModifier(Modifier modifier, boolean isMethod) {
    return modifier == Modifier.PRIVATE || (isMethod && modifier == Modifier.STATIC);
  }

  @Override
  protected void raiseIssueOnNonCompliantReturnType(MethodTree methodTree) {
    TypeTree returnType = methodTree.returnType();
    // returnType of METHOD is never null (unlike CONSTRUCTOR)
    Type type = returnType.symbolType();
    boolean methodReturnAValue = !type.isUnknown() && !type.isVoid();
    if(methodReturnAValue && !methodTree.symbol().metadata().isAnnotatedWith(""org.junit.jupiter.api.TestFactory"")) {
      List<JavaTextEdit> textEdits = new ArrayList<>();
      textEdits.add(JavaTextEdit.replaceTree(returnType, ""void""));
      // Make return statements return void
      List<ReturnStatementTree> returnStatementTrees = new ReturnStatementVisitor(methodTree).returnStatementTrees();
      returnStatementTrees.forEach(r -> textEdits.add(JavaTextEdit.removeTree(r.expression())));

      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(methodTree.returnType())
        .withMessage(""Replace the return type by void."")
        .withQuickFix(() ->
          JavaQuickFix.newQuickFix(""Replace with void"")
            .addTextEdits(textEdits)
            .build())
        .report();
    }
  }

  static final class ReturnStatementVisitor extends BaseTreeVisitor {
    private List<ReturnStatementTree> returnStatementTrees = new ArrayList<>();

    ReturnStatementVisitor(MethodTree methodTree) {
      scan(methodTree);
    }

    @Override
    public void visitReturnStatement(ReturnStatementTree tree) {
      returnStatementTrees.add(tree);
    }

    List<ReturnStatementTree> returnStatementTrees() {
      return Collections.unmodifiableList(returnStatementTrees);
    }
  }
}
"
S5826,CODE_SMELL,Methods setUp() and tearDown() should be correctly annotated starting with JUnit4,"package org.sonar.java.checks.tests;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.MapBuilder;
import org.sonar.java.checks.helpers.UnitTestUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5826"")
public class JUnit45MethodAnnotationCheck extends IssuableSubscriptionVisitor {

  private static final String JUNIT_SETUP = ""setUp"";
  private static final String JUNIT_TEARDOWN = ""tearDown"";
  private static final String ORG_JUNIT_AFTER = ""org.junit.After"";
  private static final String ORG_JUNIT_BEFORE = ""org.junit.Before"";

  private static final Map<String, String> JUNIT4_TO_JUNIT5 = MapBuilder.<String, String>newMap()
    .put(ORG_JUNIT_BEFORE, ""org.junit.jupiter.api.BeforeEach"")
    .put(""org.junit.BeforeClass"", ""org.junit.jupiter.api.BeforeAll"")
    .put(ORG_JUNIT_AFTER, ""org.junit.jupiter.api.AfterEach"")
    .put(""org.junit.AfterClass"", ""org.junit.jupiter.api.AfterAll"")
    .build();

  private static final Set<String> JUNIT4_ANNOTATIONS = JUNIT4_TO_JUNIT5.keySet();
  private static final Set<String> JUNIT5_ANNOTATIONS = new HashSet<>(JUNIT4_TO_JUNIT5.values());

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;

    List<MethodTree> methods = classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .toList();

    int jUnitVersion = getJUnitVersion(methods);
    if (jUnitVersion > 0) {
      methods.forEach(methodTree -> checkJUnitMethod(methodTree, jUnitVersion));
    }
  }

  private static int getJUnitVersion(List<MethodTree> methods) {
    boolean containsJUnit4Tests = false;
    for (MethodTree methodTree : methods) {
      SymbolMetadata metadata = methodTree.symbol().metadata();
      containsJUnit4Tests |= metadata.isAnnotatedWith(""org.junit.Test"");
      if (UnitTestUtils.hasJUnit5TestAnnotation(methodTree)) {
        // While migrating from JUnit4 to JUnit5, classes might end up in mixed state of having tests using both versions.
        // If it's the case, we consider the test classes as ultimately targeting 5
        return 5;
      }
    }
    return containsJUnit4Tests ? 4 : -1;
  }

  private void checkJUnitMethod(MethodTree methodTree, int jUnitVersion) {
    if (isSetupTearDownSignature(methodTree) || (jUnitVersion == 5 && isAnnotatedWith(methodTree, ORG_JUNIT_BEFORE, ORG_JUNIT_AFTER))) {
      checkSetupTearDownSignature(methodTree, jUnitVersion);
    }
  }

  private void checkSetupTearDownSignature(MethodTree methodTree, int jUnitVersion) {
    Symbol.MethodSymbol symbol = methodTree.symbol();
    if (!Boolean.FALSE.equals(methodTree.isOverriding())) {
      // Annotation can be in a parent. If unknown (null), consider has override to avoid FP.
      return;
    }

    SymbolMetadata metadata = symbol.metadata();
    Optional<String> junit4Annotation = JUNIT4_ANNOTATIONS.stream().filter(metadata::isAnnotatedWith).findFirst();
    boolean isAnnotatedWithJUnit4 = junit4Annotation.isPresent();
    boolean isAnnotatedWithJUnit5 = JUNIT5_ANNOTATIONS.stream().anyMatch(metadata::isAnnotatedWith);

    if (jUnitVersion == 5 && isAnnotatedWithJUnit4 && !isAnnotatedWithJUnit5) {
      String jUnit4Annotation = junit4Annotation.get();
      reportIssue(methodTree.simpleName(), String.format(""Annotate this method with JUnit5 '@%s' instead of JUnit4 '@%s'."",
        JUNIT4_TO_JUNIT5.get(jUnit4Annotation),
        jUnit4Annotation.substring(jUnit4Annotation.lastIndexOf('.') + 1)));
    } else if (!isAnnotatedWithJUnit4 && !isAnnotatedWithJUnit5) {
      reportIssue(methodTree.simpleName(), String.format(""Annotate this method with JUnit%d '@%s' or rename it to avoid confusion."",
        jUnitVersion,
        expectedAnnotation(symbol, jUnitVersion)));
    }
  }

  private static boolean isAnnotatedWith(MethodTree methodTree, String... annotations) {
    SymbolMetadata methodMetadata = methodTree.symbol().metadata();
    return Arrays.stream(annotations).anyMatch(methodMetadata::isAnnotatedWith);
  }

  private static boolean isSetupTearDownSignature(MethodTree methodTree) {
    String name = methodTree.simpleName().name();
    return (JUNIT_SETUP.equals(name) || JUNIT_TEARDOWN.equals(name))
      && methodTree.parameters().isEmpty()
      && !methodTree.symbol().isPrivate();
  }

  private static String expectedAnnotation(Symbol.MethodSymbol symbol, int jUnitVersion) {
    String expected;
    if (JUNIT_SETUP.equals(symbol.name())) {
      expected = ORG_JUNIT_BEFORE;
    } else {
      expected = ORG_JUNIT_AFTER;
    }
    return jUnitVersion == 4 ? expected : JUNIT4_TO_JUNIT5.get(expected);
  }

}
"
S5831,BUG,AssertJ configuration should be applied,"package org.sonar.java.checks.tests;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S5831"")
public class AssertJApplyConfigurationCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""org.assertj.core.configuration.Configuration"").constructor().addWithoutParametersMatcher().build();
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    Tree parent = newClassTree.parent();
    if (parent != null && parent.is(Tree.Kind.VARIABLE)) {
      VariableTree variableTree = ((VariableTree) parent);
      if (variableTree.symbol().usages().stream().noneMatch(AssertJApplyConfigurationCheck::canApplyConfiguration)) {
        reportIssue(variableTree.simpleName(), ""Apply this configuration with apply() or applyAndDisplay()."");
      }
    }
  }

  private static boolean canApplyConfiguration(IdentifierTree identifier) {
    Tree parent = identifier.parent();
    if (parent == null) {
      return false;
    }

    if (parent.is(Tree.Kind.MEMBER_SELECT)) {
      String methodName = ((MemberSelectExpressionTree) parent).identifier().name();
      return ""apply"".equals(methodName) || ""applyAndDisplay"".equals(methodName);
    }
    // The configuration can be applied when passed as argument.
    return parent.is(Tree.Kind.ARGUMENTS);
  }

}
"
S5833,BUG,AssertJ methods setting the assertion context should come before an assertion,"package org.sonar.java.checks.tests;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5833"")
public class AssertJContextBeforeAssertionCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofSubTypes(""org.assertj.core.api.AbstractAssert"")
      .name(name ->
        ""as"".equals(name) || ""describedAs"".equals(name) || ""withFailMessage"".equals(name)
          || ""overridingErrorMessage"".equals(name) || ""extracting"".equals(name)
          || name.startsWith(""using"") || name.startsWith(""filtered"")
      ).withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (isLastCallInStatement(mit)) {
      // Report only when it's the last call, if we have anything after, it's either:
      // - an assertion: compliant solution
      // - a method setting context: we will report on this other one instead (if problematic), to avoid reporting multiple times.
      // - not in a statement, meaning that it can be asserted somewhere else (assertion returned, assigned, ...)
      reportIssue(ExpressionUtils.methodName(mit), ""Add an assertion predicate after calling this method."");
    }
  }

  private static boolean isLastCallInStatement(MethodInvocationTree mit) {
    Tree parent = mit.parent();
    return parent != null && parent.is(Tree.Kind.EXPRESSION_STATEMENT);
  }

}

"
S5838,CODE_SMELL,Chained AssertJ assertions should be simplified to the corresponding dedicated assertion,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.reporting.InternalJavaIssueBuilder;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

import static org.sonar.java.checks.tests.AssertJChainSimplificationIndex.CONTEXT_FREE_SIMPLIFIERS;
import static org.sonar.java.checks.tests.AssertJChainSimplificationIndex.SIMPLIFIERS_WITH_CONTEXT;

@Rule(key = ""S5838"")
public class AssertJChainSimplificationCheck extends AbstractMethodDetection {
  private static final String ISSUE_MESSAGE_FORMAT_STRING = ""Use %s instead."";

  private static final MethodMatchers ASSERTION_MESSAGE_METHODS = MethodMatchers.create()
    .ofSubTypes(""org.assertj.core.api.AbstractAssert"")
    .names(""as"", ""describedAs"", ""withFailMessage"", ""overridingErrorMessage"").withAnyParameters().build();

  private static final MethodMatchers ASSERTIONS_SUBJECT_METHODS = MethodMatchers.create().ofTypes(
    ""org.assertj.core.api.Assertions"",
    ""org.assertj.core.api.AssertionsForInterfaceTypes"",
    ""org.assertj.core.api.AssertionsForClassTypes"")
    .names(""assertThat"", ""assertThatObject"").addParametersMatcher(MethodMatchers.ANY).build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return ASSERTIONS_SUBJECT_METHODS;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree subjectMit) {
    List<MethodInvocationTree> predicates = new ArrayList<>();
    Optional<MethodInvocationTree> nextPredicateOpt = MethodTreeUtils.consecutiveMethodInvocation(subjectMit);

    while (nextPredicateOpt.isPresent()) {
      MethodInvocationTree nextPredicate = nextPredicateOpt.get();
      if (!ASSERTION_MESSAGE_METHODS.matches(nextPredicate)) {
        predicates.add(nextPredicate);
      }
      nextPredicateOpt = MethodTreeUtils.consecutiveMethodInvocation(nextPredicate);
    }

    boolean wasIssueRaised = checkPredicatesForSimplification(
      predicates, CONTEXT_FREE_SIMPLIFIERS, SimplifierWithoutContext::simplify,
      (predicate, simplification) -> createIssueBuilder(predicate, simplification).report()
    );

    // We do not continue when we have already raised an issue to avoid potentially conflicting issue reports. If we
    // have more than one predicate we also avoid continuing to avoid FP on cases such as:
    // assertThat(Integer.valueOf(1).compareTo(2)).isGreaterThan(1).isLessThan(10)
    // We also want to ignore all assertion chains that contain methods besides predicates and messages, such as those
    // that change the assertion context, as that level of complexity is not handled by this rule. The extraction
    // function is such an example:
    // assertThat(frodo).extracting(""name"", as(InstanceOfAssertFactories.STRING)).startsWith(""Fro"");
    if (wasIssueRaised || predicates.size() > 1) {
      return;
    }

    checkPredicatesForSimplification(
      predicates, SIMPLIFIERS_WITH_CONTEXT, (simplifier, predicate) -> simplifier.simplify(subjectMit, predicate),
      (predicate, simplification) -> createIssueBuilder(predicate, simplification)
        .withSecondaries(new JavaFileScannerContext.Location(""This can be simplified"", subjectMit.arguments().get(0)))
        .report()
    );
  }

  private InternalJavaIssueBuilder createIssueBuilder(MethodInvocationTree predicate, AssertJChainSimplificationIndex.Simplification simplification) {
    InternalJavaIssueBuilder builder = QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(ExpressionUtils.methodName(predicate))
      .withMessage(ISSUE_MESSAGE_FORMAT_STRING, simplification.getReplacement());
    simplification.getQuickFix().ifPresent(builder::withQuickFixes);
    return builder;
  }private static <T> boolean checkPredicatesForSimplification(
    List<MethodInvocationTree> predicates,
    Map<String, List<T>> simplifiers,
    BiFunction<T, MethodInvocationTree, Optional<AssertJChainSimplificationIndex.Simplification>> simplificationMethod,
    BiConsumer<MethodInvocationTree, AssertJChainSimplificationIndex.Simplification> reportingMethod) {

    AssertJChainSimplificationHelper.BooleanFlag issueRaised = new AssertJChainSimplificationHelper.BooleanFlag();
    predicates.forEach(predicate -> {
      String predicateName = ExpressionUtils.methodName(predicate).name();
      if (simplifiers.containsKey(predicateName)) {
        simplifiers.get(predicateName).stream()
          .map(simplifier -> simplificationMethod.apply(simplifier, predicate))
          .filter(Optional::isPresent)
          .map(Optional::get)
          .findFirst()
          .ifPresent(replacement -> {
            reportingMethod.accept(predicate, replacement);
            issueRaised.setTrue();
          });
      }
    });
    return issueRaised.value();
  }

  interface SimplifierWithoutContext {
    Optional<AssertJChainSimplificationIndex.Simplification> simplify(MethodInvocationTree predicate);
  }

  interface SimplifierWithContext {
    Optional<AssertJChainSimplificationIndex.Simplification> simplify(MethodInvocationTree subject, MethodInvocationTree predicate);
  }
}
"
S5841,BUG,"AssertJ assertions ""allMatch"" and ""doesNotContains"" should also test for emptiness","package org.sonar.java.checks.tests;

import java.util.Collections;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.ParenthesizedTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;

@Rule(key = ""S5841"")
public class AssertJTestForEmptinessCheck extends AbstractMethodDetection {

  private static final MethodMatchers ASSERTJ_NOT_TESTING_SIZE = MethodMatchers.create()
    .ofSubTypes(""org.assertj.core.api.AbstractAssert"")
    .name(name ->
      ""as"".equals(name) || ""describedAs"".equals(name) || ""withFailMessage"".equals(name) || ""overridingErrorMessage"".equals(name)
        || ""isNotNull"".equals(name) || ""asList"".equals(name) || name.contains(""InstanceOf"")|| name.startsWith(""using"")
        || name.startsWith(""extracting"") || name.startsWith(""filtered"") || name.startsWith(""doesNotContain"") || name.startsWith(""all"")
    ).withAnyParameters()
    .build();

  private static final MethodMatchers ASSERT_THAT_MATCHER = MethodMatchers.create()
    .ofSubTypes(""org.assertj.core.api.Assertions"", ""org.assertj.core.api.AssertionsForInterfaceTypes"", ""org.assertj.core.api.AssertionsForClassTypes"")
    .names(""assertThat"", ""assertThatObject"").addParametersMatcher(MethodMatchers.ANY).build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofSubTypes(""org.assertj.core.api.AbstractIterableAssert"")
        .names(""allMatch"", ""allSatisfy"", ""doesNotContainSequence"", ""doesNotContainSubsequence"", ""doesNotContainAnyElementsOf"")
        .withAnyParameters()
        .build(),
      MethodMatchers.create()
        .ofSubTypes(""org.assertj.core.api.AbstractIterableAssert"")
        .names(""doesNotContain"")
        .addParametersMatcher(MethodMatchers.ANY)
        .build()
    );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (consecutiveInvocationTestSize(mit)) {
      return;
    }

    getSubjectArgumentNotTestedForSize(mit)
      .filter(AssertJTestForEmptinessCheck::isNotUsedSomewhereElse)
      .ifPresent(arg -> reportIssueWithSecondary(mit, arg));
  }

  private static boolean consecutiveInvocationTestSize(MethodInvocationTree mit) {
    Optional<MethodInvocationTree> consecutiveMethodInvocation = MethodTreeUtils.consecutiveMethodInvocation(mit);
    if (consecutiveMethodInvocation.isPresent()) {
      MethodInvocationTree consecutiveInvocation = consecutiveMethodInvocation.get();
      if (ASSERTJ_NOT_TESTING_SIZE.matches(consecutiveInvocation)) {
        return consecutiveInvocationTestSize(consecutiveInvocation);
      } else {
        // To avoid FP, only every others methods not explicitly listed as not testing size, will be considered as testing size
        return true;
      }
    }
    return false;
  }

  private static Optional<ExpressionTree> getSubjectArgumentNotTestedForSize(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree memberSelectExpression = ((MemberSelectExpressionTree) methodSelect).expression();
      if (memberSelectExpression.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree childMit = (MethodInvocationTree) memberSelectExpression;
        if (ASSERT_THAT_MATCHER.matches(childMit)) {
          return Optional.of(childMit.arguments().get(0));
        } else if (ASSERTJ_NOT_TESTING_SIZE.matches(childMit)) {
          return getSubjectArgumentNotTestedForSize(childMit);
        }
      }
    }
    return Optional.empty();
  }

  private static boolean isNotUsedSomewhereElse(ExpressionTree tree) {
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      return isNotUsedSomewhereElse(((MethodInvocationTree) tree).methodSelect());
    } else if (tree.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree memberSelectExpressionTree = (MemberSelectExpressionTree) tree;
      if (!ExpressionUtils.isSelectOnThisOrSuper(memberSelectExpressionTree)) {
        return isNotUsedSomewhereElse(((MemberSelectExpressionTree) tree).expression());
      }
    } else if (tree.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {
      return isNotUsedSomewhereElse(((ParenthesizedTree) tree).expression());
    } else if (tree.is(Tree.Kind.TYPE_CAST)) {
      return isNotUsedSomewhereElse(((TypeCastTree) tree).expression());
    } else if (tree.is(Tree.Kind.IDENTIFIER)) {
      return ((IdentifierTree) tree).symbol().usages().size() == 1;
    }
    return false;
  }

  private void reportIssueWithSecondary(MethodInvocationTree mit, ExpressionTree argument) {
    reportIssue(ExpressionUtils.methodName(mit),
      ""Test the emptiness of the list before calling this assertion predicate."",
      Collections.singletonList(new JavaFileScannerContext.Location("""", argument)),
      null);
  }

}
"
S5842,BUG,Repeated patterns in regular expressions should not match the empty string,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.EmptyStringRepetitionFinder;

@Rule(key = ""S5842"")
public class EmptyStringRepetitionCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new EmptyStringRepetitionFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S5843,CODE_SMELL,Regular expressions should not be too complicated,"package org.sonar.java.checks.regex;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.apache.commons.lang3.StringUtils;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.SyntaxTrivia;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.ast.FlagSet;
import org.sonarsource.analyzer.commons.regex.finders.ComplexRegexFinder;

@Rule(key = ""S5843"")
public class RegexComplexityCheck extends AbstractRegexCheck {

  private static final int DEFAULT_MAX = 20;

  @RuleProperty(
    key = ""maxComplexity"",
    description = ""The maximum authorized complexity."",
    defaultValue = """" + DEFAULT_MAX)
  private int max = DEFAULT_MAX;

  private final List<RegexConstructionInfo> regexConstructions = new ArrayList<>();

  private final Set<Integer> commentedLines = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    List<Tree.Kind> nodes = new ArrayList<>(super.nodesToVisit());
    nodes.add(Tree.Kind.TRIVIA);
    return nodes;
  }

  @Override
  public void checkRegex(RegexParseResult parseResult, ExpressionTree methodInvocationOrAnnotation) {
    // The parse result is not used except to get the initial flags. We find and parse the parts of the regex
    // ourselves because we want to count the complexity of each part individually if the regex is made out of
    // parts stored in variables.
    ExpressionTree regexArgument = getRegexLiteralExpression(methodInvocationOrAnnotation);
    // regexArgument can not be null when ""checkRegex"" is called
    regexConstructions.add(new RegexConstructionInfo(regexArgument, parseResult.getInitialFlags(), parseResult.containsComments()));
  }

  @Override
  public void visitTrivia(SyntaxTrivia syntaxTrivia) {
    int startLine = LineUtils.startLine(syntaxTrivia);
    commentedLines.add(startLine);
    int numLines = StringUtils.countMatches(syntaxTrivia.comment(), ""\n"");
    if (numLines > 0) {
      commentedLines.add(startLine + numLines);
    }
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    for (RegexConstructionInfo regexInfo : regexConstructions) {
      FlagSet flags = regexInfo.initialFlags;
      for (LiteralTree[] regexPart : findRegexParts(regexInfo)) {
        new ComplexRegexFinder(this::reportIssueFromCommons, max).visit(regexForLiterals(flags, regexPart));
      }
    }
    regexConstructions.clear();
    commentedLines.clear();
  }

  List<LiteralTree[]> findRegexParts(RegexConstructionInfo regexInfo) {
    RegexPartFinder finder = new RegexPartFinder(regexInfo.initialFlags, regexInfo.containsComments);
    finder.find(regexInfo.regexArgument);
    return finder.parts;
  }

  public void setMax(int max) {
    this.max = max;
  }

  private class RegexPartFinder {

    final FlagSet initialFlags;

    final boolean regexContainsComments;

    List<LiteralTree[]> parts = new ArrayList<>();

    RegexPartFinder(FlagSet initialFlags, boolean regexContainsComments) {
      this.initialFlags = initialFlags;
      this.regexContainsComments = regexContainsComments;
    }

    void find(ExpressionTree expr) {
      switch (expr.kind()) {
        case PLUS:
          List<LiteralTree> literals = new ArrayList<>();
          findInStringConcatenation(expr, literals);
          if (!literals.isEmpty()) {
            parts.add(literals.toArray(new LiteralTree[0]));
          }
          break;
        case IDENTIFIER:
          getFinalVariableInitializer((IdentifierTree) expr).ifPresent(this::find);
          break;
        case PARENTHESIZED_EXPRESSION:
          find(ExpressionUtils.skipParentheses(expr));
          break;
        case STRING_LITERAL:
          parts.add(new LiteralTree[] {(LiteralTree) expr});
          break;
        default:
          // Do nothing
      }
    }

    void findInStringConcatenation(ExpressionTree expr, List<LiteralTree> literals) {
      if (expr.is(Tree.Kind.STRING_LITERAL)) {
        LiteralTree literal = (LiteralTree) expr;
        if (isCommented(literal)) {
          parts.add(new LiteralTree[] {literal});
        } else {
          literals.add(literal);
        }
      } else if (expr.is(Tree.Kind.PLUS)) {
        BinaryExpressionTree binExpr = (BinaryExpressionTree) expr;
        findInStringConcatenation(binExpr.leftOperand(), literals);
        findInStringConcatenation(binExpr.rightOperand(), literals);
      } else if (expr.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {
        findInStringConcatenation(ExpressionUtils.skipParentheses(expr), literals);
      } else {
        find(expr);
      }
    }

    private boolean isCommented(LiteralTree regexPart) {
      int line = LineUtils.startLine(regexPart);
      return regexContainsComments
        || commentedLines.contains(line)
        || commentedLines.contains(line - 1);
    }

  }

  private static class RegexConstructionInfo {

    final ExpressionTree regexArgument;

    final FlagSet initialFlags;

    final boolean containsComments;

    RegexConstructionInfo(ExpressionTree regexArgument, FlagSet initialFlags, boolean containsComments) {
      this.regexArgument = regexArgument;
      this.initialFlags = initialFlags;
      this.containsComments = containsComments;
    }

  }

}
"
S5845,BUG,Assertions comparing incompatible types should not be made,"package org.sonar.java.checks.tests;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.checks.helpers.UnitTestUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.Symbols;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5845"")
public class AssertionTypesCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_LANG_OBJECT = ""java.lang.Object"";

  private static final String JUNIT4_ASSERTIONS = ""org.junit.Assert"";
  private static final String JUNIT5_ASSERTIONS = ""org.junit.jupiter.api.Assertions"";
  private static final String ASSERT_NULL = ""assertNull"";
  private static final String ASSERT_NOT_NULL = ""assertNotNull"";
  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String ASSERT_EQUALS = ""assertEquals"";
  private static final String ASSERT_NOT_EQUALS = ""assertNotEquals"";

  private static final MethodMatchers ASSERT_NULLABLE_FIRST_ARGUMENT = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(JUNIT4_ASSERTIONS)
      .names(ASSERT_NULL, ASSERT_NOT_NULL)
      .addParametersMatcher(MethodMatchers.ANY)
      .build(),
    MethodMatchers.create()
      .ofTypes(JUNIT5_ASSERTIONS)
      .names(ASSERT_NULL, ASSERT_NOT_NULL)
      .addParametersMatcher(MethodMatchers.ANY)
      .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)
      .build());

  private static final MethodMatchers ASSERT_NULLABLE_SECOND_ARGUMENT = MethodMatchers.create()
    .ofTypes(JUNIT4_ASSERTIONS)
    .names(ASSERT_NULL, ASSERT_NOT_NULL)
    .addParametersMatcher(JAVA_LANG_STRING, MethodMatchers.ANY)
    .build();

  private static final MethodMatchers ASSERT_EQUALS_FIRST_AND_SECOND_ARGUMENTS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(JUNIT4_ASSERTIONS)
      .names(ASSERT_EQUALS)
      .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)
      .build(),
    MethodMatchers.create()
      .ofTypes(JUNIT5_ASSERTIONS)
      .names(ASSERT_EQUALS)
      .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)
      .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY, MethodMatchers.ANY)
      .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY, MethodMatchers.ANY, MethodMatchers.ANY)
      .build());

  private static final MethodMatchers ASSERT_EQUALS_SECOND_AND_THIRD_ARGUMENTS = MethodMatchers.create()
    .ofTypes(JUNIT4_ASSERTIONS)
    .names(ASSERT_EQUALS)
    .addParametersMatcher(JAVA_LANG_STRING, MethodMatchers.ANY, MethodMatchers.ANY)
    .addParametersMatcher(JAVA_LANG_STRING, MethodMatchers.ANY, MethodMatchers.ANY, MethodMatchers.ANY)
    .build();

  private static final MethodMatchers ASSERT_NOT_EQUALS_FIRST_AND_SECOND_ARGUMENTS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(JUNIT4_ASSERTIONS)
      .names(ASSERT_NOT_EQUALS)
      .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)
      .build(),
    MethodMatchers.create()
      .ofTypes(JUNIT5_ASSERTIONS)
      .names(ASSERT_NOT_EQUALS)
      .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)
      .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY, MethodMatchers.ANY)
      .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY, MethodMatchers.ANY, MethodMatchers.ANY)
      .build());

  private static final MethodMatchers ASSERT_NOT_EQUALS_SECOND_AND_THIRD_ARGUMENTS = MethodMatchers.create()
    .ofTypes(JUNIT4_ASSERTIONS)
    .names(ASSERT_NOT_EQUALS)
    .addParametersMatcher(JAVA_LANG_STRING, MethodMatchers.ANY, MethodMatchers.ANY)
    .addParametersMatcher(JAVA_LANG_STRING, MethodMatchers.ANY, MethodMatchers.ANY, MethodMatchers.ANY)
    .build();

  private static final MethodMatchers ASSERTJ_ASSERT_THAT = MethodMatchers.create()
    .ofTypes(
      ""org.assertj.core.api.Assertions"",
      ""org.assertj.core.api.AssertionsForInterfaceTypes"",
      ""org.assertj.core.api.AssertionsForClassTypes"")
    .names(""assertThat"", ""assertThatObject"")
    .addParametersMatcher(MethodMatchers.ANY)
    .build();

  private static final MethodMatchers.NameBuilder MATCHER_ANY_TYPE = MethodMatchers.create().ofAnyType();

  private static final MethodMatchers ASSERTJ_NULL_AND_NOT_NULL = MATCHER_ANY_TYPE
    .names(""isNull"", ""isNotNull"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers ASSERTJ_EQUAL_TO_PREDICATE = MATCHER_ANY_TYPE
    .names(""isEqualTo"")
    .addParametersMatcher(MethodMatchers.ANY)
    .build();

  private static final MethodMatchers ASSERTJ_IS_SAME_AS_PREDICATE = MATCHER_ANY_TYPE
    .names(""isSameAs"")
    .addParametersMatcher(MethodMatchers.ANY)
    .build();

  private static final MethodMatchers ASSERTJ_IS_NOT_EQUAL_TO_PREDICATE = MATCHER_ANY_TYPE
    .names(""isNotEqualTo"")
    .addParametersMatcher(MethodMatchers.ANY)
    .build();

  private static final MethodMatchers ASSERTJ_IS_NOT_SAME_AS_PREDICATE = MATCHER_ANY_TYPE
    .names(""isNotSameAs"")
    .addParametersMatcher(MethodMatchers.ANY)
    .build();

  private static final MethodMatchers ASSERTJ_CONFIGURATION = MATCHER_ANY_TYPE
    .names(""as"", ""describedAs"", ""withFailMessage"", ""overridingErrorMessage"")
    .withAnyParameters()
    .build();

  private static final List<String> ASSERTJ_EXCEPTIONS = Arrays.asList(
    ""org.assertj.core.api.AbstractTemporalAssert"",
    ""org.assertj.core.api.AbstractDateAssert"",
    ""org.assertj.core.api.AbstractBigIntegerAssert"",
    ""org.assertj.core.api.AbstractBigDecimalAssert"");

  private enum Option {
    ACCEPT_DISSIMILAR_INTERFACE,
    REJECT_DISSIMILAR_INTERFACE,
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;
    if (ASSERT_NULLABLE_FIRST_ARGUMENT.matches(mit)) {
      checkNullableAssertion(new Argument(mit, 0));
    } else if (ASSERT_NULLABLE_SECOND_ARGUMENT.matches(mit)) {
      checkNullableAssertion(new Argument(mit, 1));
    } else if (ASSERT_EQUALS_FIRST_AND_SECOND_ARGUMENTS.matches(mit)) {
      checkCompatibleTypes(mit, new Argument(mit, 1), new Argument(mit, 0), Option.ACCEPT_DISSIMILAR_INTERFACE);
    } else if (ASSERT_EQUALS_SECOND_AND_THIRD_ARGUMENTS.matches(mit)) {
      checkCompatibleTypes(mit, new Argument(mit, 2), new Argument(mit, 1), Option.ACCEPT_DISSIMILAR_INTERFACE);
    } else if (ASSERT_NOT_EQUALS_FIRST_AND_SECOND_ARGUMENTS.matches(mit)) {
      checkCompatibleTypes(mit, new Argument(mit, 1), new Argument(mit, 0), Option.REJECT_DISSIMILAR_INTERFACE);
    } else if (ASSERT_NOT_EQUALS_SECOND_AND_THIRD_ARGUMENTS.matches(mit)) {
      checkCompatibleTypes(mit, new Argument(mit, 2), new Argument(mit, 1), Option.REJECT_DISSIMILAR_INTERFACE);
    } else if (ASSERTJ_ASSERT_THAT.matches(mit)) {
      checkSubsequentAssertJPredicateCompatibleTypes(new Argument(mit, 0), mit);
    }
  }

  private void checkSubsequentAssertJPredicateCompatibleTypes(Argument actual, MethodInvocationTree previousMethod) {
    MethodTreeUtils.consecutiveMethodInvocation(previousMethod)
      .ifPresent(mit -> {
        boolean checkFollowingMethod = true;
        if (ASSERTJ_NULL_AND_NOT_NULL.matches(mit)) {
          checkNullableAssertion(ExpressionUtils.methodName(mit), actual);
        } else if (ASSERTJ_EQUAL_TO_PREDICATE.matches(mit)) {
          checkCompatibleAssertJEqualTypes(mit, actual, new Argument(mit, 0), Option.ACCEPT_DISSIMILAR_INTERFACE);
        } else if (ASSERTJ_IS_SAME_AS_PREDICATE.matches(mit)) {
          checkCompatibleTypes(mit, actual, new Argument(mit, 0), Option.ACCEPT_DISSIMILAR_INTERFACE);
        } else if (ASSERTJ_IS_NOT_EQUAL_TO_PREDICATE.matches(mit)) {
          checkCompatibleAssertJEqualTypes(mit, actual, new Argument(mit, 0), Option.REJECT_DISSIMILAR_INTERFACE);
        } else if (ASSERTJ_IS_NOT_SAME_AS_PREDICATE.matches(mit)) {
          checkCompatibleTypes(mit, actual, new Argument(mit, 0), Option.REJECT_DISSIMILAR_INTERFACE);
        } else if (!ASSERTJ_CONFIGURATION.matches(mit)) {
          // stop checking when methods like: extracting, using*, filtered*
          checkFollowingMethod = false;
        }
        if (checkFollowingMethod) {
          checkSubsequentAssertJPredicateCompatibleTypes(actual, mit);
        }
      });
  }

  private void checkNullableAssertion(Argument actual) {
    checkNullableAssertion(actual.expression, actual);
  }

  private void checkNullableAssertion(Tree issueLocation, Argument actual) {
    if (actual.isPrimitive()) {
      reportIssue(issueLocation, ""Change the assertion arguments to not compare a primitive value with null."");
    }
  }

  private void checkCompatibleAssertJEqualTypes(MethodInvocationTree mit, Argument actual, Argument expected, Option option) {
    Type type = mit.symbolType();
    if (ASSERTJ_EXCEPTIONS.stream().anyMatch(type::isSubtypeOf)) {
      // AssertJ supports Date/Temporal and BigInteger/BigDecimal comparison with String.
      return;
    }
    checkCompatibleTypes(mit, actual, expected, option);
  }

  private void checkCompatibleTypes(MethodInvocationTree mit, Argument actual, Argument expected, Option option) {
    if (areNotCompatibleTypes(actual, expected, option) && !isNotEqualsInTestRelatedToEquals(mit)) {
      createIssue(actual, expected);
    }
  }

  private static boolean isNotEqualsInTestRelatedToEquals(MethodInvocationTree mit) {
    String methodName = ExpressionUtils.methodName(mit).name();
    return (ASSERT_NOT_EQUALS.equals(methodName) || ""isNotEqualTo"".equals(methodName)) &&
      UnitTestUtils.isInUnitTestRelatedToObjectMethods(mit);
  }

  private static boolean areNotCompatibleTypes(Argument actual, Argument expected, Option option) {
    return isNullAndPrimitive(actual, expected) ||
      isNotCompatibleArray(actual, expected, option) ||
      isArrayAndNotArray(actual, expected) ||
      isNotCompatibleClass(actual, expected, option);
  }

  private static boolean isNullAndPrimitive(Argument actual, Argument expected) {
    return (actual.isNullLiteral() && expected.isPrimitive()) ||
      (actual.isPrimitive() && expected.isNullLiteral());
  }

  private static boolean isArrayAndNotArray(Argument actual, Argument expected) {
    return (actual.isArray() && expected.isNotArray()) ||
      (actual.isNotArray() && expected.isArray());
  }

  private static boolean isNotCompatibleArray(Argument actual, Argument expected, Option option) {
    if (!actual.isArray() || !expected.isArray()) {
      return false;
    }
    Type actualElementType = ((Type.ArrayType) actual.type).elementType().erasure();
    Type expectedElementType = ((Type.ArrayType) expected.type).elementType().erasure();
    if (actualElementType.isUnknown() || expectedElementType.isUnknown()) {
      return false;
    }
    if (actualElementType.isPrimitive() || expectedElementType.isPrimitive()) {
      return !actualElementType.name().equals(expectedElementType.name());
    }
    return areNotCompatibleTypes(
      new Argument(actual.expression, actualElementType),
      new Argument(expected.expression, expectedElementType),
      option);
  }

  private static boolean isNotCompatibleClass(Argument actual, Argument expected, Option option) {
    return isNotInstanceOf(actual, expected, option) && isNotInstanceOf(expected, actual, option);
  }

  private static boolean isNotInstanceOf(Argument argumentA, Argument argumentB, Option option) {
    if (argumentA.type.isPrimitive() && argumentB.type.isPrimitive()) {
      return false;
    }
    Type typeA = wrapperType(argumentA.type);
    Type typeB = wrapperType(argumentB.type);
    if (typeA.isUnknown() || typeB.isUnknown() || !typeA.isClass() || !typeB.isClass()) {
      return false;
    } else if (typeA.symbol().isInterface() && typeB.symbol().isInterface()) {
      return option == Option.REJECT_DISSIMILAR_INTERFACE && !typeA.isSubtypeOf(typeB);
    } else if (typeB.symbol().isInterface()) {
      // typeA is not an interface
      return (option == Option.REJECT_DISSIMILAR_INTERFACE || typeA.symbol().isFinal()) &&
        !typeA.isSubtypeOf(typeB);
    } else if (typeA.symbol().isInterface()) {
      // typeB is not an interface
      return true;
    } else {
      // typeA and typeB are not interfaces
      return !typeA.isSubtypeOf(typeB);
    }
  }

  private void createIssue(Argument actual, Argument expected) {
    reportIssue(
      expected.expression,
      ""Change the assertion arguments to not compare dissimilar types."",
      Collections.singletonList(new JavaFileScannerContext.Location(""Actual"", actual.expression)),
      null);
  }

  static class Argument {

    final ExpressionTree expression;

    final Type expressionType;

    final Type type;

    Argument(MethodInvocationTree mit, int argumentIndex) {
      expression = mit.arguments().get(argumentIndex);
      expressionType = expression.symbolType().erasure();
      Type expectedType = expectedArgumentType(mit, argumentIndex);
      if (expectedType.isUnknown()) {
        type = expressionType;
      } else if (expectedType.isPrimitive()) {
        type = expectedType;
      } else {
        type = wrapperType(expressionType);
      }
    }

    Argument(ExpressionTree expression, Type type) {
      this.expression = expression;
      this.expressionType = type;
      this.type = type;
    }

    boolean isArray() {
      return type.isArray();
    }

    boolean isNotArray() {
      return !type.isUnknown() && !type.isArray() && !type.is(JAVA_LANG_OBJECT) && !isNullLiteral();
    }

    boolean isNullLiteral() {
      return expression.kind() == Tree.Kind.NULL_LITERAL;
    }

    boolean isPrimitive() {
      return expressionType.isPrimitive();
    }

    static Type expectedArgumentType(MethodInvocationTree mit, int argumentIndex) {
      if (mit.methodSymbol().isUnknown()) {
        return Symbols.unknownType;
      }
      List<Type> parameterTypes = mit.methodSymbol().parameterTypes();
      if (argumentIndex >= parameterTypes.size()) {
        return Symbols.unknownType;
      }
      return parameterTypes.get(argumentIndex).erasure();
    }
  }

  static Type wrapperType(Type type) {
    if (type.isPrimitive()) {
      Type wrapperType = type.primitiveWrapperType();
      return wrapperType != null ? wrapperType : type;
    }
    return type;
  }

}
"
S5846,CODE_SMELL,Empty lines should not be tested with regex MULTILINE flag,"package org.sonar.java.checks.regex;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.ast.BoundaryTree;
import org.sonarsource.analyzer.commons.regex.ast.NonCapturingGroupTree;
import org.sonarsource.analyzer.commons.regex.ast.RegexBaseVisitor;
import org.sonarsource.analyzer.commons.regex.ast.RegexTree;
import org.sonarsource.analyzer.commons.regex.ast.SequenceTree;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.ParenthesizedTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S5846"")
public class EmptyLineRegexCheck extends AbstractRegexCheck {
  private static final String MESSAGE = ""Remove MULTILINE mode or change the regex."";

  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String JAVA_UTIL_PATTERN = ""java.util.regex.Pattern"";

  private static final MethodMatchers STRING_REPLACE = MethodMatchers.create()
    .ofTypes(JAVA_LANG_STRING)
    .names(""replaceAll"", ""replaceFirst"")
    .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING)
    .build();

  private static final MethodMatchers PATTERN_COMPILE = MethodMatchers.create()
    .ofTypes(JAVA_UTIL_PATTERN)
    .names(""compile"")
    .addParametersMatcher(JAVA_LANG_STRING)
    .addParametersMatcher(JAVA_LANG_STRING, ""int"")
    .build();

  private static final MethodMatchers PATTERN_MATCHER = MethodMatchers.create()
    .ofTypes(JAVA_UTIL_PATTERN)
    .names(""matcher"")
    .addParametersMatcher(""java.lang.CharSequence"")
    .build();

  private static final MethodMatchers PATTERN_FIND = MethodMatchers.create()
    .ofTypes(""java.util.regex.Matcher"")
    .names(""find"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers STRING_IS_EMPTY = MethodMatchers.create()
    .ofTypes(JAVA_LANG_STRING)
    .names(""isEmpty"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    // Only a few methods can contain problematic regex, we don't need to check all of them.
    return MethodMatchers.or(STRING_REPLACE, PATTERN_COMPILE);
  }

  @Override
  protected boolean filterAnnotation(AnnotationTree annotation) {
    return false;
  }

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    MethodInvocationTree mit = (MethodInvocationTree) methodInvocationOrAnnotation;
    EmptyLineMultilineVisitor visitor = new EmptyLineMultilineVisitor();
    visitor.visit(regexForLiterals);
    if (visitor.containEmptyLine) {
      if (PATTERN_COMPILE.matches(mit)) {
        List<Tree> stringNotTestedForEmpty = getStringNotTestedForEmpty(mit);
        if (!stringNotTestedForEmpty.isEmpty()) {
          reportWithSecondaries(mit.arguments().get(0), stringNotTestedForEmpty);
        }
      } else {
        // STRING_REPLACE case
        ExpressionTree methodSelect = mit.methodSelect();
        if (methodSelect.is(Tree.Kind.MEMBER_SELECT)
          && canBeEmpty(((MemberSelectExpressionTree) methodSelect).expression())) {
          reportIssue(mit.arguments().get(0), MESSAGE);
        }
      }
    }
  }

  private static List<Tree> getStringNotTestedForEmpty(MethodInvocationTree mit) {
    Tree parent = mit.parent();
    if (parent != null && parent.is(Tree.Kind.VARIABLE)) {
      // Pattern stored in a variable, check all usage for possibly empty string
      return ((VariableTree) parent).symbol().usages().stream()
        .map(EmptyLineRegexCheck::getStringInMatcherFind)
        .filter(Optional::isPresent)
        .map(Optional::get)
        .filter(EmptyLineRegexCheck::canBeEmpty)
        .toList();
    } else {
      // Pattern can be used directly
      return getStringInMatcherFind(mit)
        .filter(EmptyLineRegexCheck::canBeEmpty)
        .map(Collections::singletonList)
        .orElseGet(Collections::emptyList);
    }
  }

  private static Optional<Tree> getStringInMatcherFind(ExpressionTree mit) {
    return MethodTreeUtils.subsequentMethodInvocation(mit, PATTERN_MATCHER)
      .filter(matcherMit -> MethodTreeUtils.subsequentMethodInvocation(matcherMit, PATTERN_FIND).isPresent())
      .map(matcherMit -> matcherMit.arguments().get(0));
  }

  private static boolean canBeEmpty(Tree expressionTree) {
    if (expressionTree.is(Tree.Kind.IDENTIFIER)) {
      Symbol identifierSymbol = ((IdentifierTree) expressionTree).symbol();
      Symbol owner = identifierSymbol.owner();
      return owner != null && owner.isMethodSymbol() && identifierSymbol.usages().stream().noneMatch(EmptyLineRegexCheck::isIsEmpty);
    } else if (expressionTree.is(Tree.Kind.STRING_LITERAL, Tree.Kind.TEXT_BLOCK)) {
      return LiteralUtils.trimQuotes(((LiteralTree) expressionTree).value()).isEmpty();
    } else if (expressionTree.is(Tree.Kind.PARENTHESIZED_EXPRESSION)) {
      return canBeEmpty(((ParenthesizedTree) expressionTree).expression());
    }
    // If not sure, consider it as not empty to avoid FP.
    return false;
  }

  private static boolean isIsEmpty(IdentifierTree id) {
    return MethodTreeUtils.subsequentMethodInvocation(id, STRING_IS_EMPTY).isPresent();
  }

  private void reportWithSecondaries(Tree regex, List<Tree> secondaries) {
    List<JavaFileScannerContext.Location> secondariesLocation =
      secondaries.stream().map(secondary -> new JavaFileScannerContext.Location(""This string can be empty."", secondary))
        .toList();
    reportIssue(regex, MESSAGE, secondariesLocation, null);
  }

  private static class EmptyLineMultilineVisitor extends RegexBaseVisitor {
    boolean visitedStart = false;
    boolean visitedEndAfterStart = false;
    boolean containEmptyLine = false;

    @Override
    public void visitSequence(SequenceTree tree) {
      List<RegexTree> items = tree.getItems().stream()
        .filter(item -> !isNonCapturingWithoutChild(item))
        .toList();

      if (items.size() == 1 && items.get(0).is(RegexTree.Kind.CAPTURING_GROUP)) {
        super.visitSequence(tree);
      } else if (items.size() == 2 && items.get(0).is(RegexTree.Kind.BOUNDARY) && items.get(1).is(RegexTree.Kind.BOUNDARY)) {
        super.visitSequence(tree);
        containEmptyLine |= visitedEndAfterStart;
      }
      visitedStart = false;
    }

    @Override
    public void visitBoundary(BoundaryTree boundaryTree) {
      if (boundaryTree.activeFlags().contains(Pattern.MULTILINE)) {
        if (boundaryTree.type().equals(BoundaryTree.Type.LINE_START)) {
          visitedStart = true;
        } else if (boundaryTree.type().equals(BoundaryTree.Type.LINE_END)) {
          visitedEndAfterStart = visitedStart;
        }
      }
    }

    private static boolean isNonCapturingWithoutChild(RegexTree tree) {
      return tree.is(RegexTree.Kind.NON_CAPTURING_GROUP) && ((NonCapturingGroupTree) tree).getElement() == null;
    }

  }

}
"
S5850,BUG,Alternatives in regular expressions should be grouped when used with anchors,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.AnchorPrecedenceFinder;

@Rule(key = ""S5850"")
public class AnchorPrecedenceCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new AnchorPrecedenceFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S5852,SECURITY_HOTSPOT,Using slow regular expressions is security-sensitive,"package org.sonar.java.checks.regex;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.MatchType;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.ast.AtomicGroupTree;
import org.sonarsource.analyzer.commons.regex.ast.AutomatonState;
import org.sonarsource.analyzer.commons.regex.ast.BackReferenceTree;
import org.sonarsource.analyzer.commons.regex.ast.CharacterClassElementTree;
import org.sonarsource.analyzer.commons.regex.ast.DisjunctionTree;
import org.sonarsource.analyzer.commons.regex.ast.DotTree;
import org.sonarsource.analyzer.commons.regex.ast.GroupTree;
import org.sonarsource.analyzer.commons.regex.ast.RegexBaseVisitor;
import org.sonarsource.analyzer.commons.regex.ast.RegexTree;
import org.sonarsource.analyzer.commons.regex.ast.RepetitionTree;
import org.sonarsource.analyzer.commons.regex.helpers.IntersectAutomataChecker;
import org.sonarsource.analyzer.commons.regex.helpers.RegexReachabilityChecker;
import org.sonarsource.analyzer.commons.regex.helpers.SimplifiedRegexCharacterClass;
import org.sonarsource.analyzer.commons.regex.helpers.SubAutomaton;

import static org.sonarsource.analyzer.commons.regex.helpers.RegexReachabilityChecker.canReachWithoutConsumingInput;
import static org.sonarsource.analyzer.commons.regex.helpers.RegexReachabilityChecker.canReachWithoutConsumingInputNorCrossingBoundaries;
import static org.sonarsource.analyzer.commons.regex.helpers.RegexTreeHelper.isAnchoredAtEnd;

@Rule(key = ""S5852"")
public class RedosCheck extends AbstractRegexCheckTrackingMatchType {

  private static final String MESSAGE = ""Make sure the regex used here, which is vulnerable to %s runtime due to backtracking,"" +
    "" cannot lead to denial of service%s."";
  private static final String JAVA8_MESSAGE = "" or make sure the code is only run using Java 9 or later"";
  private static final String EXP = ""exponential"";
  private static final String POLY = ""polynomial"";private static final int MAX_TRACKED_REPETITIONS = 10;private static final int MAX_REGEX_LENGTH = 1000;

  private boolean regexContainsBackReference;
  private BacktrackingType foundBacktrackingType;

  private final RegexReachabilityChecker reachabilityChecker = new RegexReachabilityChecker(false);
  private final IntersectAutomataChecker intersectionChecker = new IntersectAutomataChecker(false);

  // Java 9 introduced a loop optimization that's applied to greedy repetitions in regexes that don't use capturing groups.
  // Without this optimization any loop where for the same input multiple paths can be taken through the loop's body,
  // has exponential runtime. With the optimization such loops, if they are greedy, have either quadratic runtime (if
  // the paths go through an inner loop) or linear (i.e. safe) runtime.
  // Consecutive (not nested) loops that can overlap each other cause quadratic runtime and are unaffected by this
  // optimization.
  enum BacktrackingType {
    ALWAYS_EXPONENTIAL,
    QUADRATIC_WHEN_OPTIMIZED,
    ALWAYS_QUADRATIC,
    LINEAR_WHEN_OPTIMIZED,
    NO_ISSUE
  }

  private boolean isJava9OrHigher() {
    return context.getJavaVersion().isNotSet() || context.getJavaVersion().asInt() >= 9;
  }
  
  private Optional<String> message() {
    boolean canBeOptimized = !regexContainsBackReference;
    boolean optimized = isJava9OrHigher() && canBeOptimized;
    switch (foundBacktrackingType) {
      case ALWAYS_EXPONENTIAL:
        return Optional.of(String.format(MESSAGE, EXP, """"));
      case QUADRATIC_WHEN_OPTIMIZED:
        // We only suggest upgrading to Java 9+ when that would make the regex safe (i.e. linear runtime), not if it would
        // merely improve it from exponential to quadratic.
        return Optional.of(String.format(MESSAGE, optimized ? POLY : EXP, """"));
      case LINEAR_WHEN_OPTIMIZED:
        if (optimized) {
          return Optional.empty();
        } else {
          return Optional.of(String.format(MESSAGE, EXP, canBeOptimized ? JAVA8_MESSAGE : """"));
        }
      case ALWAYS_QUADRATIC:
        return Optional.of(String.format(MESSAGE, POLY, """"));
      case NO_ISSUE:
        return Optional.empty();
    }
    throw new IllegalStateException(""This line is not actually reachable"");
  }

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation, MatchType matchType) {
    if (regexForLiterals.getResult().getText().length() > MAX_REGEX_LENGTH) {
      return;
    }
    regexContainsBackReference = false;
    foundBacktrackingType = BacktrackingType.NO_ISSUE;
    reachabilityChecker.clearCache();
    intersectionChecker.clearCache();
    boolean isUsedForFullMatch = matchType == MatchType.FULL || matchType == MatchType.BOTH;
    boolean isUsedForPartialMatch = matchType == MatchType.PARTIAL || matchType == MatchType.BOTH;
    RedosFinder visitor = new RedosFinder(regexForLiterals.getStartState(), regexForLiterals.getFinalState(), isUsedForFullMatch, isUsedForPartialMatch);
    visitor.visit(regexForLiterals);
    message().ifPresent(message ->
      reportIssue(methodOrAnnotationName(methodInvocationOrAnnotation), message, null, Collections.emptyList())
    );
  }

  private void addBacktracking(BacktrackingType newBacktrackingType) {
    if (newBacktrackingType.ordinal() < foundBacktrackingType.ordinal()) {
      foundBacktrackingType = newBacktrackingType;
    }
  }

  private class RedosFinder extends RegexBaseVisitor {


    private final Deque<RepetitionTree> nonPossessiveRepetitions = new ArrayDeque<>();
    private final Map<AutomatonState, Boolean> canFailCache = new HashMap<>();

    private final AutomatonState startOfRegex;
    private final AutomatonState endOfRegex;
    private final boolean isUsedForFullMatch;
    private final boolean isUsedForPartialMatch;

    public RedosFinder(AutomatonState startOfRegex, AutomatonState endOfRegex, boolean isUsedForFullMatch, boolean isUsedForPartialMatch) {
      this.startOfRegex = startOfRegex;
      this.endOfRegex = endOfRegex;
      this.isUsedForFullMatch = isUsedForFullMatch;
      this.isUsedForPartialMatch = isUsedForPartialMatch;
    }

    @Override
    public void visitRepetition(RepetitionTree tree) {
      if (canFail(tree.continuation())) {
        if (!tree.isPossessive() && tree.getQuantifier().isOpenEnded()) {
          new BacktrackingFinder(tree.isReluctant(), tree.continuation()).visit(tree.getElement());
        } else {
          super.visitRepetition(tree);
        }
        checkForOverlappingRepetitions(tree);
      }
    }

    private void checkForOverlappingRepetitions(RepetitionTree tree) {
      if (tree.getQuantifier().isOpenEnded() && canFail(tree)) {
        for (RepetitionTree repetition : nonPossessiveRepetitions) {
          if (reachabilityChecker.canReach(repetition, tree)) {
            SubAutomaton repetitionAuto = new SubAutomaton(repetition.getElement(), repetition.continuation(), false);
            SubAutomaton continuationAuto = new SubAutomaton(repetition.continuation(), tree, false);
            SubAutomaton treeAuto = new SubAutomaton(tree.getElement(), tree.continuation(), false);
            if (subAutomatonCanConsume(repetitionAuto, continuationAuto)
              && automatonIsEmptyOrIntersects(continuationAuto, treeAuto)
              && intersectionChecker.check(repetitionAuto, treeAuto)) {
              addBacktracking(BacktrackingType.ALWAYS_QUADRATIC);
            }
          }
        }
        if (overlapsWithImplicitMatchAlls(tree)) {
          addBacktracking(BacktrackingType.ALWAYS_QUADRATIC);
        }
        addIfNonPossessive(tree);
      }
    }

    private boolean subAutomatonCanConsume(SubAutomaton auto1, SubAutomaton auto2) {
      return canReachWithoutConsumingInputNorCrossingBoundaries(auto1.end, auto2.end)
        || intersectionChecker.check(auto1, auto2);
    }

    private boolean automatonIsEmptyOrIntersects(SubAutomaton auto1, SubAutomaton auto2) {
      return canReachWithoutConsumingInputNorCrossingBoundaries(auto1.start, auto1.end)
        || intersectionChecker.check(auto1, auto2);
    }

    private void addIfNonPossessive(RepetitionTree tree) {
      if (!tree.isPossessive()) {
        nonPossessiveRepetitions.add(tree);
        if (nonPossessiveRepetitions.size() > MAX_TRACKED_REPETITIONS) {
          nonPossessiveRepetitions.removeFirst();
        }
      }
    }private boolean overlapsWithImplicitMatchAlls(RepetitionTree tree) {
      return isUsedForPartialMatch && canReachWithoutConsumingInputNorCrossingBoundaries(startOfRegex, tree);
    }

    @Override
    public void visitBackReference(BackReferenceTree tree) {
      regexContainsBackReference = true;
    }

    private boolean canFail(AutomatonState state) {
      return canFail(state, !isUsedForFullMatch && !isAnchoredAtEnd(state));
    }

    private boolean canFail(AutomatonState state, boolean succeedOnEnd) {
      if (canFailCache.containsKey(state)) {
        return canFailCache.get(state);
      }
      canFailCache.put(state, true);
      if (state.incomingTransitionType() != AutomatonState.TransitionType.EPSILON) {
        return true;
      }
      if (canMatchAnything(state)) {
        succeedOnEnd = true;
        state = state.continuation();
      }
      if ((succeedOnEnd && canReachWithoutConsumingInput(state, endOfRegex))) {
        canFailCache.put(state, false);
        return false;
      }
      for (AutomatonState successor : state.successors()) {
        if (!canFail(successor, succeedOnEnd)) {
          canFailCache.put(state, false);
          return false;
        }
      }
      return true;
    }

    private boolean canMatchAnything(AutomatonState state) {
      if (!(state instanceof RepetitionTree repetition)) {
        return false;
      }
      return repetition.getQuantifier().getMinimumRepetitions() == 0 && repetition.getQuantifier().isOpenEnded()
        && canMatchAnyCharacter(repetition.getElement());
    }

    private boolean canMatchAnyCharacter(RegexTree tree) {
      SimplifiedRegexCharacterClass characterClass = new SimplifiedRegexCharacterClass();
      for (RegexTree singleCharacter : collectSingleCharacters(tree, new ArrayList<>())) {
        if (singleCharacter.is(RegexTree.Kind.DOT)) {
          characterClass.add((DotTree) singleCharacter);
        } else {
          characterClass.add((CharacterClassElementTree) singleCharacter);
        }
      }
      return characterClass.matchesAnyCharacter();
    }

    private List<RegexTree> collectSingleCharacters(@Nullable RegexTree tree, List<RegexTree> accumulator) {
      if (tree == null) {
        return accumulator;
      }
      if (tree instanceof CharacterClassElementTree || tree.is(RegexTree.Kind.DOT)) {
        accumulator.add(tree);
      } else if (tree.is(RegexTree.Kind.DISJUNCTION)) {
        for (RegexTree alternative : ((DisjunctionTree) tree).getAlternatives()) {
          collectSingleCharacters(alternative, accumulator);
        }
      } else if (tree instanceof GroupTree groupTree) {
        collectSingleCharacters(groupTree.getElement(), accumulator);
      } else if (tree.is(RegexTree.Kind.REPETITION)) {
        RepetitionTree repetition = (RepetitionTree) tree;
        if (repetition.getQuantifier().getMinimumRepetitions() <= 1) {
          collectSingleCharacters(repetition.getElement(), accumulator);
        }
      }
      return accumulator;
    }

  }

  private class BacktrackingFinder extends RegexBaseVisitor {

    private final boolean isReluctant;
    private final AutomatonState endOfLoop;

    public BacktrackingFinder(boolean isReluctant, AutomatonState endOfLoop) {
      this.isReluctant = isReluctant;
      this.endOfLoop = endOfLoop;
    }

    @Override
    public void visitAtomicGroup(AtomicGroupTree tree) {
      new RedosFinder(tree, tree.continuation(), false, false).visit(tree);
    }

    @Override
    public void visitRepetition(RepetitionTree tree) {
      if (tree.isPossessive()) {
        new RedosFinder(tree, tree.continuation(), false, false).visit(tree);
      } else if (containsIntersections(Arrays.asList(tree.getElement(), tree.continuation()))) {
        BacktrackingType greedyComplexity = tree.getQuantifier().isOpenEnded() ? BacktrackingType.QUADRATIC_WHEN_OPTIMIZED : BacktrackingType.LINEAR_WHEN_OPTIMIZED;
        addBacktracking(isReluctant ? BacktrackingType.ALWAYS_EXPONENTIAL : greedyComplexity);
        super.visitRepetition(tree);
      } else {
        super.visitRepetition(tree);
      }
    }

    @Override
    public void visitDisjunction(DisjunctionTree tree) {
      if (containsIntersections(tree.getAlternatives())) {
        addBacktracking(isReluctant ? BacktrackingType.ALWAYS_EXPONENTIAL : BacktrackingType.LINEAR_WHEN_OPTIMIZED);
      } else {
        super.visitDisjunction(tree);
      }
    }

    @Override
    public void visitBackReference(BackReferenceTree tree) {
      regexContainsBackReference = true;
    }

    boolean containsIntersections(List<? extends AutomatonState> alternatives) {
      for (int i = 0; i < alternatives.size() - 1; i++) {
        AutomatonState state1 = alternatives.get(i);
        for (int j = i + 1; j < alternatives.size(); j++) {
          AutomatonState state2 = alternatives.get(j);
          SubAutomaton auto1 = new SubAutomaton(state1, endOfLoop, false);
          SubAutomaton auto2 = new SubAutomaton(state2, endOfLoop, false);
          if (intersectionChecker.check(auto1, auto2)) {
            return true;
          }
        }
      }
      return false;
    }
  }

}
"
S5853,CODE_SMELL,"Consecutive AssertJ ""assertThat"" statements should be chained","package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.UnitTestUtils.hasTestAnnotation;

@Rule(key = ""S5853"")
public class AssertJConsecutiveAssertionCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers ASSERT_THAT_MATCHER = MethodMatchers.create()
    .ofSubTypes(""org.assertj.core.api.Assertions"", ""org.assertj.core.api.Assert"")
    .names(""assertThat"")
    .addParametersMatcher(MethodMatchers.ANY)
    .build();

  public static final MethodMatchers ASSERTJ_SET_CONTEXT_METHODS = MethodMatchers.create()
    .ofSubTypes(""org.assertj.core.api.AbstractAssert"")
    .name(name -> name.startsWith(""extracting"") || name.startsWith(""using"") || name.startsWith(""filtered"")
      || ""flatExtracting"".equals(name) || ""map"".equals(name) || ""flatMap"".equals(name))
    .withAnyParameters()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (hasTestAnnotation(methodTree)) {
      BlockTree block = methodTree.block();
      if (block != null) {
        reportConsecutiveAssertions(block.body());
      }
    }
  }

  private void reportConsecutiveAssertions(List<StatementTree> statements) {
    AssertSubject currentSubject = null;
    List<AssertSubject> equivalentInvocations = new ArrayList<>();

    for (StatementTree statement : statements) {
      Optional<AssertSubject> assertThatInvocation = getSimpleAssertSubject(statement);

      if (assertThatInvocation.isPresent()) {
        AssertSubject assertSubject = assertThatInvocation.get();
        if (currentSubject == null) {
          currentSubject = assertSubject;
        } else if (currentSubject.hasEquivalentArgument(assertSubject)) {
          equivalentInvocations.add(assertSubject);
        } else {
          reportIssueIfMultipleCalls(currentSubject, equivalentInvocations);
          currentSubject = assertSubject;
          equivalentInvocations.clear();
        }
      } else {
        // We have something else than an assertion subject or a subject returning different values between two calls
        reportIssueIfMultipleCalls(currentSubject, equivalentInvocations);
        currentSubject = null;
        equivalentInvocations.clear();
      }
    }

    reportIssueIfMultipleCalls(currentSubject, equivalentInvocations);
  }private static Optional<AssertSubject> getSimpleAssertSubject(StatementTree statement) {
    if (statement.is(Tree.Kind.EXPRESSION_STATEMENT)) {
      ExpressionTree expression = ((ExpressionStatementTree) statement).expression();
      if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
        // First method invocation should be an assertion predicate, if not (incomplete assertion), we will not find anything
        return getSimpleAssertSubject(((MethodInvocationTree) expression).methodSelect());
      }
    }
    return Optional.empty();
  }

  private static Optional<AssertSubject> getSimpleAssertSubject(ExpressionTree expressionTree) {
    if (expressionTree.is(Tree.Kind.MEMBER_SELECT)) {
      ExpressionTree memberSelectExpression = ((MemberSelectExpressionTree) expressionTree).expression();
      if (memberSelectExpression.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree mit = (MethodInvocationTree) memberSelectExpression;
        if (ASSERT_THAT_MATCHER.matches(mit)) {
          ExpressionTree arg = mit.arguments().get(0);
          if (ExpressionsHelper.alwaysReturnSameValue(arg)) {
            return Optional.of(new AssertSubject(mit, arg));
          }
        } else if (ASSERTJ_SET_CONTEXT_METHODS.matches(mit)) {
          return Optional.empty();
        } else {
          return getSimpleAssertSubject(mit.methodSelect());
        }
      }
    }
    return Optional.empty();
  }

  private void reportIssueIfMultipleCalls(@Nullable AssertSubject assertSubject, List<AssertSubject> equivalentAssertions) {
    if (assertSubject != null && !equivalentAssertions.isEmpty()) {
      reportIssue(assertSubject.methodName(),
        ""Join these multiple assertions subject to one assertion chain."",
        equivalentAssertions.stream().map(AssertSubject::toSecondaryLocation).toList(),
        null);
    }
  }

  private static class AssertSubject {
    final MethodInvocationTree mit;
    final Type assertionType;
    final ExpressionTree arg;

    AssertSubject(MethodInvocationTree mit, ExpressionTree arg) {
      this.mit = mit;
      this.assertionType = mit.symbolType().erasure();
      this.arg = arg;
    }

    boolean hasEquivalentArgument(AssertSubject other) {
      return SyntacticEquivalence.areEquivalent(arg, other.arg)
        && (other.assertionType.isSubtypeOf(assertionType) || couldBeChained(other));
    }

    boolean couldBeChained(AssertSubject other) {
      return MethodTreeUtils.consecutiveMethodInvocation(other.mit)
        .map(chainedNextMethod -> chainedNextMethod.methodSymbol().owner().type().erasure())
        .map(mit.methodSymbol().owner().type().erasure()::isSubtypeOf)
        .orElse(false);
    }

    IdentifierTree methodName() {
      return ExpressionUtils.methodName(mit);
    }

    JavaFileScannerContext.Location toSecondaryLocation() {
      return new JavaFileScannerContext.Location(""Other assertThat"", methodName());
    }
  }

}
"
S5854,CODE_SMELL,Regexes containing characters subject to normalization should use the CANON_EQ flag,"package org.sonar.java.checks.regex;

import java.text.Normalizer;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.ast.CharacterClassTree;
import org.sonarsource.analyzer.commons.regex.ast.CharacterTree;
import org.sonarsource.analyzer.commons.regex.ast.RegexBaseVisitor;
import org.sonarsource.analyzer.commons.regex.ast.SequenceTree;

import static org.sonarsource.analyzer.commons.regex.helpers.GraphemeHelper.getGraphemeInList;

@Rule(key = ""S5854"")
public class CanonEqFlagInRegexCheck extends AbstractRegexCheck {

  protected static final MethodMatchers STRING_MATCHES = MethodMatchers.create()
    .ofTypes(JAVA_LANG_STRING)
    .names(""matches"")
    .addParametersMatcher(JAVA_LANG_STRING)
    .build();

  protected static final MethodMatchers STRING_REPLACE_ALL = MethodMatchers.create()
    .ofTypes(JAVA_LANG_STRING)
    .names(""replaceAll"")
    .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING)
    .build();

  protected static final MethodMatchers STRING_REPLACE_FIRST = MethodMatchers.create()
    .ofTypes(JAVA_LANG_STRING)
    .names(""replaceFirst"")
    .addParametersMatcher(JAVA_LANG_STRING, JAVA_LANG_STRING)
    .build();

  protected static final MethodMatchers PATTERN_MATCHES = MethodMatchers.create()
    .ofTypes(""java.util.regex.Pattern"")
    .names(""matches"")
    .addParametersMatcher(JAVA_LANG_STRING, ""java.lang.CharSequence"")
    .build();

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    if (regexForLiterals.getInitialFlags().contains(Pattern.CANON_EQ)) {
      return;
    }
    CharacterVisitor visitor = new CharacterVisitor();
    visitor.visit(regexForLiterals);

    if (!visitor.subjectToNormalization.isEmpty()) {
      String endOfMessage = ""this pattern"";
      if (methodInvocationOrAnnotation.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree mit = (MethodInvocationTree) methodInvocationOrAnnotation;
        if (STRING_MATCHES.matches(mit) || PATTERN_MATCHES.matches(mit)) {
          endOfMessage = ""\""Pattern.compile(regex, CANON_EQ).matcher(input).matches()\"""";
        } else if (STRING_REPLACE_ALL.matches(mit)) {
          endOfMessage = ""\""Pattern.compile(pattern, CANON_EQ).matcher(input).replaceAll(replacement)\"""";
        } else if (STRING_REPLACE_FIRST.matches(mit)) {
          endOfMessage = ""\""Pattern.compile(pattern, CANON_EQ).matcher(input).replaceFirst(replacement)\"""";
        }
      }
      reportIssue(regexForLiterals.getResult(), String.format(""Use the CANON_EQ flag with %s."", endOfMessage), null, visitor.subjectToNormalization);
    }
  }

  private static class CharacterVisitor extends RegexBaseVisitor {

    private final List<RegexIssueLocation> subjectToNormalization = new ArrayList<>();

    @Override
    public void visitSequence(SequenceTree tree) {
      getGraphemeInList(tree.getItems())
        .stream()
        .map(RegexIssueLocation::fromCommonsRegexIssueLocation)
        .forEach(subjectToNormalization::add);
      super.visitSequence(tree);
    }

    @Override
    public void visitCharacterClass(CharacterClassTree tree) {
      // Stop visit in classes, S5868 will report an eventual issue for it.
    }

    @Override
    public void visitCharacter(CharacterTree tree) {
      String str = tree.characterAsString();
      if (isSubjectToNormalization(str)) {
        subjectToNormalization.add(new RegexIssueLocation(tree, """"));
      }
    }

    private static boolean isSubjectToNormalization(String str) {
      return !Normalizer.isNormalized(str, Normalizer.Form.NFD);
    }

  }

}
"
S5855,BUG,Regex alternatives should not be redundant,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.RedundantRegexAlternativesFinder;

@Rule(key = ""S5855"")
public class RedundantRegexAlternativesCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new RedundantRegexAlternativesFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }
}
"
S5856,BUG,Regular expressions should be syntactically valid,"package org.sonar.java.checks.regex;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.regex.RegexCheck;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.SyntaxError;
import org.sonarsource.analyzer.commons.regex.ast.RegexSyntaxElement;
import org.sonar.plugins.java.api.tree.ExpressionTree;

@Rule(key = ""S5856"")
public class InvalidRegexCheck extends AbstractRegexCheck {

  private static final String ERROR_MESSAGE = ""Fix the syntax error%s inside this regex."";

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    List<SyntaxError> syntaxErrors = regexForLiterals.getSyntaxErrors();
    if (!syntaxErrors.isEmpty()) {
      reportSyntaxErrors(syntaxErrors);
    }
  }

  private void reportSyntaxErrors(List<SyntaxError> syntaxErrors) {
    // report on the first issue
    RegexSyntaxElement tree = syntaxErrors.get(0).getOffendingSyntaxElement();
    List<RegexIssueLocation> secondaries = syntaxErrors.stream()
      .map(error -> new RegexCheck.RegexIssueLocation(error.getOffendingSyntaxElement(), error.getMessage()))
      .toList();

    reportIssue(tree, secondaries);
  }

  private void reportIssue(RegexSyntaxElement tree, List<RegexIssueLocation> secondaries) {
    String msg = String.format(ERROR_MESSAGE, secondaries.size() > 1 ? ""s"" : """");
    reportIssue(tree, msg, null, secondaries);
  }

}
"
S5857,CODE_SMELL,Character classes should be preferred over reluctant quantifiers in regular expressions,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.ReluctantQuantifierFinder;

@Rule(key = ""S5857"")
public class ReluctantQuantifierCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new ReluctantQuantifierFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S5860,CODE_SMELL,Names of regular expressions named groups should be used,"package org.sonar.java.checks.regex;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.regex.RegexCheck;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.ast.BackReferenceTree;
import org.sonarsource.analyzer.commons.regex.ast.CapturingGroupTree;
import org.sonarsource.analyzer.commons.regex.ast.RegexBaseVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S5860"")
public class UnusedGroupNamesCheck extends AbstractRegexCheckTrackingMatchers {

  private static final String ISSUE_NO_GROUP_WITH_SUCH_NAME = ""There is no group named '%s' in the regular expression."";
  private static final String ISSUE_USE_NAME_INSTEAD_OF_NUMBER = ""Directly use '%s' instead of its group number."";
  private static final String ISSUE_USE_GROUPS_OR_REMOVE = ""Use the named groups of this regex or remove the names."";

  private static final String JAVA_UTIL_REGEX_MATCHER = ""java.util.regex.Matcher"";

  private static final Pattern GROUP_NUMBER_REPLACEMENT_REGEX = Pattern.compile(""(?<!\\\\)\\$(?<number>\\d++)"");
  private static final Pattern GROUP_NAME_REPLACEMENT_REGEX = Pattern.compile(""(?<!\\\\)\\$\\{(?<name>[A-Za-z][0-9A-Za-z]*+)\\}"");

  private static final List<String> NAMES_OF_METHODS_WITH_GROUP_ARGUMENT = List.of(""group"", ""start"", ""end"");

  private static final MethodMatchers MATCHER_GROUP = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(JAVA_UTIL_REGEX_MATCHER)
      .names(NAMES_OF_METHODS_WITH_GROUP_ARGUMENT.toArray(String[]::new))
      .addParametersMatcher(JAVA_LANG_STRING)
      .addParametersMatcher(""int"")
      .build(),
    MethodMatchers.create()
      .ofTypes(JAVA_UTIL_REGEX_MATCHER)
      .names(""appendReplacement"")
      .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)
      .build(),
    MethodMatchers.create()
      .ofTypes(JAVA_UTIL_REGEX_MATCHER)
      .names(""replaceAll"", ""replaceFirst"")
      .addParametersMatcher(MethodMatchers.ANY)
      .build());

  @Override
  protected MethodMatchers trackedMethodMatchers() {
    return MATCHER_GROUP;
  }

  @Override
  protected void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation, List<MethodInvocationTree> trackedMethodsCalled, boolean didEscape) {
    KnownGroupsCollector knownGroups = collectGroups(regexForLiterals);
    List<CapturingGroupTree> namedGroups = new ArrayList<>(knownGroups.groupsByName.values());
    if (trackedMethodsCalled.isEmpty() && !didEscape && !namedGroups.isEmpty() && !knownGroups.usesBackReferences) {
      List<RegexIssueLocation> secondaries = namedGroups.stream()
        .map(group -> toLocation(group, ""Named group '%s'"", g -> g.getName().get()))
        .toList();
      reportIssue(namedGroups.get(0), ISSUE_USE_GROUPS_OR_REMOVE, null, secondaries);
    }
    for (MethodInvocationTree groupInvocation : trackedMethodsCalled) {
      checkGroupUsage(groupInvocation, knownGroups);
    }
  }

  private void checkGroupUsage(MethodInvocationTree mit, KnownGroupsCollector knownGroups) {
    String methodName = ExpressionUtils.methodName(mit).name();
    if (NAMES_OF_METHODS_WITH_GROUP_ARGUMENT.contains(methodName)) {
      ExpressionTree arg0 = mit.arguments().get(0);
      if (arg0.symbolType().is(""int"")) {
        arg0.asConstant(Integer.class).ifPresent(index -> checkUsingNumberInsteadOfName(knownGroups, arg0, index, false));
      } else {
        arg0.asConstant(String.class).ifPresent(name -> checkNoSuchName(knownGroups, arg0, name));
      }
    } else {
      int argIndex = ""appendReplacement"".equals(methodName) ? 1 : 0;
      ExpressionTree arg = mit.arguments().get(argIndex);
      arg.asConstant(String.class).ifPresent(replacement -> checkUsingReplacementString(knownGroups, arg, replacement));
    }
  }

  private void checkUsingReplacementString(KnownGroupsCollector knownGroups, ExpressionTree arg, String replacement) {
    Matcher indexMatcher = GROUP_NUMBER_REPLACEMENT_REGEX.matcher(replacement);
    while (indexMatcher.find()) {
      int groupNumber = Integer.parseInt(indexMatcher.group(""number""));
      checkUsingNumberInsteadOfName(knownGroups, arg, groupNumber, true);
    }
    Matcher nameMatcher = GROUP_NAME_REPLACEMENT_REGEX.matcher(replacement);
    while (nameMatcher.find()) {
      checkNoSuchName(knownGroups, arg, nameMatcher.group(""name""));
    }
  }

  private void checkUsingNumberInsteadOfName(KnownGroupsCollector knownGroups, ExpressionTree arg0, int groupNumber, boolean dollarReference) {
    CapturingGroupTree capturingGroupTree = knownGroups.groupsByNumber.get(groupNumber);
    if (capturingGroupTree == null) {
      return;
    }
    String groupName = capturingGroupTree.getName().map(name -> dollarReference ? (""${"" + name + ""}"") : name).orElse(""?"");
    String message = String.format(ISSUE_USE_NAME_INSTEAD_OF_NUMBER, groupName);
    RegexIssueLocation secondary = toLocation(capturingGroupTree, ""Group %d"", g -> groupNumber);
    reportIssue(arg0, message, null, Collections.singletonList(secondary));
  }

  private void checkNoSuchName(KnownGroupsCollector knownGroups, ExpressionTree arg0, String groupName) {
    if (!knownGroups.groupsByName.containsKey(groupName)) {
      String message = String.format(ISSUE_NO_GROUP_WITH_SUCH_NAME, groupName);
      List<RegexIssueLocation> secondaries = knownGroups.groupsByName.values()
        .stream()
        .map(group -> toLocation(group, ""Named group '%s'"", g -> g.getName().get()))
        .toList();
      reportIssue(arg0, message, null, secondaries);
    }
  }

  private static RegexCheck.RegexIssueLocation toLocation(CapturingGroupTree group, String message, Function<CapturingGroupTree, Object> arg) {
    return new RegexCheck.RegexIssueLocation(group, String.format(message, arg.apply(group)));
  }

  private static KnownGroupsCollector collectGroups(RegexParseResult regex) {
    KnownGroupsCollector visitor = new KnownGroupsCollector();
    visitor.visit(regex);
    return visitor;
  }

  private static class KnownGroupsCollector extends RegexBaseVisitor {

    private final Map<String, CapturingGroupTree> groupsByName = new HashMap<>();
    private final Map<Integer, CapturingGroupTree> groupsByNumber = new HashMap<>();
    private boolean usesBackReferences = false;

    @Override
    public void visitCapturingGroup(CapturingGroupTree tree) {
      tree.getName().ifPresent(name -> {
        groupsByName.put(name, tree);
        groupsByNumber.put(tree.getGroupNumber(), tree);
      });
      super.visitCapturingGroup(tree);
    }

    @Override
    public void visitBackReference(BackReferenceTree tree) {
      usesBackReferences = true;
      super.visitBackReference(tree);
    }
  }
}
"
S5863,BUG,Assertions should not compare an object to itself,"package org.sonar.java.checks.tests;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.checks.helpers.UnitTestUtils;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext.Location;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.model.ExpressionUtils.methodName;

@Rule(key = ""S5863"")
public class AssertionCompareToSelfCheck extends IssuableSubscriptionVisitor {

  private static final String ASSERT_ARRAY_EQUALS = ""assertArrayEquals"";
  private static final String ASSERT_EQUALS = ""assertEquals"";
  private static final String IS_EQUAL_TO = ""isEqualTo"";

  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(""org.assertj.core.api.Assertions"",
        ""org.assertj.core.api.AssertionsForInterfaceTypes"",
        ""org.assertj.core.api.AssertionsForClassTypes"")
      .names(""assertThat"", ""assertThatObject"")
      .addParametersMatcher(MethodMatchers.ANY)
      .build(),
    MethodMatchers.create()
      .ofTypes(""org.fest.assertions.Assertions"")
      .names(""assertThat"")
      .addParametersMatcher(MethodMatchers.ANY)
      .build());

  private static final MethodMatchers JUNIT5_ASSERTIONS = MethodMatchers.create()
    .ofTypes(""org.junit.jupiter.api.Assertions"")
    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS, ""assertIterableEquals"", ""assertLinesMatch"")
    .addParametersMatcher(parameters -> parameters.size() >= 2)
    .build();

  private static final MethodMatchers JUNIT4_ASSERTIONS_WITHOUT_MESSAGE = MethodMatchers.create()
    .ofTypes(""org.junit.Assert"")
    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)
    .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)
    .build();

  private static final MethodMatchers JUNIT4_ASSERTIONS_WITH_MESSAGE = MethodMatchers.create()
    .ofTypes(""org.junit.Assert"")
    .names(ASSERT_ARRAY_EQUALS, ASSERT_EQUALS)
    .addParametersMatcher(""java.lang.String"", MethodMatchers.ANY, MethodMatchers.ANY)
    .build();

  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_MESSAGE_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(""org.assertj.core.api.AbstractAssert"")
      .names(""as"", ""describedAs"", ""withFailMessage"", ""overridingErrorMessage"").withAnyParameters().build(),
    MethodMatchers.create()
      .ofSubTypes(""org.fest.assertions.GenericAssert"")
      .names(""as"", ""describedAs"", ""overridingErrorMessage"").withAnyParameters().build());

  private static final MethodMatchers ASSERTJ_AND_FEST_ASSERT_PREDICATES = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(""org.assertj.core.api.AbstractAssert"")
      .names(""contains"", ""containsAll"", ""containsAllEntriesOf"", ""containsAnyElementOf"", ""containsAnyOf"",
        ""containsExactly"", ""containsExactlyElementsOf"", ""containsExactlyEntriesOf"", ""containsExactlyInAnyOrder"",
        ""containsExactlyInAnyOrderEntriesOf"", ""containsIgnoringCase"", ""containsOnly"", ""containsOnlyElementsOf"",
        ""containsSequence"", ""containsSubsequence"", ""doesNotContain"", ""endsWith"",
        ""hasSameClassAs"", ""hasSameElementsAs"", ""hasSameHashCodeAs"", ""hasSameSizeAs"", IS_EQUAL_TO,
        ""isEqualToIgnoringCase"", ""isSameAs"", ""startsWith"")
      .addParametersMatcher(MethodMatchers.ANY)
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""org.fest.assertions.GenericAssert"")
      .names(""contains"", ""containsExactly"", ""containsIgnoringCase"", ""containsOnly"", ""doesNotContain"", ""endsWith"",
        IS_EQUAL_TO, ""isEqualToIgnoringCase"", ""isSameAs"", ""startsWith"")
      .addParametersMatcher(MethodMatchers.ANY)
      .build());

  private static final Set<String> EQUALS_HASH_CODE_METHODS = SetUtils.immutableSetOf(ASSERT_EQUALS, IS_EQUAL_TO, ""hasSameHashCodeAs"");

  private static final String MESSAGE = ""Replace this assertion to not have the same actual and expected expression."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;
    if (JUNIT4_ASSERTIONS_WITH_MESSAGE.matches(mit)) {
      checkActualAndExpectedExpression(methodName(mit).name(), mit.arguments().get(2), mit.arguments().get(1));
    } else if (JUNIT4_ASSERTIONS_WITHOUT_MESSAGE.matches(mit) || JUNIT5_ASSERTIONS.matches(mit)) {
      checkActualAndExpectedExpression(methodName(mit).name(), mit.arguments().get(1), mit.arguments().get(0));
    } else if (ASSERTJ_AND_FEST_ASSERT_SUBJECT_METHODS.matches(mit)) {
      ExpressionTree actualExpression = mit.arguments().get(0);
      consecutiveMethodIgnoringMessageDescription(mit)
        .filter(predicate -> predicate.arguments().size() == 1 && ASSERTJ_AND_FEST_ASSERT_PREDICATES.matches(predicate))
        .ifPresent(predicate -> checkActualAndExpectedExpression(methodName(predicate).name(), actualExpression, predicate.arguments().get(0)));
    }
  }

  private void checkActualAndExpectedExpression(String predicateMethodName, ExpressionTree actualExpression, ExpressionTree expectedExpression) {
    if (ExpressionsHelper.alwaysReturnSameValue(actualExpression) &&
      SyntacticEquivalence.areEquivalent(actualExpression, expectedExpression) &&
      !isLegitimateSelfComparison(predicateMethodName, actualExpression)) {
      List<Location> secondaryLocations = Collections.singletonList(new Location(""actual"", actualExpression));
      reportIssue(expectedExpression, MESSAGE, secondaryLocations, null);
    }
  }

  private static boolean isLegitimateSelfComparison(String comparisonMethodName, ExpressionTree actualExpression) {
    // In a unit test validating ""equals"" and ""hashCode"" methods, it's legitimate to compare an object to itself.
    // In other kinds of tests, it's a bug. But it's complicated to know if a unit test is about validating the
    // ""equals"" method or not. The following trade-off allows the self-comparison of an object if the unit test
    // name contains a keyword like ""equals"", ""hash_code"", ...
    Type actualExpressionType = actualExpression.symbolType();
    return EQUALS_HASH_CODE_METHODS.contains(comparisonMethodName) &&
      !isPrimitiveOrNull(actualExpressionType) &&
      UnitTestUtils.isInUnitTestRelatedToObjectMethods(actualExpression);
  }

  private static boolean isPrimitiveOrNull(Type actualExpressionType) {
    return actualExpressionType.isPrimitive() || ""null"".equals(actualExpressionType.symbol().name());
  }

  private static Optional<MethodInvocationTree> consecutiveMethodIgnoringMessageDescription(MethodInvocationTree mit) {
    Optional<MethodInvocationTree> consecutiveMethod = MethodTreeUtils.consecutiveMethodInvocation(mit);
    if (consecutiveMethod.isPresent() && ASSERTJ_AND_FEST_ASSERT_MESSAGE_METHODS.matches(consecutiveMethod.get())) {
      return consecutiveMethodIgnoringMessageDescription(consecutiveMethod.get());
    }
    return consecutiveMethod;
  }

}
"
S5866,BUG,"Case insensitive Unicode regular expressions should enable the ""UNICODE_CASE"" flag","package org.sonar.java.checks.regex;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.ast.CharacterTree;
import org.sonarsource.analyzer.commons.regex.ast.FlagSet;
import org.sonarsource.analyzer.commons.regex.ast.SourceCharacter;
import org.sonarsource.analyzer.commons.regex.ast.RegexBaseVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5866"")
public class UnicodeCaseCheck extends AbstractRegexCheck {

  private static final String MESSAGE = ""Also use %s to correctly handle non-ASCII letters."";

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new Visitor(methodInvocationOrAnnotation).visit(regexForLiterals);
  }

  private class Visitor extends RegexBaseVisitor {

    final Set<SourceCharacter> problematicFlags = new HashSet<>();

    boolean problematicFlagSetOutsideOfRegex = false;

    final ExpressionTree methodInvocationOrAnnotation;

    Visitor(ExpressionTree methodInvocationOrAnnotation) {
      this.methodInvocationOrAnnotation = methodInvocationOrAnnotation;
    }

    @Override
    public void visitCharacter(CharacterTree tree) {
      if (isProblematic(tree.activeFlags(), tree.codePointOrUnit())) {
        SourceCharacter character = tree.activeFlags().getJavaCharacterForFlag(Pattern.CASE_INSENSITIVE);
        if (character == null) {
          problematicFlagSetOutsideOfRegex = true;
        } else {
          problematicFlags.add(character);
        }
      }
    }

    @Override
    protected void after(RegexParseResult regexParseResult) {
      if (problematicFlagSetOutsideOfRegex) {
        boolean isAnnotation = methodInvocationOrAnnotation.is(Tree.Kind.ANNOTATION);
        String flagName = isAnnotation ? ""\""Flag.UNICODE_CASE\"""" : ""\""Pattern.UNICODE_CASE\"""";
        getFlagsTree(methodInvocationOrAnnotation).ifPresent( flagsTree ->
          reportIssue(flagsTree, String.format(MESSAGE, flagName))
        );
      }
      for (SourceCharacter flag : problematicFlags) {
        reportIssue(flag, String.format(MESSAGE, ""the \""u\"" flag""), null, Collections.emptyList());
      }
    }

    boolean isNonAsciiLetter(int codePointOrUnit) {
      return codePointOrUnit > 127 && Character.isLetter(codePointOrUnit);
    }

    boolean isProblematic(FlagSet activeFlags, int codePointOrUnit) {
      return activeFlags.contains(Pattern.CASE_INSENSITIVE) && !activeFlags.contains(Pattern.UNICODE_CASE) && isNonAsciiLetter(codePointOrUnit);
    }
  }

}
"
S5867,CODE_SMELL,Unicode-aware versions of character classes should be preferred,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.java.regex.RegexCheck;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.UnicodeUnawareCharClassFinder;

@Rule(key = ""S5867"")
public class UnicodeAwareCharClassesCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new UnicodeUnawareCharClassFinder(this::reportIssueFromCommons, (message, cost, secondaries) -> {
      String flagName = methodInvocationOrAnnotation.is(Tree.Kind.ANNOTATION) ? ""(?U)"" : ""UNICODE_CHARACTER_CLASS"";
      reportIssue(methodOrAnnotationName(methodInvocationOrAnnotation),
        message.replace(""\""u\"""", String.format(""\""%s\"""", flagName)),
        cost,
        secondaries.stream()
          .map(RegexCheck.RegexIssueLocation::fromCommonsRegexIssueLocation)
          .toList());
    }).visit(regexForLiterals);
  }

}
"
S5868,BUG,Unicode Grapheme Clusters should be avoided inside regex character classes,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.GraphemeInClassFinder;

@Rule(key = ""S5868"")
public class GraphemeClustersInClassesCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new GraphemeInClassFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S5869,CODE_SMELL,Character classes in regular expressions should not contain the same character twice,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.DuplicatesInCharacterClassFinder;

@Rule(key = ""S5869"")
public class DuplicatesInCharacterClassCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new DuplicatesInCharacterClassFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S5876,VULNERABILITY,A new session should be created during user authentication,"package org.sonar.java.checks.spring;


import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;

@Rule(key = ""S5876"")
public class SpringSessionFixationCheck extends AbstractMethodDetection {

  private static final String ISSUE_MSG = ""Create a new session during user authentication to prevent session fixation attacks."";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurer$SessionFixationConfigurer"")
      .names(""none"")
      .addWithoutParametersMatcher()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree methodInvocation) {
    reportIssue(ExpressionUtils.methodName(methodInvocation), ISSUE_MSG);
  }

  @Override
  protected void onMethodReferenceFound(MethodReferenceTree methodReferenceTree) {
    reportIssue(methodReferenceTree.method(), ISSUE_MSG);
  }

}
"
S5917,BUG,DateTimeFormatters should not use mismatched year and week numbers,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5917"")
public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {
  private static final String TEMPORAL_FIELD_TYPE = ""java.time.temporal.TemporalField"";
  private static final String INT_TYPE = ""int"";

  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()
    .ofTypes(""java.time.format.DateTimeFormatterBuilder"")
    .names(""appendValue"")
    .addParametersMatcher(TEMPORAL_FIELD_TYPE)
    .addParametersMatcher(TEMPORAL_FIELD_TYPE, INT_TYPE)
    .addParametersMatcher(TEMPORAL_FIELD_TYPE, INT_TYPE, INT_TYPE, ""java.time.format.SignStyle"")
    .build();

  private static final String CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE = ""Change this year format to use the week-based year instead"" +
    "" (or the week format to Chronofield.ALIGNED_WEEK_OF_YEAR)."";
  private static final String CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE = ""Change this year format to use ChronoField.YEAR instead"" +
    "" (or the week format to WeekFields.ISO.weekOfWeekBasedYear())."";
  private static final String SECONDARY_LOCATION_MESSAGE = ""Week format is inconsistent with year."";

  private int depth = 0;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree invocation = (MethodInvocationTree) tree;
    if (APPEND_VALUE_MATCHER.matches(invocation)) {
      if (depth == 0) {
        ChainedInvocationVisitor visitor = new ChainedInvocationVisitor();
        invocation.accept(visitor);
        if (visitor.usesWeek && visitor.usesYear) {
          if (visitor.usesWeekBasedYear && !visitor.usesWeekOfWeekBasedYear) {
            reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE, visitor.secondaries, null);
          } else if (!visitor.usesWeekBasedYear && visitor.usesWeekOfWeekBasedYear) {
            reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE, visitor.secondaries, null);
          }
        }
      }
      depth++;
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (APPEND_VALUE_MATCHER.matches((MethodInvocationTree) tree)) {
      depth--;
    }
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    depth = 0;
  }


  private static class ChainedInvocationVisitor extends BaseTreeVisitor {
    private static final MethodMatchers WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()
      .ofTypes(""java.time.temporal.WeekFields"")
      .names(""weekBasedYear"")
      .addWithoutParametersMatcher()
      .build();

    private static final MethodMatchers WEEK_OF_WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()
      .ofTypes(""java.time.temporal.WeekFields"")
      .names(""weekOfWeekBasedYear"")
      .addWithoutParametersMatcher()
      .build();

    private boolean usesWeek = false;
    private boolean usesWeekOfWeekBasedYear = false;
    private boolean usesYear = false;
    private boolean usesWeekBasedYear = false;
    private final List<JavaFileScannerContext.Location> secondaries = new ArrayList<>();
    private ExpressionTree primary = null;

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      inspectCall(tree);
      ExpressionTree expressionTree = tree.methodSelect();
      expressionTree.accept(this);
    }

    private void inspectCall(MethodInvocationTree invocation) {
      if (!APPEND_VALUE_MATCHER.matches(invocation)) {
        return;
      }
      ExpressionTree argument = invocation.arguments().get(0);
      if (refersToYear(argument)) {
        usesYear = true;
        if (primary == null) {
          primary = argument;
        }
        boolean isWeekBasedYearArgument = isWeekBasedYearUsed(argument);
        usesWeekBasedYear |= isWeekBasedYearArgument;
        if (isWeekBasedYearArgument) {
          primary = argument;
        }
      } else if (refersToWeek(argument)) {
        usesWeek = true;
        secondaries.add(new JavaFileScannerContext.Location(SECONDARY_LOCATION_MESSAGE, argument));
        usesWeekOfWeekBasedYear |= isWeekOfWeekBasedYearUsed(argument);
      }
    }

    private static boolean refersToWeek(ExpressionTree argument) {
      return isChronoFieldWeek(argument) || isWeekOfWeekBasedYearUsed(argument);
    }

    private static boolean isWeekOfWeekBasedYearUsed(ExpressionTree argument) {
      if (argument.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree call = (MethodInvocationTree) argument;
        return WEEK_OF_WEEK_BASED_YEAR_MATCHER.matches(call);
      }
      return false;
    }

    private static boolean isChronoFieldWeek(ExpressionTree argument) {
      if (!argument.is(Tree.Kind.MEMBER_SELECT)) {
        return false;
      }
      MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;
      if (!select.symbolType().is(""java.time.temporal.ChronoField"")) {
        return false;
      }
      return ""ALIGNED_WEEK_OF_YEAR"".equals(select.identifier().name());
    }

    private static boolean refersToYear(ExpressionTree argument) {
      return isChronoFieldYear(argument) || isWeekBasedYearUsed(argument);
    }

    private static boolean isWeekBasedYearUsed(ExpressionTree argument) {
      if (argument.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree call = (MethodInvocationTree) argument;
        return WEEK_BASED_YEAR_MATCHER.matches(call);
      }
      return false;
    }

    private static boolean isChronoFieldYear(ExpressionTree argument) {
      if (argument.is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;
        String name = select.identifier().name();
        return select.symbolType().is(""java.time.temporal.ChronoField"") && (""YEAR"".equals(name) || ""YEAR_OF_ERA"".equals(name));
      }
      return false;
    }
  }
}
"
S5958,CODE_SMELL,"AssertJ ""assertThatThrownBy"" should not be used alone","package org.sonar.java.checks.tests;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5958"")
public class AssertThatThrownByAloneCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""org.assertj.core.api.Assertions"")
      .names(""assertThatThrownBy"")
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (mit.parent().is(Tree.Kind.EXPRESSION_STATEMENT)) {
      reportIssue(ExpressionUtils.methodName(mit), ""Test further the exception raised by this assertThatThrownBy call."");
    }
  }

}
"
S5960,BUG,Assertions should not be used in production code,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.UnitTestUtils;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaFileScannerContext.Location;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.PackageDeclarationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5960"")
public class AssertionsInProductionCodeCheck extends AbstractMethodDetection {

  private static final Pattern TEST_PACKAGE_REGEX = Pattern.compile(""test|junit|assert"");
  private final List<Tree> assertions = new ArrayList<>();
  private boolean packageNameNotRelatedToTests = true;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.PACKAGE);
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return UnitTestUtils.COMMON_ASSERTION_MATCHER;
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.PACKAGE)) {
      String packageName = ExpressionsHelper.concatenate(((PackageDeclarationTree) tree).packageName());
      packageNameNotRelatedToTests = !TEST_PACKAGE_REGEX.matcher(packageName).find();
    }
    if (packageNameNotRelatedToTests) {
      super.visitNode(tree);
    }
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    assertions.add(mit);
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    super.setContext(context);
    assertions.clear();
    packageNameNotRelatedToTests = true;
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    if (!assertions.isEmpty()) {
      final Tree primaryLocation = assertions.get(0);
      List<Location> secondaryLocations = assertions.stream()
        .skip(1)
        .map(expr -> new Location(""Assertion"", expr))
        .toList();
      reportIssue(primaryLocation, ""Remove this assertion from production code."", secondaryLocations, null);
    }
    assertions.clear();
    super.leaveFile(context);
  }

}
"
S5961,CODE_SMELL,Test methods should not contain too many assertions,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodReferenceTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.UnitTestUtils.ASSERTION_INVOCATION_MATCHERS;
import static org.sonar.java.checks.helpers.UnitTestUtils.isUnitTest;
import static org.sonar.java.checks.helpers.UnitTestUtils.methodNameMatchesAssertionMethodPattern;
import static org.sonar.java.model.ExpressionUtils.methodName;

@Rule(key = ""S5961"")
public class TooManyAssertionsCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_MAX = 25;

  @RuleProperty(key = ""MaximumAssertionNumber"", description = ""The maximum authorized number of assertions in a test method"", defaultValue = """" + DEFAULT_MAX)
  public int maximum = DEFAULT_MAX;

  private final Map<Symbol, List<Tree>> assertionsInMethod = new HashMap<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;
    if (ModifiersUtils.hasModifier(methodTree.modifiers(), Modifier.ABSTRACT)) {
      return;
    }

    if (isUnitTest(methodTree)) {
      List<Tree> assertionsTree = collectAssertionsInMethod(methodTree.symbol());
      int assertionsSize = assertionsTree.size();
      if (assertionsSize > maximum) {
        List<JavaFileScannerContext.Location> locations = assertionsTree.stream()
          .map(assertionTree -> new JavaFileScannerContext.Location(""Assertion"", assertionTree))
          .toList();

        reportIssue(methodTree.simpleName(),
          String.format(""Refactor this method to reduce the number of assertions from %d to less than %d."", assertionsSize, maximum),
          locations,
          null);
      }
    }
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    assertionsInMethod.clear();
    super.leaveFile(context);
  }

  private List<Tree> collectAssertionsInMethod(Symbol symbol) {
    if (!assertionsInMethod.containsKey(symbol)) {
      // can not be rewritten with map.computeIfAbsent() because of concurrent modification
      assertionsInMethod.put(symbol, Collections.emptyList());
      Tree declaration = symbol.declaration();
      if (declaration != null) {
        AssertionsCounterVisitor assertionsCounterVisitor = new AssertionsCounterVisitor();
        declaration.accept(assertionsCounterVisitor);
        assertionsInMethod.put(symbol, new ArrayList<>(assertionsCounterVisitor.assertions));
      }
    }

    return assertionsInMethod.get(symbol);
  }

  private class AssertionsCounterVisitor extends BaseTreeVisitor {

    private final Set<Tree> assertions = new LinkedHashSet<>();
    private final Set<Tree> chainedAssertions = new LinkedHashSet<>();

    @Override
    public void visitMethodInvocation(MethodInvocationTree mit) {
      super.visitMethodInvocation(mit);
      if (isAssertion(methodName(mit), mit.methodSymbol())) {
        ExpressionTree methodSelect = mit.methodSelect();
        if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
          ExpressionTree expression = ((MemberSelectExpressionTree) methodSelect).expression();
          if (assertions.contains(expression) || chainedAssertions.contains(expression)) {
            chainedAssertions.add(mit);
            return;
          }
        }
        assertions.add(mit);
      }
    }

    @Override
    public void visitMethodReference(MethodReferenceTree methodReferenceTree) {
      super.visitMethodReference(methodReferenceTree);
      if (isAssertion(methodReferenceTree.method(), methodReferenceTree.method().symbol())) {
        assertions.add(methodReferenceTree);
      }
    }

    private boolean isAssertion(IdentifierTree method, Symbol methodSymbol) {
      return methodNameMatchesAssertionMethodPattern(method.name(), methodSymbol)
        || ASSERTION_INVOCATION_MATCHERS.matches(methodSymbol)
        || !collectAssertionsInMethod(methodSymbol).isEmpty();
    }
  }
}
"
S5967,BUG,Tests method should not be annotated with competing annotations,"package org.sonar.java.checks.tests;

import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Collections;
import java.util.List;
import java.util.Set;

@Rule(key = ""S5967"")
public class JUnitCompatibleAnnotationsCheck extends IssuableSubscriptionVisitor {

  private static final Set<String> ANNOTATIONS = SetUtils.immutableSetOf(
    ""org.junit.jupiter.api.Test"",
    ""org.junit.jupiter.api.RepeatedTest"",
    ""org.junit.jupiter.api.TestFactory"",
    ""org.junit.jupiter.api.TestTemplate"",
    ""org.junit.jupiter.params.ParameterizedTest"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree method = (MethodTree) tree;
    List<AnnotationTree> annotationTrees = method.modifiers().annotations();

    List<JavaFileScannerContext.Location> locations = annotationTrees.stream()
      .filter(annotation -> ANNOTATIONS.contains(annotation.annotationType().symbolType().fullyQualifiedName()))
      .map(annotationTree -> new JavaFileScannerContext.Location(""Incompatible annotation"", annotationTree))
      .toList();

    if (locations.size() > 1) {
      reportIssue(method.simpleName(), ""Remove one of these conflicting annotations."", locations, null);
    }
  }
}
"
S5969,CODE_SMELL,Mocking all non-private methods of a class should be avoided,"package org.sonar.java.checks.tests;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5969"")
public class MockingAllMethodsCheck extends AbstractMethodDetection {

  private final Map<Symbol, Set<Symbol>> mockedMethodsPerObject = new HashMap<>();
  private final Map<Symbol, MethodInvocationTree> whenCalls = new HashMap<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.METHOD);
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create().ofTypes(""org.mockito.Mockito"").names(""when"").withAnyParameters().build();
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      mockedMethodsPerObject.clear();
      whenCalls.clear();
    } else {
      super.visitNode(tree);
    }
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree argument = mit.arguments().get(0);
    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mockedMethodCall = (MethodInvocationTree) argument;
      ExpressionTree methodSelect = mockedMethodCall.methodSelect();
      if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree mockedMethod = (MemberSelectExpressionTree) methodSelect;
        ExpressionTree object = mockedMethod.expression();
        if (object.is(Tree.Kind.IDENTIFIER)) {
          Symbol objectSymbol = ((IdentifierTree) object).symbol();
          Symbol method = mockedMethod.identifier().symbol();
          mockedMethodsPerObject.computeIfAbsent(objectSymbol, key -> new HashSet<>()).add(method);
          whenCalls.put(method, mit);
        }
      }
    }
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.METHOD)) {
      for (Map.Entry<Symbol, Set<Symbol>> entry : mockedMethodsPerObject.entrySet()) {
        Symbol mockedObject = entry.getKey();
        Tree declaration = mockedObject.declaration();
        if (declaration != null) {
          Set<Symbol> mockedMethods = entry.getValue();
          Set<Symbol> declaredMethods = mockedObject.type().symbol().memberSymbols().stream()
            .filter(MockingAllMethodsCheck::isNonPrivateMethod)
            .collect(Collectors.toSet());
          if (declaredMethods.size() > 1 && mockedMethods.containsAll(declaredMethods)) {
            List<JavaFileScannerContext.Location> secondaries = mockedMethods.stream()
              .map(method -> new JavaFileScannerContext.Location(""Method mocked here"", whenCalls.get(method)))
              .toList();
            reportIssue(declaration, ""Refactor this test instead of mocking every non-private member of this class."", secondaries, null);
          }
        }
      }
    }
  }

  private static boolean isNonPrivateMethod(Symbol symbol) {
    Tree declaration = symbol.declaration();
    return symbol.isMethodSymbol() && !symbol.isPrivate() && declaration != null
      && !declaration.is(Tree.Kind.CONSTRUCTOR);
  }
}
"
S5970,CODE_SMELL,Spring's ModelAndViewAssert assertions should be used instead of other assertions,"package org.sonar.java.checks.tests;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.MethodTreeUtils.subsequentMethodInvocation;
import static org.sonar.plugins.java.api.semantic.MethodMatchers.ANY;

@Rule(key = ""S5970"")
public class SpringAssertionsSimplificationCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE_TEMPLATE = ""Replace this assertion by \""%s\""."";

  private static final String[] ASSERTION_CLASSES = {
    // JUnit4
    ""org.junit.Assert"",
    ""junit.framework.TestCase"",
    // JUnit4 (deprecated)
    ""junit.framework.Assert"",
    // JUnit5
    ""org.junit.jupiter.api.Assertions""
  };

  private static final String[] ASSERT_J_AND_FEST_ASSERT = {""org.assertj.core.api.AbstractAssert"", ""org.fest.assertions.GenericAssert""};

  private static final MethodMatchers ASSERT_EQUALS_MATCHER = MethodMatchers.create()
    .ofTypes(ASSERTION_CLASSES)
    .names(""assertEquals"")
    .addParametersMatcher(ANY, ANY)
    .build();

  private static final MethodMatchers ASSERT_TRUE_FALSE_EQUALS_MATCHER = MethodMatchers.create()
    .ofTypes(ASSERTION_CLASSES)
    .names(""assertEquals"", ""assertTrue"", ""assertFalse"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers MODEL_VIEW_GET_VIEW_NAME = MethodMatchers.create()
    .ofTypes(""org.springframework.web.servlet.ModelAndView"")
    .names(""getViewName"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers MODEL_MAP_GET = MethodMatchers.create()
    .ofTypes(""org.springframework.ui.ModelMap"")
    .names(""get"")
    .addParametersMatcher(""java.lang.Object"")
    .build();

  private static final MethodMatchers ASSERT_THAT = MethodMatchers.create()
    .ofTypes(""org.assertj.core.api.Assertions"", ""org.fest.assertions.Assertions"")
    .names(""assertThat"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers IS_EQUAL_TO = MethodMatchers.create()
    .ofSubTypes(ASSERT_J_AND_FEST_ASSERT)
    .names(""isEqualTo"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers IS_EQUAL_TO_IS_FALSE_IS_TRUE = MethodMatchers.create()
    .ofSubTypes(ASSERT_J_AND_FEST_ASSERT)
    .names(""isEqualTo"", ""isTrue"", ""isFalse"")
    .withAnyParameters()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;
    if (MODEL_VIEW_GET_VIEW_NAME.matches(mit)) {
      getNestingCall(tree).ifPresent(call -> {
          if (ASSERT_EQUALS_MATCHER.matches(call) ||
            (ASSERT_THAT.matches(call) && subsequentMethodInvocation(call, IS_EQUAL_TO).isPresent())) {
            reportIssue(ExpressionUtils.methodName(call), String.format(MESSAGE_TEMPLATE, ""ModelAndViewAssert.assertViewName""));
          }
        }
      );
    } else if (MODEL_MAP_GET.matches(mit)) {
      getNestingCall(tree).ifPresent(call -> {
        if (ASSERT_TRUE_FALSE_EQUALS_MATCHER.matches(call) ||
          (ASSERT_THAT.matches(call) && subsequentMethodInvocation(call, IS_EQUAL_TO_IS_FALSE_IS_TRUE).isPresent())) {
          reportIssue(ExpressionUtils.methodName(call), String.format(MESSAGE_TEMPLATE, ""ModelAndViewAssert.assertModelAttributeValue""));
        }
      });
    }
  }

  private static Optional<MethodInvocationTree> getNestingCall(Tree nestedTree) {
    Tree parent = nestedTree.parent();
    // This pattern should be used with care, since it is not efficient and can hit performance.
    // It is acceptable in this case though, since we will call this method only when facing Spring methods and
    // situation that will hardly ever occur compared to common assertions.
    while (parent != null && !parent.is(Tree.Kind.METHOD)) {
      if (parent.is(Tree.Kind.METHOD_INVOCATION)) {
        return Optional.of((MethodInvocationTree) parent);
      }
      parent = parent.parent();
    }
    return Optional.empty();
  }

}
"
S5973,CODE_SMELL,Tests should be stable,"package org.sonar.java.checks.tests;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5973"")
public class TestsStabilityCheck extends IssuableSubscriptionVisitor {

  private static final String ANNOTATION = ""org.testng.annotations.Test"";
  private static final String SUCCESS_PERCENTAGE_NAME = ""successPercentage"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;

    List<AnnotationTree> annotations = methodTree.modifiers().annotations();
    Optional<Arguments> arguments = annotations.stream()
      .filter(annotationTree -> annotationTree.symbolType().is(ANNOTATION))
      .map(AnnotationTree::arguments)
      .findFirst();

    if (arguments.isPresent()) {
      for (ExpressionTree argument : arguments.get()) {
        if (argument.is(Tree.Kind.ASSIGNMENT)) {
          AssignmentExpressionTree assignmentTree = (AssignmentExpressionTree) argument;
          IdentifierTree nameTree = (IdentifierTree) assignmentTree.variable();
          if (nameTree.name().equals(SUCCESS_PERCENTAGE_NAME) ) {
            reportIssue(argument, ""Make this test stable and remove this \""successPercentage\"" argument."");
          }
        }
      }
    }
  }
}
"
S5976,CODE_SMELL,Similar tests should be grouped in a single Parameterized test,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.BiPredicate;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.JavaTree;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;

import static java.util.Arrays.asList;

@Rule(key = ""S5976"")
public class ParameterizedTestCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Replace these %d tests with a single Parameterized one."";

  private static final Set<String> TEST_ANNOTATIONS = new HashSet<>(asList(
    ""org.junit.Test"",
    ""org.junit.jupiter.api.Test"",
    ""org.testng.annotations.Test""));

  private static final int MIN_SIMILAR_METHODS = 3;
  private static final int MIN_NUMBER_STATEMENTS = 2;
  private static final int MAX_NUMBER_PARAMETER = 3;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    List<MethodTree> methods = classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .filter(ParameterizedTestCheck::isParametrizedCandidate)
      .toList();
    if (methods.size() < MIN_SIMILAR_METHODS) {
      return;
    }

    Set<MethodTree> handled = new HashSet<>();
    for (int i = 0; i < methods.size(); i++) {
      MethodTree method = methods.get(i);
      if (handled.contains(method)) {
        continue;
      }
      List<StatementTree> methodBody = method.block().body();
      // In addition to filtering literals, we want to count the number of differences since they will represent the number of parameter
      // that would be required to transform the tests to a single parametrized one.
      CollectAndIgnoreLiterals collectAndIgnoreLiterals = new CollectAndIgnoreLiterals();

      List<MethodTree> equivalentMethods = new ArrayList<>();

      for (int j = i + 1; j < methods.size(); j++) {
        MethodTree otherMethod = methods.get(j);
        if (!handled.contains(otherMethod)) {
          boolean areEquivalent = SyntacticEquivalence.areEquivalent(methodBody, otherMethod.block().body(), collectAndIgnoreLiterals);
          if (areEquivalent) {
            // If methods where not equivalent, we don't want to pollute the set of node to parameterize.
            equivalentMethods.add(otherMethod);
            collectAndIgnoreLiterals.finishCollect();
          }
          collectAndIgnoreLiterals.clearCurrentNodes();
        }
      }

      reportIfIssue(handled, method, collectAndIgnoreLiterals, equivalentMethods);
    }
  }

  private void reportIfIssue(Set<MethodTree> handled, MethodTree method, CollectAndIgnoreLiterals collectAndIgnoreLiterals, List<MethodTree> equivalentMethods) {
    if (equivalentMethods.size() + 1 >= MIN_SIMILAR_METHODS) {
      handled.addAll(equivalentMethods);

      int nParameters = collectAndIgnoreLiterals.nodeToParametrize.size();
      if (nParameters <= MAX_NUMBER_PARAMETER
        && method.block().body().size() > nParameters) {
        // We don't report an issue if the change would result in too many parameters.
        // or if no statement would be duplicated.
        // We still add it to ""handled"" to not report a subset of candidate methods.
        List<JavaFileScannerContext.Location> secondaries = collectAndIgnoreLiterals.nodeToParametrize.stream().map(param ->
          new JavaFileScannerContext.Location(""Value to parameterize"", param)).collect(Collectors.toCollection(ArrayList::new));

        equivalentMethods.stream().map(equivalentMethod ->
          new JavaFileScannerContext.Location(""Related test"", equivalentMethod.simpleName()))
          .forEach(secondaries::add);

        reportIssue(method.simpleName(), String.format(MESSAGE, equivalentMethods.size() + 1), secondaries, null);
      }
    }
  }

  private static boolean isParametrizedCandidate(MethodTree methodTree) {
    BlockTree block = methodTree.block();
    SymbolMetadata symbolMetadata = methodTree.symbol().metadata();
    return block != null &&
      block.body().size() >= MIN_NUMBER_STATEMENTS &&
      TEST_ANNOTATIONS.stream().anyMatch(symbolMetadata::isAnnotatedWith);
  }

  static class CollectAndIgnoreLiterals implements BiPredicate<JavaTree, JavaTree> {

    Set<JavaTree> nodeToParametrize = new HashSet<>();
    private final Set<JavaTree> currentNodeToParameterize = new HashSet<>();

    @Override
    public boolean test(JavaTree leftNode, JavaTree rightNode) {
      if (isCompatibleTypes(leftNode, rightNode)) {
        if (!SyntacticEquivalence.areEquivalent(leftNode, rightNode)) {
          // If the two literals are not equivalent, it means that we will have to create a parameter for it.
          currentNodeToParameterize.add(leftNode);
        }
        return true;
      }
      return false;
    }

    public void finishCollect() {
      nodeToParametrize.addAll(currentNodeToParameterize);
    }

    public void clearCurrentNodes() {
      currentNodeToParameterize.clear();
    }

    private static boolean isCompatibleTypes(@Nullable JavaTree leftNode, @Nullable JavaTree rightNode) {
      return leftNode instanceof LiteralTree
        && rightNode instanceof LiteralTree
        && (leftNode.is(rightNode.kind()) ||
        (leftNode.is(Tree.Kind.STRING_LITERAL, Tree.Kind.NULL_LITERAL) &&
          rightNode.is(Tree.Kind.STRING_LITERAL, Tree.Kind.NULL_LITERAL))
      );
    }
  }

}
"
S5977,CODE_SMELL,Tests should use fixed data instead of randomized data,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5977"")
public class RandomizedTestDataCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers RANDOM_CONSTRUCTOR_METHOD_MATCHER = MethodMatchers.create()
    .ofTypes(""java.util.Random"")
    .constructor()
    .withAnyParameters()
    .build();

  private static final MethodMatchers RANDOM_UUID_MATCHER = MethodMatchers.create()
    .ofTypes(""java.util.UUID"")
    .names(""randomUUID"")
    .addWithoutParametersMatcher()
    .build();

  private static final String LOCATIONS_TEXT = ""usage of random data in test"";
  private static final String MESSAGE = ""Replace randomly generated values with fixed ones."";

  private final List<Tree> randomSecondaryLocations = new ArrayList<>();
  private final List<Tree> randomUUIDSecondaryLocations = new ArrayList<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.NEW_CLASS)) {
      NewClassTree newClassTree = (NewClassTree) tree;
      checkForRandomConstructorUsage(newClassTree);
    }
    if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree methodInvocationTree = (MethodInvocationTree) tree;
      checkUUIDRandomUsage(methodInvocationTree);
    }
  }

  private void checkForRandomConstructorUsage(NewClassTree newClassTree) {
    if (RANDOM_CONSTRUCTOR_METHOD_MATCHER.matches(newClassTree)) {
      randomSecondaryLocations.add(newClassTree);
    }
  }

  private void checkUUIDRandomUsage(MethodInvocationTree methodInvocationTree) {
    if (RANDOM_UUID_MATCHER.matches(methodInvocationTree)) {
      randomUUIDSecondaryLocations.add(methodInvocationTree);
    }
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    if (!randomSecondaryLocations.isEmpty()) {
      reportIssue(randomSecondaryLocations.get(0), MESSAGE, convertToLocations(randomSecondaryLocations.stream().skip(1)), null);
    }
    if (!randomUUIDSecondaryLocations.isEmpty()) {
      reportIssue(randomUUIDSecondaryLocations.get(0), MESSAGE, convertToLocations(randomUUIDSecondaryLocations.stream().skip(1)), null);
    }
    cleanup();
    super.leaveFile(context);
  }

  private void cleanup() {
    randomSecondaryLocations.clear();
    randomUUIDSecondaryLocations.clear();
  }

  private static List<JavaFileScannerContext.Location> convertToLocations(Stream<Tree> trees) {
    return trees
      .map(tree -> new JavaFileScannerContext.Location(LOCATIONS_TEXT, tree))
      .toList();
  }
}
"
S5979,BUG,Annotated Mockito objects should be initialized,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.plugins.java.api.semantic.SymbolMetadata.AnnotationInstance;

@Rule(key = ""S5979"")
public class MockitoAnnotatedObjectsShouldBeInitializedCheck extends IssuableSubscriptionVisitor {
  private static final List<String> TARGET_ANNOTATIONS = Arrays.asList(
    ""org.mockito.Captor"",
    ""org.mockito.InjectMocks"",
    ""org.mockito.Mock"",
    ""org.mockito.Spy""
  );

  private static final String EXTEND_WITH_ANNOTATION = ""org.junit.jupiter.api.extension.ExtendWith"";
  private static final String RUN_WITH_ANNOTATION = ""org.junit.runner.RunWith"";

  private static final List<String> BEFORE_ANNOTATIONS = Arrays.asList(
    ""org.junit.Before"",
    ""org.junit.jupiter.api.BeforeEach""
  );

  private static final String RULE_ANNOTATION = ""org.junit.Rule"";

  private static final MethodMatchers MOCKITO_JUNIT_RULE = MethodMatchers.create()
    .ofSubTypes(""org.mockito.junit.MockitoJUnit"")
    .names(""rule"")
    .addWithoutParametersMatcher()
    .build();

  private static final String MESSAGE = ""Initialize mocks before using them."";

  private final Set<ClassTree> coveredByExtendWithAnnotation = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree testClass = (ClassTree) tree;
    if (coveredByExtendWithAnnotation.contains(testClass)) {
      return;
    }

    if (isMetaAnnotated(testClass.symbol(), EXTEND_WITH_ANNOTATION, new HashSet<>())) {
      List<ClassTree> classes = getInnerClassesCoveredByAnnotation(testClass);
      coveredByExtendWithAnnotation.addAll(classes);
      return;
    }

    List<VariableTree> mocksToInitialize = testClass.members().stream()
      .filter(MockitoAnnotatedObjectsShouldBeInitializedCheck::isFieldWithTargetAnnotation)
      .map(VariableTree.class::cast)
      .toList();

    if (!mocksToInitialize.isEmpty() && !mocksAreProperlyInitialized(testClass)) {
      AnnotationTree firstAnnotation = mocksToInitialize.get(0).modifiers().annotations().get(0);
      reportIssue(firstAnnotation, MESSAGE);
    }
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    super.leaveFile(context);
    coveredByExtendWithAnnotation.clear();
  }

  private static boolean isMetaAnnotated(Symbol symbol, String annotation, Set<Symbol> visited) {
    if (visited.contains(symbol)) {
      return false;
    }
    for (AnnotationInstance a : symbol.metadata().annotations()) {
      visited.add(symbol);
      if (a.symbol().type().is(annotation) || isMetaAnnotated(a.symbol(), annotation, visited)) {
        return true;
      }
    }
    return false;
  }

  private static boolean hasAnnotation(ClassTree tree, String annotation) {
    return tree.symbol().metadata().isAnnotatedWith(annotation);
  }

  private static boolean isFieldWithTargetAnnotation(Tree tree) {
    if (!tree.is(Tree.Kind.VARIABLE)) {
      return false;
    }
    VariableTree field = (VariableTree) tree;
    SymbolMetadata metadata = field.symbol().metadata();
    return TARGET_ANNOTATIONS.stream().anyMatch(metadata::isAnnotatedWith);
  }

  private static boolean mocksAreProperlyInitialized(ClassTree testClass) {
    return hasAnnotation(testClass, RUN_WITH_ANNOTATION) ||
      isMockitoJUnitRuleInvoked(testClass) ||
      areMocksInitializedInSetup(testClass);
  }


  private static List<ClassTree> getInnerClassesCoveredByAnnotation(ClassTree tree) {
    NestedClassesCollector collector = new NestedClassesCollector();
    tree.accept(collector);
    return collector.classes;
  }

  private static boolean isMockitoJUnitRuleInvoked(ClassTree clazz) {
    List<VariableTree> collected = clazz.members().stream()
      .filter(member -> member.is(Tree.Kind.VARIABLE))
      .map(VariableTree.class::cast)
      .toList();
    for (VariableTree field : collected) {
      if (field.type().symbolType().is(""org.mockito.junit.MockitoRule"")) {
        ExpressionTree initializer = field.initializer();
        if (initializer != null && initializer.is(Tree.Kind.METHOD_INVOCATION) &&
          field.symbol().metadata().isAnnotatedWith(RULE_ANNOTATION) &&
          isInitializedWithRule((MethodInvocationTree) initializer)) {
          return true;
        }
      }
    }
    return false;
  }

  private static boolean isInitializedWithRule(MethodInvocationTree mit) {
    MethodInvocationTree current = mit;
    while (true) {
      if (MOCKITO_JUNIT_RULE.matches(current)) {
        return true;
      }
      ExpressionTree expressionTree = current.methodSelect();
      if (!expressionTree.is(Tree.Kind.MEMBER_SELECT)) {
        return false;
      }
      ExpressionTree expression = ((MemberSelectExpressionTree) expressionTree).expression();
      if (!expression.is(Tree.Kind.METHOD_INVOCATION)) {
        return false;
      }
      current = (MethodInvocationTree) expression;
    }
  }

  private static boolean areMocksInitializedInSetup(ClassTree clazz) {
    List<MethodTree> methods = getSetupMethods(clazz);
    for (MethodTree method : methods) {
      SetupMethodVisitor visitor = new SetupMethodVisitor();
      method.accept(visitor);
      if (visitor.initMocksIsInvoked) {
        return true;
      }
    }
    return hasParentClass(clazz);
  }

  private static boolean hasParentClass(ClassTree tree) {
    return tree.superClass() != null;
  }

  private static List<MethodTree> getSetupMethods(ClassTree tree) {
    return tree.members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .filter(MockitoAnnotatedObjectsShouldBeInitializedCheck::isTaggedWithBefore)
      .toList();
  }

  private static boolean isTaggedWithBefore(MethodTree method) {
    SymbolMetadata metadata = method.symbol().metadata();
    return BEFORE_ANNOTATIONS.stream().anyMatch(metadata::isAnnotatedWith);
  }static class NestedClassesCollector extends BaseTreeVisitor {
    private static final String NESTED_ANNOTATION = ""org.junit.jupiter.api.Nested"";
    private final List<ClassTree> classes = new ArrayList<>();

    @Override
    public void visitClass(ClassTree tree) {
      if (tree.symbol().metadata().isAnnotatedWith(NESTED_ANNOTATION)) {
        classes.add(tree);
      }
      tree.members().stream()
        .filter(member -> member.is(Tree.Kind.CLASS))
        .map(ClassTree.class::cast)
        .forEach(child -> child.accept(this));
    }
  }private static class SetupMethodVisitor extends BaseTreeVisitor {
    private static final MethodMatchers OPEN_OR_INIT_MOCKS = MethodMatchers.create()
      .ofTypes(""org.mockito.MockitoAnnotations"")
      .names(""openMocks"", ""initMocks"")
      .addParametersMatcher(""java.lang.Object"")
      .build();

    private boolean initMocksIsInvoked = false;

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (OPEN_OR_INIT_MOCKS.matches(tree)) {
        initMocksIsInvoked = true;
      }
    }
  }
}
"
S5993,CODE_SMELL,"Constructors of an ""abstract"" class should not be declared ""public""","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.model.ModifiersUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Modifier;
import org.sonar.plugins.java.api.tree.ModifierKeywordTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S5993"")
public class PublicConstructorInAbstractClassCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.PRIVATE)) {
      return;
    }

    Optional<ModifierKeywordTree> abstractKeyword = ModifiersUtils.findModifier(classTree.modifiers(), Modifier.ABSTRACT);

    abstractKeyword.ifPresent(keyword -> {
      JavaFileScannerContext.Location keywordLocation = new JavaFileScannerContext.Location(""This class is \""abstract\""."", keyword);
      List<JavaFileScannerContext.Location> secondaryLocations = Collections.singletonList(keywordLocation);
      classTree.members().stream()
        .filter(PublicConstructorInAbstractClassCheck::isConstructor)
        .map(MethodTree.class::cast)
        .map(PublicConstructorInAbstractClassCheck::isPublic)
        .filter(Optional::isPresent)
        .map(Optional::get)
        .forEach(modifier -> reportIssue(modifier, ""Change the visibility of this constructor to \""protected\""."",
          secondaryLocations, null));
    });
  }

  private static Optional<ModifierKeywordTree> isPublic(MethodTree methodTree) {
    return ModifiersUtils.findModifier(methodTree.modifiers(), Modifier.PUBLIC);
  }

  private static boolean isConstructor(Tree member) {
    return member.is(Tree.Kind.CONSTRUCTOR);
  }
}
"
S5994,BUG,Regex patterns following a possessive quantifier should not always fail,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.PossessiveQuantifierContinuationFinder;

@Rule(key = ""S5994"")
public class PossessiveQuantifierContinuationCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new PossessiveQuantifierContinuationFinder(this::reportIssueFromCommons, regexForLiterals.getFinalState()).visit(regexForLiterals);
  }

}
"
S5996,BUG,Regex boundaries should not be used in a way that can never be matched,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.ImpossibleBoundaryFinder;

@Rule(key = ""S5996"")
public class ImpossibleBoundariesCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new ImpossibleBoundaryFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S5998,BUG,Regular expressions should not overflow the stack,"package org.sonar.java.checks.regex;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.ast.AutomatonState;
import org.sonarsource.analyzer.commons.regex.ast.BackReferenceTree;
import org.sonarsource.analyzer.commons.regex.ast.CapturingGroupTree;
import org.sonarsource.analyzer.commons.regex.ast.CharacterTree;
import org.sonarsource.analyzer.commons.regex.ast.DisjunctionTree;
import org.sonarsource.analyzer.commons.regex.ast.EndOfRepetitionState;
import org.sonarsource.analyzer.commons.regex.ast.GroupTree;
import org.sonarsource.analyzer.commons.regex.ast.Quantifier;
import org.sonarsource.analyzer.commons.regex.ast.RegexBaseVisitor;
import org.sonarsource.analyzer.commons.regex.ast.RegexTree;
import org.sonarsource.analyzer.commons.regex.ast.RepetitionTree;
import org.sonarsource.analyzer.commons.regex.ast.SequenceTree;
import org.sonarsource.analyzer.commons.regex.ast.StartState;
import org.sonar.plugins.java.api.tree.ExpressionTree;

@Rule(key = ""S5998"")
public class RegexStackOverflowCheck extends AbstractRegexCheck {

  private static final String MESSAGE = ""Refactor this repetition that can lead to a stack overflow for large inputs."";

  private static final String SECONDARY_MESSAGE = ""Refactor this repetition"";

  private static final double DEFAULT_MAX_STACK_CONSUMPTION_FACTOR = 5;

  @RuleProperty(
    key = ""maxStackConsumptionFactor"",
    description = ""An indicator approximately proportional to how quickly the stack grows relative to the input size. An "" +
      ""issue will be reported if the value for a regex exceeds the maximum set here. Setting this to 0 will cause an issue "" +
      ""to be reported for all regular expressions with non-constant stack consumption."",
    defaultValue = """" + DEFAULT_MAX_STACK_CONSUMPTION_FACTOR)
  private double maxStackConsumptionFactor = DEFAULT_MAX_STACK_CONSUMPTION_FACTOR;

  public void setMaxStackConsumptionFactor(int max) {
    this.maxStackConsumptionFactor = max;
  }

  @Override
  public void checkRegex(RegexParseResult parseResult, ExpressionTree methodInvocationOrAnnotation) {
    new StackOverflowFinder().visit(parseResult);
  }

  private static class PathInfo {
    int numberOfConsumedCharacters;
    int recursionDepth;

    PathInfo(int numberOfConsumedCharacters, int recursionDepth) {
      this.numberOfConsumedCharacters = numberOfConsumedCharacters;
      this.recursionDepth = recursionDepth;
    }

    PathInfo add(PathInfo other) {
      numberOfConsumedCharacters += other.numberOfConsumedCharacters;
      recursionDepth += other.recursionDepth;
      return this;
    }

    PathInfo multiply(int factor) {
      numberOfConsumedCharacters *= factor;
      recursionDepth *= factor;
      return this;
    }

    double stackConsumptionFactor() {
      return (double) recursionDepth*2 / numberOfConsumedCharacters;
    }
  }

  private class StackOverflowFinder extends RegexBaseVisitor {

    private final Map<CapturingGroupTree, Integer> consumedCharactersByCapturingGroupCache = new HashMap<>();
    private final List<RegexTree> offendingTrees = new ArrayList<>();

    @Override
    public void visitRepetition(RepetitionTree tree) {
      if (!isPossessive(tree) && tree.getQuantifier().isOpenEnded()) {
        if (containsBacktrackableBranch(tree.getElement())
          && stackConsumption(new StartState(tree.getElement(), tree.activeFlags()), tree.continuation()) > maxStackConsumptionFactor) {
          offendingTrees.add(tree);
        }
      } else {
        // Only visit the children if this isn't the kind of repetition we check
        // Otherwise, if the parent doesn't overflow the stack, neither will its children, and if it does overflow
        // it, there's no point in reporting additional issues for the children
        super.visitRepetition(tree);
      }
    }

    @Override
    protected void after(RegexParseResult regexParseResult) {
      if (!offendingTrees.isEmpty()) {
        List<RegexIssueLocation> secondaries = offendingTrees.stream()
          .skip(1)
          .map(tree -> new RegexIssueLocation(tree, SECONDARY_MESSAGE))
          .toList();
        reportIssue(offendingTrees.get(0), MESSAGE, null, secondaries);
      }
    }

    private boolean isPossessive(RepetitionTree tree) {
      return tree.getQuantifier().getModifier() == Quantifier.Modifier.POSSESSIVE;
    }

    private boolean containsBacktrackableBranch(@Nullable RegexTree tree) {
      if (tree == null) {
        return false;
      }
      switch (tree.kind()) {
        case DISJUNCTION:
          return true;
        case REPETITION:
          RepetitionTree repetition = (RepetitionTree) tree;
          return !repetition.getQuantifier().isFixed() || containsBacktrackableBranch(repetition.getElement());
        case CAPTURING_GROUP:
        case NON_CAPTURING_GROUP:
          return containsBacktrackableBranch(((GroupTree) tree).getElement());
        case SEQUENCE:
          for (RegexTree child : ((SequenceTree) tree).getItems()) {
            if (containsBacktrackableBranch(child)) {
              return true;
            }
          }
          return false;
        default:
          return false;
      }
    }

    private double stackConsumption(AutomatonState start, AutomatonState stop) {
      Comparator<PathInfo> worstPathComparator = Comparator.comparingDouble(PathInfo::stackConsumptionFactor).reversed();
      PathInfo path = shortestPath(start, stop, worstPathComparator);
      return path.stackConsumptionFactor();
    }private PathInfo shortestPath(AutomatonState start, AutomatonState end, Comparator<PathInfo> shortestPathComparator) {
      if (start == end) {
        return new PathInfo(0, 0);
      }
      AutomatonState next = start.continuation();
      if (start instanceof RegexTree startRegex) {
        if (start instanceof CharacterTree && next instanceof CharacterTree) {
          // Consecutive characters don't create an extra recursion, so we skip the character edge between them and use
          // a 1,0 edge instead.
          return new PathInfo(1, 0).add(shortestPath(next, end, shortestPathComparator));
        }
        PathInfo path = shortestInnerPath(startRegex, shortestPathComparator);
        path.add(edgeCost(next));
        path.add(shortestPath(next, end, shortestPathComparator));
        return path;
      }
      return edgeCost(next).add(shortestPath(next, end, shortestPathComparator));
    }

    private boolean ignoredNode(AutomatonState state) {
      // Java's regex implementation does not have an equivalent of these nodes, so we consider them zero cost
      return state instanceof SequenceTree || state instanceof EndOfRepetitionState;
    }

    private PathInfo edgeCost(AutomatonState state) {
      switch (state.incomingTransitionType()) {
        case EPSILON:
          return new PathInfo(0, ignoredNode(state) ? 0 : 1);
        case CHARACTER:
          return new PathInfo(1, 1);
        case BACK_REFERENCE:
          return backReferenceCost((BackReferenceTree) state);
        default:
          throw new IllegalStateException(""Lookaround should have been skipped"");
      }
    }

    private PathInfo backReferenceCost(BackReferenceTree backReference) {
      Integer consumedCharacters = 0;
      CapturingGroupTree group = backReference.group();
      if (group != null) {
        consumedCharacters = consumedCharactersByCapturingGroupCache.get(group);
        if (consumedCharacters == null) {
          // prevent reentrancy while we are computing the value
          consumedCharactersByCapturingGroupCache.put(group, 1);
          Comparator<PathInfo> pathLengthComparator = Comparator.comparingInt(p -> p.numberOfConsumedCharacters);
          RegexTree element = group.getElement();
          PathInfo pathInfo = edgeCost(element).add(shortestPath(element, element.continuation(), pathLengthComparator));
          consumedCharacters = pathInfo.numberOfConsumedCharacters;
          consumedCharactersByCapturingGroupCache.put(group, consumedCharacters);
        }
      }
      // Referencing a capturing group does not increase the stack size as parsing the group would just retrieve a saved string
      return new PathInfo(consumedCharacters, 0);
    }private PathInfo shortestInnerPath(RegexTree tree, Comparator<PathInfo> shortestPathComparator) {
      switch (tree.kind()) {
        case REPETITION:
          RepetitionTree repetition = (RepetitionTree) tree;
          if (repetition.getQuantifier().getMinimumRepetitions() == 0) {
            return new PathInfo(0, 0);
          }
          int repetitions = repetition.getQuantifier().getMinimumRepetitions();
          RegexTree element = repetition.getElement();
          return edgeCost(element).add(shortestPath(element, repetition.continuation(), shortestPathComparator)).multiply(repetitions);
        case DISJUNCTION:
          return ((DisjunctionTree) tree).getAlternatives().stream()
            .map(alt -> edgeCost(alt).add(shortestInnerPath(alt, shortestPathComparator)))
            .min(shortestPathComparator)
            .get();
        case SEQUENCE:
          List<RegexTree> items = ((SequenceTree) tree).getItems();
          if (items.isEmpty()) {
            return new PathInfo(0, 0);
          }
          RegexTree first = items.get(0);
          return edgeCost(first).add(shortestPath(first, tree.continuation(), shortestPathComparator));
        case NON_CAPTURING_GROUP:
        case CAPTURING_GROUP:
          return Optional.ofNullable(((GroupTree) tree).getElement())
            .map(groupElement -> edgeCost(groupElement).add(shortestInnerPath(groupElement, shortestPathComparator)))
            .orElse(new PathInfo(0, 0));
        default:
          return new PathInfo(0, 0);
      }
    }

  }

}
"
S6001,BUG,Back references in regular expressions should only refer to capturing groups that are matched before the reference,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.ImpossibleBackReferenceFinder;

@Rule(key = ""S6001"")
public class ImpossibleBackReferenceCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new ImpossibleBackReferenceFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S6002,BUG,Regex lookahead assertions should not be contradictory,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.MatchType;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.FailingLookaheadFinder;

@Rule(key = ""S6002"")
public class RegexLookaheadCheck extends AbstractRegexCheckTrackingMatchType {

  @Override
  protected void checkRegex(RegexParseResult regex, ExpressionTree methodInvocationOrAnnotation, MatchType matchType) {
    new FailingLookaheadFinder(this::reportIssueFromCommons, regex.getFinalState(), matchType).visit(regex);
  }

}
"
S6019,CODE_SMELL,Reluctant quantifiers in regular expressions should be followed by an expression that can't match the empty string,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.MatchType;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.ReluctantQuantifierWithEmptyContinuationFinder;

@Rule(key = ""S6019"")
public class ReluctantQuantifierWithEmptyContinuationCheck extends AbstractRegexCheckTrackingMatchType {

  @Override
  protected void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation, MatchType matchType) {
    new ReluctantQuantifierWithEmptyContinuationFinder(this::reportIssueFromCommons, matchType).visit(regexForLiterals);
  }

}
"
S6035,CODE_SMELL,Single-character alternations in regular expressions should be replaced with character classes,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.SingleCharacterAlternationFinder;

@Rule(key = ""S6035"")
public class SingleCharacterAlternationCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new SingleCharacterAlternationFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S6068,CODE_SMELL,"Call to Mockito method ""verify"", ""when"" or ""given"" should be simplified","package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6068"")
public class MockitoEqSimplificationCheck extends AbstractMockitoArgumentChecker {
  private static final MethodMatchers MOCKITO_EQ = MethodMatchers.create()
    .ofTypes(""org.mockito.ArgumentMatchers"", ""org.mockito.Matchers"", ""org.mockito.Mockito"")
    .names(""eq"").withAnyParameters().build();


  @Override
  protected void visitArguments(Arguments arguments) {
    List<MethodInvocationTree> eqs = new ArrayList<>();

    for (ExpressionTree arg : arguments) {
      arg = ExpressionUtils.skipParentheses(arg);
      if (arg.is(Tree.Kind.METHOD_INVOCATION) && MOCKITO_EQ.matches((MethodInvocationTree) arg)) {
        eqs.add((MethodInvocationTree) arg);
      } else {
        // If arguments contain anything else than a call to eq(...), we do not report an issue
        return;
      }
    }

    if (!eqs.isEmpty()) {
      reportIssue(eqs.get(0).methodSelect(), String.format(
        ""Remove this%s useless \""eq(...)\"" invocation; pass the values directly."", eqs.size() == 1 ? """" : "" and every subsequent""),
        eqs.stream()
          .skip(1)
          .map(eq -> new JavaFileScannerContext.Location("""", eq.methodSelect()))
          .toList(),
        null);
    }
  }
}
"
S6070,BUG,The regex escape sequence \cX should only be used with characters in the @-_ range,"package org.sonar.java.checks.regex;

import java.util.Collections;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.ast.CharacterTree;
import org.sonarsource.analyzer.commons.regex.ast.RegexBaseVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;

@Rule(key = ""S6070"")
public class EscapeSequenceControlCharacterCheck extends AbstractRegexCheck {

  private static final String MESSAGE = ""Remove or replace this problematic use of \\c."";

  private static final Pattern WRONG_ESCAPED_SEQUENCE = Pattern.compile(""\\\\\\\\c[^@-_]"");

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new WrongEscapeSequenceVisitor().visit(regexForLiterals);
  }

  private class WrongEscapeSequenceVisitor extends RegexBaseVisitor {
    @Override
    public void visitCharacter(CharacterTree tree) {
      if (WRONG_ESCAPED_SEQUENCE.matcher(tree.getText()).matches()) {
        reportIssue(tree, MESSAGE, null, Collections.emptyList());
      }
    }
  }


}
"
S6073,BUG,Mockito argument matchers should be used on all parameters,"package org.sonar.java.checks.tests;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;

@Rule(key = ""S6073"")
public class MockitoArgumentMatchersUsedOnAllParametersCheck extends AbstractMockitoArgumentChecker {
  private static final String ARGUMENT_CAPTOR_CLASS = ""org.mockito.ArgumentCaptor"";
  private static final String ARGUMENT_MATCHER_CLASS = ""org.mockito.ArgumentMatchers"";
  private static final String ADDITIONAL_MATCHER_CLASS = ""org.mockito.AdditionalMatchers"";
  private static final String OLD_MATCHER_CLASS = ""org.mockito.Matchers"";
  private static final String TOP_MOCKITO_CLASS = ""org.mockito.Mockito"";

  // Argument matchers are not filtered on names but the class they originate from to support the addition of new matchers.
  private static final MethodMatchers ARGUMENT_MARCHER = MethodMatchers.create()
    .ofTypes(ARGUMENT_MATCHER_CLASS, ADDITIONAL_MATCHER_CLASS, OLD_MATCHER_CLASS, TOP_MOCKITO_CLASS)
    .anyName()
    .withAnyParameters()
    .build();

  private static final MethodMatchers HAMCREST_ADAPTOR_MATCHER = MethodMatchers.create()
    .ofTypes(""org.mockito.hamcrest.MockitoHamcrest"")
    .anyName()
    .withAnyParameters()
    .build();

  private static final MethodMatchers ARGUMENT_CAPTOR = MethodMatchers.create()
    .ofTypes(ARGUMENT_CAPTOR_CLASS)
    .names(""capture"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    MethodVisitor.cachedResults.clear();
  }

  @Override
  protected void visitArguments(Arguments arguments) {
    if (arguments.isEmpty()) {
      return;
    }
    List<Tree> nonMatchers = new ArrayList<>();
    for (ExpressionTree arg : arguments) {
      arg = ExpressionUtils.skipParentheses(arg);
      if (!isArgumentMatcherLike(arg)) {
        nonMatchers.add(arg);
      }
    }
    int nonMatchersFound = nonMatchers.size();

    if (!nonMatchers.isEmpty() && nonMatchersFound < arguments.size()) {
      String primaryMessage = String.format(
        ""Add an \""eq()\"" argument matcher on %s"",
        nonMatchersFound == 1 ? ""this parameter."" : ""these parameters.""
      );
      reportIssue(nonMatchers.get(0),
        primaryMessage,
        nonMatchers.stream()
          .skip(1)
          .map(secondary -> new JavaFileScannerContext.Location("""", secondary))
          .toList(),
        null);
    }
  }

  private static boolean isArgumentMatcherLike(ExpressionTree tree) {
    ExpressionTree unpacked = skipCasts(tree);
    if (!unpacked.is(Tree.Kind.METHOD_INVOCATION)) {
      return false;
    }
    MethodInvocationTree invocation = (MethodInvocationTree) unpacked;
    return ARGUMENT_CAPTOR.matches(invocation) ||
      HAMCREST_ADAPTOR_MATCHER.matches(invocation) ||
      ARGUMENT_MARCHER.matches(invocation) ||
      returnsAnArgumentMatcher(invocation);
  }private static boolean returnsAnArgumentMatcher(MethodInvocationTree invocation) {
    ExpressionTree methodSelect = invocation.methodSelect();
    IdentifierTree identifier;
    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
      identifier = ((MemberSelectExpressionTree) methodSelect).identifier();
    } else {
      // If not a member select, then it must be an identifier
      identifier = (IdentifierTree) methodSelect;
    }
    Symbol symbol = identifier.symbol();
    if (symbol.isUnknown()) {
      return true;
    }
    Symbol.MethodSymbol methodSymbol = (Symbol.MethodSymbol) symbol;
    MethodTree declaration = methodSymbol.declaration();
    if (declaration == null) {
      return false;
    }
    MethodVisitor methodVisitor = new MethodVisitor();
    declaration.accept(methodVisitor);
    return methodVisitor.onlyReturnsMethodInvocations;
  }private static ExpressionTree skipCasts(ExpressionTree tree) {
    ExpressionTree current = ExpressionUtils.skipParentheses(tree);
    while (current.is(Tree.Kind.TYPE_CAST)) {
      TypeCastTree cast = (TypeCastTree) current;
      current = ExpressionUtils.skipParentheses(cast.expression());
    }
    return current;
  }

  private static class MethodVisitor extends BaseTreeVisitor {
    static Map<MethodTree, Boolean> cachedResults = new HashMap<>();
    boolean onlyReturnsMethodInvocations = false;

    @Override
    public void visitMethod(MethodTree tree) {
      if (cachedResults.containsKey(tree)) {
        onlyReturnsMethodInvocations = cachedResults.get(tree);
        return;
      }
      cachedResults.put(tree, Boolean.FALSE);
      BlockTree block = tree.block();
      if (block == null) {
        // If the method is abstract, we assume its potential implementations only return method invocations.
        cachedResults.put(tree, Boolean.TRUE);
        return;
      }
      onlyReturnsMethodInvocations = block.body().stream()
        .filter(statement -> statement.is(Tree.Kind.RETURN_STATEMENT))
        .map(ReturnStatementTree.class::cast)
        .map(ReturnStatementTree::expression)
        .allMatch(expression -> expression.is(Tree.Kind.METHOD_INVOCATION));
      cachedResults.put(tree, onlyReturnsMethodInvocations);
    }
  }
}
"
S6103,BUG,"AssertJ assertions with ""Consumer"" arguments should contain assertion inside consumers","package org.sonar.java.checks.tests;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.AbstractAssertionVisitor;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaFileScannerContext.Location;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static java.util.Collections.singletonList;

@Rule(key = ""S6103"")
public class AssertJAssertionsInConsumerCheck extends IssuableSubscriptionVisitor {

  private static final String ORG_ASSERTJ_CORE_API_ABSTRACT_ASSERT = ""org.assertj.core.api.AbstractAssert"";
  private static final String JAVA_UTIL_FUNCTION_CONSUMER = ""java.util.function.Consumer"";
  private static final String ORG_ASSERTJ_CORE_API_THROWING_CONSUMER = ""org.assertj.core.api.ThrowingConsumer"";
  private static final String ORG_ASSERTJ_CORE_API_THROWING_CONSUMER_ARRAY = ""org.assertj.core.api.ThrowingConsumer[]"";

  private static final MethodMatchers METHODS_WITH_CONSUMER_AT_INDEX_0_MATCHER = MethodMatchers.create()
    .ofSubTypes(ORG_ASSERTJ_CORE_API_ABSTRACT_ASSERT)
    .names(""allSatisfy"", ""anySatisfy"", ""hasOnlyOneElementSatisfying"", ""noneSatisfy"", ""satisfies"")
    .addParametersMatcher(JAVA_UTIL_FUNCTION_CONSUMER)
    .addParametersMatcher(ORG_ASSERTJ_CORE_API_THROWING_CONSUMER)
    .addParametersMatcher(ORG_ASSERTJ_CORE_API_THROWING_CONSUMER_ARRAY)
    .addParametersMatcher(JAVA_UTIL_FUNCTION_CONSUMER, ""org.assertj.core.data.Index"")
    .build();

  private static final MethodMatchers METHODS_WITH_CONSUMER_AT_INDEX_1_MATCHER = MethodMatchers.create()
    .ofSubTypes(ORG_ASSERTJ_CORE_API_ABSTRACT_ASSERT)
    .names(""isInstanceOfSatisfying"", ""zipSatisfy"")
    .addParametersMatcher(arguments -> arguments.size() > 1 && (arguments.get(1).is(JAVA_UTIL_FUNCTION_CONSUMER) || arguments.get(1).is(""java.util.function.BiConsumer"")))
    .build();

  private static final MethodMatchers SATISFIES_ANY_OF_MATCHER = MethodMatchers.create()
    .ofSubTypes(ORG_ASSERTJ_CORE_API_ABSTRACT_ASSERT)
    .names(""satisfiesAnyOf"")
    .withAnyParameters()
    .build();

  private final Map<Symbol, Boolean> assertionInLocalMethod = new HashMap<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree invocation = (MethodInvocationTree) tree;
    if (METHODS_WITH_CONSUMER_AT_INDEX_0_MATCHER.matches(invocation)) {
      checkAssertions(invocation, singletonList(invocation.arguments().get(0)));
    } else if (METHODS_WITH_CONSUMER_AT_INDEX_1_MATCHER.matches(invocation)) {
      checkAssertions(invocation, singletonList(invocation.arguments().get(1)));
    } else if (SATISFIES_ANY_OF_MATCHER.matches(invocation)) {
      checkAssertions(invocation, invocation.arguments());
    }
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    assertionInLocalMethod.clear();
    super.leaveFile(context);
  }

  private void checkAssertions(MethodInvocationTree invocation, List<ExpressionTree> argumentsToCheck) {
    List<Location> argumentsMissingAssertion = argumentsToCheck.stream()
      .filter(argument -> !hasAssertion(argument))
      .map(argument -> new Location(""Argument missing assertion"", argument))
      .toList();

    if (!argumentsMissingAssertion.isEmpty()) {
      IdentifierTree methodName = ExpressionUtils.methodName(invocation);
      reportIssue(
        methodName,
        ""Rework this assertion to assert something inside the Consumer argument."",
        argumentsMissingAssertion,
        null);
    }
  }

  private boolean hasAssertion(@Nullable ExpressionTree expressionTree) {
    // if the expression to check cannot be resolved, we assume it has assertions to avoid FP
    if (expressionTree == null) {
      return true;
    }

    if (expressionTree.is(Tree.Kind.IDENTIFIER)) {
      Tree argumentDeclaration = ((IdentifierTree) expressionTree).symbol().declaration();
      return argumentDeclaration instanceof VariableTree variableTree && hasAssertion(variableTree.initializer());
    } else {
      AssertionVisitor assertionVisitor = new AssertionVisitor();
      expressionTree.accept(assertionVisitor);
      return assertionVisitor.hasAssertion();
    }
  }

  private class AssertionVisitor extends AbstractAssertionVisitor {
    @Override
    protected boolean isAssertion(Symbol methodSymbol) {
      if (!assertionInLocalMethod.containsKey(methodSymbol)) {
        assertionInLocalMethod.put(methodSymbol, false);
        Tree declaration = methodSymbol.declaration();
        if (declaration != null) {
          AssertionVisitor assertionVisitor = new AssertionVisitor();
          declaration.accept(assertionVisitor);
          assertionInLocalMethod.put(methodSymbol, assertionVisitor.hasAssertion());
        }
      }

      return assertionInLocalMethod.get(methodSymbol);
    }
  }

}
"
S6104,BUG,"Map ""computeIfAbsent()"" and ""computeIfPresent()"" should not be used to add ""null"" values.","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6104"")
public class NullReturnedOnComputeIfPresentOrAbsentCheck extends AbstractMethodDetection {
  private static final String PRIMARY_MESSAGE = ""Use \""Map.containsKey(key)\"" followed by \""Map.put(key, null)\"" to add null values."";
  private static final String SECONDARY_MESSAGE = ""null literal in the arguments"";
  private static final MethodMatchers COMPUTE_IF = MethodMatchers.create()
    .ofTypes(""java.util.Map"")
    .names(""computeIfPresent"", ""computeIfAbsent"")
    .addParametersMatcher(MethodMatchers.ANY, MethodMatchers.ANY)
    .build();@Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return COMPUTE_IF;
  }

  @Override
  public void onMethodInvocationFound(MethodInvocationTree invocation) {
    Arguments arguments = invocation.arguments();
    getNullReturnInLambda(arguments.get(1)).ifPresent(nullReturn ->
      reportIssue(ExpressionUtils.methodName(invocation),
        PRIMARY_MESSAGE,
        Collections.singletonList(new JavaFileScannerContext.Location(SECONDARY_MESSAGE, nullReturn)),
        null));
  }

  private static Optional<Tree> getNullReturnInLambda(Tree tree) {
    if (tree.is(Tree.Kind.LAMBDA_EXPRESSION)) {
      Tree body = ((LambdaExpressionTree) tree).body();
      if (body.is(Tree.Kind.NULL_LITERAL)) {
        return Optional.of(body);
      }
    }
    return Optional.empty();
  }
}
"
S6126,CODE_SMELL,String multiline concatenation should be replaced with Text Blocks,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6126"")
public class StringConcatToTextBlockCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  private static final String MESSAGE = ""Replace this String concatenation with Text block."";
  public static final int MINIMAL_CONTENT_LENGTH = 19;
  public static final int MINIMAL_NUMBER_OF_LINES = 2;
  // matches '\n' characters, but skips '\\n'
  public static final Pattern EOL = Pattern.compile(""(?<!\\\\)\\\\n"");
  private final Set<Tree> visitedNodes = new HashSet<>();

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava15Compatible();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.PLUS);
  }

  @Override
  public void visitNode(Tree tree) {
    if (visitedNodes.contains(tree)) {
      return;
    }
    StringBuilder builder = new StringBuilder();
    if (concatStringLiterals(builder, tree)) {
      String content = builder.toString();
      if (content.length() >= MINIMAL_CONTENT_LENGTH
        && isMultiline(content)) {
        reportIssue(tree, MESSAGE);
      }
    }
  }

  private static boolean isMultiline(String line) {
    Matcher matcher = EOL.matcher(line);
    int matches = 0;
    while (matcher.find() && matches < MINIMAL_NUMBER_OF_LINES) {
      matches++;
    }
    return matches == MINIMAL_NUMBER_OF_LINES;
  }

  private boolean concatStringLiterals(StringBuilder concatenatedContent, Tree tree) {
    if (tree.is(Tree.Kind.PLUS)) {
      BinaryExpressionTree binaryExpression = (BinaryExpressionTree) tree;
      visitedNodes.add(binaryExpression);
      return concatStringLiterals(concatenatedContent, ExpressionUtils.skipParentheses(binaryExpression.leftOperand())) &&
        concatStringLiterals(concatenatedContent, ExpressionUtils.skipParentheses(binaryExpression.rightOperand()));
    } else if (tree instanceof LiteralTree literalTree) {
      String treeValue = LiteralUtils.getAsStringValue(literalTree);
      concatenatedContent.append(treeValue);
      return true;
    } else {
      return false;
    }
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    visitedNodes.clear();
    super.setContext(context);
  }

}
"
S6201,CODE_SMELL,"Pattern Matching for ""instanceof"" operator should be used instead of simple ""instanceof"" + cast","package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.InstanceOfTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeCastTree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.sonar.plugins.java.api.tree.WhileStatementTree;

@Rule(key = ""S6201"")
public class InstanceOfPatternMatchingCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {
  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.IF_STATEMENT, Tree.Kind.FOR_STATEMENT, Tree.Kind.WHILE_STATEMENT,
      Tree.Kind.CONDITIONAL_AND, Tree.Kind.CONDITIONAL_OR, Tree.Kind.CONDITIONAL_EXPRESSION);
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava16Compatible();
  }

  @Override
  public void visitNode(Tree tree) {
    switch (tree.kind()) {
      case IF_STATEMENT:
        IfStatementTree ifStatement = (IfStatementTree) tree;
        handleConditional(ifStatement.condition(), ifStatement.thenStatement(), ifStatement.elseStatement());
        break;
      case FOR_STATEMENT:
        ForStatementTree forStatement = (ForStatementTree) tree;
        if (forStatement.condition() != null) {
          // Technically a negated instanceof inside a for- or while-condition should make us look for casts that
          // come after the loop, but for that we'd need the CFG and that seems overkill for this rule.
          handleConditional(forStatement.condition(), forStatement.statement(), null);
        }
        break;
      case WHILE_STATEMENT:
        WhileStatementTree whileStatement = (WhileStatementTree) tree;
        handleConditional(whileStatement.condition(), whileStatement.statement(), null);
        break;
      case CONDITIONAL_AND:
        BinaryExpressionTree and = (BinaryExpressionTree) tree;
        handleConditional(and.leftOperand(), and.rightOperand(), null);
        break;
      case CONDITIONAL_OR:
        BinaryExpressionTree or = (BinaryExpressionTree) tree;
        handleConditional(or.leftOperand(), null, or.rightOperand());
        break;
      default: // CONDITIONAL_EXPRESSION
        ConditionalExpressionTree conditional = (ConditionalExpressionTree) tree;
        handleConditional(conditional.condition(), conditional.trueExpression(), conditional.falseExpression());
        break;
    }
  }

  private void handleConditional(ExpressionTree condition, @Nullable Tree thenBody, @Nullable Tree elseBody) {
    findInstanceOf(condition).ifPresent(instanceOf -> {
      if (!instanceOf.negated && thenBody != null) {
        thenBody.accept(new BodyVisitor(instanceOf.tree));
      } else if (instanceOf.negated && elseBody != null) {
        elseBody.accept(new BodyVisitor(instanceOf.tree));
      }
    });
  }

  // Note: If a condition contains multiple instanceof checks, we'll only return (and thus only check) the first one.
  // The number of FNs resulting from that should be small and in the case that's probably the most common
  // (`if (x instanceof X && y instanceof Y) { X x = (X) x; Y y = (Y) y;}`), we'll still find the second issue after the
  // first has been fixed.
  private static Optional<InstanceOfInfo> findInstanceOf(ExpressionTree condition) {
    return findInstanceOf(condition, false);
  }

  private static Optional<InstanceOfInfo> findInstanceOf(ExpressionTree condition, boolean negated) {
    condition = ExpressionUtils.skipParentheses(condition);
    switch (condition.kind()) {
      case INSTANCE_OF:
        return Optional.of(new InstanceOfInfo((InstanceOfTree) condition, negated));
      case CONDITIONAL_AND:
        // If the condition is part of a negated AND, it won't dominate the else case of the if because only one of the
        // operands of the AND would have to be
        if (negated) return Optional.empty();
        return findInstanceOfInBinaryExpression(condition, negated);
      case CONDITIONAL_OR:
        if (!negated) return Optional.empty();
        return findInstanceOfInBinaryExpression(condition, negated);
      case LOGICAL_COMPLEMENT:
        return findInstanceOf(((UnaryExpressionTree) condition).expression(), !negated);
      default:
        return Optional.empty();
    }
  }

  private static Optional<InstanceOfInfo> findInstanceOfInBinaryExpression(ExpressionTree condition, boolean negated) {
    BinaryExpressionTree binaryExpression = (BinaryExpressionTree) condition;
    Optional<InstanceOfInfo> leftResult = findInstanceOf(binaryExpression.leftOperand(), negated);
    if (leftResult.isPresent()) return leftResult;
    return findInstanceOf(binaryExpression.rightOperand(), negated);
  }

  private static class InstanceOfInfo {
    InstanceOfTree tree;
    boolean negated;

    public InstanceOfInfo(InstanceOfTree tree, boolean negated) {
      this.tree = tree;
      this.negated = negated;
    }
  }

  private class BodyVisitor extends BaseTreeVisitor {
    InstanceOfTree instanceOf;

    BodyVisitor(InstanceOfTree instanceOf) {
      this.instanceOf = instanceOf;
    }

    @Override
    public void visitVariable(VariableTree tree) {
      Type type = tree.type().symbolType();
      if (!type.isUnknown() && type.equals(instanceOf.type().symbolType())) {
        ExpressionTree init = tree.initializer();
        if (init != null && init.is(Tree.Kind.TYPE_CAST)
          && SyntacticEquivalence.areEquivalentIncludingSameVariables(((TypeCastTree) init).expression(), instanceOf.expression())) {
          report(instanceOf, init, tree.simpleName().name());
          return;
        }
      }
      super.visitVariable(tree);
    }

    @Override
    public void visitTypeCast(TypeCastTree tree) {
      Type type = tree.symbolType();
      if (!type.isUnknown() && type.equals(instanceOf.type().symbolType())
        && SyntacticEquivalence.areEquivalentIncludingSameVariables(tree.expression(), instanceOf.expression())) {
        report(instanceOf, tree, tree.type().symbolType().name().toLowerCase(Locale.ROOT));
      }
    }

    private void report(InstanceOfTree instanceOf, ExpressionTree cast, String name) {
      String type = instanceOf.type().symbolType().name();
      String message = String.format(""Replace this instanceof check and cast with 'instanceof %s %s'"", type, name);
      JavaFileScannerContext.Location secondary = new JavaFileScannerContext.Location(""Location of the cast"", cast);
      reportIssue(instanceOf, message, Collections.singletonList(secondary), null);
    }
  }
}
"
S6202,CODE_SMELL,"Operator ""instanceof"" should be used instead of ""A.class.isInstance()""","package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6202"")
public class IsInstanceMethodCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Replace this usage of \""%1$s.class.isInstance()\"" with \""instanceof %1$s\""."";
  private static final MethodMatchers IS_INSTANCE_MATCHER = MethodMatchers.create()
    .ofTypes(""java.lang.Class"")
    .names(""isInstance"")
    .withAnyParameters()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree methodInvocationTree = (MethodInvocationTree) tree;
    if (IS_INSTANCE_MATCHER.matches(methodInvocationTree)) {
      ExpressionTree methodSelect = methodInvocationTree.methodSelect();
      if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
        ExpressionTree expression = ((MemberSelectExpressionTree) methodSelect).expression();
        getClassIdentifier(expression)
          .ifPresent(identifier -> reportIssue(tree, String.format(MESSAGE, identifier)));
      }
    }
  }

  private static Optional<String> getClassIdentifier(ExpressionTree expression) {
    ExpressionTree originalExpression = ExpressionUtils.skipParentheses(expression);
    if (originalExpression.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) originalExpression;
      if (""class"".equals(memberSelect.identifier().name())) {
        ExpressionTree selectedExpression = ExpressionUtils.skipParentheses(memberSelect.expression());
        return getName(selectedExpression);
      }
    }
    return Optional.empty();
  }

  private static Optional<String> getName(ExpressionTree selectedExpression) {
    Type type = selectedExpression.symbolType();
    return type.isUnknown() ? 
      Optional.empty() :
      Optional.of(type.name());
  }
}
"
S6203,CODE_SMELL,Text blocks should not be used in complex expressions,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6203"")
public class TextBlocksInComplexExpressionsCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Move this text block out of the lambda body and refactor it to a local variable or a static final field."";
  private static final int DEFAULT_LINES_NUMBER = 5;
  @RuleProperty(key = ""MaximumNumberOfLines"", 
    description = ""The maximum number of lines in a text block that can be nested into a complex expression."",
    defaultValue = """" + DEFAULT_LINES_NUMBER)
  private int linesNumber = DEFAULT_LINES_NUMBER;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.LAMBDA_EXPRESSION);
  }

  @Override
  public void visitNode(Tree tree) {
    LambdaExpressionTree lambdaExpressionTree = (LambdaExpressionTree) tree;
    if (lambdaExpressionTree.parent().is(Tree.Kind.ARGUMENTS)) {
      TextBlockFinder finder = new TextBlockFinder(linesNumber);
      lambdaExpressionTree.body().accept(finder);
      finder.misusedTextBlocks.forEach(textBlock -> reportIssue(textBlock, MESSAGE));
    }
  }

  public void setLinesNumber(int linesNumber) {
    this.linesNumber = linesNumber;
  }

  private static final class TextBlockFinder extends BaseTreeVisitor {

    private final int maxLines;
    
    public TextBlockFinder(int maxLines) {
      this.maxLines = maxLines;
    }

    private final List<Tree> misusedTextBlocks = new ArrayList<>();

    @Override
    public void visitLiteral(LiteralTree tree) {
      if (tree.is(Tree.Kind.TEXT_BLOCK)) {
        String value = tree.value();
        if (value.split(""\r?\n|\r"").length > maxLines) {
          misusedTextBlocks.add(tree);
        }
      }
    }
  }
}
"
S6204,CODE_SMELL,"""Stream.toList()"" method should be used instead of ""collectors"" when unmodifiable list needed","package org.sonar.java.checks;

import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ArrayAccessExpressionTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6204"")
public class CollectorsToListCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {
  private static final String MESSAGE = ""Replace this usage of 'Stream.collect(Collectors.%s())' with 'Stream.toList()'%s."";

  private static final MethodMatchers COLLECT = MethodMatchers.create()
    .ofSubTypes(""java.util.stream.Stream"")
    .names(""collect"")
    .addParametersMatcher(""java.util.stream.Collector"")
    .build();

  private static final MethodMatchers COLLECTORS_TO_LIST = MethodMatchers.create()
    .ofSubTypes(""java.util.stream.Collectors"")
    .names(""toList"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers COLLECTORS_TO_UNMODIFIABLE_LIST = MethodMatchers.create()
    .ofSubTypes(""java.util.stream.Collectors"")
    .names(""toUnmodifiableList"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers LIST_MODIFICATION_METHODS = MethodMatchers.create()
    .ofSubTypes(""java.util.List"")
    .names(""add"", ""addAll"", ""remove"", ""removeAll"", ""retainAll"", ""replaceAll"", ""set"", ""sort"", ""clear"", ""removeIf"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers COLLECTIONS_MUTATOR_METHODS = MethodMatchers.create()
    .ofSubTypes(""java.util.Collections"")
    .names(""addAll"", ""copy"", ""fill"", ""replaceAll"", ""reverse"", ""rotate"", ""shuffle"", ""sort"", ""swap"")
    .withAnyParameters()
    .build();

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava16Compatible();
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return COLLECT;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    boolean mutable;
    if (!mit.arguments().get(0).is(Tree.Kind.METHOD_INVOCATION)) return;
    MethodInvocationTree collector = (MethodInvocationTree) mit.arguments().get(0);
    if (COLLECTORS_TO_LIST.matches(collector)) {
      mutable = true;
    } else if (COLLECTORS_TO_UNMODIFIABLE_LIST.matches(collector)) {
      mutable = false;
    } else {
      return;
    }
    if (isInvariantTypeArgument(mit) && (!mutable || isReturnedListUnmodified(mit))) {
      reportIssue(collector, mutable);
    }
  }

  private static boolean isReturnedListUnmodified(MethodInvocationTree mit) {
    Symbol assignedVariable = findAssignedVariable(mit.parent());
    return assignedVariable == null || assignedVariable.usages().stream().noneMatch(CollectorsToListCheck::isListBeingModified);
  }

  private static boolean isInvariantTypeArgument(MethodInvocationTree collectMethodInvocation) {
    Type streamType = collectMethodInvocation.methodSymbol().owner().type();
    if (streamType.isRawType()) {
      return true;
    }
    Type collectArgType = collectMethodInvocation.symbolType().typeArguments().get(0);
    Type streamArgType = streamType.typeArguments().get(0);
    return collectArgType.is(streamArgType.fullyQualifiedName());
  }

  private void reportIssue(MethodInvocationTree collector, boolean mutable) {
    String message = mutable? String.format(MESSAGE, ""toList"", "" and ensure that the list is unmodified"")
      : String.format(MESSAGE, ""toUnmodifiableList"", """");
    reportIssue(collector, message);
  }

  private static boolean isListBeingModified(Tree list) {
    return isListTargetOfCallAndBeingModified(list) || isListArgumentToCollectionsMutatorMethod(list);
  }

  private static boolean isListArgumentToCollectionsMutatorMethod(Tree list) {
    if (list.parent().is(Tree.Kind.ARGUMENTS)) {
      Tree potentialMethodInvocation = list.parent().parent();
      if (potentialMethodInvocation.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree mit = (MethodInvocationTree) potentialMethodInvocation;
        return COLLECTIONS_MUTATOR_METHODS.matches(mit);
      }
    }
    return false;
  }

  private static boolean isListTargetOfCallAndBeingModified(Tree list) {
    while (list.parent().is(Tree.Kind.ARRAY_ACCESS_EXPRESSION, Tree.Kind.MEMBER_SELECT)) {
      Tree possibleMethodInvocation = list.parent().parent();
      if (possibleMethodInvocation.is(Tree.Kind.METHOD_INVOCATION)) {
        MethodInvocationTree mit = (MethodInvocationTree) possibleMethodInvocation;
        ExpressionTree receiver = ((MemberSelectExpressionTree) mit.methodSelect()).expression();
        return receiver == list && LIST_MODIFICATION_METHODS.matches(mit);
      }
      list = list.parent();
    }
    return false;
  }

  @CheckForNull
  private static Symbol findAssignedVariable(Tree tree) {
    return switch (tree.kind()) {
      case ASSIGNMENT -> findAssignedVariable(((AssignmentExpressionTree) tree).variable());
      case VARIABLE -> ((VariableTree) tree).symbol();
      case IDENTIFIER -> ((IdentifierTree) tree).symbol();
      case MEMBER_SELECT -> ((MemberSelectExpressionTree) tree).identifier().symbol();
      case ARRAY_ACCESS_EXPRESSION -> findAssignedVariable(((ArrayAccessExpressionTree) tree).expression());
      default -> null;
    };
  }
}
"
S6205,CODE_SMELL,Switch arrow labels should not use redundant keywords,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.BreakStatementTree;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.CaseLabelTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.YieldStatementTree;

@Rule(key = ""S6205"")
public class SwitchRedundantKeywordCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  private static final String MESSAGE = ""Remove this redundant %s."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CASE_GROUP);
  }

  @Override
  public void visitNode(Tree tree) {
    CaseGroupTree caseGroupTree = (CaseGroupTree) tree;
    boolean isCaseWithArrow = caseGroupTree.labels().stream().noneMatch(CaseLabelTree::isFallThrough);
    if (isCaseWithArrow) {
      caseGroupTree.body().stream()
        .filter(t -> t.is(Tree.Kind.BLOCK))
        .map(BlockTree.class::cast)
        .filter(b -> !b.body().isEmpty())
        .forEach(this::reportRedundantKeywords);
    }
  }

  private void reportRedundantKeywords(BlockTree blockTree) {
    List<StatementTree> body = blockTree.body();
    int statementsInBody = body.size();
    StatementTree lastStatement = body.get(statementsInBody - 1);

    if (statementsInBody == 1) {
      if (lastStatement.is(Tree.Kind.YIELD_STATEMENT)) {
        SyntaxToken yieldKeyword = ((YieldStatementTree) lastStatement).yieldKeyword();
        // Yield can never be implicit in a block, still checking it for defensive programming
        if (yieldKeyword != null) {
          reportStatementInBlock(yieldKeyword, blockTree, ""block and \""yield\"""");
        }
      } else {
        if (lastStatement.is(Tree.Kind.EXPRESSION_STATEMENT, Tree.Kind.THROW_STATEMENT)) {
          reportIssue(blockTree.openBraceToken(),
            String.format(MESSAGE, ""block""),
            Collections.singletonList(new JavaFileScannerContext.Location(""Redundant close brace"", blockTree.closeBraceToken())),
            null);
        }
      }
    } else if (lastStatement.is(Tree.Kind.BREAK_STATEMENT) && ((BreakStatementTree) lastStatement).label() == null) {
      if (statementsInBody == 2) {
        reportStatementInBlock(lastStatement, blockTree, ""block and \""break\"""");
      } else {
        reportIssue(lastStatement, String.format(MESSAGE, ""\""break\""""));
      }
    }
  }

  private void reportStatementInBlock(Tree statement, BlockTree blockTree, String redundantParts) {
    reportIssue(statement, String.format(MESSAGE, redundantParts), blockBraceLocations(blockTree), null);
  }

  private static List<JavaFileScannerContext.Location> blockBraceLocations(BlockTree blockTree) {
    return Arrays.asList(new JavaFileScannerContext.Location(""Redundant opening brace"", blockTree.openBraceToken()),
      new JavaFileScannerContext.Location(""Redundant closing brace"", blockTree.closeBraceToken()));
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava14Compatible();
  }

}
"
S6206,CODE_SMELL,Records should be used instead of ordinary classes when representing immutable data structure,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ArrayTypeTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.PrimitiveTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6206"")
public class RecordInsteadOfClassCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava16Compatible();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (classTree.superClass() != null) {
      // records can not extends other classes
      return;
    }
    Symbol.TypeSymbol classSymbol = classTree.symbol();
    if (classSymbol.isAbstract()) {
      // records can not be abstract
      return;
    }
    if (!classSymbol.isFinal()) {
      // records can not be extended
      return;
    }

    List<Symbol.VariableSymbol> fields = classFields(classSymbol);
    if (fields.isEmpty() || !hasOnlyPrivateFinalFields(fields)) {
      return;
    }
    List<Symbol.MethodSymbol> methods = classMethods(classSymbol);
    Map<String, Type> fieldsNameToType = fields.stream().collect(Collectors.toMap(Symbol::name, Symbol::type));

    if (!hasGetterForEveryField(methods, fieldsNameToType)) {
      return;
    }
    List<Symbol.MethodSymbol> constructors = classConstructors(methods);
    if (constructors.size() != 1) {
      return;
    }
    Symbol.MethodSymbol constructor = constructors.get(0);
    if (hasParameterForEveryField(constructor, fieldsNameToType.keySet()) && !constructorHasSmallerVisibility(constructor, classSymbol)) {
      reportIssue(classTree.simpleName(), String.format(""Refactor this class declaration to use 'record %s'."", recordName(classTree, constructor)));
    }
  }

  private static boolean constructorHasSmallerVisibility(Symbol.MethodSymbol constructor, Symbol.TypeSymbol classSymbol) {
    boolean constructorIsPrivate = constructor.isPrivate();
    boolean constructorIsPackageVisibility = constructor.isPackageVisibility();
    if (classSymbol.isPublic()) {
      return constructorIsPrivate || constructorIsPackageVisibility || constructor.isProtected();
    } else if (classSymbol.isProtected()) {
      return constructorIsPrivate || constructorIsPackageVisibility;
    } else if (classSymbol.isPackageVisibility()) {
      return constructorIsPrivate;
    }
    return false;
  }

  private static List<Symbol.MethodSymbol> classMethods(Symbol.TypeSymbol classSymbol) {
    return classSymbol
      .memberSymbols()
      .stream()
      .filter(Symbol::isMethodSymbol)
      .map(Symbol.MethodSymbol.class::cast)
      .toList();
  }

  private static List<Symbol.VariableSymbol> classFields(Symbol.TypeSymbol classSymbol) {
    return classSymbol
      .memberSymbols()
      .stream()
      .filter(Symbol::isVariableSymbol)
      // records can have constant, so discarding them
      .filter(s -> !isConstant(s))
      .map(Symbol.VariableSymbol.class::cast)
      .toList();
  }

  private static List<Symbol.MethodSymbol> classConstructors(List<Symbol.MethodSymbol> methods) {
    return methods.stream()
      .filter(m -> ""<init>"".equals(m.name()))
      // only explicit constructors
      .filter(m -> m.declaration() != null)
      .toList();
  }

  private static boolean hasOnlyPrivateFinalFields(List<Symbol.VariableSymbol> fields) {
    return fields.stream()
      .allMatch(RecordInsteadOfClassCheck::isPrivateFinal);
  }

  private static boolean isConstant(Symbol symbol) {
    return symbol.isStatic() && symbol.isFinal();
  }

  private static boolean isPrivateFinal(Symbol symbol) {
    return symbol.isPrivate() && symbol.isFinal();
  }

  private static boolean hasGetterForEveryField(List<Symbol.MethodSymbol> methods, Map<String, Type> fieldsNameToType) {
    Set<String> gettersForField = methods.stream()
      .filter(m -> isGetter(m, fieldsNameToType))
      .map(Symbol::name)
      .map(RecordInsteadOfClassCheck::toFieldName)
      .collect(Collectors.toSet());
    return gettersForField.containsAll(fieldsNameToType.keySet());
  }

  private static boolean isGetter(Symbol.MethodSymbol method, Map<String, Type> fieldsNameToType) {
    String methodName = method.name();
    if (!method.parameterTypes().isEmpty()) {
      return false;
    }
    if (matchNameAndType(methodName, method, fieldsNameToType)) {
      // simple more recent 'myField()' form for getters
      return true;
    }
    if (""get"".equals(methodName) || ""is"".equals(methodName)) {
      return false;
    }
    // traditional getters: 'getMyField()' or 'isMyBooleanField()'
    return (methodName.startsWith(""get"") || methodName.startsWith(""is""))
      && matchNameAndType(toFieldName(methodName), method, fieldsNameToType);
  }

  private static boolean matchNameAndType(String methodName, Symbol.MethodSymbol method, Map<String, Type> fieldsNameToType) {
    return method.returnType().type().equals(fieldsNameToType.get(methodName));
  }

  private static String toFieldName(String methodName) {
    if (methodName.startsWith(""is"")) {
      return lowerCaseFirstLetter(methodName.substring(2));
    }
    if (methodName.startsWith(""get"")) {
      return lowerCaseFirstLetter(methodName.substring(3));
    }
    return methodName;
  }

  private static String lowerCaseFirstLetter(String methodName) {
    return Character.toLowerCase(methodName.charAt(0)) + methodName.substring(1);
  }

  private static boolean hasParameterForEveryField(Symbol.MethodSymbol constructor, Set<String> fieldNames) {
    Set<String> parameterNames = constructor.declaration()
      .parameters()
      .stream()
      .map(VariableTree::simpleName)
      .map(IdentifierTree::name)
      .collect(Collectors.toSet());
    return parameterNames.equals(fieldNames);
  }

  private static String recordName(ClassTree classTree, Symbol.MethodSymbol constructor) {
    String typeName = classTree.simpleName().name();
    return String.format(""%s(%s)"", typeName, parametersAsString(constructor.declaration().parameters()));
  }

  private static String parametersAsString(List<VariableTree> parameters) {
    String parametersAsString = parameters.stream()
      .map(p -> String.format(""%s %s"", typeAsString(p.type()), p.simpleName().name()))
      .collect(Collectors.joining("", ""));
    if (parametersAsString.length() > 50) {
      return parametersAsString.substring(0, 47) + ""..."";
    }
    return parametersAsString;
  }private static String typeAsString(TypeTree type) {
    switch (type.kind()) {
      case PARAMETERIZED_TYPE:
        return typeAsString(((ParameterizedTypeTree) type).type()) + ""<...>"";
      case IDENTIFIER:
        return ((IdentifierTree) type).name();
      case ARRAY_TYPE:
        ArrayTypeTree arrayTypeTree = (ArrayTypeTree) type;
        String arrayText = arrayTypeTree.ellipsisToken() != null ? "" ..."" : ""[]"";
        return typeAsString(arrayTypeTree.type()) + arrayText;
      case PRIMITIVE_TYPE:
        return ((PrimitiveTypeTree) type).keyword().text();
      case MEMBER_SELECT:
        return typeAsString(((MemberSelectExpressionTree) type).identifier());
      default:
        // This should not be possible. The Remaining TypeTrees are UnionType, WildcardType and VarType, which can not be used in such context
        return ""?"";
    }
  }
}
"
S6207,CODE_SMELL,Redundant constructors/methods should be avoided in records,"package org.sonar.java.checks;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6207"")
public class RedundantRecordMethodsCheck extends IssuableSubscriptionVisitor {
  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree targetRecord = (ClassTree) tree;

    List<Symbol.VariableSymbol> components = targetRecord.recordComponents().stream()
      .map(VariableTree::symbol)
      .filter(Symbol.VariableSymbol.class::isInstance)
      .map(Symbol.VariableSymbol.class::cast)
      .toList();
    Set<String> componentNames = components.stream()
      .map(Symbol.VariableSymbol::name)
      .collect(Collectors.toSet());

    for (Tree member : targetRecord.members()) {
      if (member.is(Tree.Kind.CONSTRUCTOR)) {
        checkConstructor((MethodTree) member, components);
      } else if (member.is(Tree.Kind.METHOD)) {
        checkMethod((MethodTree) member, components, componentNames);
      }
    }
  }

  private void checkConstructor(MethodTree constructor, List<Symbol.VariableSymbol> components) {
    if (constructor.block().body().isEmpty() || onlyDoesSimpleAssignments(constructor, components)) {
      reportIssue(constructor.simpleName(), ""Remove this redundant constructor which is the same as a default one."");
    }
  }

  private void checkMethod(MethodTree method, List<Symbol.VariableSymbol> components, Set<String> componentsByName) {
    String methodName = method.symbol().name();
    if (!componentsByName.contains(methodName)) {
      return;
    }
    if (onlyReturnsRawValue(method, components)) {
      reportIssue(method.simpleName(), ""Remove this redundant method which is the same as a default one."");
    }
  }

  public static boolean onlyReturnsRawValue(MethodTree method, Collection<Symbol.VariableSymbol> components) {
    Optional<ReturnStatementTree> returnStatement = getFirstReturnStatement(method);
    if (!returnStatement.isPresent()) {
      return false;
    }
    ExpressionTree expression = returnStatement.get().expression();
    Symbol identifierSymbol;
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      identifierSymbol = ((IdentifierTree) expression).symbol();
    } else if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      identifierSymbol = (((MemberSelectExpressionTree) expression).identifier()).symbol();
    } else {
      return false;
    }
    return components.stream().anyMatch(identifierSymbol::equals);
  }

  private static Optional<ReturnStatementTree> getFirstReturnStatement(MethodTree method) {
    return method.block().body().stream()
      .filter(statement -> statement.is(Tree.Kind.RETURN_STATEMENT))
      .map(ReturnStatementTree.class::cast)
      .findFirst();
  }

  public static boolean onlyDoesSimpleAssignments(MethodTree constructor, List<Symbol.VariableSymbol> components) {
    if (constructor.parameters().size() != components.size()) {
      return false;
    }
    List<Symbol.VariableSymbol> parameters = constructor.parameters().stream()
      .map(parameter -> (Symbol.VariableSymbol) parameter.symbol())
      .toList();
    List<AssignmentExpressionTree> assignments = extractAssignments(constructor.block().body());
    Set<Symbol> componentsAssignedInConstructor = new HashSet<>();
    for (AssignmentExpressionTree assignment : assignments) {
      assignsParameterToComponent(assignment, components, parameters).ifPresent(componentsAssignedInConstructor::add);
    }
    return componentsAssignedInConstructor.containsAll(components);
  }

  private static List<AssignmentExpressionTree> extractAssignments(List<StatementTree> statements) {
    return statements.stream()
      .map(RedundantRecordMethodsCheck::extractAssignment)
      .filter(Optional::isPresent)
      .map(Optional::get)
      .toList();
  }

  private static Optional<AssignmentExpressionTree> extractAssignment(StatementTree statement) {
    if (!statement.is(Tree.Kind.EXPRESSION_STATEMENT)) {
      return Optional.empty();
    }
    ExpressionStatementTree initialStatement = (ExpressionStatementTree) statement;
    if (!initialStatement.expression().is(Tree.Kind.ASSIGNMENT)) {
      return Optional.empty();
    }
    return Optional.of((AssignmentExpressionTree) initialStatement.expression());
  }private static Optional<Symbol.VariableSymbol> assignsParameterToComponent(
    AssignmentExpressionTree assignment,
    List<Symbol.VariableSymbol> components,
    List<Symbol.VariableSymbol> parameters) {
    ExpressionTree leftHandSide = assignment.variable();
    if (!leftHandSide.is(Tree.Kind.MEMBER_SELECT)) {
      return Optional.empty();
    }
    Symbol variableSymbol = ((MemberSelectExpressionTree) leftHandSide).identifier().symbol();
    Optional<Symbol.VariableSymbol> component = components.stream()
      .filter(variableSymbol::equals)
      .findFirst();
    if (!component.isPresent()) {
      return Optional.empty();
    }
    ExpressionTree rightHandSide = assignment.expression();
    if (!rightHandSide.is(Tree.Kind.IDENTIFIER)) {
      return Optional.empty();
    }
    Symbol valueSymbol = ((IdentifierTree) rightHandSide).symbol();
    if (parameters.stream().anyMatch(valueSymbol::equals) && variableSymbol.name().equals(valueSymbol.name())) {
      return component;
    }
    return Optional.empty();
  }
}
"
S6208,CODE_SMELL,Comma-separated labels should be used in Switch with colon case,"package org.sonar.java.checks;

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.List;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.ast.visitors.SubscriptionVisitor;
import org.sonar.java.model.DefaultJavaFileScannerContext;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.CaseLabelTree;
import org.sonar.plugins.java.api.tree.SwitchTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6208"")
public class SwitchCasesShouldBeCommaSeparatedCheck extends SubscriptionVisitor implements JavaVersionAwareVisitor {
  private static final String MESSAGE = ""Merge the previous cases into this one using comma-separated label."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(
      Tree.Kind.SWITCH_EXPRESSION,
      Tree.Kind.SWITCH_STATEMENT
    );
  }

  @Override
  public void visitNode(Tree tree) {
    SwitchTree switchExpression = (SwitchTree) tree;
    if (!usesColons(switchExpression)) {
      return;
    }
    for (CaseGroupTree aCase : switchExpression.cases()) {
      List<CaseLabelTree> labels = aCase.labels();
      int size = labels.size();
      if (size == 1) {
        continue;
      }

      Deque<CaseLabelTree> caseLabels = labels.stream()
        .filter(label -> ""case"".equals(label.caseOrDefaultKeyword().text()))
        .collect(Collectors.toCollection(ArrayDeque::new));

      if (caseLabels.size() > 1) {
        CaseLabelTree lastLabel = caseLabels.removeLast();
        ((DefaultJavaFileScannerContext) context).newIssue()
          .forRule(this)
          .onTree(lastLabel)
          .withMessage(MESSAGE)
          .withSecondaries(caseLabels.stream().map(label -> new JavaFileScannerContext.Location("""", label)).toList())
          .report();
      }

    }
    super.visitNode(tree);
  }

  public static boolean usesColons(SwitchTree tree) {
    return !tree.cases().isEmpty() &&
      "":"".equals(tree.cases().get(0).labels().get(0).colonOrArrowToken().text());
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return 14 <= version.asInt();
  }
}
"
S6209,BUG,Members ignored during record serialization should not be used,"package org.sonar.java.checks.serialization;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6209"")
public class RecordSerializationIgnoredMembersCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers SERIALIZABLE_MATCHERS = MethodMatchers.or(
    // java.io.Serializable contract
    methodMatcher(""readObjectNoData""),
    methodMatcher(""readObject"", ""java.io.ObjectInputStream""),
    methodMatcher(""writeObject"", ""java.io.ObjectOutputStream""),
    // java.io.Externalizable contract
    methodMatcher(""readExternal"", ""java.io.ObjectInput""),
    methodMatcher(""writeExternal"", ""java.io.ObjectOutput""));

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    for (Tree member : ((ClassTree) tree).members()) {
      if (member.is(Tree.Kind.VARIABLE)) {
        checkField((VariableTree) member);
      } else if (member.is(Tree.Kind.METHOD)) {
        checkMethod((MethodTree) member);
      }
    }
  }

  private void checkField(VariableTree field) {
    if (isSerialPersistentFields(field.symbol())) {
      reportIssue(field.simpleName(), issueMessage(""field""));
    }
  }

  private static boolean isSerialPersistentFields(Symbol field) {
    // a non-static serialPersistentFields field causes compilation errors
    return ""serialPersistentFields"".equals(field.name())
      && field.isPrivate()
      && field.isFinal()
      && field.type().is(""java.io.ObjectStreamField[]"");
  }

  private void checkMethod(MethodTree method) {
    Symbol.MethodSymbol methodSymbol = method.symbol();
    if (!SERIALIZABLE_MATCHERS.matches(methodSymbol)) {
      return;
    }
    if (isFromExternalizable(methodSymbol) || isFromSerializable(methodSymbol)) {
      reportIssue(method.simpleName(), issueMessage(""method""));
    }
  }

  private static boolean isFromSerializable(Symbol.MethodSymbol method) {
    return method.name().contains(""Object"") && method.isPrivate();
  }

  private static boolean isFromExternalizable(Symbol.MethodSymbol method) {
    return method.name().contains(""External"") && !method.overriddenSymbols().isEmpty();
  }

  private static String issueMessage(String tree) {
    return String.format(""Remove this %s that will be ignored during record serialization."", tree);
  }

  private static MethodMatchers methodMatcher(String methodName, String ... parameterTypes) {
    return MethodMatchers.create()
      // since we target method declarations, checking the owner is not relevant
      .ofAnyType()
      .names(methodName)
      .addParametersMatcher(parameterTypes)
      .build();
  }
}
"
S6211,CODE_SMELL,Custom getter method should not be used to override record's getter behavior,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.SyntacticEquivalence;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Symbol.MethodSymbol;
import org.sonar.plugins.java.api.semantic.Type.Primitives;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6211"")
public class RecordDuplicatedGetterCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    Symbol.TypeSymbol recordSymbol = ((ClassTree) tree).symbol();

    for (Symbol.VariableSymbol component : recordComponents(recordSymbol)) {
      findDeclaredMethod(recordSymbol, getterName(component)).ifPresent(m -> checkConflictWithAccessor(recordSymbol, component, m));
    }
  }

  private static String getterName(Symbol.VariableSymbol component) {
    return (component.type().isPrimitive(Primitives.BOOLEAN) ? ""is"" : ""get"") + upperCaseFirstCharacter(component.name());
  }

  private void checkConflictWithAccessor(Symbol.TypeSymbol recordSymbol, Symbol.VariableSymbol component, MethodTree getter) {
    if (isDirectCallToAccessor(getter, component) || isPojoGetter(getter, component)) {
      return;
    }
    Optional<MethodTree> accessor = findDeclaredMethod(recordSymbol, component.name());
    if (!accessor.isPresent()) {
      reportIssue(getter.simpleName(), issueMessage(getter, component));
    } else {
      MethodTree accessorMethod = accessor.get();
      if (!SyntacticEquivalence.areEquivalent(accessorMethod.block(), getter.block()) && !isDirectCallToGetter(accessorMethod, getter)) {
        reportIssue(getter.simpleName(), issueMessage(getter, component));
      }
    }
  }

  private static boolean isPojoGetter(MethodTree method, Symbol.VariableSymbol component) {
    return singleReturnStatementExpression(method).filter(expr -> isComponent(expr, component)).isPresent();
  }

  private static boolean isDirectCallToAccessor(MethodTree getter, Symbol.VariableSymbol component) {
    return singleReturnStatementExpression(getter).filter(expr -> isAccessorInvocation(expr, component)).isPresent();
  }

  private static boolean isDirectCallToGetter(MethodTree accessor, MethodTree getter) {
    return singleReturnStatementExpression(accessor).filter(expr -> isGetterInvocation(expr, getter.symbol()))
      .isPresent();
  }

  private static Optional<ExpressionTree> singleReturnStatementExpression(MethodTree method) {
    return Optional.ofNullable(method.block())
      .filter(b -> b.body().size() == 1)
      .map(b -> b.body().get(0))
      .filter(s -> s.is(Tree.Kind.RETURN_STATEMENT))
      .map(ReturnStatementTree.class::cast)
      .map(ReturnStatementTree::expression)
      .filter(Objects::nonNull);
  }

  private static boolean isComponent(ExpressionTree expression, Symbol.VariableSymbol component) {
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      return component.equals(((IdentifierTree) expression).symbol());
    }
    if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree mset = (MemberSelectExpressionTree) expression;
      return ExpressionUtils.isThis(mset.expression())
        && isComponent(mset.identifier(), component);
    }
    return false;
  }

  private static boolean isAccessorInvocation(ExpressionTree expression, Symbol.VariableSymbol component) {
    if (!expression.is(Tree.Kind.METHOD_INVOCATION)) {
      return false;
    }
    MethodInvocationTree mit = (MethodInvocationTree) expression;
    Symbol methodSymbol = mit.methodSymbol();
    return mit.arguments().isEmpty()
      && component.name().equals(methodSymbol.name())
      && component.owner().equals(methodSymbol.owner());
  }

  private static boolean isGetterInvocation(ExpressionTree expression, Symbol.MethodSymbol getter) {
    return expression.is(Tree.Kind.METHOD_INVOCATION) && getter.equals(((MethodInvocationTree) expression).methodSymbol());
  }

  private static String issueMessage(MethodTree getter, Symbol.VariableSymbol component) {
    return String.format(""Remove this getter '%s()' from record and override an existing one '%s()'."", getter.simpleName().name(), component.name());
  }

  private static List<Symbol.VariableSymbol> recordComponents(Symbol.TypeSymbol recordSymbol) {
    return recordSymbol
      .memberSymbols()
      .stream()
      .filter(Symbol::isVariableSymbol)
      .map(Symbol.VariableSymbol.class::cast)
      .toList();
  }

  private static Optional<MethodTree> findDeclaredMethod(Symbol.TypeSymbol recordSymbol, String methodName) {
    return recordSymbol.lookupSymbols(methodName)
      .stream()
      .filter(Symbol::isMethodSymbol)
      .filter(Symbol::isPublic)
      .map(Symbol.MethodSymbol.class::cast)
      .filter(m -> m.parameterTypes().isEmpty())
      // only keep explicit declaration
      .map(MethodSymbol::declaration)
      .filter(Objects::nonNull)
      .findFirst();
  }

  private static String upperCaseFirstCharacter(String string) {
    return Character.toUpperCase(string.charAt(0)) + string.substring(1);
  }
}
"
S6212,CODE_SMELL,Local-Variable Type Inference should be used,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Locale;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.LineUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6212"")
public class VarCanBeUsedCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  public static final String MESSAGE = ""Declare this local variable with \""var\"" instead."";
  private int typeAssignmentLine = -1;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.VARIABLE);
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava10Compatible();
  }

  @Override
  public void setContext(JavaFileScannerContext context) {
    typeAssignmentLine = -1;
    super.setContext(context);
  }

  @Override
  public void visitNode(Tree tree) {
    VariableTree variableTree = (VariableTree) tree;
    ExpressionTree initializer = variableTree.initializer();
    TypeTree type = variableTree.type();
    Type symbolType = type.symbolType();
    String typeName = symbolType.name().toLowerCase(Locale.ROOT);
    IdentifierTree identifierTree = variableTree.simpleName();

    if (isMultiAssignment(variableTree) ||
      initializer == null ||
      type.is(Tree.Kind.VAR_TYPE) ||
      isArrayInitializerWithoutType(initializer) ||
      symbolType.isUnknown() ||
      !variableTree.symbol().isLocalVariable() ||
      symbolType.isParameterized()) {
      return;
    }

    initializer = ExpressionUtils.skipParentheses(initializer);

    if (isExcludedInitializer(initializer)) {
      return;
    }

    Type initializerType = initializer.symbolType();
    if (symbolType.fullyQualifiedName().equals(initializerType.fullyQualifiedName()) &&
      (isSelfExplained(initializer) ||
        typeWasMentionedInTheName(identifierTree, typeName) ||
        typeWasMentionedInTheInitializer(initializer, typeName))) {
      reportIssue(identifierTree, MESSAGE);
    }
  }

  private static boolean isExcludedInitializer(ExpressionTree initializer) {
    if (initializer.is(Tree.Kind.METHOD_INVOCATION)) {
      Symbol.MethodSymbol symbol = ((MethodInvocationTree) initializer).methodSymbol();
      return !symbol.isUnknown() && symbol.isParametrizedMethod();
    }
    return initializer.is(Tree.Kind.CONDITIONAL_EXPRESSION, Tree.Kind.METHOD_REFERENCE, Tree.Kind.LAMBDA_EXPRESSION);
  }

  private static boolean typeWasMentionedInTheName(IdentifierTree variable, String type) {
    return isLogicallyReferable(variable.name(), type);
  }

  private static boolean isSelfExplained(ExpressionTree initializer) {
    return initializer.is(Tree.Kind.NEW_CLASS, Tree.Kind.NEW_ARRAY) || initializer instanceof LiteralTree;
  }

  private static boolean typeWasMentionedInTheInitializer(ExpressionTree initializer, String type) {
    if (initializer.is(Tree.Kind.IDENTIFIER) && typeWasMentionedInTheName(((IdentifierTree) initializer), type)) {
      return true;
    } else if (initializer.is(Tree.Kind.METHOD_INVOCATION)) {
      ExpressionTree methodSelect = ExpressionUtils.skipParentheses(((MethodInvocationTree) initializer).methodSelect());
      if (methodSelect.is(Tree.Kind.IDENTIFIER) && typeWasMentionedInTheName((IdentifierTree) methodSelect, type)) {
        return true;
      } else if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree memberSelectExpressionTree = (MemberSelectExpressionTree) methodSelect;
        return typeWasMentionedInTheName(memberSelectExpressionTree.identifier(), type) ||
          (memberSelectExpressionTree.expression().is(Tree.Kind.IDENTIFIER) &&
            typeWasMentionedInTheName((IdentifierTree) memberSelectExpressionTree.expression(), type));
      }
    }
    return false;
  }

  private static boolean isLogicallyReferable(String identifierName, String typeName) {
    return identifierName.toLowerCase(Locale.ROOT).contains(typeName);
  }

  private boolean isMultiAssignment(VariableTree variableTree) {
    SyntaxToken firstToken = variableTree.type().firstToken();
    if (firstToken == null) {
      return false;
    }
    int line = LineUtils.startLine(firstToken);
    if (typeAssignmentLine == line) {
      return true;
    }
    typeAssignmentLine = line;
    SyntaxToken token = variableTree.endToken();
    return token != null && "","".equals(token.text());
  }

  private static boolean isArrayInitializerWithoutType(ExpressionTree initializer) {
    return initializer.is(Tree.Kind.NEW_ARRAY) && ((NewArrayTree) initializer).newKeyword() == null;
  }
}
"
S6213,CODE_SMELL,Restricted Identifiers should not be used as Identifiers,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Arrays;
import java.util.List;
import java.util.Set;

@Rule(key = ""S6213"")
public class RestrictedIdentifiersUsageCheck extends IssuableSubscriptionVisitor {

  private static final Set<String> RESTRICTED_IDENTIFIERS = SetUtils.immutableSetOf(""var"", ""record"", ""yield"");
  private static final String MESSAGE = ""Rename this %s to not match a restricted identifier."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.VARIABLE, Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.VARIABLE)) {
      VariableTree variableTree = (VariableTree) tree;
      IdentifierTree identifierTree = variableTree.simpleName();
      reportRestrictedIdentifier(identifierTree, ""variable"");
    } else {
      MethodTree methodTree = (MethodTree) tree;
      IdentifierTree identifierTree = methodTree.simpleName();
      reportRestrictedIdentifier(identifierTree, ""method"");
    }
  }

  private void reportRestrictedIdentifier(IdentifierTree identifierTree, String method) {
    if (RESTRICTED_IDENTIFIERS.contains(identifierTree.name())) {
      reportIssue(identifierTree, String.format(MESSAGE, method));
    }
  }
}
"
S6216,BUG,Reflection should not be used to increase accessibility of records' fields,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6216"")
public class AccessibilityChangeOnRecordsCheck extends AbstractAccessibilityChangeChecker {
  private static final String MESSAGE = ""Remove this private field update which will never succeed"";
  private static final String SECONDARY_MESSAGE = ""Remove this accessibility bypass which will never succeed"";

  private Map<Symbol, MethodInvocationTree> primaryTargets = new HashMap<>();
  private Map<Symbol, List<MethodInvocationTree>> secondaryTargets = new HashMap<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.COMPILATION_UNIT, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      primaryTargets.clear();
      secondaryTargets.clear();
    }
    super.visitNode(tree);
  }

  @Override
  public void leaveNode(Tree tree) {
    if (tree.is(Tree.Kind.COMPILATION_UNIT)) {
      for (Map.Entry<Symbol, MethodInvocationTree> entry : primaryTargets.entrySet()) {
        Symbol symbol = entry.getKey();
        MethodInvocationTree setInvocation = entry.getValue();
        List<JavaFileScannerContext.Location> secondaries = secondaryTargets.getOrDefault(symbol, Collections.emptyList())
          .stream()
          .map(mit -> new JavaFileScannerContext.Location(SECONDARY_MESSAGE, mit))
          .toList();
        reportIssue(setInvocation, MESSAGE, secondaries, null);
      }
    }
    super.leaveNode(tree);
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (!isModifyingFieldFromRecord(mit)) {
      return;
    }
    if (SET_MATCHERS.matches(mit)) {
      Optional<Symbol> symbol = getIdentifierSymbol(mit);
      if (symbol.isPresent()) {
        primaryTargets.put(symbol.get(), mit);
      } else {
        reportIssue(mit, MESSAGE);
      }
    } else if (setsToPubliclyAccessible(mit)) {
      Optional<Symbol> symbol = getIdentifierSymbol(mit);
      symbol.ifPresent(key -> {
        List<MethodInvocationTree> secondaries = secondaryTargets.getOrDefault(key, new ArrayList<>());
        secondaries.add(mit);
        secondaryTargets.put(key, secondaries);
      });
    }
  }private static Optional<Symbol> getIdentifierSymbol(MethodInvocationTree mit) {
    ExpressionTree expression = mit.methodSelect();
    if (!expression.is(Tree.Kind.MEMBER_SELECT)) {
      return Optional.empty();
    }
    MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) expression;
    ExpressionTree callee = memberSelect.expression();
    if (!callee.is(Tree.Kind.IDENTIFIER)) {
      return Optional.empty();
    }
    IdentifierTree identifier = (IdentifierTree) callee;
    return Optional.of(identifier.symbol());
  }
}
"
S6217,CODE_SMELL,Permitted types of a sealed class should be omitted if they are declared in the same file,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ListTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;

import static org.sonar.java.reporting.AnalyzerMessage.textSpanBetween;

@Rule(key = ""S6217"")
public class OmitPermittedTypesCheck extends IssuableSubscriptionVisitor {

  private static final String MESSAGE = ""Remove this redundant permitted list."";

  private final List<ClassTree> sealedClassesInFile = new ArrayList<>();
  private final Set<Type> typesDeclaredInFile = new HashSet<>();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (classTree.permitsKeyword() != null) {
      sealedClassesInFile.add(classTree);
    }
    typesDeclaredInFile.add(classTree.symbol().type());
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    for (ClassTree sealedClass : sealedClassesInFile) {
      ListTree<TypeTree> permittedTypes = sealedClass.permittedTypes();
      if (permittedTypes.stream().map(TypeTree::symbolType).allMatch(typesDeclaredInFile::contains)) {
        SyntaxToken permitsKeyword = sealedClass.permitsKeyword();
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(permitsKeyword)
          .withMessage(MESSAGE)
          .withSecondaries(permittedTypes.stream().map(t ->
            new JavaFileScannerContext.Location(""Permitted type"", t))
            .toList())
          .withQuickFix(() -> getQuickFix(permitsKeyword, permittedTypes))
          .report();
      }
    }
    sealedClassesInFile.clear();
    typesDeclaredInFile.clear();
    super.leaveFile(context);
  }

  private static JavaQuickFix getQuickFix(SyntaxToken permitsKeyword, ListTree<TypeTree> typeTrees) {
    return JavaQuickFix.newQuickFix(""Remove permitted list"")
      .addTextEdit(JavaTextEdit.removeTextSpan(textSpanBetween(
        permitsKeyword, true, QuickFixHelper.nextToken(typeTrees), false)))
      .build();
  }

}
"
S6218,BUG,Equals method should be overridden in records containing array fields,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6218"")
public class MissingOverridesInRecordWithArrayComponentCheck extends IssuableSubscriptionVisitor {
  private static final MethodMatchers EQUALS_MATCHER = MethodMatchers.create()
    .ofAnyType()
    .names(""equals"")
    .addParametersMatcher(""java.lang.Object"")
    .build();

  private static final MethodMatchers HASH_CODE_MATCHER = MethodMatchers.create()
    .ofAnyType()
    .names(""hashCode"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers TO_STRING_MATCHER = MethodMatchers.create()
    .ofAnyType()
    .names(""toString"")
    .addWithoutParametersMatcher()
    .build();

  private static final String MESSAGE_TEMPLATE = ""Override %s to consider array's content in the method"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree targetRecord = (ClassTree) tree;

    List<VariableTree> recordArrayComponents = targetRecord.recordComponents().stream()
      .filter(component -> component.symbol().type().isArray())
      .toList();

    if (recordArrayComponents.isEmpty()) {
      return;
    }

    inspectRecord(targetRecord)
      .ifPresent(composedMessage -> reportIssue(targetRecord.simpleName(), composedMessage, secondaries(recordArrayComponents), null));
  }

  private static List<JavaFileScannerContext.Location> secondaries(List<VariableTree> recordArrayComponents) {
    return recordArrayComponents.stream()
      .map(arrayComponent -> new JavaFileScannerContext.Location(""Array"", arrayComponent))
      .toList();
  }

  public static Optional<String> inspectRecord(ClassTree tree) {
    boolean equalsIsOverridden = false;
    boolean hashCodeIsOverridden = false;
    boolean toStringIsOverridden = false;
    for (Tree member : tree.members()) {
      if (!member.is(Tree.Kind.METHOD)) {
        continue;
      }
      MethodTree method = (MethodTree) member;
      if (EQUALS_MATCHER.matches(method)) {
        equalsIsOverridden = true;
      } else if (HASH_CODE_MATCHER.matches(method)) {
        hashCodeIsOverridden = true;
      } else if (TO_STRING_MATCHER.matches(method)) {
        toStringIsOverridden = true;
      }
    }
    return computeMessage(equalsIsOverridden, hashCodeIsOverridden, toStringIsOverridden);
  }

  private static Optional<String> computeMessage(boolean equalsIsOverridden, boolean hashCodeIsOverridden, boolean toStringIsOverridden) {
    List<String> missingOverrides = new ArrayList<>(3);
    if (!equalsIsOverridden) {
      missingOverrides.add(""equals"");
    }
    if (!hashCodeIsOverridden) {
      missingOverrides.add(""hashCode"");
    }
    if (!toStringIsOverridden) {
      missingOverrides.add(""toString"");
    }

    String filler = null;
    switch (missingOverrides.size()) {
      case 0:
        return Optional.empty();
      case 1:
        filler = missingOverrides.get(0);
        break;
      case 2:
        filler = missingOverrides.get(0) + "" and "" + missingOverrides.get(1);
        break;
      default:
        filler = missingOverrides.get(0) + "", "" + missingOverrides.get(1) + "" and "" + missingOverrides.get(2);
    }
    return Optional.of(String.format(MESSAGE_TEMPLATE, filler));
  }
}
"
S6219,CODE_SMELL,'serialVersionUID' field should not be set to '0L' in records,"package org.sonar.java.checks.serialization;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6219"")
public class SerialVersionUidInRecordCheck extends IssuableSubscriptionVisitor {
  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.RECORD);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree targetRecord = (ClassTree) tree;
    if (!targetRecord.symbol().type().isSubtypeOf(""java.io.Serializable"")) {
      return;
    }
    for (Tree member : targetRecord.members()) {
      if (!member.is(Tree.Kind.VARIABLE)) {
        continue;
      }
      VariableTree variable = (VariableTree) member;
      if (isSerialVersionUIDField(variable) && setsTheValueToZero(variable)) {
        reportIssue(variable, ""Remove this redundant \""serialVersionUID\"" field"");
        return;
      }
    }
  }

  private static boolean isSerialVersionUIDField(VariableTree variable) {
    Symbol symbol = variable.symbol();
    return symbol.isFinal() &&
      symbol.type().is(""long"") &&
      ""serialVersionUID"".equals(symbol.name());
  }

  private static boolean setsTheValueToZero(VariableTree variable) {
    ExpressionTree initializer = variable.initializer();
    if (initializer == null) {
      return false;
    }
    Optional<Long> longValue = initializer.asConstant(Long.class);
    if (longValue.isPresent()) {
      return longValue.get() == 0L;
    }
    Optional<Integer> integerValue = initializer.asConstant(Integer.class);
    return integerValue.isPresent() && integerValue.get() == 0;
  }
}
"
S6288,SECURITY_HOTSPOT,Authorizing non-authenticated users to use keys in the Android KeyStore is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.checks.helpers.MethodTreeUtils.subsequentMethodInvocation;

@Rule(key = ""S6288"")
public class AndroidNonAuthenticatedUsersCheck extends AbstractMethodDetection {

  private static final String KEY_GEN_PARAMETER_SPEC_BUILDER_TYPE = ""android.security.keystore.KeyGenParameterSpec$Builder"";

  private static final MethodMatchers KEY_GEN_BUILDER_BUILD = MethodMatchers.create()
    .ofTypes(KEY_GEN_PARAMETER_SPEC_BUILDER_TYPE)
    .names(""build"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers KEY_GEN_BUILDER_SET_AUTH_MATCHER = MethodMatchers.create()
    .ofTypes(KEY_GEN_PARAMETER_SPEC_BUILDER_TYPE)
    .names(""setUserAuthenticationRequired"")
    .addParametersMatcher(""boolean"")
    .build();

  private static final MethodMatchers KEY_GEN_BUILDER = MethodMatchers.create()
    .ofTypes(KEY_GEN_PARAMETER_SPEC_BUILDER_TYPE)
    .constructor()
    .withAnyParameters()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return KEY_GEN_BUILDER_BUILD;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    // Bottom-up approach, start from the method select of the ""build()"" method
    getNotAuthenticatedConstructor(mit.methodSelect()).ifPresent(newClassTree ->
      reportIssue(newClassTree.identifier(), ""Make sure authorizing non-authenticated users to use this key is safe here."")
    );
  }

  private static Optional<NewClassTree> getNotAuthenticatedConstructor(ExpressionTree expression) {
    if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      expression = ((MemberSelectExpressionTree) expression).expression();
    }

    if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) expression;
      if (!authenticate(mit)) {
        return getNotAuthenticatedConstructor(mit.methodSelect());
      }
    } else if (expression.is(Tree.Kind.IDENTIFIER)) {
      Symbol symbol = ((IdentifierTree) expression).symbol();
      if (symbol.usages().stream().anyMatch(AndroidNonAuthenticatedUsersCheck::canAuthenticate)) {
        return Optional.empty();
      }
      return getNotAuthenticatedConstructorInDeclaration(symbol);
    } else if (expression.is(Tree.Kind.NEW_CLASS)) {
      NewClassTree newClassTree = (NewClassTree) expression;
      if (KEY_GEN_BUILDER.matches(newClassTree)) {
        return Optional.of(newClassTree);
      }
    }
    return Optional.empty();
  }

  private static Optional<NewClassTree> getNotAuthenticatedConstructorInDeclaration(Symbol symbol) {
    if (symbol.isLocalVariable()) {
      Tree declaration = symbol.declaration();
      if (declaration instanceof VariableTree variableTree) {
        ExpressionTree initializer = variableTree.initializer();
        if (initializer != null) {
          return getNotAuthenticatedConstructor(initializer);
        }
      }
    }
    return Optional.empty();
  }

  private static boolean canAuthenticate(IdentifierTree tokenIdentifier) {
    Tree parent = tokenIdentifier.parent();
    if (parent != null && parent.is(Tree.Kind.ARGUMENTS)) {
      // When given as argument, we consider it as signed to avoid FP.
      return true;
    }
    Optional<MethodInvocationTree> subsequentInvocation = subsequentMethodInvocation(tokenIdentifier, KEY_GEN_BUILDER_SET_AUTH_MATCHER);
    return subsequentInvocation.isPresent() && LiteralUtils.isTrue(subsequentInvocation.get().arguments().get(0));
  }

  private static boolean authenticate(MethodInvocationTree mit) {
    return KEY_GEN_BUILDER_SET_AUTH_MATCHER.matches(mit) && LiteralUtils.isTrue(mit.arguments().get(0));
  }

}
"
S6291,SECURITY_HOTSPOT,Using unencrypted databases in mobile applications is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6291"")
public class AndroidUnencryptedDatabaseCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_LANG_STRING = ""java.lang.String"";
  private static final String ANDROID_CONTENT_CONTEXT = ""android.content.Context"";
  private static final String REALM_CONFIGURATION_BUILDER_TYPE = ""io.realm.RealmConfiguration$Builder"";

  private static final MethodMatchers UNSAFE_DATABASE_CALL = MethodMatchers.or(
    MethodMatchers.create()
      .ofSubTypes(""android.app.Activity"")
      .names(""getPreferences"")
      .addParametersMatcher(""int"")
      .build(),
    MethodMatchers.create()
      .ofSubTypes(""android.preference.PreferenceManager"")
      .names(""getDefaultSharedPreferences"")
      .addParametersMatcher(ANDROID_CONTENT_CONTEXT)
      .build(),
    MethodMatchers.create()
      .ofSubTypes(ANDROID_CONTENT_CONTEXT)
      .names(""getSharedPreferences"")
      .addParametersMatcher(JAVA_LANG_STRING, ""int"")
      .addParametersMatcher(""java.io.File"", ""int"")
      .build(),
    MethodMatchers.create()
      .ofSubTypes(ANDROID_CONTENT_CONTEXT)
      .names(""openOrCreateDatabase"")
      .addParametersMatcher(JAVA_LANG_STRING, ""int"", ""android.database.sqlite.SQLiteDatabase$CursorFactory"")
      .addParametersMatcher(JAVA_LANG_STRING, ""int"", ""android.database.sqlite.SQLiteDatabase$CursorFactory"", ""android.database.DatabaseErrorHandler"")
      .build()
  );

  private static final MethodMatchers REALM_CONFIGURATION_BUILDER_BUILD = MethodMatchers.create()
    .ofSubTypes(REALM_CONFIGURATION_BUILDER_TYPE)
    .names(""build"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers REALM_CONFIGURATION_BUILDER_ENCRYPTION_KEY = MethodMatchers.create()
    .ofSubTypes(REALM_CONFIGURATION_BUILDER_TYPE)
    .names(""encryptionKey"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers REALM_CONFIGURATION_BUILDER_BUILDER = MethodMatchers.create()
    .ofSubTypes(REALM_CONFIGURATION_BUILDER_TYPE)
    .constructor()
    .withAnyParameters()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;
    if (UNSAFE_DATABASE_CALL.matches(mit) || (REALM_CONFIGURATION_BUILDER_BUILD.matches(mit) && !isEncrypted(mit.methodSelect()))) {
      reportIssue(ExpressionUtils.methodName(mit), ""Make sure using an unencrypted database is safe here."");
    }
  }

  private static boolean isEncrypted(ExpressionTree expression) {
    if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      expression = ((MemberSelectExpressionTree) expression).expression();
    }

    if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) expression;
      if (!REALM_CONFIGURATION_BUILDER_ENCRYPTION_KEY.matches(mit)) {
        return isEncrypted(mit.methodSelect());
      }
    } else if (expression.is(Tree.Kind.IDENTIFIER)) {
      Symbol symbol = ((IdentifierTree) expression).symbol();
      if (symbol.usages().stream().anyMatch(AndroidUnencryptedDatabaseCheck::canEncryptToken)) {
        return true;
      }
      return declarationIsEncrypted(symbol);
    } else if (expression.is(Tree.Kind.NEW_CLASS)) {
      NewClassTree newClassTree = (NewClassTree) expression;
      if (REALM_CONFIGURATION_BUILDER_BUILDER.matches(newClassTree)) {
        return false;
      }
    }
    return true;
  }

  private static boolean canEncryptToken(IdentifierTree tokenIdentifier) {
    Tree parent = tokenIdentifier.parent();
    // When given as argument, we consider it as encrypted to avoid FP.
    return (parent != null && parent.is(Tree.Kind.ARGUMENTS)) ||
      MethodTreeUtils.subsequentMethodInvocation(tokenIdentifier, REALM_CONFIGURATION_BUILDER_ENCRYPTION_KEY).isPresent();
  }

  private static boolean declarationIsEncrypted(Symbol symbol) {
    if (symbol.isLocalVariable()) {
      Tree declaration = symbol.declaration();
      if (declaration instanceof VariableTree variableTree) {
        ExpressionTree initializer = variableTree.initializer();
        return initializer instanceof MethodInvocationTree && isEncrypted(initializer);
      }
    }
    // Can be encrypted anywhere (field, other file), we consider it as encrypted
    return true;
  }
}
"
S6293,SECURITY_HOTSPOT,Using biometric authentication without a cryptographic solution is security-sensitive,"package org.sonar.java.checks.security;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S6293"")
public class AndroidBiometricAuthWithoutCryptoCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    // no need to check method calls with CryptoObject null, NonNull required
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofTypes(""android.hardware.biometrics.BiometricPrompt"")
        .names(""authenticate"")
        .addParametersMatcher(""android.os.CancellationSignal"", ""java.util.concurrent.Executor"", ""android.hardware.biometrics.BiometricPrompt$AuthenticationCallback"")
        .build(),
      MethodMatchers.create()
        .ofTypes(""androidx.biometric.BiometricPrompt"")
        .names(""authenticate"")
        .addParametersMatcher(""androidx.biometric.BiometricPrompt$PromptInfo"")
        .build()
    );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIssue(ExpressionUtils.methodName(mit), ""Make sure performing a biometric authentication without a \""CryptoObject\"" is safe here."");
  }
}
"
S6300,SECURITY_HOTSPOT,Using unencrypted files in mobile applications is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6300"")
public class AndroidUnencryptedFilesCheck extends AbstractMethodDetection {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS);
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create()
        .ofSubTypes(""java.nio.file.Files"")
        .names(""write"")
        .withAnyParameters()
        .build(),
      MethodMatchers.create()
        .ofSubTypes(""java.io.FileWriter"",
          ""java.io.FileOutputStream"")
        .constructor()
        .withAnyParameters()
        .build()
    );
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    reportIfInAndroidContext(ExpressionUtils.methodName(mit));
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    reportIfInAndroidContext(newClassTree.identifier());
  }

  private void reportIfInAndroidContext(Tree tree) {
    if (context.inAndroidContext()) {
      reportIssue(tree, ""Make sure using unencrypted files is safe here."");
    }
  }

}
"
S6301,VULNERABILITY,Mobile database encryption keys should not be disclosed,"package org.sonar.java.checks.security;

import java.util.Arrays;
import java.util.List;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.ExpressionsHelper.getSingleWriteUsage;

@Rule(key = ""S6301"")
public class AndroidMobileDatabaseEncryptionKeysCheck extends IssuableSubscriptionVisitor {

  private static final String JAVA_LANG_STRING = ""java.lang.String"";

  private static final MethodMatchers SQLITE_DATABASE_CONSTRUCTOR = MethodMatchers.create()
    .ofTypes(""net.sqlcipher.database.SQLiteDatabase"")
    .constructor()
    .addParametersMatcher(args -> !args.isEmpty())
    .build();

  private static final MethodMatchers SQLITE_DATABASE_METHODS = MethodMatchers.create()
    .ofTypes(""net.sqlcipher.database.SQLiteDatabase"")
    .names(""changePassword"", ""openDatabase"", ""openOrCreateDatabase"", ""create"")
    .addParametersMatcher(args -> !args.isEmpty())
    .build();

  private static final MethodMatchers REALM_CONFIGURATION_BUILDER_ENCRYPTION_KEY = MethodMatchers.create()
    .ofTypes(""io.realm.RealmConfiguration$Builder"")
    .names(""encryptionKey"")
    .addParametersMatcher(""byte[]"")
    .build();

  private static final MethodMatchers JAVA_LANG_STRING_TO_CHAR_GET_BYTES = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(JAVA_LANG_STRING)
      .names(""toCharArray"")
      .addWithoutParametersMatcher()
      .build(),
    MethodMatchers.create()
      .ofTypes(JAVA_LANG_STRING)
      .names(""getBytes"")
      .addParametersMatcher(MethodMatchers.ANY)
      .build());

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.NEW_CLASS)) {
      final NewClassTree newClassTree = (NewClassTree) tree;
      if (SQLITE_DATABASE_CONSTRUCTOR.matches(newClassTree)) {
        reportIssueIfHardCoded(newClassTree.arguments().get(1), ""password"");
      }
    } else {
      final MethodInvocationTree mit = (MethodInvocationTree) tree;
      if (REALM_CONFIGURATION_BUILDER_ENCRYPTION_KEY.matches(mit)) {
        reportIssueIfHardCoded(mit, ""encryptionKey"");
      } else if (SQLITE_DATABASE_METHODS.matches(mit)) {
        reportIssueIfHardCoded(mit, ""password"");
      }
    }
  }

  private void reportIssueIfHardCoded(MethodInvocationTree mit, String argName) {
    Arguments arguments = mit.arguments();
    ExpressionTree passwordArg = arguments.size() == 1 ? arguments.get(0) : arguments.get(1);
    reportIssueIfHardCoded(passwordArg, argName);
  }

  private void reportIssueIfHardCoded(ExpressionTree expressionTree, String messageArg) {
    ExpressionTree stringExpression = expressionTree;
    if (!expressionTree.symbolType().is(JAVA_LANG_STRING)) {
      // byte[] or char[]
      stringExpression = tryGetOriginStringFromByteOrCharArray(expressionTree);
      if (stringExpression == null) {
        return;
      }
    }
    ExpressionsHelper.ValueResolution<String> constantValueAsString = ExpressionsHelper.getConstantValueAsString(stringExpression);
    if (constantValueAsString.value() != null) {
      reportIssue(expressionTree, ""The \"""" + messageArg + ""\"" parameter should not be hardcoded."", constantValueAsString.valuePath(), null);
    }
  }

  @CheckForNull
  private static ExpressionTree tryGetOriginStringFromByteOrCharArray(ExpressionTree givenExpression) {
    ExpressionTree expression = givenExpression;
    if (expression.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) expression;
      ExpressionTree singleWriteUsage = getSingleWriteUsage(identifier.symbol());
      if (singleWriteUsage != null) {
        expression = singleWriteUsage;
      }
    }
    if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
      MethodInvocationTree mit = (MethodInvocationTree) expression;
      if (JAVA_LANG_STRING_TO_CHAR_GET_BYTES.matches(mit)) {
        return ((MemberSelectExpressionTree) (mit).methodSelect()).expression();
      }
    }
    return null;
  }

}
"
S6326,CODE_SMELL,Regular expressions should not contain multiple spaces,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.MultipleWhitespaceFinder;

@Rule(key = ""S6326"")
public class MultipleWhitespaceCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new MultipleWhitespaceFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S6331,CODE_SMELL,Regular expressions should not contain empty groups,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.EmptyGroupFinder;

@Rule(key = ""S6331"")
public class EmptyRegexGroupCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new EmptyGroupFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S6353,CODE_SMELL,Regular expression quantifiers and character classes should be used concisely,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.VerboseRegexFinder;

@Rule(key = ""S6353"")
public class VerboseRegexCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new VerboseRegexFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S6355,CODE_SMELL,Deprecated annotations should include explanations,"package org.sonar.java.checks;

import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6355"")
public class DeprecatedArgumentsCheck extends AbstractMissingDeprecatedChecker {

  private boolean isJava9 = false;

  @Override
  public void setContext(JavaFileScannerContext context) {
    isJava9 = context.getJavaVersion().isJava9Compatible();
    super.setContext(context);
  }

  @Override
  void handleDeprecatedElement(Tree tree, @CheckForNull AnnotationTree deprecatedAnnotation, boolean hasJavadocDeprecatedTag) {
    if (isJava9 && deprecatedAnnotation != null && deprecatedAnnotation.arguments().isEmpty()) {
      reportIssue(deprecatedAnnotation, ""Add 'since' and/or 'forRemoval' arguments to the @Deprecated annotation."");
    }
  }

}
"
S6362,SECURITY_HOTSPOT,Enabling JavaScript support for WebViews is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6362"")
public class WebViewJavaScriptSupportCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofSubTypes(""android.webkit.WebSettings"")
      .names(""setJavaScriptEnabled"")
      .addParametersMatcher(""boolean"")
      .build();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree argument = mit.arguments().get(0);
    if (Boolean.TRUE.equals(ExpressionUtils.resolveAsConstant(argument))) {
      reportIssue(argument, ""Make sure that enabling JavaScript support is safe here."");
    }
  }

}
"
S6363,SECURITY_HOTSPOT,Enabling file access for WebViews is security-sensitive,"package org.sonar.java.checks.security;

import java.util.Collections;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6363"")
public class WebViewsFileAccessCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofSubTypes(""android.webkit.WebSettings"")
      .names(
        ""setAllowFileAccess"",
        ""setAllowFileAccessFromFileURLs"",
        ""setAllowContentAccess"",
        ""setAllowUniversalAccessFromFileURLs"")
      .addParametersMatcher(""boolean"")
      .build();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree argument = mit.arguments().get(0);
    if (Boolean.TRUE.equals(ExpressionUtils.resolveAsConstant(argument))) {
      reportIssue(argument, ""Make sure that enabling file access is safe here."");
    }
  }

}
"
S6395,CODE_SMELL,Non-capturing groups without quantifier should not be used,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.UnquantifiedNonCapturingGroupFinder;

@Rule(key = ""S6395"")
public class UnquantifiedNonCapturingGroupCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new UnquantifiedNonCapturingGroupFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S6396,CODE_SMELL,Superfluous curly brace quantifiers should be avoided,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.SuperfluousCurlyBraceFinder;

@Rule(key = ""S6396"")
public class SuperfluousCurlyBraceCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new SuperfluousCurlyBraceFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S6397,CODE_SMELL,Character classes in regular expressions should not contain only one character,"package org.sonar.java.checks.regex;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonarsource.analyzer.commons.regex.RegexParseResult;
import org.sonarsource.analyzer.commons.regex.finders.SingleCharCharacterClassFinder;

@Rule(key = ""S6397"")
public class SingleCharCharacterClassCheck extends AbstractRegexCheck {

  @Override
  public void checkRegex(RegexParseResult regexForLiterals, ExpressionTree methodInvocationOrAnnotation) {
    new SingleCharCharacterClassFinder(this::reportIssueFromCommons).visit(regexForLiterals);
  }

}
"
S6411,CODE_SMELL,Types used as keys in Maps should implement Comparable,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.model.JUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeArguments;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.WildcardTree;

@Rule(key = ""S6411"")
public class MapKeyNotComparableCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.PARAMETERIZED_TYPE);
  }

  @Override
  public void visitNode(Tree tree) {
    ParameterizedTypeTree typeTree = (ParameterizedTypeTree) tree;
    Type type = typeTree.symbolType();
    if (type.isSubtypeOf(""java.util.Map"")) {
      getMapKeyTree(typeTree).ifPresent(mapKeyTree -> {
        if (!isGenericOrWildCard(mapKeyTree) &&
          !implementsComparable(mapKeyTree.symbolType()) &&
          !JUtils.hasUnknownTypeInHierarchy(mapKeyTree.symbolType().symbol())) {
          reportIssue(mapKeyTree, ""The key type should implement Comparable."");
        }
      });
    }
  }

  private static boolean isGenericOrWildCard(TypeTree tree) {
    return tree.symbolType().isTypeVar() || tree instanceof WildcardTree;
  }

  private static Optional<TypeTree> getMapKeyTree(ParameterizedTypeTree typeTree) {
    TypeArguments typeArgs = typeTree.typeArguments();
    if (typeArgs.size() == 2) {
      TypeTree mapKeyTree = typeArgs.get(0);
      return Optional.of(mapKeyTree);
    }
    return Optional.empty();
  }

  private static boolean implementsComparable(Type mapKeyType) {
    return mapKeyType.isSubtypeOf(""java.lang.Comparable"");
  }
}
"
S6418,SECURITY_HOTSPOT,Hard-coded secrets are security-sensitive,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.RandomnessDetector;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.VariableTree;

import static org.sonar.java.checks.HardcodedIpCheck.IP_V6_ALONE;

@Rule(key = ""S6418"")
public class HardCodedSecretCheck extends AbstractHardCodedCredentialChecker {

  private static final String DEFAULT_SECRET_WORDS = ""api[_.-]?key,auth,credential,secret,token"";
  private static final String DEFAULT_RANDOMNESS_SENSIBILITY= ""5.0"";
  private static final int MINIMUM_CREDENTIAL_LENGTH = 17;

  private static final String FIRST_ACCEPTED_CHARACTER = ""[\\w.+/~$:&-]"";
  private static final String FOLLOWING_ACCEPTED_CHARACTER = ""[=\\w.+/~$:&-]"";
  private static final Pattern SECRET_PATTERN =
    Pattern.compile(FIRST_ACCEPTED_CHARACTER + ""("" + FOLLOWING_ACCEPTED_CHARACTER + ""|\\\\\\\\"" + FOLLOWING_ACCEPTED_CHARACTER + "")++"");
  private static final Pattern IPV_6_PATTERN = Pattern.compile(IP_V6_ALONE);

  private RandomnessDetector randomnessDetector;

  @RuleProperty(
    key = ""secretWords"",
    description = ""Comma separated list of words identifying potential secrets"",
    defaultValue = DEFAULT_SECRET_WORDS)
  public String secretWords = DEFAULT_SECRET_WORDS;

  @RuleProperty(
    key = ""randomnessSensibility"",
    description = ""Allows to tune the Randomness Sensibility (from 0 to 10)"",
    defaultValue = DEFAULT_RANDOMNESS_SENSIBILITY)
  public double randomnessSensibility = Double.parseDouble(DEFAULT_RANDOMNESS_SENSIBILITY);

  @Override
  protected String getCredentialWords() {
    return secretWords;
  }

  @Override
  protected boolean isCredentialContainingPattern(ExpressionTree expression) {
    // Secrets containing a secret word is not considered as containing an expression.
    // Simple constant declaration like ""String secret = ""secret"""" will anyway be filtered by the entropy filter.
    return false;
  }

  @Override
  public List<Kind> nodesToVisit() {
    return Arrays.asList(Kind.STRING_LITERAL, Kind.VARIABLE, Kind.ASSIGNMENT, Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Kind.STRING_LITERAL)) {
      handleStringLiteral((LiteralTree) tree);
    } else if (tree.is(Kind.VARIABLE)) {
      handleVariable((VariableTree) tree);
    } else if (tree.is(Kind.ASSIGNMENT)) {
      handleAssignment((AssignmentExpressionTree) tree);
    } else {
      handleMethodInvocation((MethodInvocationTree) tree);
    }
  }

  private void handleMethodInvocation(MethodInvocationTree mit) {
    ExpressionTree methodSelect = mit.methodSelect();
    if (EQUALS_MATCHER.matches(mit) && methodSelect.is(Kind.MEMBER_SELECT)) {
      handleEqualsMethod(mit, (MemberSelectExpressionTree) methodSelect);
    } else {
      isSettingCredential(mit).ifPresent(settingPassword -> report(ExpressionUtils.methodName(mit), settingPassword));
    }
  }

  @Override
  protected boolean isPotentialCredential(String literal) {
    if (literal.length() < MINIMUM_CREDENTIAL_LENGTH || !SECRET_PATTERN.matcher(literal).matches()) {
      return false;
    }
    return getRandomnessDetector().isRandom(literal)
      && isNotIpV6(literal);
  }

  private RandomnessDetector getRandomnessDetector() {
    if (randomnessDetector == null) {
      randomnessDetector = new RandomnessDetector(randomnessSensibility);
    }
    return randomnessDetector;
  }

  private static boolean isNotIpV6(String literal) {
    return !IPV_6_PATTERN.matcher(literal).matches();
  }

  @Override
  protected void report(Tree tree, String match) {
    reportIssue(tree, ""'"" + match + ""' detected in this expression, review this potentially hard-coded secret."");
  }

}
"
S6432,VULNERABILITY,Counter Mode initialization vectors should not be reused,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import javax.crypto.Cipher;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.HardcodedStringExpressionChecker;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.expression.MemberSelectExpressionTreeImpl;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S6432"")
public class CounterModeIVShouldNotBeReusedCheck extends IssuableSubscriptionVisitor {

  private static final String PRIMARY_LOCATION_ISSUE_MESSAGE = ""Use a dynamically-generated initialization vector (IV) to avoid IV-key pair reuse."";
  private static final String SECONDARY_LOCATION_ISSUE_MESSAGE = ""The static value is defined here."";

  private static final MethodMatchers JCA_CHIPER_INIT_METHODS = MethodMatchers.create()
    .ofTypes(""javax.crypto.Cipher"")
    .names(""init"")
    .addParametersMatcher(""int"", MethodMatchers.ANY, ""java.security.spec.AlgorithmParameterSpec"")
    .build();

  private static final MethodMatchers BC_CHIPER_INIT_METHODS = MethodMatchers.create()
    .ofTypes(""org.bouncycastle.crypto.modes.GCMBlockCipher"", ""org.bouncycastle.crypto.modes.CCMBlockCipher"")
    .names(""init"")
    .addParametersMatcher(""boolean"", ""org.bouncycastle.crypto.CipherParameters"")
    .build();

  private static final MethodMatchers GCM_CONSTRUCTOR = MethodMatchers.create()
    .ofTypes(""javax.crypto.spec.GCMParameterSpec"")
    .constructor()
    .addParametersMatcher(parameters -> !parameters.isEmpty())
    .build();

  private static final MethodMatchers AEAD_CONSTRUCTOR = MethodMatchers.create()
    .ofTypes(""org.bouncycastle.crypto.params.AEADParameters"")
    .constructor()
    .addParametersMatcher(parameters -> !parameters.isEmpty())
    .build();

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree method = (MethodInvocationTree) tree;
    var secondaryLocations = new ArrayList<JavaFileScannerContext.Location>();

    if (isJCAOperationModeEncrypt(method)) {
      checkForHardcodedIVInitialization(method, 2, secondaryLocations);
    } else if (isBCCipherForEncryption(method)) {
      checkForHardcodedIVInitialization(method, 1, secondaryLocations);
    }

  }

  private void checkForHardcodedIVInitialization(MethodInvocationTree method, int constructorParamIndex, List<JavaFileScannerContext.Location> secondaryLocations) {
    if (checkForJCAHardcodedIVInitialization(method.arguments().get(constructorParamIndex), secondaryLocations)) {
      MemberSelectExpressionTree methodSelect = (MemberSelectExpressionTreeImpl) method.methodSelect();
      reportIssue(methodSelect.identifier(), PRIMARY_LOCATION_ISSUE_MESSAGE, secondaryLocations, null);
    }
  }

  private static boolean isJCAOperationModeEncrypt(MethodInvocationTree method) {
    if (JCA_CHIPER_INIT_METHODS.matches(method)) {
      Optional<Integer> value = method.arguments().get(0).asConstant(Integer.class);
      return value.isPresent() && value.get() == Cipher.ENCRYPT_MODE;
    }
    return false;
  }

  private static boolean isBCCipherForEncryption(MethodInvocationTree method) {
    if (BC_CHIPER_INIT_METHODS.matches(method)) {
      Optional<Boolean> value = method.arguments().get(0).asConstant(Boolean.class);
      return value.isPresent() && value.get();
    }
    return false;
  }

  // argument here is going to be a GCMParameterSpec
  private static boolean checkForJCAHardcodedIVInitialization(ExpressionTree expression, List<JavaFileScannerContext.Location> secondaryLocations) {
    ExpressionTree argument = ExpressionUtils.skipParentheses(expression);
    switch (argument.kind()) {
      case IDENTIFIER:
        List<ExpressionTree> assignments = ExpressionsHelper.getIdentifierAssignments((IdentifierTree) argument);
        secondaryLocations.add(new JavaFileScannerContext.Location(SECONDARY_LOCATION_ISSUE_MESSAGE, argument));
        return assignments.stream()
          .allMatch(assignment -> checkForJCAHardcodedIVInitialization(assignment, secondaryLocations));
      case NEW_CLASS:
        NewClassTree constructor = (NewClassTree) argument;
        if (GCM_CONSTRUCTOR.matches(constructor)) {
          ExpressionTree arg = constructor.arguments().get(1);
          secondaryLocations.add(new JavaFileScannerContext.Location(SECONDARY_LOCATION_ISSUE_MESSAGE, arg));
          return HardcodedStringExpressionChecker.isExpressionDerivedFromPlainText(arg, secondaryLocations, new HashSet<>());
        } else if (AEAD_CONSTRUCTOR.matches(constructor)) {
          ExpressionTree arg = constructor.arguments().get(2);
          secondaryLocations.add(new JavaFileScannerContext.Location(SECONDARY_LOCATION_ISSUE_MESSAGE, arg));
          return HardcodedStringExpressionChecker.isExpressionDerivedFromPlainText(arg, secondaryLocations, new HashSet<>());
        }
        return false;
      default:
        return false;
    }

  }

}
"
S6485,CODE_SMELL,Hash-based collections with known capacity should be initialized with the proper related static method.,"package org.sonar.java.checks;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree.Kind;

@Rule(key = ""S6485"")
public class KnownCapacityHashBasedCollectionCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final Map<String, String> TYPES_TO_METHODS = Map.of(
    ""HashMap"", ""HashMap.newHashMap(int numMappings)"",
    ""HashSet"", ""HashSet.newHashSet(int numMappings)"",
    ""LinkedHashMap"", ""LinkedHashMap.newLinkedHashMap(int numMappings)"",
    ""LinkedHashSet"", ""LinkedHashSet.newLinkedHashSet(int numMappings)"",
    ""WeakHashMap"", ""WeakHashMap.newWeakHashMap(int numMappings)"");

  @Override
  public List<Kind> nodesToVisit() {
    return Collections.singletonList(Kind.NEW_CLASS);
  }

  @Override
  protected void onConstructorFound(NewClassTree newClassTree) {
    reportIssue(newClassTree, getIssueMessage(newClassTree));
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.util.HashMap"", ""java.util.HashSet"", ""java.util.LinkedHashMap"", ""java.util.LinkedHashSet"", ""java.util.WeakHashMap"")
      .constructor()
      .addParametersMatcher(""int"")
      .build();
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava19Compatible();
  }

  private static String getIssueMessage(NewClassTree newClassTree) {
    String replacementMethod = TYPES_TO_METHODS.get(newClassTree.symbolType().name());
    return String.format(""Replace this call to the constructor with the better suited static method %s"", replacementMethod);
  }

}
"
S6539,CODE_SMELL,Classes should not depend on an excessive number of classes (aka Monster Class),"package org.sonar.java.checks.design;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.checks.helpers.ClassPatternsUtils;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.java.model.JavaTree;
import org.sonar.java.model.expression.IdentifierTreeImpl;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.CompilationUnitTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ImportTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6539"")
public class ClassImportCouplingCheck extends AbstractCouplingChecker {

  private static final int COUPLING_THRESHOLD = 20;
  @RuleProperty(
    key = ""couplingThreshold"",
    description = ""Maximum number of classes a single class is allowed to depend upon. This value is an experimental value."",
    defaultValue = """" + COUPLING_THRESHOLD)
  public int couplingThreshold = COUPLING_THRESHOLD;
  private String packageName;
  private Set<Tree> imports;
  private Set<Tree> secondaryLocations;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    super.scanFile(context);
    imports = null;
    secondaryLocations = null;
  }

  @Override
  public void visitClass(ClassTree tree) {
    // if class is utility or private inner class -> don't report
    if (ClassPatternsUtils.isUtilityClass(tree) || ClassPatternsUtils.isPrivateInnerClass(tree)) {
      return;
    }

    if (tree.is(Tree.Kind.CLASS) && tree.simpleName() != null) {
      nesting.push(types);
      types = new HashSet<>();
    }
    CompilationUnitTree compilationUnitTree = (CompilationUnitTree) ExpressionUtils.getParentOfType(tree, Tree.Kind.COMPILATION_UNIT);
    packageName = JavaTree.PackageDeclarationTreeImpl.packageNameAsString(compilationUnitTree.packageDeclaration());

    if (imports == null) {
      String fileProjectName = context.getProject().key();

      imports = compilationUnitTree.imports().stream()
        .filter(i -> !i.is(Tree.Kind.EMPTY_STATEMENT))
        .map(ImportTree.class::cast)
        .map(ImportTree::qualifiedIdentifier)
        .filter(i -> ExpressionsHelper.concatenate(((ExpressionTree) i)).startsWith(fileProjectName))
        .collect(Collectors.toSet());

      secondaryLocations = new HashSet<>();
      secondaryLocations.addAll(imports);
    }

    checkTypes(tree.superClass(), types);
    checkTypes(tree.superInterfaces());
    super.visitClass(tree);

    if (tree.is(Tree.Kind.CLASS) && tree.simpleName() != null) {
      int size = imports.size() + types.size();
      if (size > couplingThreshold) {
        context.reportIssue(this, tree.simpleName(), ""Split this Monster Class into smaller and more specialized ones "" +
          ""to reduce its dependencies on other classes from "" + size +
          "" to the maximum authorized "" + couplingThreshold + "" or less."", getSecondaryLocations(), null);
      }
      types = nesting.pop();
    }
  }

  private List<JavaFileScannerContext.Location> getSecondaryLocations() {
    return secondaryLocations.stream()
      .map(element -> new JavaFileScannerContext.Location(""This class contributes to the tight class coupling."", element))
      .toList();
  }

  @Override
  public void checkTypes(@Nullable Tree type, @Nullable Set<String> types) {
    if (type == null || types == null) {
      return;
    }
    if (type.is(Tree.Kind.IDENTIFIER)) {
      IdentifierTreeImpl identifierTree = (IdentifierTreeImpl) type;
      String fullyQualifiedName = identifierTree.symbolType().fullyQualifiedName();
      if (fullyQualifiedName.contains(packageName)) {
        types.add(fullyQualifiedName);
        secondaryLocations.add(type);
      }
    } else if (type.is(Tree.Kind.MEMBER_SELECT)) {
      MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) type;
      String name = ExpressionsHelper.concatenate(memberSelect);
      if (name.contains(packageName)) {
        types.add(name);
        secondaryLocations.add(type);
      }
    }
  }

}
"
S6541,CODE_SMELL,Methods should not perform too many tasks (aka Brain method),"package org.sonar.java.checks.design;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.java.annotations.VisibleForTesting;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.metrics.MetricsScannerContext;
import org.sonar.java.model.DefaultModuleScannerContext;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.ModuleScannerContext;
import org.sonar.plugins.java.api.internal.EndOfAnalysis;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6541"")
public class BrainMethodCheck extends IssuableSubscriptionVisitor implements EndOfAnalysis {

  private static final String ISSUE_MESSAGE = ""A \""Brain Method\"" was detected. Refactor it to reduce at least one of the following metrics: ""
    + ""LOC from %d to %d, Complexity from %d to %d, Nesting Level from %d to %d, Number of Variables from %d to %d."";

  // these default property values are derived from statistics coming from code of almost a hundred projects (Java, C++)
  // ""Object-oriented metrics in practice"" https://link.springer.com/book/10.1007/3-540-39538-5

  // LOC high threshold for a method, is equal to half the high LOC threshold for classes (130)
  private static final int DEFAULT_LOC_THRESHOLD = 65;
  // High cyclomatic complexity is defined as a ratio of 0.24 per LOC, so DEFAULT_LOC_THRESHOLD * 0.24 = 15 rounded down
  private static final int DEFAULT_CYCLO_THRESHOLD = 15;
  // Deep nesting is defined when nesting level lies within the range 2-5, we picked 3 as default
  private static final int DEFAULT_NESTING_THRESHOLD = 3;
  // Defined as a human short-term memory numeric limit of variables that can be kept in mind
  private static final int DEFAULT_VARIABLES_THRESHOLD = 7;

  @RuleProperty(key = ""locThreshold"", description = ""The maximum number of LOC allowed."", defaultValue = """" + DEFAULT_LOC_THRESHOLD)
  public int locThreshold = DEFAULT_LOC_THRESHOLD;

  @RuleProperty(key = ""cyclomaticThreshold"", description = ""The maximum cyclomatic complexity allowed."", defaultValue = """" + DEFAULT_CYCLO_THRESHOLD)
  public int cyclomaticThreshold = DEFAULT_CYCLO_THRESHOLD;

  @RuleProperty(key = ""nestingThreshold"", description = ""The maximum nesting level allowed."", defaultValue = """" + DEFAULT_NESTING_THRESHOLD)
  public int nestingThreshold = DEFAULT_NESTING_THRESHOLD;

  @RuleProperty(key = ""noavThreshold"", description = ""The maximum number of accessed variables allowed."", defaultValue = """" + DEFAULT_VARIABLES_THRESHOLD)
  public int noavThreshold = DEFAULT_VARIABLES_THRESHOLD;

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.METHOD);
  }

  @VisibleForTesting
  int numberOfIssuesToReport = 10;
  private final List<IssueFound> issuesFound = new ArrayList<>();

  @Override
  public void visitNode(Tree tree) {
    MethodTree methodTree = (MethodTree) tree;

    var metricsComputer = ((MetricsScannerContext) context).getMetricsComputer();

    if (isExcluded(methodTree)) {
      return;
    }

    int cyclomaticComplexity = metricsComputer.getComplexityNodes(methodTree).size();
    int maxNestingLevel = metricsComputer.getMethodNestingLevel(methodTree);
    int linesOfCode = metricsComputer.getLinesOfCode(methodTree.block());
    int numberOfAccessedVariables = metricsComputer.getNumberOfAccessedVariables(methodTree);

    if (linesOfCode >= locThreshold &&
      cyclomaticComplexity >= cyclomaticThreshold &&
      maxNestingLevel >= nestingThreshold &&
      numberOfAccessedVariables >= noavThreshold) {

      int brainScore = numberOfAccessedVariables + cyclomaticComplexity + maxNestingLevel * linesOfCode;
      String issueMessage = String.format(ISSUE_MESSAGE,
        linesOfCode, locThreshold - 1,
        cyclomaticComplexity, cyclomaticThreshold - 1,
        maxNestingLevel, nestingThreshold - 1,
        numberOfAccessedVariables, noavThreshold - 1);

      AnalyzerMessage analyzerMessage = new AnalyzerMessage(this, context.getInputFile(),
        AnalyzerMessage.textSpanFor(methodTree.simpleName()), issueMessage, 0);
      issuesFound.add(new IssueFound(brainScore, analyzerMessage));
    }

  }

  private static boolean isExcluded(MethodTree methodTree) {
    return methodTree.symbol().isAbstract() || methodTree.block() == null || MethodTreeUtils.isEqualsMethod(methodTree) || MethodTreeUtils.isHashCodeMethod(methodTree);
  }

  @Override
  public void endOfAnalysis(ModuleScannerContext context) {
    if (issuesFound.size() > numberOfIssuesToReport) {
      numberOfIssuesToReport += issuesFound.size() / 10;
      issuesFound.sort((a, b) -> b.brainScore - a.brainScore);
    } else {
      numberOfIssuesToReport = issuesFound.size();
    }
    var defaultContext = (DefaultModuleScannerContext) context;
    for (int i = 0; i < numberOfIssuesToReport; i++) {
      IssueFound issueFound = issuesFound.get(i);
      defaultContext.reportIssue(issueFound.analyzerMessage);
    }
  }

  private static class IssueFound {

    int brainScore;
    AnalyzerMessage analyzerMessage;

    public IssueFound(int brainScore, AnalyzerMessage analyzerMessage) {
      this.brainScore = brainScore;
      this.analyzerMessage = analyzerMessage;
    }

  }

}
"
S6548,CODE_SMELL,The Singleton design pattern should be used with care,"package org.sonar.java.checks.design;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.EnumConstantTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6548"")
public class SingletonUsageCheck extends IssuableSubscriptionVisitor {
  private static final String MESSAGE = ""A Singleton implementation was detected."" + "" "" +
    ""Make sure the use of the Singleton pattern is required and the implementation is the right one for the context."";
  private static final String MESSAGE_FOR_ENUMS = ""An Enum-based Singleton implementation was detected."" + "" "" +
    ""Make sure the use of the Singleton pattern is required and an Enum-based implementation is the right one for the context."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.CLASS, Tree.Kind.ENUM);
  }

  @Override
  public void visitNode(Tree tree) {
    final var classTree = (ClassTree) tree;
    if (tree.is(Tree.Kind.CLASS)) {
      visitClass(classTree);
    } else {
      visitEnum(classTree);
    }
  }

  private void visitEnum(ClassTree classTree) {
    var enumConstants = classTree.members().stream().filter(member -> member.is(Tree.Kind.ENUM_CONSTANT)).toList();
    if (enumConstants.size() == 1) {
      EnumConstantTree constant = (EnumConstantTree) enumConstants.get(0);
      if (isInitializedWithParameterFreeConstructor(constant) &&
        hasNonPrivateInstanceMethodsOrFields(classTree)) {
        reportIssue(classTree.simpleName(), MESSAGE_FOR_ENUMS,
          Collections.singletonList(new JavaFileScannerContext.Location(""Single enum"", constant)), null);
      }
    }
  }

  private void visitClass(ClassTree classTree) {
    var classAndInstance = collectClassAndField(classTree);

    if (classAndInstance == null) return;

    ClassTree singletonClass = classAndInstance.getKey();
    VariableTree singletonField = classAndInstance.getValue();

    var allConstructors = singletonClass.members().stream()
      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR))
      .map(MethodTree.class::cast)
      .toList();

    if (allConstructors.size() <= 1 &&
      allConstructors.stream().allMatch(constructor -> constructor.symbol().isPrivate() && constructor.parameters().isEmpty()) &&
      hasNonPrivateInstanceMethodsOrFields(singletonClass)) {

      var flows = new ArrayList<JavaFileScannerContext.Location>();
      flows.add(new JavaFileScannerContext.Location(""Singleton field"", singletonField.simpleName()));
      if (singletonClass != classTree) {
        flows.add(new JavaFileScannerContext.Location(""Singleton helper"", classTree.simpleName()));
      }
      allConstructors.forEach(constructor -> {
        IdentifierTree methodName = allConstructors.get(0).simpleName();
        flows.add(new JavaFileScannerContext.Location(""Private constructor"", methodName));
      });
      extractAssignments(singletonField).forEach(assignment -> flows.add(new JavaFileScannerContext.Location(""Value assignment"", assignment)));

      reportIssue(singletonClass.simpleName(), MESSAGE, flows, null);
    }
  }

  @CheckForNull
  private static Map.Entry<ClassTree, VariableTree> collectClassAndField(ClassTree classTree) {
    ClassTree wrappingClass = null;
    final var parent = classTree.parent();
    if (parent != null && parent.is(Tree.Kind.CLASS)) {
      wrappingClass = (ClassTree) parent;
    }

    List<VariableTree> staticFields = collectStaticFields(classTree, wrappingClass);
    if (staticFields.size() != 1) return null;

    var field = staticFields.get(0);

    final var fieldSymbol = field.symbol();
    ClassTree singletonClass = null;
    if (fieldSymbol.type().equals(classTree.symbol().type())) {
      singletonClass = classTree;
    } else {
      singletonClass = wrappingClass;
    }

    if (!isEffectivelyFinal(fieldSymbol)) return null;

    return new AbstractMap.SimpleEntry<>(singletonClass, field);
  }

  private static List<VariableTree> collectStaticFields(ClassTree classTree, @Nullable ClassTree wrappingClass) {
    Type type = classTree.symbol().type();
    Type wrappingType = wrappingClass != null ? wrappingClass.symbol().type() : null;
    return classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.VARIABLE) && ((VariableTree) member).symbol().isStatic())
      .map(VariableTree.class::cast)
      .filter(field -> {
        Type fieldType = field.symbol().type();
        return fieldType.equals(type) || (wrappingType != null && fieldType.equals(wrappingType));
      }).toList();
  }

  private static boolean isEffectivelyFinal(Symbol symbol) {
    return symbol.isFinal() ||
      (symbol.isPrivate() && ExpressionsHelper.getSingleWriteUsage(symbol) != null);
  }

  private static boolean isInitializedWithParameterFreeConstructor(EnumConstantTree constant) {
    return constant.initializer().methodSymbol().parameterTypes().isEmpty();
  }

  private static boolean hasNonPrivateInstanceMethodsOrFields(ClassTree classTree) {
    return classTree.members().stream().anyMatch(member -> {
      if (member.is(Tree.Kind.METHOD)) {
        var symbol = ((MethodTree) member).symbol();
        return !symbol.isPrivate() && !symbol.isStatic();
      } else if (member.is(Tree.Kind.VARIABLE)) {
        var symbol = ((VariableTree) member).symbol();
        return !symbol.isPrivate() && !symbol.isStatic();
      } else {
        return false;
      }
    });
  }

  private static List<AssignmentExpressionTree> extractAssignments(VariableTree variable) {
    return variable.symbol().usages().stream()
      .map(Tree::parent)
      .filter(usage -> usage.is(Tree.Kind.ASSIGNMENT))
      .map(AssignmentExpressionTree.class::cast)
      .toList();
  }
}
"
S6804,CODE_SMELL,"""@Value"" annotation should inject property or SpEL expression","package org.sonar.java.checks.spring;

import java.util.List;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6804"")
public class ValueAnnotationShouldInjectPropertyOrSpELCheck extends IssuableSubscriptionVisitor {

  private static final String SPRING_VALUE = ""org.springframework.beans.factory.annotation.Value"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS, Tree.Kind.ANNOTATION_TYPE);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree cls = (ClassTree) tree;

    List<AnnotationTree> fieldsAnnotations = cls.members()
      .stream()
      .filter(m -> m.is(Tree.Kind.VARIABLE))
      .flatMap(field -> ((VariableTree) field).modifiers().annotations().stream())
      .toList();

    List<AnnotationTree> interfaceAnnotations = cls.is(Tree.Kind.ANNOTATION_TYPE) ? cls.modifiers().annotations() : List.of();

    Stream.concat(fieldsAnnotations.stream(), interfaceAnnotations.stream())
      .filter(ValueAnnotationShouldInjectPropertyOrSpELCheck::isSimpleSpringValue)
      .forEach(ann -> reportIssue(
        ann,
        ""Either replace the \""@Value\"" annotation with a standard field initialization,"" +
          "" use \""${propertyName}\"" to inject a property "" +
          ""or use \""#{expression}\"" to evaluate a SpEL expression.""));
  }

  private static boolean isSimpleSpringValue(AnnotationTree annotation) {
    if (annotation.symbolType().is(SPRING_VALUE)) {
      String value = extractArgumentValue(annotation.arguments().get(0));
      return value != null && !isPropertyName(value) && !isSpEL(value) && !referenceResource(value);
    }
    return false;
  }

  private static String extractArgumentValue(ExpressionTree annotationArgument) {
    if (annotationArgument.is(Tree.Kind.ASSIGNMENT)) {
      ExpressionTree expression = ((AssignmentExpressionTree) annotationArgument).expression();
      return ExpressionsHelper.getConstantValueAsString(expression).value();
    }
    return ExpressionsHelper.getConstantValueAsString(annotationArgument).value();
  }

  private static boolean isPropertyName(String value) {
    return value.startsWith(""${"") && value.endsWith(""}"");
  }

  private static boolean isSpEL(String value) {
    return value.startsWith(""#{"") && value.endsWith(""}"");
  }

  private static boolean referenceResource(String value) {
    return value.startsWith(""classpath:"") || value.startsWith(""file:"") || value.startsWith(""url:"");
  }

}
"
S6806,BUG,Model attributes should follow the Java identifier naming convention,"package org.sonar.java.checks.spring;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.LiteralUtils;
import org.sonar.java.model.declaration.VariableTreeImpl;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6806"")
public class ModelAttributeNamingConventionForSpELCheck extends AbstractMethodDetection {

  private static final Pattern pattern = Pattern.compile(""^[a-zA-Z_$][a-zA-Z0-9_$]*$"");

  private static final MethodMatchers ADD_ATTRIBUTE_MATCHER_WITH_TWO_PARAMS = MethodMatchers.create()
    .ofTypes(""org.springframework.ui.Model"")
    .names(""addAttribute"")
    .addParametersMatcher(""java.lang.String"", ""java.lang.Object"")
    .build();

  private static final MethodMatchers ADD_ATTRIBUTE_MATCHER_WITH_ONE_PARAM = MethodMatchers.create()
    .ofTypes(""org.springframework.ui.Model"")
    .names(""addAllAttributes"")
    .addParametersMatcher(""java.util.Map"")
    .build();

  private static final MethodMatchers MAP_OF = MethodMatchers.create()
    .ofTypes(""java.util.Map"")
    .names(""of"", ""ofEntries"", ""entry"")
    .withAnyParameters()
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(ADD_ATTRIBUTE_MATCHER_WITH_TWO_PARAMS, ADD_ATTRIBUTE_MATCHER_WITH_ONE_PARAM);
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree argumentTree = mit.arguments().get(0);
    checkExpression(argumentTree, argumentTree);
  }

  private void checkExpression(ExpressionTree argumentTree, ExpressionTree reportTree) {
    if (argumentTree.is(Tree.Kind.STRING_LITERAL)) {
      checkStringLiteralAndReport(argumentTree, reportTree);
    } else if (argumentTree.is(Tree.Kind.IDENTIFIER)) {
      checkIdentifier((IdentifierTree) argumentTree);
    } else if (argumentTree.is(Tree.Kind.MEMBER_SELECT)) {
      checkMemberSelect((MemberSelectExpressionTree) argumentTree);
    } else if (argumentTree.is(Tree.Kind.METHOD_INVOCATION)) {
      checkMethodInvocation((MethodInvocationTree) argumentTree);
    }
  }

  private void checkStringLiteralAndReport(ExpressionTree tree, ExpressionTree reportTree) {
    LiteralTree literalTree = (LiteralTree) tree;
    String literalValue = LiteralUtils.getAsStringValue(literalTree);
    Matcher matcher = pattern.matcher(literalValue);
    if (!matcher.matches()) {
      reportIssue(reportTree,
        ""Attribute names must begin with a letter (a-z, A-Z), underscore (_), or dollar sign ($) and can be followed by letters, digits, underscores, or dollar signs."");
    }
  }

  private void checkIdentifier(IdentifierTree identifierTree) {
    VariableTreeImpl declaration = (VariableTreeImpl) identifierTree.symbol().declaration();
    if (declaration != null && declaration.initializer()!=null) {
      checkExpression(declaration.initializer(), identifierTree);
    }
  }

  private void checkMemberSelect(MemberSelectExpressionTree memberSelectExpressionTree) {
    checkIdentifier(memberSelectExpressionTree.identifier());
  }

  private void checkMethodInvocation(MethodInvocationTree methodInvocationTree) {
    if (MAP_OF.matches(methodInvocationTree)) {
      for (int i = 0; i < methodInvocationTree.arguments().size(); i += 2) {
        ExpressionTree key = methodInvocationTree.arguments().get(i);
        checkExpression(key, key);
      }
    }
  }

}
"
S6809,CODE_SMELL,"Methods with Spring proxy should not be called via ""this""","package org.sonar.java.checks.spring;

import java.util.List;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6809"")
public class AsyncMethodsCalledViaThisCheck extends IssuableSubscriptionVisitor {

  private static final Map<String, String> DISALLOWED_METHOD_ANNOTATIONS = Map.of(
    ""org.springframework.scheduling.annotation.Async"", ""async"",
    ""org.springframework.transaction.annotation.Transactional"", ""transactional"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    var mit = (MethodInvocationTree) tree;

    if (
      // If the call is not a member select, it must be an identifier, so it's a call to a local method, implicitly via 'this'
      !mit.methodSelect().is(Tree.Kind.MEMBER_SELECT) ||
        // On the other hand, if calls do have a qualifier, an explicit 'this' means we also want to raise an issue.
        ExpressionUtils.isThis(((MemberSelectExpressionTree) mit.methodSelect()).expression())
    ) {
      DISALLOWED_METHOD_ANNOTATIONS.entrySet().stream()
        .filter(entry -> mit.methodSymbol().metadata().isAnnotatedWith(entry.getKey()))
        .findFirst()
        .map(Map.Entry::getValue)
        .ifPresent(friendlyName -> reportIssue(mit, ""Call "" + friendlyName + "" methods via an injected dependency instead of directly via 'this'.""));
    }
  }
}
"
S6810,BUG,Async methods should return void or Future,"package org.sonar.java.checks.spring;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6810"")
public class AsyncMethodsReturnTypeCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    var mt = (MethodTree) tree;
    if (mt.symbol().metadata().isAnnotatedWith(""org.springframework.scheduling.annotation.Async"")) {
      var returnType = mt.returnType();
      // returnType can only be null if the method is a constructor. Since the @Async annotation is not allowed on constructors, and since
      // we hence only visit methods, not constructors, we assume that returnType is not null.
      if (!returnType.symbolType().isVoid() && !returnType.symbolType().isSubtypeOf(""java.util.concurrent.Future"")) {
        reportIssue(returnType, ""Async methods should return 'void' or a 'Future' type."");
      }
    }
  }
}
"
S6813,CODE_SMELL,Field dependency injection should be avoided,"package org.sonar.java.checks.spring;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6813"")
public class FieldDependencyInjectionCheck extends IssuableSubscriptionVisitor {
  private static final List<String> INJECTION_ANNOTATIONS = List.of(
    ""org.springframework.beans.factory.annotation.Autowired"",
    ""javax.inject.Inject"",
    ""jakarta.inject.Inject"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    var ct = (ClassTree) tree;
    ct.members().forEach(member -> {
      if (member.is(Tree.Kind.VARIABLE)) {
        var vt = (VariableTree) member;

        vt.modifiers().annotations().stream()
          .filter(annotationTree -> INJECTION_ANNOTATIONS.stream()
            .anyMatch(targetAnnotation -> annotationTree.symbolType().is(targetAnnotation)))
          .findFirst()
          .ifPresent(annotationTree -> reportIssue(annotationTree, ""Remove this field injection and use constructor injection instead.""));
      }
    });
  }
}
"
S6814,CODE_SMELL,Optional REST parameters should have an object type,"package org.sonar.java.checks.spring;

import java.util.List;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6814"")
public class OptionalRestParametersShouldBeObjectsCheck extends IssuableSubscriptionVisitor {
  private static final String PATH_VARIABLE_ANNOTATION = ""org.springframework.web.bind.annotation.PathVariable"";
  private static final String REQUEST_PARAM_ANNOTATION = ""org.springframework.web.bind.annotation.RequestParam"";
  private static final List<String> PARAMETER_ANNOTATIONS = List.of(
    PATH_VARIABLE_ANNOTATION,
    REQUEST_PARAM_ANNOTATION
  );

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodTree method = (MethodTree) tree;
    method.parameters().stream()
      .filter(OptionalRestParametersShouldBeObjectsCheck::isOptionalPrimitive)
      .forEach(parameter -> reportIssue(parameter, ""Convert this optional parameter to an Object type.""));
  }

  private static boolean isOptionalPrimitive(VariableTree parameter) {
    return parameter.type().symbolType().isPrimitive() &&
      parameter.modifiers().annotations().stream()
        .anyMatch(annotation -> isMarkingAsOptional(annotation) && !hasDefaultValue(annotation));
  }

  private static boolean isMarkingAsOptional(AnnotationTree annotation) {
    return PARAMETER_ANNOTATIONS.stream().anyMatch(candidate -> annotation.annotationType().symbolType().is(candidate)) &&
      streamAllNamedArguments(annotation).anyMatch(assignment -> {
        IdentifierTree variable = (IdentifierTree) assignment.variable();
        Boolean constant = assignment.expression().asConstant(Boolean.class).orElse(Boolean.TRUE);
        return ""required"".equals(variable.name()) && Boolean.FALSE.equals(constant);
      });
  }

  private static boolean hasDefaultValue(AnnotationTree annotation) {
    return annotation.annotationType().symbolType().is(REQUEST_PARAM_ANNOTATION) &&
      streamAllNamedArguments(annotation).anyMatch(assignment -> {
        IdentifierTree variable = (IdentifierTree) assignment.variable();
        return ""defaultValue"".equals(variable.name());
      });
  }

  private static Stream<AssignmentExpressionTree> streamAllNamedArguments(AnnotationTree annotation) {
    return annotation.arguments().stream()
      .filter(expression -> expression.is(Tree.Kind.ASSIGNMENT))
      .map(AssignmentExpressionTree.class::cast);
  }
}
"
S6816,BUG,Nullable injected fields and parameters should provide a default value,"package org.sonar.java.checks.spring;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6816"")
public class NullableInjectedFieldsHaveDefaultValueCheck extends IssuableSubscriptionVisitor {

  private static final String VALUE_ANNOTATION = ""org.springframework.beans.factory.annotation.Value"";

  private static final String MESSAGE_FOR_FIELDS = ""Provide a default null value for this field."";
  private static final String MESSAGE_FOR_PARAMETERS = ""Provide a default null value for this parameter."";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS, Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    final AnnotationTree methodLevelValueAnnotation;
    final boolean isClass = tree.is(Tree.Kind.CLASS);
    Stream<VariableTree> variables;
    if (isClass) {
      methodLevelValueAnnotation = null;
      variables = ((ClassTree) tree).members().stream()
        .filter(member -> member.is(Tree.Kind.VARIABLE))
        .map(VariableTree.class::cast);
    } else {
      var method = ((MethodTree) tree);
      variables = method.parameters().stream();
      methodLevelValueAnnotation = extractValueAnnotationOnSetter(method);
    }
    String issueMessage = isClass ? MESSAGE_FOR_FIELDS : MESSAGE_FOR_PARAMETERS;
    variables.map(variable -> mapToAnnotationsOfInterest(variable, methodLevelValueAnnotation))
      .filter(Optional::isPresent)
      .map(Optional::get)
      .forEach(trees ->
        QuickFixHelper.newIssue(context)
          .forRule(this)
          .onTree(trees.valueAnnotation)
          .withMessage(issueMessage)
          .withSecondaries(new JavaFileScannerContext.Location(""The nullable annotation"", trees.nullableAnnotation))
          .withQuickFixes(() -> computeQuickFix(trees.valueAnnotation))
          .report()
      );
  }

  private static List<JavaQuickFix> computeQuickFix(AnnotationTree annotation) {
    ExpressionTree expression = extractExpressionTree(annotation.arguments().get(0));
    // We provide at most 2 quickfixes
    List<JavaQuickFix> quickFixes = new ArrayList<>(2);
    // Compute replacement value
    String originalValue = ExpressionsHelper.getConstantValueAsString(expression).value();
    if (originalValue == null) {
      // Unlikely since we are computing a quickfix, then the value must have been resolved
      return List.of();
    }
    String currentValue = originalValue.strip();
    String replacementValue = ""\"""" +
      originalValue.strip().substring(0, currentValue.lastIndexOf('}'))
      + "":#{null}}""
      + ""\"""";
    String quickFixMessage = ""Set null as default value"";
    // Test if the value is defined in a constant that can be fixed as an alternative
    if (!expression.is(Tree.Kind.STRING_LITERAL)) {
      quickFixMessage = ""Set null as default value locally"";
      computeQuickFixOnOriginalDefinition(expression, replacementValue).ifPresent(quickFixes::add);
    }
    // Insert local replacement
    quickFixes.add(
      JavaQuickFix.newQuickFix(quickFixMessage)
        .addTextEdit(JavaTextEdit.replaceTree(expression, replacementValue))
        .build()
    );
    return quickFixes;
  }

  private static Optional<JavaQuickFix> computeQuickFixOnOriginalDefinition(ExpressionTree expression, String replacementValue) {
    Symbol symbol;
    if (expression.is(Tree.Kind.MEMBER_SELECT)) {
      symbol = ((MemberSelectExpressionTree) expression).identifier().symbol();
    } else {
      symbol = ((IdentifierTree) expression).symbol();
    }
    Tree declaration = symbol.declaration();
    if (declaration != null && declaration.is(Tree.Kind.VARIABLE)) {
      ExpressionTree assignedExpression = ((VariableTree) declaration).initializer();
      if (assignedExpression != null) {
        return Optional.of(
          JavaQuickFix.newQuickFix(""Set null as default value"")
            .addTextEdit(JavaTextEdit.replaceTree(assignedExpression, replacementValue))
            .build());
      }
    }
    return Optional.empty();
  }private static Optional<AnnotationsOfInterest> mapToAnnotationsOfInterest(VariableTree variable, @Nullable AnnotationTree valueAnnotationOnParent) {
    final AnnotationTree valueAnnotation;
    if (valueAnnotationOnParent == null) {
      Optional<AnnotationTree> annotationOnVariable = getValueAnnotationWithoutDefault(variable);
      if (annotationOnVariable.isEmpty()) {
        return Optional.empty();
      }
      valueAnnotation = annotationOnVariable.get();
    } else {
      valueAnnotation = valueAnnotationOnParent;
    }
    Optional<AnnotationTree> nullableAnnotation = getNullableAnnotation(variable);
    return nullableAnnotation.map(annotationTree -> new AnnotationsOfInterest(valueAnnotation, annotationTree));
  }

  @Nullable
  private static AnnotationTree extractValueAnnotationOnSetter(MethodTree method) {
    if (MethodTreeUtils.isSetterMethod(method)) {
      return method.modifiers().annotations().stream()
        .filter(annotation -> annotation.symbolType().is(VALUE_ANNOTATION) &&
          !hasDefaultValue(annotation))
        .findFirst()
        .orElse(null);
    }
    return null;
  }

  private static Optional<AnnotationTree> getNullableAnnotation(VariableTree field) {
    SymbolMetadata.NullabilityData nullabilityData = field.symbol().metadata().nullabilityData(SymbolMetadata.NullabilityTarget.FIELD);
    SymbolMetadata.AnnotationInstance instance = nullabilityData.annotation();
    if (instance == null) {
      return Optional.empty();
    }
    return Optional.ofNullable(field.symbol().metadata().findAnnotationTree(instance));
  }

  private static Optional<AnnotationTree> getValueAnnotationWithoutDefault(VariableTree field) {
    return field.modifiers().annotations().stream()
      .filter(annotation -> annotation.symbolType().is(VALUE_ANNOTATION) && !hasDefaultValue(annotation))
      .findFirst();
  }private static boolean hasDefaultValue(AnnotationTree valueAnnotation) {
    ExpressionTree expression = valueAnnotation.arguments().get(0);
    String value = extractLiteralValue(expression);
    String argument = value.strip();
    if (argument.startsWith(""${"") && argument.endsWith(""}"")) {
      return argument.contains("":"");
    }
    return true;
  }

  private static String extractLiteralValue(ExpressionTree annotationArgument) {
    ExpressionTree expressionTree = extractExpressionTree(annotationArgument);
    String value = ExpressionsHelper.getConstantValueAsString(expressionTree).value();
    return value != null ? value : """";
  }

  private static ExpressionTree extractExpressionTree(ExpressionTree annotationArgument) {
    if (annotationArgument.is(Tree.Kind.ASSIGNMENT)) {
      return ((AssignmentExpressionTree) annotationArgument).expression();
    }
    return annotationArgument;
  }

  private static class AnnotationsOfInterest {
    public final AnnotationTree valueAnnotation;
    public final AnnotationTree nullableAnnotation;

    public AnnotationsOfInterest(AnnotationTree valueAnnotation, AnnotationTree nullableAnnotation) {
      this.valueAnnotation = valueAnnotation;
      this.nullableAnnotation = nullableAnnotation;
    }
  }
}
"
S6817,BUG,"Use of the ""@Async"" annotation on methods declared within a ""@Configuration"" class in Spring Boot","package org.sonar.java.checks.spring;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6817"")
public class AsyncMethodsOnConfigurationClassCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    boolean isConfiguration = classTree.modifiers().annotations().stream()
      .anyMatch(annotation -> annotation.annotationType().symbolType().is(""org.springframework.context.annotation.Configuration""));

    if (isConfiguration) {
      classTree.members().stream()
        .filter(member -> member.is(Tree.Kind.METHOD))
        .map(MethodTree.class::cast)
        .forEach(member -> member.modifiers().annotations().stream()
          .filter(annotation -> annotation.annotationType().symbolType().is(""org.springframework.scheduling.annotation.Async""))
          .findFirst()
          .ifPresent(annotation -> QuickFixHelper.newIssue(context)
            .forRule(this)
            .onTree(annotation)
            .withMessage(""Remove this \""@Async\"" annotation from this method."")
            .withQuickFix(() -> JavaQuickFix.newQuickFix(""Remove \""@Async\"""")
              .addTextEdit(JavaTextEdit.removeTree(annotation))
              .build())
            .report()));
    }
  }

}
"
S6818,BUG,"""@Autowired"" should only be used on a single constructor","package org.sonar.java.checks.spring;

import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6818"")
public class AutowiredOnMultipleConstructorsCheck extends IssuableSubscriptionVisitor {

  private static final String AUTOWIRED_ANNOTATION = ""org.springframework.beans.factory.annotation.Autowired"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    List<MethodTree> constructors = classTree.members().stream()
      .filter(m -> m.is(Tree.Kind.CONSTRUCTOR))
      .map(m -> (MethodTree) m)
      .toList();

    if (constructors.size() > 1) {
      boolean isAutowiredAlreadyFound = false;
      for (MethodTree constructor : constructors) {
        boolean isAutowired = checkConstructor(constructor, isAutowiredAlreadyFound);
        if (isAutowired) {
          isAutowiredAlreadyFound = true;
        }
      }
    }
  }

  private boolean checkConstructor(MethodTree methodTree, boolean isAutowiredAlreadyFound) {
    boolean isAutowired = isAutowired(methodTree.symbol());

    if (isAutowiredAlreadyFound && isAutowired) {
      Optional<AnnotationTree> autowiredAnnotation = methodTree.modifiers().annotations().stream()
        .filter(a -> a.annotationType().symbolType().is(AUTOWIRED_ANNOTATION))
        .findFirst();
      autowiredAnnotation.ifPresent(annotationTree -> reportIssue(annotationTree, ""Remove this \""@Autowired\"" annotation.""));
    }

    return isAutowired;
  }

  private static boolean isAutowired(Symbol s) {
    if (s.metadata().isAnnotatedWith(AUTOWIRED_ANNOTATION)) {
      List<SymbolMetadata.AnnotationValue> annotationValues = s.metadata().valuesForAnnotation(AUTOWIRED_ANNOTATION);
      return annotationValues.isEmpty() || annotationValues.stream().anyMatch(a -> a.value().equals(true));
    }
    return false;
  }

}
"
S6829,CODE_SMELL,"""@Autowired"" should be used when multiple constructors are provided","package org.sonar.java.checks.spring;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6829"")
public class AutowiredOnConstructorWhenMultipleConstructorsCheck extends IssuableSubscriptionVisitor {

  private final List<String> annotations = List.of(
    ""org.springframework.context.annotation.Bean"",
    ""org.springframework.context.annotation.Configuration"",
    ""org.springframework.stereotype.Component"",
    ""org.springframework.stereotype.Controller"",
    ""org.springframework.stereotype.Repository"",
    ""org.springframework.stereotype.Service"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;

    boolean isSpringClass = classTree.modifiers().annotations().stream()
      .anyMatch(annotation -> annotations.contains(annotation.symbolType().fullyQualifiedName()));
    if (!isSpringClass) {
      return;
    }

    var constructors = classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.CONSTRUCTOR))
      .map(MethodTree.class::cast)
      .toList();

    if (constructors.size() > 1) {
      boolean anyHasAutowired = constructors.stream()
        .anyMatch(constructor -> constructor.modifiers().annotations().stream()
          .anyMatch(annotation -> annotation.symbolType().is(""org.springframework.beans.factory.annotation.Autowired"")));

      if (!anyHasAutowired) {
        reportIssue(classTree.simpleName(), ""Add @Autowired to one of the constructors."");
      }
    }
  }

}
"
S6830,CODE_SMELL,Bean names should adhere to the naming conventions,"package org.sonar.java.checks.spring;

import java.util.List;
import java.util.Objects;
import java.util.regex.Pattern;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6830"")
public class SpringBeanNamingConventionCheck extends IssuableSubscriptionVisitor {

  private static final List<String> ANNOTATIONS_TO_CHECK = List.of(
    ""org.springframework.beans.factory.annotation.Qualifier"",
    ""org.springframework.context.annotation.Bean"",
    ""org.springframework.context.annotation.Configuration"",
    ""org.springframework.stereotype.Controller"",
    ""org.springframework.stereotype.Component"",
    ""org.springframework.stereotype.Repository"",
    ""org.springframework.stereotype.Service"",
    ""org.springframework.web.bind.annotation.RestController"");

  private static final Pattern NAMING_CONVENTION = Pattern.compile(""^[a-z][a-zA-Z0-9]*$"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.ANNOTATION);
  }

  @Override
  public void visitNode(Tree tree) {
    var annotation = (AnnotationTree) tree;
    ANNOTATIONS_TO_CHECK.stream().filter(a -> annotation.symbolType().is(a)).findFirst()
      .map(a -> getNoncompliantNameArgument(annotation))
      .ifPresent(n -> reportIssue(n, ""Rename this bean to match the regular expression '"" + NAMING_CONVENTION.pattern() + ""'.""));
  }

  @CheckForNull
  private static ExpressionTree getNoncompliantNameArgument(AnnotationTree annotation) {
    return annotation.arguments().stream()
      .map(arg -> {
        if (breaksNamingConvention(getArgValue(arg))) {
          return arg;
        } else  {
          return null;
        }
      }).filter(Objects::nonNull).findFirst().orElse(null);
  }

  private static ExpressionTree getArgValue(ExpressionTree argument) {
    if (argument.is(Tree.Kind.ASSIGNMENT)) {
      var assignment = (AssignmentExpressionTree) argument;
      var argName = ((IdentifierTree) assignment.variable()).name();
      var argValue = assignment.expression();
      if (argName.equals(""name"") || argName.equals(""value"")) {
        return argValue;
      }
    } else {
      return argument;
    }
    return null;
  }

  private static boolean breaksNamingConvention(@Nullable ExpressionTree nameTree) {
    if (nameTree == null) {
      return false;
    } else {
      var name = ExpressionsHelper.getConstantValueAsString(nameTree).value();
      return name != null && !NAMING_CONVENTION.matcher(name).matches();
    }
  }
}
"
S6831,BUG,"""@Qualifier"" should not be used on ""@Bean"" methods","package org.sonar.java.checks.spring;

import java.util.LinkedList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.model.expression.AssignmentExpressionTreeImpl;
import org.sonar.java.model.expression.LiteralTreeImpl;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6831"")
public class AvoidQualifierOnBeanMethodsCheck extends IssuableSubscriptionVisitor {
  private static final String BEAN_ANNOTATION = ""org.springframework.context.annotation.Bean"";
  private static final String QUALIFIER_ANNOTATION = ""org.springframework.beans.factory.annotation.Qualifier"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.METHOD);
  }@Override
  public void visitNode(Tree tree) {
    var methodTree = (MethodTree) tree;

    var beanAnnotation = getAnnotation(methodTree, BEAN_ANNOTATION);
    var qualifierAnnotation = getAnnotation(methodTree, QUALIFIER_ANNOTATION);

    if (beanAnnotation != null && qualifierAnnotation != null) {
      QuickFixHelper.newIssue(context)
        .forRule(this)
        .onTree(qualifierAnnotation)
        .withMessage(""Remove this redundant \""@Qualifier\"" annotation and rely on the @Bean method."")
        .withQuickFixes(() -> getQuickFix(methodTree, qualifierAnnotation))
        .report();
    }
  }

  private static AnnotationTree getAnnotation(MethodTree methodTree, String annotation) {
    return methodTree.modifiers()
      .annotations()
      .stream()
      .filter(annotationTree -> annotationTree.symbolType().is(annotation))
      .findFirst()
      .orElse(null);
  }

  private static List<JavaQuickFix> getQuickFix(MethodTree methodTree, AnnotationTree qualifierAnnotation) {
    List<JavaQuickFix> quickFixes = new LinkedList<>();

    // quick fix only for @Qualifier annotations without arguments or with argument that matches the method name
    if (isFixable(methodTree, qualifierAnnotation)) {
      var quickFix = JavaQuickFix.newQuickFix(""Remove \""@Qualifier\"""")
        .addTextEdit(JavaTextEdit.removeTree(qualifierAnnotation))
        .build();
      quickFixes.add(quickFix);
    }

    return quickFixes;
  }

  private static boolean isFixable(MethodTree methodTree, AnnotationTree qualifierAnnotation) {
    var arguments = qualifierAnnotation.arguments();

    // @Qualifier annotation without argument can be always removed
    if (arguments.isEmpty()) {
      return true;
    }

    // @Qualifier that matches the method name is redundant and can be removed
    var methodName = methodTree.simpleName().name();
    return getQualifierAnnotationValue(arguments).equals(methodName);
  }

  private static String getQualifierAnnotationValue(Arguments arguments) {
    var argument = arguments.get(0);
    String qualifierAnnotationValue;

    if (argument.is(Tree.Kind.ASSIGNMENT)) {
      qualifierAnnotationValue = ((LiteralTreeImpl) ((AssignmentExpressionTreeImpl) argument).expression()).value();
    } else if (argument.is(Tree.Kind.STRING_LITERAL)) {
      qualifierAnnotationValue = ((LiteralTreeImpl) argument).token().text();
    } else {
      // case when argument is an identifier: don't suggest a quick fix
      qualifierAnnotationValue = """";
    }

    return removeQuotes(qualifierAnnotationValue);
  }

  private static String removeQuotes(String value) {
    return value.replace(""\"""", """");
  }
}
"
S6832,CODE_SMELL,Non-singleton Spring beans should not be injected into singleton beans,"package org.sonar.java.checks.spring;

import java.util.List;
import java.util.Optional;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.MethodTreeUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6832"")
public class NonSingletonAutowiredInSingletonCheck extends IssuableSubscriptionVisitor {
  private static final String SCOPED_ANNOTATION = ""org.springframework.context.annotation.Scope"";
  private static final String AUTOWIRED_ANNOTATION = ""org.springframework.beans.factory.annotation.Autowired"";
  private static final String JAVAX_INJECT_ANNOTATION = ""javax.inject.Inject"";
  private static final String JAKARTA_INJECT_ANNOTATION = ""jakarta.inject.Inject"";
  private static final Set<String> AUTO_WIRING_ANNOTATIONS = Set.of(AUTOWIRED_ANNOTATION, JAVAX_INJECT_ANNOTATION, JAKARTA_INJECT_ANNOTATION);

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.ANNOTATION, Tree.Kind.CONSTRUCTOR);
  }@Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.ANNOTATION)) {
      analyzeAnnotation((AnnotationTree) tree);
    }

    if (tree.is(Tree.Kind.CONSTRUCTOR)) {
      analyzeSingleArgumentConstructor((MethodTree) tree);
    }
  }

  private void analyzeAnnotation(AnnotationTree annotationTree) {
    if (!isAutoWiringAnnotation(annotationTree)) {
      return;
    }

    var annotatedSymbol = Optional.ofNullable(annotationTree.parent()).map(Tree::parent).orElse(null);
    if (annotatedSymbol == null) {
      return;
    }

    if (annotatedSymbol.is(Tree.Kind.VARIABLE)) {
      analyzeAnnotatedFieldOrParameter((VariableTree) annotatedSymbol);

    } else if (annotatedSymbol.is(Tree.Kind.METHOD)) {
      analyzeAnnotatedSetter((MethodTree) annotatedSymbol);

    } else if (annotatedSymbol.is(Tree.Kind.CONSTRUCTOR)) {
      analyzeAnnotatedConstructor((MethodTree) annotatedSymbol);
    }
  }

  private void analyzeAnnotatedFieldOrParameter(VariableTree annotatedVar) {
    String injectionType;

    if (isClassField(annotatedVar)) {
      injectionType = ""autowired field"";
    } else if (isSetterParameter(annotatedVar) || isConstructorParameter(annotatedVar)) {
      injectionType = ""autowired parameter"";
    } else {
      injectionType = null;
    }

    if (injectionType != null) {
      getEnclosingClass(annotatedVar.symbol().enclosingClass())
        .ifPresent(enclosingClassTree -> reportIfNonSingletonInSingleton(enclosingClassTree, annotatedVar, injectionType));
    }
  }

  private void analyzeAnnotatedSetter(MethodTree annotatedMethod) {
    if (MethodTreeUtils.isSetterMethod(annotatedMethod)) {
      getEnclosingClass(annotatedMethod.symbol().enclosingClass())
        .ifPresent(enclosingClassTree -> annotatedMethod.parameters()
          .forEach(variableTree -> reportIfNonSingletonInSingleton(enclosingClassTree, variableTree, ""autowired setter method"")));
    }
  }

  private void analyzeAnnotatedConstructor(MethodTree annotatedConstructor) {
    getEnclosingClass(annotatedConstructor.symbol().enclosingClass())
      .ifPresent(enclosingClassTree -> annotatedConstructor.parameters()
        .forEach(variableTree -> reportIfNonSingletonInSingleton(enclosingClassTree, variableTree, ""autowired constructor"")));
  }

  private void analyzeSingleArgumentConstructor(MethodTree constructorTree) {
    if (constructorTree.parameters().size() == 1) {
      var constructorParameter = constructorTree.parameters().get(0);
      getEnclosingClass(constructorTree.symbol().enclosingClass())
        .ifPresent(enclosingClassTree -> reportIfNonSingletonInSingleton(enclosingClassTree, constructorParameter, ""single argument constructor""));
    }
  }

  private static boolean isClassField(VariableTree variableTree) {
    return Optional.ofNullable(variableTree.parent())
      .filter(parent -> parent.is(Tree.Kind.CLASS))
      .isPresent();
  }

  private static boolean isSetterParameter(VariableTree variableTree) {
    return Optional.ofNullable(variableTree.parent())
      .filter(parent -> parent.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .filter(MethodTreeUtils::isSetterMethod)
      .isPresent();
  }

  private static boolean isConstructorParameter(VariableTree variableTree) {
    return Optional.ofNullable(variableTree.parent())
      .filter(parent -> parent.is(Tree.Kind.CONSTRUCTOR))
      .isPresent();
  }

  private static Optional<ClassTree> getEnclosingClass(@Nullable Symbol.TypeSymbol enclosingClassSymbol) {
    return Optional.ofNullable(enclosingClassSymbol).map(Symbol::declaration).map(ClassTree.class::cast);
  }

  private void reportIfNonSingletonInSingleton(ClassTree enclosingClassTree, VariableTree variableTree, String injectionType) {
    if (isSingletonBean(enclosingClassTree) && hasTypeNotSingletonBean(variableTree)) {
      reportIssue(variableTree.type(), ""Don't auto-wire this non-Singleton bean into a Singleton bean ("" + injectionType + "")."");
    }
  }

  private static boolean hasTypeNotSingletonBean(VariableTree variableTree) {
    return hasNotSingletonScopeAnnotation(variableTree.symbol().type().symbol().metadata().annotations());
  }

  private static boolean isAutoWiringAnnotation(AnnotationTree annotationTree) {
    return AUTO_WIRING_ANNOTATIONS.contains(annotationTree.symbolType().fullyQualifiedName());
  }

  private static boolean isSingletonBean(ClassTree classTree) {
    return !hasNotSingletonScopeAnnotation(classTree.symbol().metadata().annotations());
  }

  private static boolean hasNotSingletonScopeAnnotation(List<SymbolMetadata.AnnotationInstance> annotations) {
    // Only classes annotated with @Scope, having a value different from ""singleton"", are considered as non-Singleton
    return annotations.stream().anyMatch(NonSingletonAutowiredInSingletonCheck::isNotSingletonScopeAnnotation);
  }

  private static boolean isNotSingletonScopeAnnotation(SymbolMetadata.AnnotationInstance annotationInstance) {
    return annotationInstance.symbol().type().is(SCOPED_ANNOTATION)
      && annotationInstance.values()
        .stream()
        .anyMatch(NonSingletonAutowiredInSingletonCheck::isNotSingletonAnnotationValue);
  }

  private static boolean isNotSingletonAnnotationValue(SymbolMetadata.AnnotationValue annotationValue) {
    return (""value"".equals(annotationValue.name()) || ""scopeName"".equals(annotationValue.name()))
      // both ""value"" and ""scopeName"" in @Scope annotation have String type
      && !""singleton"".equalsIgnoreCase((String) annotationValue.value());
  }
}
"
S6833,CODE_SMELL,"""@Controller"" should be replaced with ""@RestController""","package org.sonar.java.checks.spring;

import java.util.ArrayList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6833"")
public class ControllerWithRestControllerReplacementCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    var classTree = (ClassTree) tree;

    var annotation = classTree.modifiers().annotations().stream()
      .filter(a -> ""org.springframework.stereotype.Controller"".equals(a.annotationType().symbolType().fullyQualifiedName()))
      .findFirst();

    if (annotation.isEmpty()) {
      return;
    }

    var secondaryLocations = new ArrayList<JavaFileScannerContext.Location>();
    List<JavaTextEdit> edits = new ArrayList<>();

    classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .forEach(method -> {
        var methodAnnotation = method.modifiers().annotations().stream()
          .filter(a -> ""org.springframework.web.bind.annotation.ResponseBody"".equals(a.annotationType().symbolType().fullyQualifiedName()))
          .findFirst();
        methodAnnotation.ifPresent(annotationTree -> secondaryLocations.add(new JavaFileScannerContext.Location(""Remove this \""@ResponseBody\"" annotation."", annotationTree)));
        methodAnnotation.ifPresent(annotationTree -> edits.add(JavaTextEdit.removeTree(annotationTree)));
      });

    classTree.modifiers().annotations().stream()
      .filter(a -> ""org.springframework.web.bind.annotation.ResponseBody"".equals(a.annotationType().symbolType().fullyQualifiedName()))
      .forEach(annotationTree -> secondaryLocations.add(new JavaFileScannerContext.Location(""Remove this \""@ResponseBody\"" annotation."", annotationTree)));

    if (secondaryLocations.isEmpty()) {
      return;
    }

    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(annotation.get())
      .withMessage(""Replace the \""@Controller\"" annotation by \""@RestController\"" and remove all \""@ResponseBody\"" annotations."")
      .withSecondaries(secondaryLocations)
      .withQuickFixes(() -> List.of(JavaQuickFix.newQuickFix(""Remove \""@ResponseBody\"" annotations."").addTextEdits(edits).build(),
        JavaQuickFix.newQuickFix(""Replace \""@Controller\"" by \""@RestController\""."").addTextEdit(JavaTextEdit.replaceTree(annotation.get(), ""@RestController"")).build()))
      .report();

  }

}
"
S6837,CODE_SMELL,"Superfluous ""@ResponseBody"" annotations should be removed","package org.sonar.java.checks.spring;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6837"")
public class SuperfluousResponseBodyAnnotationCheck extends IssuableSubscriptionVisitor {
  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    var ct = (ClassTree) tree;
    if (!ct.symbol().metadata().isAnnotatedWith(""org.springframework.web.bind.annotation.RestController"")) {
      return;
    }

    ct.members().stream().filter(member -> member.is(Tree.Kind.METHOD)).forEach(member -> {
      var mt = (MethodTree) member;
      mt.modifiers().annotations().stream()
        .filter(annotationTree -> annotationTree.symbolType().is(""org.springframework.web.bind.annotation.ResponseBody""))
        .findFirst()
        .ifPresent(annotationTree -> reportIssue(annotationTree, ""Remove this superfluous \""@ResponseBody\"" annotation.""));
    });
  }
}
"
S6838,BUG,"""@Bean"" methods for Singleton should not be invoked in ""@Configuration"" when proxyBeanMethods is false","package org.sonar.java.checks.spring;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;


@Rule(key = ""S6838"")
public class DirectBeanMethodInvocationWithoutProxyCheck extends IssuableSubscriptionVisitor {
  private static final String BEAN_ANNOTATION = ""org.springframework.context.annotation.Bean"";
  private static final String CONFIGURATION_ANNOTATION = ""org.springframework.context.annotation.Configuration"";
  private static final String SCOPE_ANNOTATION = ""org.springframework.context.annotation.Scope"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    Optional<AnnotationTree> configurationAnnotation = getConfigurationAnnotation((ClassTree) tree);
    if (configurationAnnotation.isEmpty() || !hasProxyBeanMethodsDisabled(configurationAnnotation.get())) {
      return;
    }
    var visitor = new NonProxiedMethodInvocationVisitor((ClassTree) tree);
    tree.accept(visitor);
    visitor.locations.forEach(invocation -> reportIssue(invocation, ""Replace this bean method invocation with a dependency injection.""));
  }

  private static Optional<AnnotationTree> getConfigurationAnnotation(ClassTree tree) {
    return tree.modifiers().annotations().stream()
      .filter(annotation -> annotation.symbolType().is(CONFIGURATION_ANNOTATION))
      .findFirst();
  }


  private static boolean hasProxyBeanMethodsDisabled(AnnotationTree annotation) {
    return annotation.arguments().stream()
      .filter(argument -> argument.is(Tree.Kind.ASSIGNMENT))
      .map(AssignmentExpressionTree.class::cast)
      .anyMatch(DirectBeanMethodInvocationWithoutProxyCheck::setsProxyBeanMethodsToFalse);
  }

  private static boolean setsProxyBeanMethodsToFalse(AssignmentExpressionTree assignment) {
    return ""proxyBeanMethods"".equals(((IdentifierTree) assignment.variable()).name()) &&
      Boolean.FALSE.equals(ExpressionsHelper.getConstantValueAsBoolean(assignment.expression()).value());
  }

  private static class NonProxiedMethodInvocationVisitor extends BaseTreeVisitor {
    private final ClassTree parentClass;
    private final List<MethodInvocationTree> locations = new ArrayList<>();

    public NonProxiedMethodInvocationVisitor(ClassTree parentClass) {
      this.parentClass = parentClass;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      super.visitMethodInvocation(tree);
      MethodTree declaration = tree.methodSymbol().declaration();
      if (declaration == null || !isBeanMethod(declaration) || hasPrototypeScope(declaration)) {
        return;
      }
      Tree parent = declaration.parent();
      if (parent == parentClass) {
        locations.add(tree);
      }
    }

    private static boolean isBeanMethod(MethodTree tree) {
      return tree.modifiers().annotations().stream()
        .anyMatch(annotation -> annotation.symbolType().is(BEAN_ANNOTATION));
    }private static boolean hasPrototypeScope(MethodTree method) {
      List<SymbolMetadata.AnnotationValue> annotationValues = method.symbol().metadata().valuesForAnnotation(SCOPE_ANNOTATION);
      return annotationValues != null && annotationValues.stream()
        .filter(argument -> List.of(""value"", ""scopeName"").contains(argument.name()))
        .map(SymbolMetadata.AnnotationValue::value)
        .map(String.class::cast)
        .anyMatch(""prototype""::equalsIgnoreCase);
    }
  }

}
"
S6856,BUG,"""@PathVariable"" annotation should be present if a path variable is used","package org.sonar.java.checks;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.Predicate;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.SymbolMetadata;
import org.sonar.plugins.java.api.semantic.Type;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6856"")
public class MissingPathVariableAnnotationCheck extends IssuableSubscriptionVisitor {
  private static final String PATH_VARIABLE_ANNOTATION = ""org.springframework.web.bind.annotation.PathVariable"";
  private static final String MODEL_ATTRIBUTE_ANNOTATION = ""org.springframework.web.bind.annotation.ModelAttribute"";
  private static final Pattern EXTRACT_PATH_VARIABLE = Pattern.compile(""([^:}/]*)(:.*)?}.*"");
  private static final Predicate<String> CONTAINS_PLACEHOLDER = Pattern.compile(""\\$\\{.*}"").asPredicate();
  private static final Predicate<String> PATH_ARG_REGEX = Pattern.compile(""\\{([^{}:]+:.*)}"").asPredicate();
  private static final Pattern PATH_REGEX = Pattern.compile(""\\{([^{}]+)}"");

  private static final List<String> MAPPING_ANNOTATIONS = List.of(
    ""org.springframework.web.bind.annotation.GetMapping"",
    ""org.springframework.web.bind.annotation.PostMapping"",
    ""org.springframework.web.bind.annotation.PutMapping"",
    ""org.springframework.web.bind.annotation.DeleteMapping"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree clazzTree = (ClassTree) tree;

    List<MethodTree> methods = clazzTree.members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .toList();

    Set<String> modelAttributePathVariable = methods.stream()
      .filter(method -> method.symbol().metadata().isAnnotatedWith(MODEL_ATTRIBUTE_ANNOTATION))
      .flatMap(method -> method.parameters().stream())
      .map(MissingPathVariableAnnotationCheck::pathVariableName)
      .flatMap(Optional::stream)
      .collect(Collectors.toSet());

    methods.forEach(method -> MAPPING_ANNOTATIONS
      .forEach(annotation -> checkParameters(method, annotation, modelAttributePathVariable)));
  }

  private void checkParameters(MethodTree method, String annotation, Set<String> modelAttributePathVariable) {
    if (containsMap(method)) {return;
    }

    Set<String> unusedPathVariables = findUnusedPathVariables(method, annotation, modelAttributePathVariable);
    if (!unusedPathVariables.isEmpty()) {
      reportIssue(
        annotation(method, annotation),
        ""Bind path variable \"""" + String.join(""\"", \"""", unusedPathVariables) + ""\"" to a method parameter."");
    }
  }

  private static Set<String> findUnusedPathVariables(MethodTree method, String annotation, Set<String> modelAttributePathVariable) {
    Set<String> pathVariablesUsedInArguments = method.parameters().stream()
      .map(MissingPathVariableAnnotationCheck::pathVariableName)
      .flatMap(Optional::stream)
      .collect(Collectors.toSet());

    return extractPathArgumentFromMappingAnnotations(method, annotation)
      .map(MissingPathVariableAnnotationCheck::extractPathVariables)
      .flatMap(pathVariables -> {
        pathVariables.removeAll(pathVariablesUsedInArguments);
        pathVariables.removeAll(modelAttributePathVariable);
        return pathVariables.stream();
      })
      .collect(Collectors.toSet());
  }

  private static boolean containsMap(MethodTree method) {
    return method.parameters().stream()
      .filter(parameter -> parameter.symbol().metadata().isAnnotatedWith(PATH_VARIABLE_ANNOTATION))
      .anyMatch(parameter -> {
        Type type = parameter.type().symbolType();
        return type.isSubtypeOf(""java.util.Map"");
      });
  }

  private static ExpressionTree annotation(MethodTree method, String name) {
    return method.modifiers().annotations().stream()
      .filter(annotation -> annotation.symbolType().is(name))
      .findFirst()
      // it will never be empty because we are filtering on the annotation before.
      .orElseThrow();
  }

  private static Set<String> extractPathVariables(String path) {
    if (CONTAINS_PLACEHOLDER.test(path)) {
      return new HashSet<>();
    }

    if (PATH_ARG_REGEX.test(path)) {
      return PATH_REGEX.matcher(path).results()
        .map(MatchResult::group)
        .map(s -> s.substring(1))
        .filter(s -> s.contains("":""))
        .map(s -> s.split("":"")[0])
        .collect(Collectors.toSet());
    }

    return Stream.of(path.split(""\\{""))
      .map(EXTRACT_PATH_VARIABLE::matcher)
      .filter(Matcher::matches)
      .map(matcher -> matcher.group(1))
      .collect(Collectors.toSet());
  }

  private static Optional<String> pathVariableName(VariableTree parameter) {
    SymbolMetadata metadata = parameter.symbol().metadata();

    return Optional.ofNullable(metadata.valuesForAnnotation(PATH_VARIABLE_ANNOTATION)).flatMap(arguments -> {
      Map<String, Object> nameToValue = arguments.stream().collect(
        Collectors.toMap(SymbolMetadata.AnnotationValue::name, SymbolMetadata.AnnotationValue::value));

      return Optional.ofNullable((String) nameToValue.get(""value""))
        .or(() -> Optional.ofNullable((String) nameToValue.get(""name"")))
        .or(() -> Optional.of(parameter.simpleName().name()));
    });

  }

  private static Stream<String> extractPathArgumentFromMappingAnnotations(MethodTree method, String annotation) {
    SymbolMetadata metadata = method.symbol().metadata();
    return Optional.ofNullable(metadata.valuesForAnnotation(annotation)).flatMap(arguments -> {
      Map<String, Object> nameToValue = arguments.stream().collect(
        Collectors.toMap(SymbolMetadata.AnnotationValue::name, SymbolMetadata.AnnotationValue::value));

      return arrayOrString(nameToValue.get(""path""))
        .or(() -> arrayOrString(nameToValue.get(""value"")));
    }).orElseGet(Stream::empty);
  }

  private static Optional<Stream<String>> arrayOrString(Object value) {
    if (value == null) {
      return Optional.empty();
    }

    Object[] array = (Object[]) value;
    return Optional.of(Stream.of(array)
      .map(x -> (String) x));
  }

}
"
S6857,BUG,SpEL expression should have a valid syntax,"package org.sonar.java.checks.spring;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.ObjIntConsumer;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.ExpressionsHelper;
import org.sonar.java.model.DefaultJavaFileScannerContext;
import org.sonar.java.reporting.AnalyzerMessage;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.location.Position;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;
import org.springframework.expression.ParseException;
import org.springframework.expression.spel.standard.SpelExpressionParser;

@Rule(key = ""S6857"")
public class SpelExpressionCheck extends IssuableSubscriptionVisitor {

  private static final String SPRING_PREFIX = ""org.springframework"";private static final Pattern PROPERTY_PLACEHOLDER_PATTERN = Pattern.compile(
    ""[a-zA-Z0-9_-]++(\\[\\d++])*+(\\.[a-zA-Z0-9_-]++(\\[\\d++])*+)*+""
  );

  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS, Tree.Kind.INTERFACE);
  }

  @Override
  public void visitNode(Tree tree) {
    getClassAndMemberAnnotations((ClassTree) tree)
      .filter(SpelExpressionCheck::isSpringAnnotation)
      .forEach(this::checkSpringAnnotationArguments);
  }

  private static Stream<AnnotationTree> getClassAndMemberAnnotations(ClassTree cls) {
    return Stream.concat(
      Stream.of(cls.modifiers().annotations()),
      cls.members().stream().map(SpelExpressionCheck::getMemberAnnotations)
    ).flatMap(Collection::stream);
  }

  private static List<AnnotationTree> getMemberAnnotations(Tree member) {
    if (member.is(Tree.Kind.METHOD)) {
      return ((MethodTree) member).modifiers().annotations();
    } else if (member.is(Tree.Kind.VARIABLE)) {
      return ((VariableTree) member).modifiers().annotations();
    } else {
      return Collections.emptyList();
    }
  }

  private static boolean isSpringAnnotation(AnnotationTree annotation) {
    return annotation.symbolType().fullyQualifiedName().startsWith(SPRING_PREFIX);
  }

  private void checkSpringAnnotationArguments(AnnotationTree annotation) {
    annotation.arguments().stream().map(SpelExpressionCheck::extractArgumentValue).filter(Objects::nonNull)
      .forEach(this::checkSpringExpressionsInString);
  }

  @CheckForNull
  private static Map.Entry<Tree, String> extractArgumentValue(ExpressionTree expression) {
    expression = getExpressionOrAssignmentRhs(expression);
    var stringValue = ExpressionsHelper.getConstantValueAsString(expression).value();
    if (stringValue == null) {
      return null;
    }
    return Map.entry(expression, stringValue);
  }

  private static ExpressionTree getExpressionOrAssignmentRhs(ExpressionTree expression) {
    return expression.is(Tree.Kind.ASSIGNMENT) ? ((AssignmentExpressionTree) expression).expression() : expression;
  }

  private void checkSpringExpressionsInString(Map.Entry<Tree, String> entry) {
    var expression = entry.getKey();
    try {
      var argValue = entry.getValue();
      if (expression.is(Tree.Kind.STRING_LITERAL)) {
        checkStringContents(argValue, 1);
      } else {
        checkStringContents(argValue, 0);
      }
    } catch (SyntaxError e) {
      reportIssue(expression, e);
    }
  }

  private void reportIssue(Tree expression, SyntaxError error) {
    if (expression.is(Tree.Kind.STRING_LITERAL)) {
      // For string literals, report exact issue location within the string.
      var tokenStart = Position.startOf(expression);
      var textSpan = new AnalyzerMessage.TextSpan(
        tokenStart.line(),
        tokenStart.columnOffset() + error.startColumn,
        tokenStart.line(),
        tokenStart.columnOffset() + error.endColumn
      );

      var analyzerMessage = new AnalyzerMessage(this, context.getInputFile(), textSpan, error.getMessage(), 0);
      ((DefaultJavaFileScannerContext) context).reportIssue(analyzerMessage);
    } else {
      reportIssue(expression, error.getMessage());
    }
  }

  private static void checkStringContents(String content, int startColumn) throws SyntaxError {
    var i = 0;
    while (i < content.length()) {
      var c = content.charAt(i);
      switch (c) {
        case '$':
          i = parseDelimitersAndContents(content, i + 1, startColumn + i, SpelExpressionCheck::parseValidPropertyPlaceholder);
          break;
        case '#':
          i = parseDelimitersAndContents(content, i + 1, startColumn + i, SpelExpressionCheck::parseValidSpelExpression);
          break;
        default:
          i++;
          break;
      }
    }
  }private static int parseDelimitersAndContents(
    String value,
    int startIndex,
    int startColumn,
    ObjIntConsumer<String> parseContents
  ) throws SyntaxError {
    if (startIndex == value.length()) {
      return startIndex;
    }
    var endIndex = parseDelimiterBraces(value, startIndex, startColumn);
    if (endIndex == startIndex) {
      return endIndex;
    }
    var contents = value.substring(startIndex + 1, endIndex - 1);
    parseContents.accept(contents, startColumn);
    return endIndex;
  }

  private static int parseDelimiterBraces(String value, int startIndex, int startColumn) throws SyntaxError {
    if (value.charAt(startIndex) != '{') {
      return startIndex;
    }

    int openCount = 1;
    for (var i = startIndex + 1; i < value.length(); i++) {
      var c = value.charAt(i);
      if (c == '{') {
        openCount++;
      } else if (c == '}') {
        openCount--;
        if (openCount == 0) {
          return i + 1;
        }
      }
    }

    // +1 because of prefix `$` or `#`
    var endColumn = startColumn + value.length() - startIndex + 1;
    throw new SyntaxError(""Add missing '}' for this property placeholder or SpEL expression."", startColumn, endColumn);
  }

  private static void parseValidPropertyPlaceholder(String placeholder, int startColumn) throws SyntaxError {
    if (!isValidPropertyPlaceholder(placeholder, startColumn)) {
      // +3 because of delimiter `#{` and `}`
      var endColumn = startColumn + placeholder.length() + 3;
      throw new SyntaxError(""Correct this malformed property placeholder."", startColumn, endColumn);
    }
  }

  private static boolean isValidPropertyPlaceholder(String placeholder, int startColumn) throws SyntaxError {
    var segments = placeholder.split("":"",2);
    if (!isValidPropertyPlaceholderFirstSegment(segments[0], startColumn)) {
      return false;
    }
    return segments.length < 2 || (isValidPropertyPlaceholderDefaultSegment(segments[1], startColumn + segments[0].length() + 1));
  }

  private static boolean isValidPropertyPlaceholderFirstSegment(String segment, int startColumn) throws SyntaxError {
    var stripped = segment.stripLeading();
    startColumn += segment.length() - stripped.length();
    stripped = stripped.stripTrailing();

    if (stripped.startsWith(""#{"")) {
      parseDelimitersAndContents(stripped, 1, startColumn + 2, SpelExpressionCheck::parseValidSpelExpression);
      return true;
    } else {
      return PROPERTY_PLACEHOLDER_PATTERN.matcher(stripped).matches();
    }
  }

  private static boolean isValidPropertyPlaceholderDefaultSegment(String segment, int startColumn) throws SyntaxError {
    var stripped = segment.stripLeading();
    startColumn += segment.length() - stripped.length();
    stripped = stripped.stripTrailing();

    var contentsParser = getContentsParser(stripped);
    if (contentsParser != null) {
      var endIndex = parseDelimitersAndContents(stripped, 1, startColumn + 2, contentsParser);
      return endIndex == segment.stripTrailing().length();
    }
    return segment.indexOf(':') < 0;
  }

  private static ObjIntConsumer<String> getContentsParser(String contents) {
    if (contents.startsWith(""${"")) {
      return SpelExpressionCheck::parseValidPropertyPlaceholder;
    }
    if (contents.startsWith(""#{"")) {
      return SpelExpressionCheck::parseValidSpelExpression;
    }
    return null;
  }

  private static void parseValidSpelExpression(String expressionString, int startColumn) throws SyntaxError {
    if (!isValidSpelExpression(expressionString)) {
      // +3 because of delimiter `${` and `}`
      var endColumn = startColumn + expressionString.length() + 3;
      throw new SyntaxError(""Correct this malformed SpEL expression."", startColumn, endColumn);
    }
  }

  private static boolean isValidSpelExpression(String expressionString) {
    expressionString = expressionString.strip();
    if (expressionString.isEmpty()) {
      return false;
    }
    try {
      new SpelExpressionParser().parseExpression(expressionString);
    } catch (ParseException | IllegalStateException e) {
      return false;
    }
    return true;
  }

  private static class SyntaxError extends RuntimeException {

    SyntaxError(String message, int startColumn, int endColumn) {
      super(message);
      this.startColumn = startColumn;
      this.endColumn = endColumn;
    }

    public final int startColumn;
    public final int endColumn;
  }
}
"
S6862,BUG,"Beans in ""@Configuration"" class should have different names","package org.sonar.java.checks;

import java.util.HashSet;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6862"")
public class ConfigurationBeanNamesCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    var classTree = (ClassTree) tree;
    if (!isConfigurationClass(classTree)) {
      return;
    }

    var beanMethods = getBeanMethods(classTree);
    var foundNames = new HashSet<String>();
    for (MethodTree beanMethod : beanMethods) {
      if (!foundNames.add(beanMethod.simpleName().name())) {
        reportIssue(beanMethod.simpleName(), ""Rename this bean method to prevent any conflict with other beans."");
      }
    }
  }

  private static boolean isConfigurationClass(ClassTree classTree) {
    return classTree.symbol().metadata().isAnnotatedWith(""org.springframework.context.annotation.Configuration"");
  }

  private static List<MethodTree> getBeanMethods(ClassTree classTree) {
    return classTree.members().stream()
      .filter(member -> member.is(Tree.Kind.METHOD))
      .map(MethodTree.class::cast)
      .filter(method -> method.symbol().metadata().isAnnotatedWith(""org.springframework.context.annotation.Bean""))
      .toList();
  }

}
"
S6863,BUG,Set appropriate Status Codes on HTTP responses,"package org.sonar.java.checks.spring;

import java.util.List;
import java.util.stream.Stream;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ClassTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6863"")
public class StatusCodesOnResponseCheck extends IssuableSubscriptionVisitor {

  public static final String RESPONSE_ENTITY = ""org.springframework.http.ResponseEntity"";
  public static final String ISSUE_MESSAGE = ""Set a HttpStatus code reflective of the operation."";private static final List<String> OK_CODES = List.of(""ACCEPTED"",
    ""ALREADY_REPORTED"",
    ""CHECKPOINT"",
    ""CONTINUE"",
    ""CREATED"",
    ""FOUND"",
    ""IM_USED"",
    ""MOVED_PERMANENTLY"",
    ""MULTIPLE_CHOICES"",
    ""MULTI_STATUS"",
    ""NON_AUTHORITATIVE_INFORMATION"",
    ""NOT_MODIFIED"",
    ""NO_CONTENT"",
    ""OK"",
    ""PARTIAL_CONTENT"",
    ""PERMANENT_REDIRECT"",
    ""PROCESSING"",
    ""RESET_CONTENT"",
    ""SEE_OTHER"",
    ""SWITCHING_PROTOCOLS"",
    ""TEMPORARY_REDIRECT"");private static final List<String> ERROR_CODES = List.of(""BAD_GATEWAY"",
    ""BAD_REQUEST"",
    ""BANDWIDTH_LIMIT_EXCEEDED"",
    ""CONFLICT"",
    ""EXPECTATION_FAILED"",
    ""FAILED_DEPENDENCY"",
    ""FORBIDDEN"",
    ""GATEWAY_TIMEOUT"",
    ""GONE"",
    ""HTTP_VERSION_NOT_SUPPORTED"",
    ""INSUFFICIENT_STORAGE"",
    ""INTERNAL_SERVER_ERROR"",
    ""I_AM_A_TEAPOT"",
    ""LENGTH_REQUIRED"",
    ""LOCKED"",
    ""LOOP_DETECTED"",
    ""METHOD_NOT_ALLOWED"",
    ""NETWORK_AUTHENTICATION_REQUIRED"",
    ""NOT_ACCEPTABLE"",
    ""NOT_EXTENDED"",
    ""NOT_FOUND"",
    ""NOT_IMPLEMENTED"",
    ""PAYLOAD_TOO_LARGE"",
    ""PAYMENT_REQUIRED"",
    ""PRECONDITION_FAILED"",
    ""PRECONDITION_REQUIRED"",
    ""PROXY_AUTHENTICATION_REQUIRED"",
    ""REQUESTED_RANGE_NOT_SATISFIABLE"",
    ""REQUEST_HEADER_FIELDS_TOO_LARGE"",
    ""REQUEST_TIMEOUT"",
    ""SERVICE_UNAVAILABLE"",
    ""TOO_MANY_REQUESTS"",
    ""UNAUTHORIZED"",
    ""UNAVAILABLE_FOR_LEGAL_REASONS"",
    ""UNPROCESSABLE_ENTITY"",
    ""UNSUPPORTED_MEDIA_TYPE"",
    ""UPGRADE_REQUIRED"",
    ""URI_TOO_LONG"",
    ""VARIANT_ALSO_NEGOTIATES"");

  private static final MethodMatchers STATUS_METHOD_MATCHERS = MethodMatchers.create()
    .ofTypes(RESPONSE_ENTITY)
    .names(""status"")
    .addParametersMatcher(""org.springframework.http.HttpStatus"")
    .build();

  private static final MethodMatchers OK_METHOD_MATCHERS = MethodMatchers.create()
    .ofTypes(RESPONSE_ENTITY)
    .names(""ok"", ""created"", ""accepted"", ""noContent"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers ERROR_METHODS_MATCHER = MethodMatchers.create()
    .ofTypes(RESPONSE_ENTITY)
    .names(""badRequest"", ""notFound"", ""unprocessableEntity"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    ClassTree classTree = (ClassTree) tree;
    if (!isClassController(classTree)) {
      return;
    }

    MethodInvocationVisitor methodInvocationVisitor = new MethodInvocationVisitor();
    classTree.accept(methodInvocationVisitor);
  }

  private class MethodInvocationVisitor extends BaseTreeVisitor {

    @Override
    public void visitMethodInvocation(MethodInvocationTree methodInvocationTree) {

      if (STATUS_METHOD_MATCHERS.matches(methodInvocationTree)) {
        checkTryCatch(methodInvocationTree);
        return;
      }

      if (OK_METHOD_MATCHERS.matches(methodInvocationTree)) {
        Tree catchParent = checkCatch(methodInvocationTree, false);
        if (catchParent == null) {
          checkTry(methodInvocationTree, true);
        }
        return;
      }

      if (ERROR_METHODS_MATCHER.matches(methodInvocationTree)) {
        Tree catchParent = checkCatch(methodInvocationTree, true);
        if (catchParent == null) {
          checkTry(methodInvocationTree, false);
        }
        return;
      }

      super.visitMethodInvocation(methodInvocationTree);
    }

    private void checkTryCatch(MethodInvocationTree methodInvocationTree) {
      Tree catchParent = ExpressionUtils.getParentOfType(methodInvocationTree, Tree.Kind.CATCH);
      boolean isError = isCodeInList(methodInvocationTree, ERROR_CODES);

      if (catchParent != null && !isError) {
        reportIssue(methodInvocationTree, ISSUE_MESSAGE);
        return;
      }

      if (catchParent == null) {
        Tree tryParent = ExpressionUtils.getParentOfType(methodInvocationTree, Tree.Kind.TRY_STATEMENT);
        boolean isOk = isCodeInList(methodInvocationTree, OK_CODES);

        if (tryParent != null && !isOk) {
          reportIssue(methodInvocationTree, ISSUE_MESSAGE);
        }
      }
    }

    private boolean isCodeInList(MethodInvocationTree methodInvocationTree, List<String> codes) {
      ExpressionTree arg = methodInvocationTree.arguments().get(0);
      if (arg.is(Tree.Kind.MEMBER_SELECT)) {
        MemberSelectExpressionTree memberSelectExpressionTree = (MemberSelectExpressionTree) arg;
        return codes.contains(memberSelectExpressionTree.identifier().name());
      } else if (arg.is(Tree.Kind.IDENTIFIER)) {
        IdentifierTree identifierTree = (IdentifierTree) arg;
        return codes.contains(identifierTree.name());
      }
      return true;
    }

    private Tree checkCatch(MethodInvocationTree methodInvocationTree, boolean isError) {
      Tree catchParent = ExpressionUtils.getParentOfType(methodInvocationTree, Tree.Kind.CATCH);
      if (catchParent != null && !isError) {
        reportIssue(methodInvocationTree, ISSUE_MESSAGE);
      }
      return catchParent;
    }

    private Tree checkTry(MethodInvocationTree methodInvocationTree, boolean isOk) {
      Parents parents = getParentsTryAndIf(methodInvocationTree);
      if (!parents.foundIfWithinTry() && parents.foundTryStatement && !isOk) {
        reportIssue(methodInvocationTree, ISSUE_MESSAGE);
      }
      return null;
    }
  }

  private static Parents getParentsTryAndIf(Tree tree) {
    Tree parent = tree.parent();
    boolean foundIfStatement = false;
    boolean foundTryStatement = false;
    while (parent != null && !parent.is(Tree.Kind.METHOD)) {
      if (parent.is(Tree.Kind.IF_STATEMENT)) {
        foundIfStatement = true;
      }
      if (parent.is(Tree.Kind.TRY_STATEMENT)) {
        foundTryStatement = true;
        break;
      }
      parent = parent.parent();
    }
    return new Parents(foundIfStatement, foundTryStatement);
  }

  private static class Parents {
    boolean foundIfStatement;
    boolean foundTryStatement;

    public Parents(boolean foundIfStatement, boolean foundTryStatement) {
      this.foundIfStatement = foundIfStatement;
      this.foundTryStatement = foundTryStatement;
    }

    boolean foundIfWithinTry() {
      return foundIfStatement && foundTryStatement;
    }
  }

  private static boolean isClassController(ClassTree classTree) {
    return Stream.of(""org.springframework.stereotype.Controller"", ""org.springframework.web.bind.annotation.RestController"")
      .anyMatch(annotation -> classTree.symbol().metadata().isAnnotatedWith(annotation));
  }

}
"
S6876,CODE_SMELL,Reverse iteration should utilize reversed view,"package org.sonar.java.checks;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.ListTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6876"")
public class ReversedMethodSequencedCollectionCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  private static final String ISSUE_MESSAGE = ""Use the \""reversed()\"" method instead of manually iterating the list in reverse."";

  private static final MethodMatchers LIST_ITERATOR_MATCHER = MethodMatchers.create()
    .ofTypes(""java.util.List"")
    .names(""listIterator"")
    .addParametersMatcher(""int"")
    .build();

  private static final MethodMatchers LIST_SIZE_MATCHER = MethodMatchers.create()
    .ofTypes(""java.util.List"")
    .names(""size"")
    .addWithoutParametersMatcher()
    .build();

  private static final MethodMatchers LIST_HAS_PREVIOUS_MATCHER = MethodMatchers.create()
    .ofTypes(""java.util.ListIterator"")
    .names(""hasPrevious"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava21Compatible();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.FOR_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    var forStatement = (ForStatementTree) tree;

    ListTree<StatementTree> initializerStatements = forStatement.initializer();
    if (initializerStatements.size() != 1) {
      return;
    }
    var initializer = initializerStatements.get(0);
    var condition = forStatement.condition();
    if (condition == null) {
      return;
    }

    if (isInitializerListIteratorFromLast(initializer) && isConditionHasPrevious(condition)) {
      reportIssue(forStatement.forKeyword(), ISSUE_MESSAGE);
    }
  }

  private static boolean isInitializerListIteratorFromLast(Tree initializer) {
    return initializer instanceof VariableTree variable
      && variable.initializer() instanceof MethodInvocationTree variableInitializer
      && LIST_ITERATOR_MATCHER.matches(variableInitializer)
      && variableInitializer.arguments().get(0) instanceof MethodInvocationTree arg
      && LIST_SIZE_MATCHER.matches(arg);
  }

  private static boolean isConditionHasPrevious(Tree condition) {
    return condition instanceof MethodInvocationTree invocation && LIST_HAS_PREVIOUS_MATCHER.matches(invocation);
  }

}
"
S6877,CODE_SMELL,Reverse view should be used instead of reverse copy in read-only cases,"package org.sonar.java.checks;

import java.util.EnumSet;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.semantic.Symbol.VariableSymbol;
import org.sonar.plugins.java.api.tree.Arguments;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6877"")
public class ReverseSequencedCollectionCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final String MESSAGE = ""Remove this \""reverse\"" statement and replace \""%s\"" with \""%s.reversed()\"" after."";

  private static final String ADD_ALL = ""addAll"";

  private static final MethodMatchers LIST_CONSTRUCTORS = MethodMatchers.create()
    .ofTypes(
      ""java.util.ArrayList"",
      ""java.util.LinkedList"",
      ""java.util.Vector"",
      ""java.util.Stack"",
      ""java.util.concurrent.CopyOnWriteArrayList"",
      ""javax.management.AttributeList"",
      ""javax.management.relation.RoleList"",
      ""javax.management.relation.RoleUnresolvedList"")
    .constructor()
    .withAnyParameters()
    .build();

  private static final MethodMatchers LIST_READONLY_CONSUMERS = MethodMatchers.create()
    .ofSubTypes(""java.util.List"")
    .names(ADD_ALL, ""copyOf"")
    .addParametersMatcher(""java.util.Collection"")
    .build();

  private static final MethodMatchers LIST_READ_ACCESSORS = MethodMatchers.or(
    MethodMatchers.create()
      .ofAnyType()
      .names(""clone"", ""getClass"", ""getFirst"", ""getLast"", ""hashCode"", ""isEmpty"", ""listIterator"", ""parallelStream"",
        ""size"", ""spliterator"", ""stream"", ""toArray"", ""toString"", ""wait"", ""notify"", ""notifyAll"")
      .addWithoutParametersMatcher()
      .build(),
    MethodMatchers.create()
      .ofAnyType()
      .names(""contains"", ""containsAll"", ""equals"", ""forEach"", ""get"", ""indexOf"", ""lastIndexOf"", ""listIterator"", ""toArray"")
      .addParametersMatcher(MethodMatchers.ANY)
      .build());

  private static final MethodMatchers LIST_WRITE_ACCESSORS = MethodMatchers.or(
    MethodMatchers.create()
      .ofAnyType()
      .names(""clear"", ""removeFirst"", ""removeLast"")
      .addWithoutParametersMatcher()
      .build(),
    MethodMatchers.create()
      .ofAnyType()
      .names(""add"", ADD_ALL, ""addFirst"", ""addLast"", ""remove"", ""removeAll"", ""replaceAll"", ""retainAll"", ""sort"")
      .addParametersMatcher(MethodMatchers.ANY)
      .build(),
    MethodMatchers.create()
      .ofAnyType()
      .names(""add"", ADD_ALL, ""set"")
      .addParametersMatcher(""int"", MethodMatchers.ANY)
      .build());

  private static final Set<Tree.Kind> SUPPORTED_REVERSE_SCOPE_CHILD_KINDS = EnumSet.of(
    Tree.Kind.IDENTIFIER,
    Tree.Kind.ARGUMENTS,
    Tree.Kind.METHOD_INVOCATION,
    Tree.Kind.EXPRESSION_STATEMENT,
    Tree.Kind.MEMBER_SELECT,
    Tree.Kind.BLOCK,
    Tree.Kind.IF_STATEMENT);

  private static final Set<Tree.Kind> SUPPORTED_USAGE_SCOPE_CHILD_KINDS = EnumSet.of(
    Tree.Kind.IDENTIFIER,
    Tree.Kind.MEMBER_SELECT,
    Tree.Kind.METHOD_INVOCATION,
    Tree.Kind.ASSIGNMENT,
    Tree.Kind.EXPRESSION_STATEMENT,
    Tree.Kind.BLOCK,
    Tree.Kind.IF_STATEMENT);

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava21Compatible();
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.util.Collections"")
      .names(""reverse"")
      .addParametersMatcher(""java.util.List"")
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree methodInvocation) {
    Arguments reverseMethodArguments = methodInvocation.arguments();
    if (reverseMethodArguments.isEmpty() || !reverseMethodArguments.get(0).is(Tree.Kind.IDENTIFIER)) {
      return;
    }
    IdentifierTree reverseMethodArgument = (IdentifierTree) reverseMethodArguments.get(0);
    Symbol symbol = reverseMethodArgument.symbol();
    // Only support local variables. ""Collections.reverse(list)"" mutates ""list"" and return void. If ""list"" was a
    // field or a method parameter, we don't know if the mutation of the ""list"" is used outside of this method body. So
    // we don't raise issue.
    if (!symbol.isLocalVariable() || symbol.isParameter()) {
      return;
    }
    VariableSymbol reverseMethodArgumentSymbol = (VariableSymbol) symbol;
    if (areUsagesCompatibleWithReversed(reverseMethodArgument, reverseMethodArgumentSymbol)) {
      String message = String.format(MESSAGE, reverseMethodArgumentSymbol.name(), reverseMethodArgumentSymbol.name());
      reportIssue(ExpressionUtils.methodName(methodInvocation), message);
    }
  }

  private static boolean areUsagesCompatibleWithReversed(IdentifierTree reverseArgument, VariableSymbol listSymbol) {
    VariableTree declaration = listSymbol.declaration();
    // We are checking that there are no write modifiers of ""list"" after ""Collections.reverse(list)"".
    // Because we don't use symbolic execution, we will know that a usage is after by using its position in the file.
    // This strategy only works if there are no loops or lambdas. To ensure this, we will check that ""Collections.reverse(list)""
    // and its write usages share the same ""reverseParentScope"".
    Tree reverseParentScope = findParentScope(reverseArgument, SUPPORTED_REVERSE_SCOPE_CHILD_KINDS);
    if (declaration == null || reverseParentScope == null ||
      !isInitializerCompatibleWithReversed(declaration, reverseParentScope)) {
      return false;
    }
    for (IdentifierTree usage : listSymbol.usages()) {
      if (!isUsageCompatibleWithReversed(usage, reverseArgument, reverseParentScope)) {
        return false;
      }
    }
    return true;
  }

  private static boolean isInitializerCompatibleWithReversed(VariableTree declaration, Tree reverseParentScope) {
    if (declaration.parent() instanceof ForEachStatement) {
      return false;
    }
    ExpressionTree initializer = declaration.initializer();
    if (initializer == null) {
      return true;
    }
    return isNullOrListConstructor(initializer) &&
      matchReverseParentSafeScope(declaration.parent(), reverseParentScope);
  }

  private static boolean isUsageCompatibleWithReversed(IdentifierTree usage, IdentifierTree reverseArgument, Tree reverseParentScope) {
    if (usage == reverseArgument || isCompatibleReadUsage(usage)) {
      return true;
    }
    if (isAfter(usage, reverseArgument)) {
      return false;
    }
    return isCompatibleWriteUsage(usage) && matchReverseParentSafeScope(usage, reverseParentScope);
  }

  private static boolean isCompatibleWriteUsage(IdentifierTree usage) {
    if (matchAccessor(usage, LIST_WRITE_ACCESSORS)) {
      return true;
    }
    return usage.parent() instanceof AssignmentExpressionTree assignmentExpression &&
      isNullOrListConstructor(assignmentExpression.expression());
  }

  private static boolean isCompatibleReadUsage(IdentifierTree usage) {
    if (matchAccessor(usage, LIST_READ_ACCESSORS)) {
      return true;
    }
    Tree parent = usage.parent();
    if (parent instanceof Arguments arguments) {
      return isListReadOnlyConsumer(arguments.parent());
    } else {
      return parent instanceof ForEachStatement forEachStatement && forEachStatement.expression() == usage;
    }
  }private static boolean matchAccessor(IdentifierTree usage, MethodMatchers methodMatchers) {
    Tree parent = usage.parent();
    if (parent instanceof MemberSelectExpressionTree memberSelect && memberSelect.expression() == usage) {
      Tree grandParent = parent.parent();
      if (grandParent instanceof MethodInvocationTree methodInvocation && methodInvocation.methodSelect() == parent) {
        return methodMatchers.matches(methodInvocation);
      }
    }
    return false;
  }

  private static boolean isAfter(IdentifierTree a, IdentifierTree b) {
    return a.identifierToken().range().start().isAfter(b.identifierToken().range().start());
  }

  private static boolean isNullOrListConstructor(ExpressionTree expression) {
    if (expression.is(Tree.Kind.NULL_LITERAL)) {
      return true;
    }
    return isListConstructor(expression);
  }

  private static boolean isListReadOnlyConsumer(@Nullable Tree tree) {
    if (tree instanceof MethodInvocationTree methodInvocation) {
      return LIST_READONLY_CONSUMERS.matches(methodInvocation);
    }
    return isListConstructor(tree);
  }

  private static boolean isListConstructor(@Nullable Tree tree) {
    return tree instanceof NewClassTree newClassTree && LIST_CONSTRUCTORS.matches(newClassTree);
  }

  private static Tree findParentScope(@Nullable Tree tree, Set<Tree.Kind> supportedChildKinds) {
    while (tree != null && supportedChildKinds.contains(tree.kind())) {
      tree = tree.parent();
    }
    return tree;
  }private static boolean matchReverseParentSafeScope(@Nullable Tree tree, Tree reverseParentScope) {
    return findParentScope(tree, SUPPORTED_USAGE_SCOPE_CHILD_KINDS) == reverseParentScope;
  }

}
"
S6878,CODE_SMELL,Use record pattern instead of explicit field access,"package org.sonar.java.checks;

import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.CaseLabelTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.PatternInstanceOfTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypePatternTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6878"")
public class RecordPatternInsteadOfFieldAccessCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  private static final List<String> ALLOWED_METHODS = List.of(""toString"", ""hashCode"", ""equals"");

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava21Compatible();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.PATTERN_INSTANCE_OF, Tree.Kind.CASE_LABEL);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree instanceof PatternInstanceOfTree instanceOf) {
      var pattern = instanceOf.pattern();
      if (pattern instanceof TypePatternTree typePattern && isRecordPattern(typePattern)) {
        checkTypePatternVariableUsage(typePattern.patternVariable());
      }
    } else {
      checkCaseLabel((CaseLabelTree) tree);
    }
  }

  private void checkCaseLabel(CaseLabelTree caseLabel) {
    var typePattern = getRecordTypePatternFromCaseGroup(caseLabel);
    typePattern.ifPresent(typePatternTree -> checkTypePatternVariableUsage(typePatternTree.patternVariable()));
  }

  private static Optional<TypePatternTree> getRecordTypePatternFromCaseGroup(CaseLabelTree caseLabel) {
    if (caseLabel.expressions().size() == 1
      && caseLabel.expressions().get(0) instanceof TypePatternTree typePattern
      && isRecordPattern(typePattern)) {
      return Optional.of(typePattern);
    }
    return Optional.empty();
  }

  private void checkTypePatternVariableUsage(VariableTree patternVariable) {
    var secondaryLocationsTrees = new HashSet<MemberSelectExpressionTree>();
    var recordSymbol = patternVariable.symbol().type().symbol();
    for (Tree usage : patternVariable.symbol().usages()) {
      if (usage.parent() instanceof MemberSelectExpressionTree mse && isNotRecordGetter(mse)) {
        secondaryLocationsTrees.add(mse);
      } else {
        return;
      }
    }
    // only if all the records components are used we report an issue
    if (isEveryRecordComponentUsed(secondaryLocationsTrees, recordSymbol)) {
      reportIssue(patternVariable, ""Use the record pattern instead of this pattern match variable."",
        getSecondaryLocations(secondaryLocationsTrees), null);
    }
  }

  private static boolean isEveryRecordComponentUsed(Set<MemberSelectExpressionTree> secondaryLocationsTrees, Symbol.TypeSymbol recordSymbol) {
    var recordComponentNames = recordComponentNames(recordSymbol);
    return !recordComponentNames.isEmpty() &&
      secondaryLocationsTrees.stream()
        .map(mse -> mse.identifier().name())
        .collect(Collectors.toSet())
        .equals(recordComponentNames);
  }

  private static boolean isNotRecordGetter(MemberSelectExpressionTree mse) {
    return !ALLOWED_METHODS.contains(mse.identifier().name());
  }

  private static List<JavaFileScannerContext.Location> getSecondaryLocations(Set<MemberSelectExpressionTree> secondaryLocationsTrees) {
    return secondaryLocationsTrees.stream()
      .map(tree ->
        new JavaFileScannerContext.Location(""Replace this getter with the respective record pattern component"", tree))
      .toList();
  }

  private static boolean isRecordPattern(TypePatternTree typePattern) {
    return typePattern.patternVariable().type().symbolType().isSubtypeOf(""java.lang.Record"");
  }

  private static Set<String> recordComponentNames(Symbol.TypeSymbol recordSymbol) {
    return recordSymbol
      .memberSymbols()
      .stream()
      .filter(Symbol::isVariableSymbol)
      .map(Symbol.VariableSymbol.class::cast)
      .map(Symbol.VariableSymbol::name)
      .collect(Collectors.toSet());
  }

}
"
S6880,CODE_SMELL,Use switch instead of if-else chain to compare a variable against multiple cases,"package org.sonar.java.checks;

import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.PatternInstanceOfTree;
import org.sonar.plugins.java.api.tree.PatternTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.ThrowStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;


@Rule(key = ""S6880"")
public class PatternMatchUsingIfCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  private static final String ISSUE_MESSAGE = ""Replace the chain of if/else with a switch expression."";
  private static final int INDENT = 2;
  private static final Set<String> SCRUTINEE_TYPES_FOR_NON_PATTERN_SWITCH = Set.of(
    ""byte"", ""short"", ""char"", ""int"",
    ""java.lang.Byte"", ""java.lang.Short"", ""java.lang.Character"", ""java.lang.Integer""
  );

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava21Compatible();
  }

  @Override
  public List<Kind> nodesToVisit() {
    return List.of(Kind.IF_STATEMENT);
  }

  @Override
  public void visitNode(Tree tree) {
    var topLevelIfStat = (IfStatementTree) tree;

    if (isElseIf(topLevelIfStat) || !hasElseIf(topLevelIfStat)) {
      return;
    }

    // Optimization
    if (!topLevelIfStat.condition().is(Kind.PATTERN_INSTANCE_OF, Kind.EQUAL_TO, Kind.CONDITIONAL_AND, Kind.CONDITIONAL_OR)) {
      return;
    }

    var cases = extractCasesFromIfSequence(topLevelIfStat);
    if (cases == null || !(cases.get(cases.size() - 1) instanceof DefaultCase) || !casesHaveCommonScrutinee(cases)
      || (cases.get(0) instanceof EqualityCase && !hasValidScrutineeTypeForNonPatternSwitch(cases.get(0).scrutinee()))) {
      return;
    }

    QuickFixHelper.newIssue(context).forRule(this)
      .onTree(topLevelIfStat.ifKeyword())
      .withMessage(ISSUE_MESSAGE)
      .withQuickFix(() -> computeQuickFix(cases, topLevelIfStat))
      .report();
  }

  private static boolean casesHaveCommonScrutinee(List<Case> cases) {
    return cases.stream().allMatch(c -> c.scrutinee().name().equals(cases.get(0).scrutinee().name()));
  }

  private static boolean hasValidScrutineeTypeForNonPatternSwitch(IdentifierTree scrutinee) {
    if (scrutinee.symbolType().symbol().isEnum()) {
      return true;
    }
    var fullyQualifiedTypeName = scrutinee.symbolType().fullyQualifiedName();
    return SCRUTINEE_TYPES_FOR_NON_PATTERN_SWITCH.contains(fullyQualifiedTypeName);
  }

  private static @Nullable List<Case> extractCasesFromIfSequence(IfStatementTree topLevelIfStat) {
    var cases = new LinkedList<Case>();
    StatementTree stat;
    for (stat = topLevelIfStat; stat instanceof IfStatementTree ifStat; stat = ifStat.elseStatement()) {
      var caze = convertToCase(ifStat.condition(), ifStat.thenStatement());
      if (caze == null) {
        return null;
      }
      cases.add(caze);
    }
    if (stat != null) {
      cases.add(new DefaultCase(cases.getLast().scrutinee(), stat));
    }
    return cases;
  }

  private static @Nullable Case convertToCase(ExpressionTree condition, StatementTree body) {
    var leftmost = findLeftmostInConjunction(condition);
    var guards = new LinkedList<ExpressionTree>();
    populateGuardsList(condition, guards);
    if (leftmost instanceof PatternInstanceOfTree patInstOf && patInstOf.pattern() != null
      && patInstOf.expression() instanceof IdentifierTree idTree) {
      return new PatternMatchCase(idTree, patInstOf.pattern(), guards, body);
    } else if ((leftmost.kind() == Kind.CONDITIONAL_OR || leftmost.kind() == Kind.EQUAL_TO) && guards.isEmpty()) {
      return buildEqualityCase(leftmost, body);
    } else {
      return null;
    }
  }private static @Nullable EqualityCase buildEqualityCase(ExpressionTree expr, StatementTree body) {
    var constantsList = new LinkedList<ExpressionTree>();
    IdentifierTree scrutinee = null;
    while (expr.kind() == Kind.CONDITIONAL_OR) {
      var binary = (BinaryExpressionTree) expr;
      var varAndCst = extractVarAndConstFromEqualityCheck(binary.rightOperand());
      if (varAndCst == null) {
        return null;
      } else if (scrutinee == null) {
        scrutinee = varAndCst.a;
      } else if (!varAndCst.a.name().equals(scrutinee.name())) {
        return null;
      }
      constantsList.addFirst(varAndCst.b);
      expr = binary.leftOperand();
    }
    var varAndCst = extractVarAndConstFromEqualityCheck(expr);
    if (varAndCst == null || (scrutinee != null && !varAndCst.a.name().equals(scrutinee.name()))) {
      return null;
    }
    constantsList.addFirst(varAndCst.b);
    return new EqualityCase(scrutinee == null ? varAndCst.a : scrutinee, constantsList, body);
  }

  private static @Nullable Pair<IdentifierTree, ExpressionTree> extractVarAndConstFromEqualityCheck(ExpressionTree expr) {
    if (expr.kind() == Kind.EQUAL_TO) {
      var binary = (BinaryExpressionTree) expr;
      if (binary.leftOperand() instanceof IdentifierTree idTree && isPossibleConstantForCase(binary.rightOperand())) {
        return new Pair<>(idTree, binary.rightOperand());
      } else if (binary.rightOperand() instanceof IdentifierTree idTree && isPossibleConstantForCase(binary.leftOperand())) {
        return new Pair<>(idTree, binary.leftOperand());
      }
    }
    return null;
  }

  private static boolean isPossibleConstantForCase(ExpressionTree expr) {
    return expr.asConstant().isPresent() || expr.symbolType().symbol().isEnum();
  }

  private static ExpressionTree findLeftmostInConjunction(ExpressionTree expr) {
    while (expr.kind() == Kind.CONDITIONAL_AND) {
      expr = ((BinaryExpressionTree) expr).leftOperand();
    }
    return expr;
  }

  private static void populateGuardsList(ExpressionTree expr, Deque<ExpressionTree> guards) {
    while (expr instanceof BinaryExpressionTree binary && binary.kind() == Kind.CONDITIONAL_AND) {
      guards.addFirst(binary.rightOperand());
      expr = binary.leftOperand();
    }
  }

  private static boolean isElseIf(IfStatementTree ifStat) {
    return ifStat.parent() instanceof IfStatementTree parentIf && parentIf.elseStatement() == ifStat;
  }

  private static boolean hasElseIf(IfStatementTree ifStat) {
    return ifStat.elseStatement() instanceof IfStatementTree;
  }

  private JavaQuickFix computeQuickFix(List<Case> cases, IfStatementTree topLevelIfStat) {
    var canLiftReturn = cases.stream().allMatch(caze -> exprWhenReturnLifted(caze) != null);
    var baseIndent = topLevelIfStat.firstToken().range().start().column() - 1;
    var sb = new StringBuilder();
    if (canLiftReturn) {
      sb.append(""return "");
    }
    sb.append(""switch ("").append(cases.get(0).scrutinee().name()).append("") {\n"");
    for (Case caze : cases) {
      sb.append("" "".repeat(baseIndent + INDENT));
      writeCase(caze, sb, baseIndent, canLiftReturn);
      sb.append(""\n"");
    }
    sb.append("" "".repeat(baseIndent)).append(""}"");
    if (canLiftReturn) {
      sb.append("";"");
    }
    var edit = JavaTextEdit.replaceTree(topLevelIfStat, sb.toString());
    return JavaQuickFix.newQuickFix(ISSUE_MESSAGE).addTextEdit(edit).build();
  }

  private void writeCase(Case caze, StringBuilder sb, int baseIndent, boolean canLiftReturn) {
    if (caze instanceof PatternMatchCase patternMatchCase) {
      sb.append(""case "").append(QuickFixHelper.contentForTree(patternMatchCase.pattern, context));
      if (!patternMatchCase.guards().isEmpty()) {
        List<ExpressionTree> guards = patternMatchCase.guards();
        sb.append("" when "");
        join(guards, "" && "", sb);
      }
    } else if (caze instanceof EqualityCase equalityCase) {
      sb.append(""case "");
      join(equalityCase.constants, "", "", sb);
    } else {
      sb.append(""default"");
    }
    sb.append("" -> "");
    if (canLiftReturn) {
      sb.append(exprWhenReturnLifted(caze));
    } else {
      addIndentedExceptFirstLine(makeBlockCode(caze.body(), baseIndent), sb);
    }
  }

  private String makeBlockCode(StatementTree stat, int baseIndent) {
    var rawCode = QuickFixHelper.contentForTree(stat, context);
    if (stat instanceof BlockTree) {
      return rawCode;
    } else {
      return ""{\n"" + "" "".repeat(baseIndent + INDENT) + rawCode + ""\n"" + "" "".repeat(baseIndent) + ""}"";
    }
  }

  private static void addIndentedExceptFirstLine(String s, StringBuilder sb) {
    var lines = s.lines().iterator();
    var indentStr = "" "".repeat(INDENT);
    sb.append(lines.next());
    while (lines.hasNext()) {
      sb.append(""\n"").append(indentStr).append(lines.next());
    }
  }

  private void join(List<? extends Tree> elems, String sep, StringBuilder sb) {
    var iter = elems.iterator();
    while (iter.hasNext()) {
      var e = iter.next();
      sb.append(QuickFixHelper.contentForTree(e, context));
      if (iter.hasNext()) {
        sb.append(sep);
      }
    }
  }

  private @Nullable String exprWhenReturnLifted(Case caze) {
    var stat = caze.body();
    while (stat instanceof BlockTree block && block.body().size() == 1) {
      stat = block.body().get(0);
    }
    if (stat instanceof ReturnStatementTree returnStat && returnStat.expression() != null) {
      return QuickFixHelper.contentForTree(returnStat.expression(), context) + "";"";
    } else if (stat instanceof ThrowStatementTree throwStatementTree) {
      return QuickFixHelper.contentForTree(throwStatementTree, context);
    }
    return null;
  }

  private sealed interface Case permits PatternMatchCase, EqualityCase, DefaultCase {
    IdentifierTree scrutinee();

    StatementTree body();
  }

  private record PatternMatchCase(IdentifierTree scrutinee, PatternTree pattern, List<ExpressionTree> guards,
                                  StatementTree body) implements Case {
  }

  private record EqualityCase(IdentifierTree scrutinee, List<ExpressionTree> constants, StatementTree body) implements Case {
  }private record DefaultCase(IdentifierTree scrutinee, StatementTree body) implements Case {
  }

  private record Pair<A, B>(A a, B b) {
  }

}
"
S6881,BUG,Virtual threads should be used for tasks that include heavy blocking operations,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6881"")
public class BlockingOperationsInVirtualThreadsCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {private static final String JAVA_LANG_THREAD = ""java.lang.Thread"";

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.NEW_CLASS, Tree.Kind.METHOD_INVOCATION, Tree.Kind.METHOD);
  }

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava21Compatible();
  }

  // This rule currently only supports a limited set of blocking operations, focused on core Java HTTP requests.
  private static final MethodMatchers blockingOperations = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(""java.net.URLConnection"", ""java.net.HttpURLConnection"")
      .names(""getResponseCode"", ""getResponseMessage"")
      .withAnyParameters()
      .build(),
    MethodMatchers.create()
      .ofTypes(JAVA_LANG_THREAD)
      .names(""sleep"")
      .addParametersMatcher(""long"")
      .build());

  private static final MethodMatchers threadCreationConstructors = MethodMatchers.create()
    .ofSubTypes(JAVA_LANG_THREAD)
    .constructor()
    .addParametersMatcher(""java.lang.Runnable"")
    .build();

  private static final MethodMatchers platformThreadMethods = MethodMatchers.create()
    .ofTypes(JAVA_LANG_THREAD + ""$Builder$OfPlatform"")
    .names(""start"", ""unstarted"")
    .addParametersMatcher(""java.lang.Runnable"")
    .build();

  // For cases where a method is overwritten to define a thread's behavior (instead of e.g. passing a lambda to a Thread's constructor).
  private static final MethodMatchers overwritableThreadMethods = MethodMatchers.create()
    .ofSubTypes(JAVA_LANG_THREAD)
    .names(""run"")
    .addWithoutParametersMatcher()
    .build();

  @Override
  public void visitNode(Tree tree) {
    switch (tree.kind()) {
      case NEW_CLASS -> onConstructorFound((NewClassTree) tree);
      case METHOD_INVOCATION -> onMethodInvocationFound((MethodInvocationTree) tree);
      case METHOD -> onMethodFound((MethodTree) tree);
    }
  }

  private void onConstructorFound(NewClassTree newClassTree) {
    if (threadCreationConstructors.matches(newClassTree)) {
      analyzeForIssues(newClassTree.arguments().get(0), newClassTree.identifier());
    }
  }

  private void onMethodInvocationFound(MethodInvocationTree mit) {
    if (platformThreadMethods.matches(mit)) {
      analyzeForIssues(mit.arguments().get(0), mit.methodSelect());
    }
  }

  private void onMethodFound(MethodTree tree) {
    if (overwritableThreadMethods.matches(tree)) {
      analyzeForIssues(tree, tree.simpleName());
    }
  }

  private void analyzeForIssues(Tree tree, Tree secondary) {
    var finder = new BlockingOperationFinder();
    tree.accept(finder);
    finder.collectedBlockingOperations.forEach(mit -> reportIssue(
      ExpressionUtils.methodName(mit),
      ""Use virtual threads for heavy blocking operations."",
      List.of(new JavaFileScannerContext.Location(""Containing thread"", secondary)),
      null));
  }

  private static class BlockingOperationFinder extends BaseTreeVisitor {
    final List<MethodInvocationTree> collectedBlockingOperations = new ArrayList<>();

    @Override
    public void visitMethodInvocation(MethodInvocationTree mit) {
      if (blockingOperations.matches(mit)) {
        collectedBlockingOperations.add(mit);
      }
    }
  }
}
"
S6885,CODE_SMELL,"Use built-in ""Math.clamp"" methods","package org.sonar.java.checks;

import java.util.List;
import javax.annotation.CheckForNull;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.model.ExpressionUtils.skipParentheses;

@Rule(key = ""S6885"")
public class MathClampMethodsCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  public static final String CONDITIONAL_EXPRESSION_MESSAGE = ""Use \""Math.clamp\"" instead of a conditional expression."";
  public static final String METHOD_INVOCATION_MESSAGE = ""Use \""Math.clamp\"" instead of \""Math.min\"" or \""Math.max\""."";

  public static final String JAVA_LANG_MATH = ""java.lang.Math"";
  private static final MethodMatchers MATH_MIN_METHOD_MATCHERS = MethodMatchers.create()
    .ofTypes(JAVA_LANG_MATH)
    .names(""min"")
    .withAnyParameters()
    .build();

  private static final MethodMatchers MATH_MAX_METHOD_MATCHERS = MethodMatchers.create()
    .ofTypes(JAVA_LANG_MATH)
    .names(""max"")
    .withAnyParameters()
    .build();

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava21Compatible();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CONDITIONAL_EXPRESSION, Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    if (tree.is(Tree.Kind.CONDITIONAL_EXPRESSION)) {
      checkConditionalExpression((ConditionalExpressionTree) tree);
    } else { // METHOD_INVOCATION
      checkMethodInvocation((MethodInvocationTree) tree);
    }
  }

  private void checkConditionalExpression(ConditionalExpressionTree firstConditionalExpression) {
    BinaryExpressionTree condition = greaterOrLessBinaryExpression(firstConditionalExpression.condition());
    if (condition != null) {
      boolean isGreater = isGreaterThanOrEqual(condition);
      var trueExpression = skipParentheses(firstConditionalExpression.trueExpression());
      var falseExpression = skipParentheses(firstConditionalExpression.falseExpression());
      if ((shouldReportOnConditional(condition.rightOperand(), trueExpression, falseExpression, isGreater) ||
        shouldReportOnConditional(condition.rightOperand(), falseExpression, trueExpression, !isGreater))
        || (shouldReportOnConditional(condition.leftOperand(), falseExpression, trueExpression, isGreater) ||
          shouldReportOnConditional(condition.leftOperand(), trueExpression, falseExpression, !isGreater))) {
        reportIssue(firstConditionalExpression, CONDITIONAL_EXPRESSION_MESSAGE);
      }
    }
  }

  private static boolean shouldReportOnConditional(ExpressionTree condition, ExpressionTree tree1, ExpressionTree tree2, boolean isMax) {
    if (ExpressionUtils.areVariablesSame(condition, tree1, false)) {
      if (tree2.is(Tree.Kind.CONDITIONAL_EXPRESSION)) {
        var innerExpression = (ConditionalExpressionTree) skipParentheses(tree2);
        var innerCondition = (BinaryExpressionTree) skipParentheses(innerExpression.condition());

        return (isLessThanOrEqual(innerExpression.condition())
          && checkInnerExpression(innerCondition, innerExpression.trueExpression(), innerExpression.falseExpression(), isMax))
          || (isGreaterThanOrEqual(innerExpression.condition())
            && checkInnerExpression(innerCondition, innerExpression.trueExpression(), innerExpression.falseExpression(), !isMax));
      } else {
        return matches(isMax ? MATH_MAX_METHOD_MATCHERS : MATH_MIN_METHOD_MATCHERS, tree2);
      }
    }
    return false;
  }

  private static boolean checkInnerExpression(BinaryExpressionTree innerCondition, ExpressionTree innerTrueExpression, ExpressionTree innerFalseExpression, boolean isMax) {
    return isMax
      ? (ExpressionUtils.areVariablesSame(innerCondition.leftOperand(), innerFalseExpression, false)
        && ExpressionUtils.areVariablesSame(innerCondition.rightOperand(), innerTrueExpression, false))
      : (ExpressionUtils.areVariablesSame(innerCondition.leftOperand(), innerTrueExpression, false)
        && ExpressionUtils.areVariablesSame(innerCondition.rightOperand(), innerFalseExpression, false));
  }

  private void checkMethodInvocation(MethodInvocationTree tree) {
    boolean isMinMax = isMin(tree) && isMax(tree.arguments().get(0), tree.arguments().get(1));
    boolean isMaxMin = isMax(tree) && isMin(tree.arguments().get(0), tree.arguments().get(1));
    if (isMinMax || isMaxMin) {
      reportIssue(tree, METHOD_INVOCATION_MESSAGE);
    }
  }

  @CheckForNull
  private static BinaryExpressionTree greaterOrLessBinaryExpression(ExpressionTree tree) {
    ExpressionTree expr = skipParentheses(tree);
    return isGreaterThanOrEqual(expr) || isLessThanOrEqual(expr) ? (BinaryExpressionTree) expr : null;
  }

  private static boolean isGreaterThanOrEqual(ExpressionTree tree) {
    return tree.is(Tree.Kind.GREATER_THAN) || tree.is(Tree.Kind.GREATER_THAN_OR_EQUAL_TO);
  }

  private static boolean isLessThanOrEqual(ExpressionTree tree) {
    return tree.is(Tree.Kind.LESS_THAN) || tree.is(Tree.Kind.LESS_THAN_OR_EQUAL_TO);
  }

  private static boolean isMax(Tree... trees) {
    return matches(MATH_MAX_METHOD_MATCHERS, trees);
  }

  private static boolean isMin(Tree... trees) {
    return matches(MATH_MIN_METHOD_MATCHERS, trees);
  }

  private static boolean matches(MethodMatchers methodMatchers, Tree... trees) {
    for (Tree tree : trees) {
      if (tree.is(Tree.Kind.METHOD_INVOCATION) && methodMatchers.matches((MethodInvocationTree) tree)) {
        return true;
      }
    }
    return false;
  }

}
"
S6889,CODE_SMELL,Proper Sensor Resource Management,"package org.sonar.java.checks;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.IntStream;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.Tree;@Rule(key = ""S6889"")
public class ReleaseSensorsCheck extends IssuableSubscriptionVisitor {

  private enum AcquireReleaseSensor {
    LOCATION_MANAGER(""android.location.LocationManager"", ""requestLocationUpdates"", ""removeUpdates""),
    SENSOR_MANAGER(""android.hardware.SensorManager"", ""registerListener"", ""unregisterListener""),
    VIRTUAL_DISPLAY(""android.media.projection.MediaProjection"", ""createVirtualDisplay"", ""android.hardware.display.VirtualDisplay"", RELEASE),
    CAMERA(""android.hardware.Camera"", ""open"", RELEASE),
    CAMERA2(""android.hardware.camera2.CameraManager"", ""openCamera"", ""android.hardware.camera2.CameraDevice"", ""close""),
    POWER_MANAGER(""android.os.PowerManager$WakeLock"", ACQUIRE, RELEASE),
    WIFI_MANAGER(""android.net.wifi.WifiManager$MulticastLock"", ACQUIRE, RELEASE),
    SOUND_POOL(""android.media.SoundPool$Builder"", ""build"", ""android.media.SoundPool"", RELEASE),
    VISUALIZER(""android.media.audiofx.Visualizer"", MethodMatchers.CONSTRUCTOR, RELEASE),
    MEDIA_PLAYER(""android.media.MediaPlayer"", MethodMatchers.CONSTRUCTOR, RELEASE),
    MEDIA_RECORDER(""android.media.MediaRecorder"", MethodMatchers.CONSTRUCTOR, RELEASE);

    private final MethodMatchers acquireMethodMatcher;
    private final MethodMatchers releaseMethodMatcher;

    AcquireReleaseSensor(String sensorClass, String acquireMethod, String releaseMethod) {
      this.acquireMethodMatcher = MethodMatchers.create().ofTypes(sensorClass).names(acquireMethod).withAnyParameters().build();
      this.releaseMethodMatcher = MethodMatchers.create().ofTypes(sensorClass).names(releaseMethod).withAnyParameters().build();
    }

    AcquireReleaseSensor(String acquireSensorClass, String acquireMethod, String releaseSensorClass, String releaseMethod) {
      this.acquireMethodMatcher = MethodMatchers.create().ofTypes(acquireSensorClass).names(acquireMethod).withAnyParameters().build();
      this.releaseMethodMatcher = MethodMatchers.create().ofTypes(releaseSensorClass).names(releaseMethod).withAnyParameters().build();
    }
  }

  private static class AcquireReleaseStatus {
    List<Tree> acquireInvocations = new LinkedList<>();
    boolean released = false;
  }

  private static final String ACQUIRE = ""acquire"";
  private static final String RELEASE = ""release"";
  private AcquireReleaseStatus[] statuses;

  @Override
  public void setContext(JavaFileScannerContext context) {
    super.setContext(context);
    initStatuses();
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    Arrays.stream(statuses)
      .filter(status -> !status.released)
      .forEach(status -> status.acquireInvocations.forEach(mit -> reportIssue(mit, ""Make sure to release this sensor after use."")));
    statuses = null;
  }

  private void initStatuses() {
    this.statuses = IntStream.range(0, AcquireReleaseSensor.values().length)
      .mapToObj(i -> new AcquireReleaseStatus())
      .toArray(AcquireReleaseStatus[]::new);
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.METHOD_INVOCATION, Tree.Kind.NEW_CLASS);
  }

  @Override
  public void visitNode(Tree tree) {
    // collect acquire invocations
    Arrays.stream(AcquireReleaseSensor.values())
      .filter(sensor -> isMethodMatched(tree, sensor.acquireMethodMatcher))
      .findAny()
      .ifPresent(sensor -> statuses[sensor.ordinal()].acquireInvocations.add(tree));

    // flag released invocations
    Arrays.stream(AcquireReleaseSensor.values())
      .filter(sensor -> isMethodMatched(tree, sensor.releaseMethodMatcher))
      .findAny()
      .ifPresent(sensor -> statuses[sensor.ordinal()].released = true);
  }

  private static boolean isMethodMatched(Tree tree, MethodMatchers methodMatchers) {
    switch (tree.kind()) {
      case METHOD_INVOCATION:
        return methodMatchers.matches((MethodInvocationTree) tree);
      case NEW_CLASS:
        return methodMatchers.matches((NewClassTree) tree);
      default:
        return false;
    }
  }
}
"
S6891,CODE_SMELL,Exact alarms should not be abused,"package org.sonar.java.checks.sustainability;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6891"")
public class AndroidExactAlarmCheck extends AbstractMethodDetection {

  private static final String SET_EXACT_NAME = ""setExact"";

  private static final String SET_EXACT_AND_ALLOW_WHILE_IDLE_NAME = ""setExactAndAllowWhileIdle"";

  private static final String SET_WINDOW_NAME = ""setWindow"";

  private static final long SUGGESTED_MIN_LENGTH_MILLIS = 10L * 60L * 1000L;

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofSubTypes(""android.app.AlarmManager"")
      .names(SET_EXACT_NAME, SET_EXACT_AND_ALLOW_WHILE_IDLE_NAME, SET_WINDOW_NAME)
      .withAnyParameters()
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree tree) {
    if (SET_WINDOW_NAME.equals(tree.methodSymbol().name())) {
      onSetWindowInvocation(tree);
    } else {
      onSetExactInvocation(tree);
    }
  }

  private void onSetExactInvocation(MethodInvocationTree tree) {
    var identifier = ExpressionUtils.methodName(tree);
    var methodName = identifier.name();
    var replacementName = methodName.replace(""Exact"", """");
    reportIfInAndroidContext(identifier, String.format(""Use \""%s\"" instead of \""%s\""."", replacementName, methodName));
  }

  private void onSetWindowInvocation(MethodInvocationTree tree) {
    if (tree.arguments().size() < 3) return;
    var windowLengthMillisArg = tree.arguments().get(2);
    var windowLengthMillis = ExpressionUtils.resolveAsConstant(windowLengthMillisArg);

    if (windowLengthMillis instanceof Number num && num.longValue() < SUGGESTED_MIN_LENGTH_MILLIS) {
      reportIfInAndroidContext(windowLengthMillisArg, ""Use alarm windows of 10 minutes or more instead."");
    }
  }

  private void reportIfInAndroidContext(Tree tree, String message) {
    if (context.inAndroidContext()) {
      reportIssue(tree, message);
    }
  }
}
"
S6898,CODE_SMELL,High frame rates should not be used,"package org.sonar.java.checks;

import java.util.List;
import java.util.Map;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6898"")
public class AvoidHighFrameratesOnMobileCheck extends IssuableSubscriptionVisitor {

  private static final int DEFAULT_THRESHOLD = 60;
  private static final Map<MethodMatchers, Integer> FRAME_RATE_SETTERS = Map.of(
    MethodMatchers.create().ofTypes(""android.view.Surface"").names(""setFrameRate"").withAnyParameters().build(), 0,
    MethodMatchers.create().ofTypes(""android.view.SurfaceControl"").names(""setFrameRate"").withAnyParameters().build(), 1);

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    var mit = (MethodInvocationTree) tree;
    FRAME_RATE_SETTERS.entrySet().stream().filter(e -> e.getKey().matches(mit)).findFirst().ifPresent(e -> {
      var frameRateArg = mit.arguments().get(e.getValue());
      var frameRateArgVal = ExpressionUtils.resolveAsConstant(frameRateArg);

      if (frameRateArgVal instanceof Number frameRateNumber && frameRateNumber.intValue() > DEFAULT_THRESHOLD) {
        reportIssue(frameRateArg, ""Avoid setting high frame rates higher than "" + DEFAULT_THRESHOLD + "" on mobile devices."");
      }
    });
  }
}
"
S6901,BUG,"""setDaemon"", ""setPriority"" and ""getThreadGroup"" should not be invoked on virtual threads","package org.sonar.java.checks;

import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6901"")
public class VirtualThreadUnsupportedMethodsCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final String ISSUE_MESSAGE = ""Method '%s' is not supported on virtual threads."";
  private static final String SECONDARY_LOCATION_ISSUE_MESSAGE = ""Virtual thread initialized here."";

  private static final MethodMatchers VIRTUAL_THREAD_BUILDER_METHODS = MethodMatchers.or(
    MethodMatchers.create()
      .ofTypes(""java.lang.Thread$Builder$OfVirtual"")
      .names(""unstarted"", ""start"")
      .addParametersMatcher(""java.lang.Runnable"").build(),
    MethodMatchers.create()
      .ofTypes(""java.lang.Thread"")
      .names(""startVirtualThread"")
      .addParametersMatcher(""java.lang.Runnable"").build()
  );

  private static final MethodMatchers VIRTUAL_THREAD_UNSUPPORTED_METHODS = MethodMatchers.create()
    .ofTypes(""java.lang.Thread"")
    .names(""setDaemon"", ""setPriority"", ""getThreadGroup"")
    .withAnyParameters()
    .build();

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava21Compatible();
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return VIRTUAL_THREAD_UNSUPPORTED_METHODS;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    var memberSelect = (MemberSelectExpressionTree) mit.methodSelect();
    var expression = memberSelect.expression();
    var virtualThreadExpression = getVirtualThreadInitializer(expression);
    if (virtualThreadExpression.isPresent()) {
      reportIssue(
        memberSelect.identifier(),
        String.format(ISSUE_MESSAGE, memberSelect.identifier().name()),
        List.of(new JavaFileScannerContext.Location(SECONDARY_LOCATION_ISSUE_MESSAGE, ExpressionUtils.methodName(virtualThreadExpression.get()))),
        null);
    }
  }

  private static Optional<MethodInvocationTree> getVirtualThreadInitializer(ExpressionTree expression) {
    var isMit = getMethodInvocationAndReturningVirtualThread(expression);
    if (isMit.isPresent()) {
      return isMit;
    } else {
      return getIdentifierAndVirtualThread(expression);
    }
  }

  private static Optional<MethodInvocationTree> getIdentifierAndVirtualThread(ExpressionTree expression) {
    if (expression instanceof IdentifierTree identifier && identifier.symbol().declaration() instanceof VariableTree variableTree) {
      return getMethodInvocationAndReturningVirtualThread(variableTree.initializer());
    }
    return Optional.empty();
  }

  private static Optional<MethodInvocationTree> getMethodInvocationAndReturningVirtualThread(ExpressionTree expression) {
    if (expression instanceof MethodInvocationTree mit && VIRTUAL_THREAD_BUILDER_METHODS.matches(mit)) {
      return Optional.of(mit);
    }
    return Optional.empty();
  }

}
"
S6904,CODE_SMELL,"Avoid using ""FetchType.EAGER""","package org.sonar.java.checks;

import java.util.List;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Nullable;
import org.sonar.check.Rule;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6904"")
public class JpaEagerFetchTypeCheck extends IssuableSubscriptionVisitor {

  private static final Set<String> FETCH_TYPE_ENUMS = Set.of(
    ""jakarta.persistence.FetchType"",
    ""javax.persistence.FetchType"");

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.ANNOTATION);
  }

  @Override
  public void visitNode(Tree tree) {
    var at = (AnnotationTree) tree;

    // Report an issue if any argument in the annotation is FetchType.EAGER
    at.arguments().stream()
      .map(JpaEagerFetchTypeCheck::getEagerArgument)
      .filter(Objects::nonNull)
      .findAny()
      .ifPresent(arg -> reportIssue(arg, ""Use lazy fetching instead.""));
  }

  @Nullable
  private static IdentifierTree getEagerArgument(ExpressionTree tree) {
    if (tree.is(Tree.Kind.ASSIGNMENT)) {
      var assignmentTree = (AssignmentExpressionTree) tree;
      var assignedExpr = assignmentTree.expression();
      IdentifierTree fetchType;
      if (assignedExpr.is(Tree.Kind.MEMBER_SELECT)) {
        fetchType = ((MemberSelectExpressionTree) assignedExpr).identifier();
      } else if (assignedExpr.is(Tree.Kind.IDENTIFIER)) {
        fetchType = (IdentifierTree) assignedExpr;
      } else {
        return null;
      }

      if (""fetch"".equals(ExpressionUtils.extractIdentifier(assignmentTree).name()) &&
        ""EAGER"".equals(fetchType.name()) &&
        FETCH_TYPE_ENUMS.contains(assignedExpr.symbolType().fullyQualifiedName())) {

        return fetchType;
      }
    }

    return null;
  }
}
"
S6905,CODE_SMELL,SQL queries should retrieve only necessary fields,"package org.sonar.java.checks;

import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Predicate;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.semantic.Symbol;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

import static java.util.regex.Pattern.CASE_INSENSITIVE;
import static java.util.regex.Pattern.compile;@Rule(key = ""S6905"")
public class QueryOnlyRequiredFieldsCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers SQL_QUERY_METHODS = MethodMatchers.create()
    .ofSubTypes(""java.sql.Connection"", ""java.sql.Statement"")
    .names(""prepareStatement"", ""prepareCall"", ""execute"", ""executeQuery"")
    .addParametersMatcher(types -> !types.isEmpty() && types.get(0).is(""java.lang.String""))
    .build();

  private static final Predicate<String> SELECT_FROM_REGEXP = compile(""select\\s+\\*\\s+from"", CASE_INSENSITIVE).asPredicate();

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.METHOD_INVOCATION);
  }

  @Override
  public void visitNode(Tree tree) {
    MethodInvocationTree mit = (MethodInvocationTree) tree;

    if (SQL_QUERY_METHODS.matches(mit)) {
      mit.arguments().stream()
        .map(QueryOnlyRequiredFieldsCheck::extractQuery)
        .filter(Objects::nonNull)
        .filter(arg -> SELECT_FROM_REGEXP.test(arg.value()))
        .forEach(arg -> reportIssue(arg, ""Don't use the query \""SELECT *\"".""));
    }
  }

  private static LiteralTree extractQuery(ExpressionTree expression) {
    switch (expression.kind()) {
      case STRING_LITERAL:
        return (LiteralTree) expression;
      case IDENTIFIER:
        return Optional.of(expression)
          .map(IdentifierTree.class::cast)
          .map(IdentifierTree::symbol)
          .map(Symbol::declaration)
          .filter(VariableTree.class::isInstance)
          .map(VariableTree.class::cast)
          .map(VariableTree::initializer)
          .filter(LiteralTree.class::isInstance)
          .map(LiteralTree.class::cast)
          .orElse(null);
      default:
        return null;
    }
  }
}
"
S6906,BUG,Virtual threads should not run tasks that include synchronized code,"package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6906"")
public class VirtualThreadNotSynchronizedCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava21Compatible();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.COMPILATION_UNIT);
  }

  @Override
  public void visitNode(Tree tree) {
    var runnablesCollector = new RunnablesToCheckCollector();
    tree.accept(runnablesCollector);

    var synchonizedTreesCollector = new TreesWithSynchronizedCodeCollector();
    runnablesCollector.invocations.stream()
      .filter(it -> synchonizedTreesCollector.isInvokingSynchronizedCode(it.arguments().get(0)))
      .forEach(it -> reportIssue(it, synchonizedTreesCollector.getSecondaryLocation(it.arguments().get(0))));
  }

  void reportIssue(MethodInvocationTree tree, Tree secondaryLocation) {
    reportIssue(
      tree.methodSelect(),
      ""Use a platform thread instead of a virtual thread"",
      List.of(new JavaFileScannerContext.Location(""synchronized"", secondaryLocation)),
      null
    );
  }

  private static class RunnablesToCheckCollector extends BaseTreeVisitor {

    private static final String OF_VIRTUAL = ""java.lang.Thread$Builder$OfVirtual"";

    private static final MethodMatchers VIRTUAL_THREAD_BUILDER_METHODS = MethodMatchers.or(
      MethodMatchers.create()
        .ofSubTypes(""java.lang.Thread$Builder"")
        .names(""start"", ""unstarted"")
        .addParametersMatcher(""java.lang.Runnable"").build(),
      MethodMatchers.create()
        .ofTypes(""java.lang.Thread"")
        .names(""startVirtualThread"")
        .addParametersMatcher(""java.lang.Runnable"").build(),
      MethodMatchers.create()
        .ofSubTypes(""java.util.concurrent.ExecutorService"")
        .names(""execute"", ""submit"")
        .withAnyParameters().build()
    );

    private static final MethodMatchers EXECUTOR_BUILDER_SERVICE_WITH_VIRTUAL_TASKS_METHOD = MethodMatchers.create()
      .ofTypes(""java.util.concurrent.Executors"")
      .names(""newVirtualThreadPerTaskExecutor"")
      .withAnyParameters().build();

    public final List<MethodInvocationTree> invocations = new ArrayList<>();

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      super.visitMethodInvocation(tree);
      if (VIRTUAL_THREAD_BUILDER_METHODS.matches(tree) && isRunnableInVirtualThread(tree)) {
        invocations.add(tree);
      }
    }

    private static boolean isRunnableInVirtualThread(MethodInvocationTree tree) {
      return switch (tree.methodSymbol().name()) {
        case ""start"", ""unstarted"" -> isCallToOfVirtual(tree);
        case ""execute"", ""submit"" -> isCallToExecutorServiceWithVirtualTasks(tree);
        default -> true;
      };
    }

    private static boolean isCallToOfVirtual(MethodInvocationTree tree) {
      var callSiteExpression = ((MemberSelectExpressionTree) tree.methodSelect()).expression();
      if (callSiteExpression.symbolType().is(OF_VIRTUAL)) {
        return true;
      }

      // Cover the case that call site is not type OfVirtual, but initialized with OfVirtual
      return getInitializerExpression(callSiteExpression)
        .stream()
        .anyMatch(it -> it.symbolType().is(OF_VIRTUAL));
    }

    private static boolean isCallToExecutorServiceWithVirtualTasks(MethodInvocationTree tree) {
      var callSiteExpression = ((MemberSelectExpressionTree) tree.methodSelect()).expression();
      if (isCallToExecutorServiceBuilderWithVirtualTasks(callSiteExpression)) {
        return true;
      }

      return getInitializerExpression(callSiteExpression)
        .stream()
        .anyMatch(RunnablesToCheckCollector::isCallToExecutorServiceBuilderWithVirtualTasks);
    }

    private static Optional<ExpressionTree> getInitializerExpression(ExpressionTree expression) {
      return expression instanceof IdentifierTree identifier && identifier.symbol().declaration() instanceof VariableTree variableTree ?
        Optional.ofNullable(variableTree.initializer()) : Optional.empty();
    }

    private static boolean isCallToExecutorServiceBuilderWithVirtualTasks(ExpressionTree expression) {
      return expression instanceof MethodInvocationTree mit && EXECUTOR_BUILDER_SERVICE_WITH_VIRTUAL_TASKS_METHOD.matches(mit);
    }
  }

  private static class TreesWithSynchronizedCodeCollector extends BaseTreeVisitor {

    private Tree currentCheckedTree;

    private final Map<Tree, Tree> treesWithSynchronizedCode = new HashMap<>();

    private final Set<Tree> checkedTrees = new HashSet<>();

    private boolean isSynchronizedAttributeFound = false;

    public boolean isInvokingSynchronizedCode(Tree tree) {
      this.currentCheckedTree = tree;
      isSynchronizedAttributeFound = false;
      tree.accept(this);
      return treesWithSynchronizedCode.containsKey(tree);
    }

    public Tree getSecondaryLocation(Tree tree) {
      return treesWithSynchronizedCode.get(tree);
    }

    private void markSynchronizedBy(Tree secondaryLocation) {
      treesWithSynchronizedCode.put(currentCheckedTree, secondaryLocation);
      isSynchronizedAttributeFound = true;
    }

    @Override
    public void visitSynchronizedStatement(SynchronizedStatementTree tree) {
      if (!isSynchronizedAttributeFound) {
        markSynchronizedBy(tree.synchronizedKeyword());
      }
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (isSynchronizedAttributeFound) {
        return;
      }
      if (tree.methodSymbol().isSynchronizedMethod()) {
        markSynchronizedBy(tree);
        return;
      }
      // Make sure to visit arguments even for methods without declaration
      super.visitMethodInvocation(tree);

      var declaration = tree.methodSymbol().declaration();
      if (declaration != null) {
        checkNonSynchronizedMethod(declaration);
      }
    }

    void checkNonSynchronizedMethod(MethodTree method) {
      var methodMarkedSynchronizedBy = treesWithSynchronizedCode.get(method);
      if (methodMarkedSynchronizedBy != null) {
        markSynchronizedBy(methodMarkedSynchronizedBy);
        return;
      }

      if (checkedTrees.contains(method)) {
        return;
      }
      checkedTrees.add(method);

      var block = method.block();
      if (block == null) {
        return;
      }
      var restoreCurrentCheckedTree = currentCheckedTree;
      currentCheckedTree = method;
      block.accept(this);
      currentCheckedTree = restoreCurrentCheckedTree;
      if (isSynchronizedAttributeFound) {
        markSynchronizedBy(treesWithSynchronizedCode.get(method));
      }
    }
  }
}
"
S6909,CODE_SMELL,"Constant parameters in a ""PreparedStatement"" should not be set more than once","package org.sonar.java.checks;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.TreeHelper;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ForEachStatement;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.StatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S6909"")
public class PreparedStatementLoopInvariantCheck extends IssuableSubscriptionVisitor {

  private static final MethodMatchers MATCHERS = MethodMatchers.create()
    .ofSubTypes(""java.sql.PreparedStatement"")
    .name(it -> it.startsWith(""set""))
    .withAnyParameters()
    .build();

  private static final Set<Tree.Kind> LOOP_KINDS = EnumSet.of(
    Tree.Kind.FOR_STATEMENT, Tree.Kind.FOR_EACH_STATEMENT, Tree.Kind.WHILE_STATEMENT, Tree.Kind.DO_STATEMENT
  );

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    var invocationCollector = new MethodInvocationCollector(MATCHERS);
    tree.accept(invocationCollector);

    invocationCollector.invocations.stream()
      .map(PreparedStatementLoopInvariantCheck::getCandidate)
      .filter(Objects::nonNull)
      .collect(Collectors.groupingBy(candidate -> candidate.enclosingLoop))
      .forEach(this::checkCandidatesInLoop);
  }

  void checkCandidatesInLoop(StatementTree loop, List<Candidate> candidates) {
    var localsCollector = new DeclaredOrAssignedLocalsCollector();
    loop.accept(localsCollector);
    candidates.forEach(it -> reportIfLoopInvariant(localsCollector.declaredOrAssignedLocals, it));
  }

  private void reportIfLoopInvariant(Set<String> declaredOrAssignedLocals, Candidate candidate) {
    if (isLoopInvariant(declaredOrAssignedLocals, candidate)) {
      var secondaryLocation = new JavaFileScannerContext.Location(
        ""Enclosing loop"",
        Objects.requireNonNull(candidate.enclosingLoop)
      );
      reportIssue(
        candidate.invocation,
        ""Move this loop-invariant setter invocation out of this loop."",
        List.of(secondaryLocation),
        null
      );
    }
  }

  private static boolean isLoopInvariant(Set<String> declaredOrAssignedLocals, Candidate candidate) {
    return (candidate.identifierArguments.stream().noneMatch(declaredOrAssignedLocals::contains));
  }

  private static Candidate getCandidate(MethodInvocationTree invocation) {
    var identifierArguments = new ArrayList<String>();
    for (var arg : invocation.arguments()) {
      if (arg.is(Tree.Kind.IDENTIFIER)) {
        identifierArguments.add(((IdentifierTree) arg).name());
      } else {
        var argValue = ExpressionUtils.resolveAsConstant(arg);
        if (argValue == null) return null;
      }
    }

    var loop = TreeHelper.findClosestParentOfKind(invocation, LOOP_KINDS);
    if (loop != null) {
      return new Candidate(invocation, identifierArguments, (StatementTree) loop);
    }
    return null;
  }

  private static class Candidate {
    public final MethodInvocationTree invocation;
    public final List<String> identifierArguments;
    public final StatementTree enclosingLoop;

    private Candidate(MethodInvocationTree invocation, List<String> argumentVariables, StatementTree enclosingLoop) {
      this.invocation = invocation;
      this.identifierArguments = argumentVariables;
      this.enclosingLoop = enclosingLoop;
    }
  }

  private static class MethodInvocationCollector extends BaseTreeVisitor {

    public final List<MethodInvocationTree> invocations = new ArrayList<>();
    private final MethodMatchers matchers;

    public MethodInvocationCollector(MethodMatchers matchers) {
      this.matchers = matchers;
    }

    @Override
    public void visitMethodInvocation(MethodInvocationTree tree) {
      if (matchers.matches(tree)) {
        invocations.add(tree);
      }
      super.visitMethodInvocation(tree);
    }
  }

  private static class DeclaredOrAssignedLocalsCollector extends BaseTreeVisitor {

    public final Set<String> declaredOrAssignedLocals = new HashSet<>();

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
      super.visitAssignmentExpression(tree);
      var variable = tree.variable();
      if (variable.is(Tree.Kind.IDENTIFIER)) {
        declaredOrAssignedLocals.add(((IdentifierTree) variable).name());
      }
    }

    @Override
    public void visitVariable(VariableTree tree) {
      super.visitVariable(tree);
      declaredOrAssignedLocals.add(tree.simpleName().name());
    }

    @Override
    public void visitUnaryExpression(UnaryExpressionTree tree) {
      super.visitUnaryExpression(tree);
      switch (tree.kind()) {
        case POSTFIX_INCREMENT, POSTFIX_DECREMENT, PREFIX_INCREMENT, PREFIX_DECREMENT -> {
          var expression = tree.expression();
          if (expression.is(Tree.Kind.IDENTIFIER)) {
            declaredOrAssignedLocals.add(((IdentifierTree) expression).name());
          }
        }
        default -> {
          // empty
        }
      }
    }

    @Override
    public void visitForEachStatement(ForEachStatement tree) {
      super.visitForEachStatement(tree);
      visitVariable(tree.variable());
    }
  }
}
"
S6912,CODE_SMELL,Use batch Processing in JDBC,"package org.sonar.java.checks;

import java.util.EnumSet;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

import static org.sonar.java.checks.helpers.TreeHelper.findClosestParentOfKind;@Rule(key = ""S6912"")
public class BatchSQLStatementsCheck extends AbstractMethodDetection {
  private static final String MESSAGE = ""Use \""addBatch\"" and \""executeBatch\"" to execute multiple SQL statements in a single call."";
  private static final Set<Tree.Kind> LOOP_TREE_KINDS = EnumSet.of(Tree.Kind.FOR_STATEMENT, Tree.Kind.WHILE_STATEMENT, Tree.Kind.DO_STATEMENT, Tree.Kind.FOR_EACH_STATEMENT);
  private static final MethodMatchers EXECUTE_METHODS = MethodMatchers.create()
    .ofSubTypes(""java.sql.Statement"")
    .names(""execute"", ""executeQuery"", ""executeUpdate"")
    .withAnyParameters()
    .build();
  private static final MethodMatchers FOR_EACH_MATCHER = MethodMatchers.create()
    .ofSubTypes(""java.lang.Iterable"", ""java.util.stream.Stream"", ""java.util.Map"")
    .names(""forEach"")
    .withAnyParameters()
    .build();

  private final Set<MethodInvocationTree> invocations = new HashSet<>();

  @Override
  public void setContext(JavaFileScannerContext context) {
    super.setContext(context);
    invocations.clear();
  }

  @Override
  public void leaveFile(JavaFileScannerContext context) {
    // Collecting invocations in a Set and reporting issues when leaving the file to avoid duplicates in case of nested loops or lambdas
    invocations.forEach(mit -> reportIssue(mit, MESSAGE));
    invocations.clear();
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return EXECUTE_METHODS;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (hasLoopParent(mit) || isLambdaInsideForEach(mit)) {
      invocations.add(mit);
    }
  }

  private static boolean hasLoopParent(MethodInvocationTree mit) {
    return Optional.ofNullable(mit.parent()) // ExpressionStatementTree
      .map(Tree::parent)// BlockTree
      .map(Tree::parent)
      .map(Tree::kind)
      .filter(LOOP_TREE_KINDS::contains)
      .isPresent();
  }

  private static boolean isLambdaInsideForEach(MethodInvocationTree mit) {
    return findClosestParentOfKind(mit, Set.of(Tree.Kind.LAMBDA_EXPRESSION)) instanceof LambdaExpressionTree enclosingLambda
      && findClosestParentOfKind(enclosingLambda, Set.of(Tree.Kind.METHOD_INVOCATION)) instanceof MethodInvocationTree enclosingMit
      && FOR_EACH_MATCHER.matches(enclosingMit);
  }
}
"
S6913,BUG,"""Math.clamp"" should be used with correct ranges","package org.sonar.java.checks;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.annotations.VisibleForTesting;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

import static org.sonar.java.model.SyntacticEquivalence.areEquivalentIncludingSameVariables;

@Rule(key = ""S6913"")
public class MathClampRangeCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  public static final String DOUBLE = ""double"";
  public static final String FLOAT = ""float"";
  public static final String INT = ""int"";
  public static final String LONG = ""long"";

  public static final String MIN = ""min"";
  public static final String MAX = ""max"";
  public static final String VALUE = ""value"";

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava21Compatible();
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofTypes(""java.lang.Math"")
      .names(""clamp"")
      .addParametersMatcher(DOUBLE, DOUBLE, DOUBLE)
      .addParametersMatcher(FLOAT, FLOAT, FLOAT)
      .addParametersMatcher(LONG, LONG, LONG)
      .addParametersMatcher(LONG, INT, INT)
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    // according to the MethodMatchers, MethodSymbol.parameterTypes().size() is always 3
    // but it's not a 100% guarantee that mit.arguments().size() is 3 when there is a semantic recovery approximation
    if (mit.arguments().size() == 3) {
      checkMathClampArguments(
        mit.arguments().get(0),
        mit.arguments().get(1),
        mit.arguments().get(2));
    }
  }

  private boolean checkMathClampArguments(ExpressionTree valueExpression, ExpressionTree minExpression, ExpressionTree maxExpression) {
    return checkEquals(minExpression, MIN, maxExpression, MAX) ||
      checkEquals(minExpression, MIN, valueExpression, VALUE) ||
      checkEquals(maxExpression, MAX, valueExpression, VALUE) ||
      checkLessThan(maxExpression, MAX, minExpression, MIN) ||
      checkLessThan(minExpression, MIN, valueExpression, VALUE) ||
      checkLessThan(valueExpression, VALUE, maxExpression, MAX);
  }

  private boolean checkEquals(ExpressionTree exprA, String nameA, ExpressionTree exprB, String nameB) {
    if (!areEquivalentIncludingSameVariables(exprA, exprB)) {
      return false;
    }
    reportIssue(
      exprA, String.format(""Change the \""clamp(value,min,max)\""'s arguments so \""%s\"" is not equals to \""%s\""."", nameA, nameB),
      List.of(new JavaFileScannerContext.Location(nameB + "" argument"", exprB)),
      null);
    return true;
  }

  private boolean checkLessThan(ExpressionTree exprA, String nameA, ExpressionTree exprB, String nameB) {
    if (!isLessThan(exprA, exprB)) {
      return false;
    }
    QuickFixHelper.newIssue(context)
      .forRule(this)
      .onTree(exprA)
      .withMessage(""Change the \""clamp(value,min,max)\""'s arguments so \""%s\"" is not always less than \""%s\""."", nameA, nameB)
      .withSecondaries(new JavaFileScannerContext.Location(nameB + "" argument"", exprB))
      .withQuickFix(() -> JavaQuickFix.newQuickFix(""Swap \"""" + nameA + ""\"" and \"""" + nameB + ""\"" arguments"")
        .addTextEdit(JavaTextEdit.replaceTree(exprA, QuickFixHelper.contentForTree(exprB, context)))
        .addTextEdit(JavaTextEdit.replaceTree(exprB, QuickFixHelper.contentForTree(exprA, context)))
        .build())
      .report();
    return true;
  }

  private static boolean isLessThan(ExpressionTree exprA, ExpressionTree exprB) {
    return exprA.asConstant().orElse(null) instanceof Number a &&
      exprB.asConstant().orElse(null) instanceof Number b &&
      isLessThan(a, b);
  }

  @VisibleForTesting
  static boolean isLessThan(Number a, Number b) {
    if (a instanceof Double || b instanceof Double) {
      return a.doubleValue() < b.doubleValue();
    } else if (a instanceof Float || b instanceof Float) {
      return a.floatValue() < b.floatValue();
    } else {
      // Byte, Short, Integer, Long
      return a.longValue() < b.longValue();
    }
  }

}
"
S6914,CODE_SMELL,Use Fused Location to optimize battery power,"package org.sonar.java.checks.sustainability;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;

@Rule(key = ""S6914"")
public class AndroidFusedLocationProviderClientCheck extends AbstractMethodDetection {

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.create()
      .ofSubTypes(""android.content.Context"")
      .names(""getSystemService"")
      .addParametersMatcher(""java.lang.String"")
      .build();
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree tree) {
    var nameArg = tree.arguments().get(0);
    if (""location"".equals(ExpressionUtils.resolveAsConstant(nameArg))) {
      reportIfInAndroidContext(nameArg);
    }
  }

  private void reportIfInAndroidContext(Tree tree) {
    if (context.inAndroidContext()) {
      reportIssue(tree, ""Use \""FusedLocationProviderClient\"" instead of \""LocationManager\""."");
    }
  }
}
"
S6915,BUG,"""String.indexOf"" should be used with correct ranges","package org.sonar.java.checks;

import java.util.List;
import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;


@Rule(key = ""S6915"")
public class StringIndexOfRangesCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {

  private static final String JAVA_LANG_STRING = ""java.lang.String"";

  private static final String BEGIN_IDX_SMALLER_THAN_STR_LENGTH = ""Begin index should be smaller than the length of the string."";
  private static final String END_IDX_AT_MOST_STR_LENGTH = ""End index should be at most the length of the string."";
  private static final String BEGIN_IDX_NOT_LARGER_THAN_END_IDX = ""Begin index should not be larger than endIndex."";
  private static final String END_INDEX = ""End index"";
  private static final String RECEIVER_STRING = ""Receiver string"";

  private static final MethodMatchers INDEX_OF_MATCHERS =
    MethodMatchers.create()
      .ofTypes(JAVA_LANG_STRING)
      .names(""indexOf"")
      .addParametersMatcher(""int"", ""int"", ""int"")
      .addParametersMatcher(JAVA_LANG_STRING, ""int"", ""int"")
      .build();

  private static final MethodMatchers LENGTH_MATCHERS =
    MethodMatchers.create()
      .ofTypes(JAVA_LANG_STRING)
      .names(""length"")
      .addWithoutParametersMatcher()
      .build();

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava21Compatible();
  }

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return INDEX_OF_MATCHERS;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree methodInvocation) {
    var issueFound = checkConstantBounds(methodInvocation);
    if (!issueFound && methodInvocation.methodSelect() instanceof MemberSelectExpressionTree memberSelect
      && memberSelect.expression() instanceof IdentifierTree idTree) {
      checkBoundsThatDependOnLength(methodInvocation, idTree.name());
    }
  }private boolean checkConstantBounds(MethodInvocationTree methodInvocation) {
    var beginIdxExpr = methodInvocation.arguments().get(1);
    var endIdxExpr = methodInvocation.arguments().get(2);

    var beginIdxConst = beginIdxExpr.asConstant(Integer.class);
    var endIdxConst = endIdxExpr.asConstant(Integer.class);

    if (beginIdxConst.isPresent() && beginIdxConst.get() < 0) {
      reportIssue(beginIdxExpr, ""Begin index should be non-negative."");
      return true;
    }

    if (beginIdxConst.isPresent() && endIdxConst.isPresent() && beginIdxConst.get() > endIdxConst.get()) {
      reportWithSecondaryLocation(beginIdxExpr, BEGIN_IDX_NOT_LARGER_THAN_END_IDX, endIdxExpr, END_INDEX);
      return true;
    }

    Optional<String> receiverConst = methodInvocation.methodSelect() instanceof MemberSelectExpressionTree memberSelect
      ? memberSelect.expression().asConstant(String.class) : Optional.empty();

    if (receiverConst.isPresent() && beginIdxConst.isPresent() && beginIdxConst.get() >= receiverConst.get().length()) {
      reportWithSecondaryLocation(beginIdxExpr, BEGIN_IDX_SMALLER_THAN_STR_LENGTH, methodInvocation.methodSelect(), RECEIVER_STRING);
      return true;
    }

    if (receiverConst.isPresent() && endIdxConst.isPresent() && endIdxConst.get() > receiverConst.get().length()) {
      reportWithSecondaryLocation(endIdxExpr, END_IDX_AT_MOST_STR_LENGTH, methodInvocation.methodSelect(), RECEIVER_STRING);
      return true;
    }

    return false;
  }

  private void checkBoundsThatDependOnLength(MethodInvocationTree methodInvocation, String lengthReceiverVarName) {
    var beginIdxExpr = methodInvocation.arguments().get(1);
    var endIdxExpr = methodInvocation.arguments().get(2);
    var beginIdxDelta = lengthDelta(beginIdxExpr, lengthReceiverVarName);
    var endIdxDelta = lengthDelta(endIdxExpr, lengthReceiverVarName);
    if (beginIdxDelta.isPresent() && beginIdxDelta.get() >= 0) {
      reportIssue(beginIdxExpr, BEGIN_IDX_SMALLER_THAN_STR_LENGTH);
    } else if (endIdxDelta.isPresent() && endIdxDelta.get() > 0) {
      reportIssue(endIdxExpr, END_IDX_AT_MOST_STR_LENGTH);
    } else if (beginIdxDelta.isPresent() && endIdxDelta.isPresent() && beginIdxDelta.get() > endIdxDelta.get()) {
      reportWithSecondaryLocation(beginIdxExpr, BEGIN_IDX_NOT_LARGER_THAN_END_IDX, endIdxExpr, END_INDEX);
    }
  }

  private void reportWithSecondaryLocation(ExpressionTree tree, String msg, ExpressionTree secondaryLocation, String secondaryMsg) {
    reportIssue(tree, msg, List.of(new JavaFileScannerContext.Location(secondaryMsg, secondaryLocation)), null);
  }private static Optional<Integer> lengthDelta(ExpressionTree expr, String varName) {
    if (isCallToLengthOnVariable(expr, varName)) {
      // 1st pattern: var.length()
      return Optional.of(0);
    }
    if (expr instanceof BinaryExpressionTree binaryExpr) {
      var isPlus = binaryExpr.kind() == Tree.Kind.PLUS;
      var isMinus = binaryExpr.kind() == Tree.Kind.MINUS;
      if (!(isPlus || isMinus)) {
        return Optional.empty();
      }
      var leftCst = binaryExpr.leftOperand().asConstant(Integer.class);
      var rightCst = binaryExpr.rightOperand().asConstant(Integer.class);
      if (isCallToLengthOnVariable(binaryExpr.leftOperand(), varName) && rightCst.isPresent()) {
        // 2nd pattern:  var.length() + cst  or  var.length() - cst
        return isPlus ? rightCst : rightCst.map(x -> -x);
      } else if (isPlus && leftCst.isPresent() && isCallToLengthOnVariable(binaryExpr.rightOperand(), varName)) {
        // 3rd pattern: cst + var.length()
        return leftCst;
      }
    }
    return Optional.empty();
  }

  private static boolean isCallToLengthOnVariable(ExpressionTree expr, String varName) {
    if (expr instanceof MethodInvocationTree mit) {
      return LENGTH_MATCHERS.matches(mit.methodSymbol())
        && mit.methodSelect() instanceof MemberSelectExpressionTree memberSelect
        && memberSelect.expression() instanceof IdentifierTree idTree
        && idTree.symbol().name().equals(varName);
    }
    return false;
  }

}
"
S6916,CODE_SMELL,Use when instead of a single if inside a pattern match body,"package org.sonar.java.checks;

import java.util.List;
import org.sonar.check.Rule;
import org.sonar.java.checks.helpers.QuickFixHelper;
import org.sonar.java.reporting.JavaQuickFix;
import org.sonar.java.reporting.JavaTextEdit;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.JavaVersion;
import org.sonar.plugins.java.api.JavaVersionAwareVisitor;
import org.sonar.plugins.java.api.tree.BlockTree;
import org.sonar.plugins.java.api.tree.CaseGroupTree;
import org.sonar.plugins.java.api.tree.CaseLabelTree;
import org.sonar.plugins.java.api.tree.GuardedPatternTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.NullPatternTree;
import org.sonar.plugins.java.api.tree.Tree;


@Rule(key = ""S6916"")
public class SingleIfInsteadOfPatternMatchGuardCheck extends IssuableSubscriptionVisitor implements JavaVersionAwareVisitor {

  private static final String ISSUE_MESSAGE_REPLACE = ""Replace this \""if\"" statement with a pattern match guard."";
  private static final String ISSUE_MESSAGE_MERGE = ""Merge this \""if\"" statement with the enclosing pattern match guard."";

  @Override
  public boolean isCompatibleWithJavaVersion(JavaVersion version) {
    return version.isJava21Compatible();
  }

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return List.of(Tree.Kind.CASE_GROUP);
  }

  @Override
  public void visitNode(Tree tree) {
    var caseGroup = (CaseGroupTree) tree;

    var ifStatement = getFirstIfStatementInCaseBody(caseGroup);
    // We do not want to inspect case groups where the body does not have an if statement or if it has also an else statement
    if (ifStatement == null || ifStatement.elseStatement() != null) {
      return;
    }
    var caseLabel = caseGroup.labels().get(0);
    if (isCaseDefaultOrNull(caseLabel)) {
      return;
    }

    var caseExpression = caseLabel.expressions().get(0);
    boolean isGuardedPattern = caseExpression instanceof GuardedPatternTree;

    QuickFixHelper.newIssue(context).forRule(this)
      .onTree(ifStatement)
      .withMessage(isGuardedPattern ? ISSUE_MESSAGE_MERGE : ISSUE_MESSAGE_REPLACE)
      .withQuickFix(() -> computeQuickFix(ifStatement, caseLabel, isGuardedPattern, context))
      .report();

  }

  private static IfStatementTree getFirstIfStatementInCaseBody(CaseGroupTree caseGroup) {
    if (!caseGroup.body().isEmpty() && caseGroup.body().get(0) instanceof BlockTree caseBlock) {
      // We need to check if the first and only element of the body is an if statement
      var blockBody = caseBlock.body();
      if (blockBody.size() == 1 && blockBody.get(0) instanceof IfStatementTree ifStatement) {
        return ifStatement;
      }
    }
    return null;
  }

  private static boolean isCaseDefaultOrNull(CaseLabelTree caseLabel) {
    return caseLabel.expressions().isEmpty() || caseLabel.expressions().get(0) instanceof NullPatternTree;
  }

  private static JavaQuickFix computeQuickFix(IfStatementTree ifStatement, CaseLabelTree caseLabel, boolean shouldMergeConditions,
    JavaFileScannerContext context) {
    var quickFixBuilder = JavaQuickFix.newQuickFix(shouldMergeConditions ? ISSUE_MESSAGE_MERGE : ISSUE_MESSAGE_REPLACE);
    String replacement;
    if (ifStatement.thenStatement() instanceof BlockTree block && !block.body().isEmpty()) {
      var firstToken = QuickFixHelper.nextToken(block.openBraceToken());
      var lastToken = QuickFixHelper.previousToken(block.closeBraceToken());
      replacement = QuickFixHelper.contentForRange(firstToken, lastToken, context);
    } else {
      replacement = QuickFixHelper.contentForTree(ifStatement.thenStatement(), context);
    }
    quickFixBuilder.addTextEdit(
      JavaTextEdit.replaceTree(ifStatement, replacement)
    );
    var replacementStringPrefix = shouldMergeConditions ? "" && "" : "" when "";
    quickFixBuilder.addTextEdit(
      JavaTextEdit.insertBeforeTree(caseLabel.colonOrArrowToken(),
        replacementStringPrefix + QuickFixHelper.contentForTree(ifStatement.condition(), context) + "" "")
    );
    return quickFixBuilder.build();
  }

}
"
S6923,CODE_SMELL,Motion Sensor should not use gyroscope,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S6923"")
public class UseMotionSensorWithoutGyroscopeCheck extends AbstractMethodDetection {
  private static final String MESSAGE = ""Replace `TYPE_ROTATION_VECTOR` (11) with `TYPE_GEOMAGNETIC_ROTATION_VECTOR` (20) to optimize battery life."";
  private static final int TYPE_ROTATION_VECTOR = 11;
  private static final MethodMatchers GET_DEFAULT_SENSOR_MATCHER = MethodMatchers.create()
    .ofTypes(""android.hardware.SensorManager"")
    .names(""getDefaultSensor"")
    .withAnyParameters()
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return GET_DEFAULT_SENSOR_MATCHER;
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    mit.arguments().get(0)
      .asConstant(Integer.class)
      .filter(argValue -> argValue == TYPE_ROTATION_VECTOR)
      .ifPresent(unused -> reportIssue(mit, MESSAGE));
  }
}
"
S6926,CODE_SMELL,Bluetooth should be configured to use low power,"package org.sonar.java.checks;

import java.util.Optional;
import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.java.model.ExpressionUtils;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;

@Rule(key = ""S6926"")
public class BluetoothLowPowerModeCheck extends AbstractMethodDetection {

  private static final int CONNECTION_PRIORITY_LOW_POWER = 2;
  private static final int ADVERTISE_MODE_LOW_POWER = 0;

  private static final MethodMatchers REQUEST_CONNECTION_PRIORITY = MethodMatchers.create()
    .ofSubTypes(""android.bluetooth.BluetoothGatt"")
    .names(""requestConnectionPriority"")
    .addParametersMatcher(""int"")
    .build();

  private static final MethodMatchers SET_ADVERTISE_MODE = MethodMatchers.create()
    .ofSubTypes(""android.bluetooth.le.AdvertiseSettings$Builder"")
    .names(""setAdvertiseMode"")
    .addParametersMatcher(""int"")
    .build();

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(REQUEST_CONNECTION_PRIORITY, SET_ADVERTISE_MODE);
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    if (firstArgumentNotEqualsTo(mit, ""requestConnectionPriority"", CONNECTION_PRIORITY_LOW_POWER)
      || firstArgumentNotEqualsTo(mit, ""setAdvertiseMode"", ADVERTISE_MODE_LOW_POWER)) {

      reportIssue(mit.methodSelect(), ""Use the low power mode for this Bluetooth operation."");
    }
  }

  private static boolean firstArgumentNotEqualsTo(MethodInvocationTree mit, String methodName, int expectedValue) {
    return methodName.equals(ExpressionUtils.methodName(mit).name())
      && Optional.ofNullable(ExpressionUtils.resolveAsConstant(mit.arguments().get(0)))
        .filter(Integer.class::isInstance)
        .map(Integer.class::cast)
        .filter(value -> value != expectedValue)
        .isPresent();
  }

}
"
S818,CODE_SMELL,Literal suffixes should be upper case,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.check.RuleProperty;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.Tree;

import java.util.Arrays;
import java.util.List;

@Rule(key = ""S818"")
public class UppercaseSuffixesCheck extends IssuableSubscriptionVisitor {

  @RuleProperty(
    key = ""checkOnlyLong"",
    description = ""Set to \""true\"" to ignore \""float\"" and \""double\"" declarations."",
    defaultValue = ""false"")
  public boolean checkOnlyLong = false;

  private static final char LONG = 'l';
  private static final char DOUBLE = 'd';
  private static final char FLOAT = 'f';

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Arrays.asList(Tree.Kind.DOUBLE_LITERAL, Tree.Kind.FLOAT_LITERAL, Tree.Kind.LONG_LITERAL);
  }

  @Override
  public void visitNode(Tree tree) {
    String value = ((LiteralTree) tree).value();
    char suffix = value.charAt(value.length() - 1);
    switch (suffix) {
      case DOUBLE:
      case FLOAT:
        if (checkOnlyLong) {
          return;
        }
      case LONG:
        reportIssue(tree, ""Upper-case this literal \"""" + suffix + ""\"" suffix."");
        break;
      default:
        // do nothing
    }
  }
}
"
S864,CODE_SMELL,Limited dependence should be placed on operator precedence,"package org.sonar.java.checks;

import java.util.Deque;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import org.apache.commons.lang3.BooleanUtils;
import org.sonar.check.Rule;
import org.sonar.java.model.LineUtils;
import org.sonarsource.analyzer.commons.collections.SetUtils;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.AnnotationTree;
import org.sonar.plugins.java.api.tree.ArrayAccessExpressionTree;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ConditionalExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.IfStatementTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.LiteralTree;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.NewArrayTree;
import org.sonar.plugins.java.api.tree.NewClassTree;
import org.sonar.plugins.java.api.tree.ParenthesizedTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

@Rule(key = ""S864"")
public class OperatorPrecedenceCheck extends BaseTreeVisitor implements JavaFileScanner {

  private static final Map<OperatorRelation, Boolean> OPERATORS_RELATION_TABLE = new HashMap<>();

  private static final Set<Tree.Kind> ARITHMETIC_OPERATORS = EnumSet.of(
    Tree.Kind.MINUS,
    Tree.Kind.REMAINDER,
    Tree.Kind.MULTIPLY,
    Tree.Kind.PLUS
    );

  private static final Set<Tree.Kind> EQUALITY_RELATIONAL_OPERATORS = EnumSet.of(
    Tree.Kind.EQUAL_TO,
    Tree.Kind.GREATER_THAN,
    Tree.Kind.GREATER_THAN_OR_EQUAL_TO,
    Tree.Kind.LESS_THAN,
    Tree.Kind.LESS_THAN_OR_EQUAL_TO,
    Tree.Kind.NOT_EQUAL_TO
    );

  private static final Set<Tree.Kind> SHIFT_OPERATORS = EnumSet.of(
    Tree.Kind.LEFT_SHIFT,
    Tree.Kind.RIGHT_SHIFT,
    Tree.Kind.UNSIGNED_RIGHT_SHIFT
    );

  private static final Tree.Kind[] CONDITIONAL_EXCLUSIONS = new Tree.Kind[]{
      Tree.Kind.METHOD_INVOCATION, Tree.Kind.IDENTIFIER, Tree.Kind.MEMBER_SELECT,
      Tree.Kind.PARENTHESIZED_EXPRESSION, Tree.Kind.TYPE_CAST, Tree.Kind.NEW_CLASS,
      Tree.Kind.ARRAY_ACCESS_EXPRESSION, Tree.Kind.NEW_ARRAY, Tree.Kind.METHOD_REFERENCE
  };

  static {
    put(ARITHMETIC_OPERATORS, SetUtils.concat(SHIFT_OPERATORS, EnumSet.of(Tree.Kind.AND, Tree.Kind.XOR, Tree.Kind.OR)));
    put(SHIFT_OPERATORS, SetUtils.concat(ARITHMETIC_OPERATORS, EnumSet.of(Tree.Kind.AND, Tree.Kind.XOR, Tree.Kind.OR)));
    put(EnumSet.of(Tree.Kind.AND), SetUtils.concat(ARITHMETIC_OPERATORS, SHIFT_OPERATORS, EnumSet.of(Tree.Kind.XOR, Tree.Kind.OR)));
    put(EnumSet.of(Tree.Kind.XOR), SetUtils.concat(ARITHMETIC_OPERATORS, SHIFT_OPERATORS, EnumSet.of(Tree.Kind.AND, Tree.Kind.OR)));
    put(EnumSet.of(Tree.Kind.OR), SetUtils.concat(ARITHMETIC_OPERATORS, SHIFT_OPERATORS, EnumSet.of(Tree.Kind.AND, Tree.Kind.XOR)));
    put(EnumSet.of(Tree.Kind.CONDITIONAL_AND), EnumSet.of(Tree.Kind.CONDITIONAL_OR));
    put(EnumSet.of(Tree.Kind.CONDITIONAL_OR), EnumSet.of(Tree.Kind.CONDITIONAL_AND));
  }

  private JavaFileScannerContext context;
  private Deque<Tree.Kind> stack = new LinkedList<>();
  private Set<Integer> reportedLines = new HashSet<>();

  private static void put(Iterable<Tree.Kind> firstSet, Iterable<Tree.Kind> secondSet) {
    for (Tree.Kind first : firstSet) {
      for (Tree.Kind second : secondSet) {
        OPERATORS_RELATION_TABLE.put(new OperatorRelation(first, second), true);
      }
    }
  }

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    reportedLines.clear();
    scan(context.getTree());
    reportedLines.clear();
  }

  @Override
  public void visitAnnotation(AnnotationTree tree) {
    stack.push(null);
    for (ExpressionTree argument : tree.arguments()) {
      if (argument.is(Tree.Kind.ASSIGNMENT)) {
        scan(((AssignmentExpressionTree) argument).expression());
      } else {
        scan(argument);
      }
    }
    stack.pop();
  }

  @Override
  public void visitArrayAccessExpression(ArrayAccessExpressionTree tree) {
    scan(tree.expression());
    stack.push(null);
    scan(tree.dimension());
    stack.pop();
  }

  @Override
  public void visitBinaryExpression(BinaryExpressionTree tree) {
    Tree.Kind peek = stack.peek();
    Tree.Kind kind = tree.kind();
    if (requiresParenthesis(peek, kind)) {
      raiseIssue(LineUtils.startLine(tree.operatorToken()), tree);
    }
    stack.push(kind);
    super.visitBinaryExpression(tree);
    stack.pop();
  }

  private static boolean requiresParenthesis(Tree.Kind kind1, Tree.Kind kind2) {
    return BooleanUtils.isTrue(OPERATORS_RELATION_TABLE.get(new OperatorRelation(kind1, kind2)));
  }

  @Override
  public void visitIfStatement(IfStatementTree tree) {
    super.visitIfStatement(tree);
    ExpressionTree condition = tree.condition();
    if (condition.is(Tree.Kind.ASSIGNMENT) && EQUALITY_RELATIONAL_OPERATORS.contains(((AssignmentExpressionTree) condition).expression().kind())) {
      raiseIssue(LineUtils.startLine(((AssignmentExpressionTree) condition).operatorToken()), tree);
    }
  }

  @Override
  public void visitMethodInvocation(MethodInvocationTree tree) {
    scan(tree.methodSelect());
    scan(tree.typeArguments());
    for (ExpressionTree argument : tree.arguments()) {
      stack.push(null);
      scan(argument);
      stack.pop();
    }
  }

  @Override
  public void visitNewArray(NewArrayTree tree) {
    stack.push(null);
    super.visitNewArray(tree);
    stack.pop();
  }

  @Override
  public void visitNewClass(NewClassTree tree) {
    stack.push(null);
    super.visitNewClass(tree);
    stack.pop();
  }

  @Override
  public void visitParenthesized(ParenthesizedTree tree) {
    stack.push(null);
    super.visitParenthesized(tree);
    stack.pop();
  }

  @Override
  public void visitConditionalExpression(ConditionalExpressionTree tree) {
    checkConditionalOperand(tree.trueExpression());
    checkConditionalOperand(tree.falseExpression());
    super.visitConditionalExpression(tree);
  }

  private void checkConditionalOperand(ExpressionTree tree) {
    if (tree.is(CONDITIONAL_EXCLUSIONS)
      || tree instanceof LiteralTree
      || tree instanceof UnaryExpressionTree
      || isSimpleLambda(tree)) {
      return;
    }
    raiseIssue(LineUtils.startLine(tree), tree);
  }

  private static boolean isSimpleLambda(ExpressionTree tree) {
    if (!tree.is(Tree.Kind.LAMBDA_EXPRESSION)) {
      return false;
    }
    Tree body = ((LambdaExpressionTree) tree).body();
    return body instanceof LiteralTree
      || body instanceof UnaryExpressionTree
      || body.is(Tree.Kind.IDENTIFIER);
  }

  private void raiseIssue(int line, Tree tree) {
    if (reportedLines.add(line)) {
      context.reportIssue(this, tree, ""Add parentheses to make the operator precedence explicit."");
    }
  }
  
  private static final class OperatorRelation {
    private final Tree.Kind first;
    private final Tree.Kind second;

    public OperatorRelation(Tree.Kind first, Tree.Kind second) {
      this.first = first;
      this.second = second;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || getClass() != o.getClass()) {
        return false;
      }
      OperatorRelation that = (OperatorRelation) o;
      return first == that.first &&
        second == that.second;
    }

    @Override
    public int hashCode() {
      return Objects.hash(first, second);
    }
  } 

}
"
S881,CODE_SMELL,Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.JavaFileScanner;
import org.sonar.plugins.java.api.JavaFileScannerContext;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
import org.sonar.plugins.java.api.tree.ReturnStatementTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.Tree.Kind;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

@Rule(key = ""S881"")
public class IncrementDecrementInSubExpressionCheck extends BaseTreeVisitor implements JavaFileScanner {

  private JavaFileScannerContext context;

  @Override
  public void scanFile(JavaFileScannerContext context) {
    this.context = context;
    scan(context.getTree());
  }

  @Override
  public void visitExpressionStatement(ExpressionStatementTree tree) {
    scanSkippingIncrementOrDecrement(tree.expression());
  }

  @Override
  public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
    scan(lambdaExpressionTree.parameters());
    scanSkippingIncrementOrDecrement(lambdaExpressionTree.body());
  }

  private void scanSkippingIncrementOrDecrement(Tree expressionTree) {
    if (isIncrementOrDecrement(expressionTree)) {
      UnaryExpressionTree unaryExpressionTree = (UnaryExpressionTree) expressionTree;
      expressionTree = unaryExpressionTree.expression();
    }
    scan(expressionTree);
  }

  @Override
  public void visitUnaryExpression(UnaryExpressionTree tree) {
    super.visitUnaryExpression(tree);
    if (isIncrementOrDecrement(tree)) {
      context.reportIssue(this, tree, ""Extract this increment or decrement operator into a dedicated statement."");
    }
  }

  @Override
  public void visitReturnStatement(ReturnStatementTree tree) {
    ExpressionTree expression = tree.expression();
    if(expression == null || !isIncrementOrDecrement(expression)) {
      scan(expression);
    }
  }

  private static boolean isIncrementOrDecrement(Tree tree) {
    return tree.is(Kind.PREFIX_INCREMENT) ||
      tree.is(Kind.PREFIX_DECREMENT) ||
      tree.is(Kind.POSTFIX_INCREMENT) ||
      tree.is(Kind.POSTFIX_DECREMENT);
  }

}
"
S888,CODE_SMELL,"Equality operators should not be used in ""for"" loop termination conditions","package org.sonar.java.checks;

import java.util.Arrays;
import org.sonar.check.Rule;
import org.sonar.java.model.LiteralUtils;
import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
import org.sonar.plugins.java.api.tree.ExpressionTree;
import org.sonar.plugins.java.api.tree.ForStatementTree;
import org.sonar.plugins.java.api.tree.IdentifierTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.UnaryExpressionTree;

@Rule(key = ""S888"")
public class ForLoopTerminationConditionCheck extends AbstractForLoopRule {

  @Override
  public void visitForStatement(ForStatementTree forStatement) {
    ExpressionTree condition = forStatement.condition();
    if (condition == null || !condition.is(Tree.Kind.NOT_EQUAL_TO)) {
      return;
    }
    BinaryExpressionTree inequalityCondition = (BinaryExpressionTree) condition;
    IntInequality loopVarAndTerminalValue = IntInequality.of(inequalityCondition);
    if (loopVarAndTerminalValue != null) {
      IdentifierTree loopIdentifier = loopVarAndTerminalValue.identifier;
      int terminationValue = loopVarAndTerminalValue.literalValue;
      Integer initialValue = initialValue(loopIdentifier, forStatement);
      if (initialValue != null && initialValue != terminationValue) {
        checkIncrement(forStatement, loopIdentifier, initialValue < terminationValue);
      }
    }
  }

  private void checkIncrement(ForStatementTree forStatement, IdentifierTree loopIdentifier, boolean positiveIncrement) {
    if (forStatement.update().size() <= 1) {
      ForLoopIncrement loopIncrement = ForLoopIncrement.findInUpdates(forStatement);
      if (loopIncrement == null || !loopIncrement.hasSameIdentifier(loopIdentifier)) {
        addIssue(forStatement);
      } else if (loopIncrement.hasValue()) {
        int requiredIncrement = positiveIncrement ? 1 : -1;
        if (loopIncrement.value() != requiredIncrement || forBodyUpdatesLoopIdentifier(forStatement, loopIdentifier)) {
          addIssue(forStatement);
        }
      }
    }
  }

  private void addIssue(ForStatementTree tree) {
    reportIssue(tree.condition(), ""Replace '!=' operator with one of '<=', '>=', '<', or '>' comparison operators."");
  }

  private static boolean forBodyUpdatesLoopIdentifier(ForStatementTree forStatement, IdentifierTree loopIdentifier) {
    LoopVariableAssignmentVisitor visitor = new LoopVariableAssignmentVisitor(loopIdentifier);
    forStatement.statement().accept(visitor);
    return visitor.foundAssignment;
  }

  private static class LoopVariableAssignmentVisitor extends BaseTreeVisitor {

    private final IdentifierTree loopIdentifier;
    private boolean foundAssignment = false;

    public LoopVariableAssignmentVisitor(IdentifierTree loopIdentifier) {
      this.loopIdentifier = loopIdentifier;
    }

    @Override
    public void visitUnaryExpression(UnaryExpressionTree unaryExp) {
      if (isSameIdentifier(loopIdentifier, unaryExp.expression())
        && unaryExp.is(Tree.Kind.POSTFIX_INCREMENT, Tree.Kind.POSTFIX_DECREMENT, Tree.Kind.PREFIX_INCREMENT, Tree.Kind.PREFIX_DECREMENT)) {
        foundAssignment = true;
      }
      super.visitUnaryExpression(unaryExp);
    }

    @Override
    public void visitAssignmentExpression(AssignmentExpressionTree assignmentExpression) {
      if (isSameIdentifier(loopIdentifier, assignmentExpression.variable())) {
        foundAssignment = true;
      }
      super.visitAssignmentExpression(assignmentExpression);
    }
  }

  private static Integer initialValue(IdentifierTree loopIdentifier, ForStatementTree forStatement) {
    Integer value = null;
    for (ForLoopInitializer initializer : ForLoopInitializer.list(forStatement)) {
      if (initializer.hasSameIdentifier(loopIdentifier) && initializer.value() != null) {
        value = initializer.value();
      }
    }
    return value;
  }
  
  private static class IntInequality {
    
    private final IdentifierTree identifier;
    private final int literalValue;
    
    private IntInequality(IdentifierTree identifier, int value) {
      this.identifier = identifier;
      this.literalValue = value;
    }
    
    public static IntInequality of(BinaryExpressionTree binaryExp) {
      Integer value = null;
      IdentifierTree identifier = null;
      for (ExpressionTree expressionTree : Arrays.asList(binaryExp.leftOperand(), binaryExp.rightOperand())) {
        if (expressionTree.is(Tree.Kind.IDENTIFIER)) {
          identifier = (IdentifierTree) expressionTree;
        } else {
          value = LiteralUtils.intLiteralValue(expressionTree);
        }
      }
      if (identifier != null && value != null) {
        return new IntInequality(identifier, value);
      }
      return null;
    }
  }

}
"
S899,BUG,Return values should not be ignored when they contain the operation status code,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.java.checks.methods.AbstractMethodDetection;
import org.sonar.plugins.java.api.semantic.MethodMatchers;
import org.sonar.plugins.java.api.tree.MethodInvocationTree;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.VariableTree;

@Rule(key = ""S899"")
public class IgnoredOperationStatusCheck extends AbstractMethodDetection {

  private static final String FILE = ""java.io.File"";
  private static final String CONDITION = ""java.util.concurrent.locks.Condition"";
  private static final String BLOCKING_QUEUE = ""java.util.concurrent.BlockingQueue"";

  @Override
  protected MethodMatchers getMethodInvocationMatchers() {
    return MethodMatchers.or(
      MethodMatchers.create().ofSubTypes(""java.util.concurrent.locks.Lock"").names(""tryLock"").addWithoutParametersMatcher().build(),
      MethodMatchers.create().ofTypes(FILE)
        .name(name -> ""delete"".equals(name) || ""exists"".equals(name) || ""createNewFile"".equals(name) ||
          name.startsWith(""can"") || name.startsWith(""is""))
        .addWithoutParametersMatcher()
        .build(),

      MethodMatchers.create().ofTypes(FILE).name(name -> name.startsWith(""set""))
        .withAnyParameters().build(),

      MethodMatchers.create().ofTypes(FILE).names(""renameTo"").addParametersMatcher(FILE).build(),

      MethodMatchers.create().ofSubTypes(""java.util.Iterator"").names(""hasNext"").addWithoutParametersMatcher().build(),
      MethodMatchers.create().ofSubTypes(""java.util.Enumeration"").names(""hasMoreElements"").addWithoutParametersMatcher().build(),

      MethodMatchers.create().ofSubTypes(CONDITION).names(""await"").addParametersMatcher(""long"", ""java.util.concurrent.TimeUnit"").build(),
      MethodMatchers.create().ofSubTypes(CONDITION).names(""awaitUntil"").addParametersMatcher(""java.util.Date"").build(),
      MethodMatchers.create().ofSubTypes(CONDITION).names(""awaitNanos"").addParametersMatcher(""long"").build(),

      MethodMatchers.create().ofTypes(""java.util.concurrent.CountDownLatch"").names(""await"").addParametersMatcher(""long"", ""java.util.concurrent.TimeUnit"").build(),
      MethodMatchers.create().ofTypes(""java.util.concurrent.Semaphore"").names(""tryAcquire"").withAnyParameters().build(),

      MethodMatchers.create().ofSubTypes(BLOCKING_QUEUE).names(""offer"").withAnyParameters().build(),
      MethodMatchers.create().ofSubTypes(BLOCKING_QUEUE).names(""remove"").withAnyParameters().build());
  }

  @Override
  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    Tree parent = mit.parent();
    if (parent.is(Tree.Kind.EXPRESSION_STATEMENT)
      || (parent.is(Tree.Kind.VARIABLE) && ((VariableTree) parent).symbol().usages().isEmpty())) {
      reportIssue(parent, ""Do something with the \"""" + mit.symbolType().name() + ""\"" value returned by \"""" + mit.methodSymbol().name() + ""\""."");
    }
  }

}
"
S923,CODE_SMELL,Functions should not be defined with a variable number of arguments,"package org.sonar.java.checks;

import org.sonar.check.Rule;
import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
import org.sonar.plugins.java.api.tree.ArrayTypeTree;
import org.sonar.plugins.java.api.tree.MethodTree;
import org.sonar.plugins.java.api.tree.SyntaxToken;
import org.sonar.plugins.java.api.tree.Tree;
import org.sonar.plugins.java.api.tree.TypeTree;
import org.sonar.plugins.java.api.tree.VariableTree;

import java.util.Collections;
import java.util.List;

@Rule(key = ""S923"")
public class VarArgCheck extends IssuableSubscriptionVisitor {

  @Override
  public List<Tree.Kind> nodesToVisit() {
    return Collections.singletonList(Tree.Kind.METHOD);
  }

  @Override
  public void visitNode(Tree tree) {
    List<VariableTree> parameters = ((MethodTree) tree).parameters();
    if(!parameters.isEmpty()) {
      TypeTree lastParam = parameters.get(parameters.size() - 1).type();
      if(lastParam.is(Tree.Kind.ARRAY_TYPE)) {
        SyntaxToken ellipsisToken = ((ArrayTypeTree) lastParam).ellipsisToken();
        if(ellipsisToken != null) {
          reportIssue(ellipsisToken, ""Do not use varargs."");
        }
      }
    }
  }

}
"
